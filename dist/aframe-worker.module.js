var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: !0 });
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 == "object" || typeof module2 == "function")
    for (let key of __getOwnPropNames(module2))
      !__hasOwnProp.call(target, key) && key !== "default" && __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  return target;
}, __toModule = (module2) => __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: !0 } : { value: module2, enumerable: !0 })), module2);

// node_modules/aframe/dist/aframe-master.js
var require_aframe_master = __commonJS({
  "node_modules/aframe/dist/aframe-master.js"(exports, module2) {
    (function(root, factory) {
      typeof exports == "object" && typeof module2 == "object" ? module2.exports = factory() : typeof define == "function" && define.amd ? define([], factory) : typeof exports == "object" ? exports.AFRAME = factory() : root.AFRAME = factory();
    })(self, () => (() => {
      var __webpack_modules__ = {
        "./node_modules/an-array/index.js": (module3) => {
          var str = Object.prototype.toString;
          module3.exports = anArray;
          function anArray(arr) {
            return arr.BYTES_PER_ELEMENT && str.call(arr.buffer) === "[object ArrayBuffer]" || Array.isArray(arr);
          }
        },
        "./node_modules/as-number/index.js": (module3) => {
          module3.exports = function(num, def) {
            return typeof num == "number" ? num : typeof def == "number" ? def : 0;
          };
        },
        "./node_modules/base64-js/index.js": (__unused_webpack_module, exports2) => {
          "use strict";
          exports2.byteLength = byteLength, exports2.toByteArray = toByteArray, exports2.fromByteArray = fromByteArray;
          for (var lookup = [], revLookup = [], Arr = typeof Uint8Array != "undefined" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i)
            lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
          revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
          function getLens(b64) {
            var len2 = b64.length;
            if (len2 % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var validLen = b64.indexOf("=");
            validLen === -1 && (validLen = len2);
            var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
            return [validLen, placeHoldersLen];
          }
          function byteLength(b64) {
            var lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
          }
          function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
          }
          function toByteArray(b64) {
            var tmp, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Arr(_byteLength(b64, validLen, placeHoldersLen)), curByte = 0, len2 = placeHoldersLen > 0 ? validLen - 4 : validLen, i2;
            for (i2 = 0; i2 < len2; i2 += 4)
              tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
            return placeHoldersLen === 2 && (tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4, arr[curByte++] = tmp & 255), placeHoldersLen === 1 && (tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255), arr;
          }
          function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
          }
          function encodeChunk(uint8, start, end) {
            for (var tmp, output = [], i2 = start; i2 < end; i2 += 3)
              tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255), output.push(tripletToBase64(tmp));
            return output.join("");
          }
          function fromByteArray(uint8) {
            for (var tmp, len2 = uint8.length, extraBytes = len2 % 3, parts = [], maxChunkLength = 16383, i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength)
              parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
            return extraBytes === 1 ? (tmp = uint8[len2 - 1], parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==")) : extraBytes === 2 && (tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1], parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=")), parts.join("");
          }
        },
        "./node_modules/buffer-equal/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var Buffer2 = __webpack_require__2("./node_modules/buffer/index.js").Buffer;
          module3.exports = function(a, b) {
            if (!!Buffer2.isBuffer(a) && !!Buffer2.isBuffer(b)) {
              if (typeof a.equals == "function")
                return a.equals(b);
              if (a.length !== b.length)
                return !1;
              for (var i = 0; i < a.length; i++)
                if (a[i] !== b[i])
                  return !1;
              return !0;
            }
          };
        },
        "./node_modules/buffer/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
          "use strict";
          let base64 = __webpack_require__2("./node_modules/base64-js/index.js"), ieee754 = __webpack_require__2("./node_modules/ieee754/index.js"), customInspectSymbol = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
          exports2.Buffer = Buffer2, exports2.SlowBuffer = SlowBuffer, exports2.INSPECT_MAX_BYTES = 50;
          let K_MAX_LENGTH = 2147483647;
          exports2.kMaxLength = K_MAX_LENGTH, Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport(), !Buffer2.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
          function typedArraySupport() {
            try {
              let arr = new Uint8Array(1), proto = {
                foo: function() {
                  return 42;
                }
              };
              return Object.setPrototypeOf(proto, Uint8Array.prototype), Object.setPrototypeOf(arr, proto), arr.foo() === 42;
            } catch (e) {
              return !1;
            }
          }
          Object.defineProperty(Buffer2.prototype, "parent", {
            enumerable: !0,
            get: function() {
              if (!!Buffer2.isBuffer(this))
                return this.buffer;
            }
          }), Object.defineProperty(Buffer2.prototype, "offset", {
            enumerable: !0,
            get: function() {
              if (!!Buffer2.isBuffer(this))
                return this.byteOffset;
            }
          });
          function createBuffer(length) {
            if (length > K_MAX_LENGTH)
              throw new RangeError('The value "' + length + '" is invalid for option "size"');
            let buf = new Uint8Array(length);
            return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
          }
          function Buffer2(arg, encodingOrOffset, length) {
            if (typeof arg == "number") {
              if (typeof encodingOrOffset == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
              return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
          }
          Buffer2.poolSize = 8192;
          function from(value, encodingOrOffset, length) {
            if (typeof value == "string")
              return fromString(value, encodingOrOffset);
            if (ArrayBuffer.isView(value))
              return fromArrayView(value);
            if (value == null)
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer)))
              return fromArrayBuffer(value, encodingOrOffset, length);
            if (typeof value == "number")
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            let valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value)
              return Buffer2.from(valueOf, encodingOrOffset, length);
            let b = fromObject(value);
            if (b)
              return b;
            if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] == "function")
              return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
          }
          Buffer2.from = function(value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          }, Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype), Object.setPrototypeOf(Buffer2, Uint8Array);
          function assertSize(size) {
            if (typeof size != "number")
              throw new TypeError('"size" argument must be of type number');
            if (size < 0)
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
          }
          function alloc(size, fill, encoding) {
            return assertSize(size), size <= 0 ? createBuffer(size) : fill !== void 0 ? typeof encoding == "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill) : createBuffer(size);
          }
          Buffer2.alloc = function(size, fill, encoding) {
            return alloc(size, fill, encoding);
          };
          function allocUnsafe(size) {
            return assertSize(size), createBuffer(size < 0 ? 0 : checked(size) | 0);
          }
          Buffer2.allocUnsafe = function(size) {
            return allocUnsafe(size);
          }, Buffer2.allocUnsafeSlow = function(size) {
            return allocUnsafe(size);
          };
          function fromString(string, encoding) {
            if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer2.isEncoding(encoding))
              throw new TypeError("Unknown encoding: " + encoding);
            let length = byteLength(string, encoding) | 0, buf = createBuffer(length), actual = buf.write(string, encoding);
            return actual !== length && (buf = buf.slice(0, actual)), buf;
          }
          function fromArrayLike(array) {
            let length = array.length < 0 ? 0 : checked(array.length) | 0, buf = createBuffer(length);
            for (let i = 0; i < length; i += 1)
              buf[i] = array[i] & 255;
            return buf;
          }
          function fromArrayView(arrayView) {
            if (isInstance(arrayView, Uint8Array)) {
              let copy = new Uint8Array(arrayView);
              return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
            }
            return fromArrayLike(arrayView);
          }
          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset)
              throw new RangeError('"offset" is outside of buffer bounds');
            if (array.byteLength < byteOffset + (length || 0))
              throw new RangeError('"length" is outside of buffer bounds');
            let buf;
            return byteOffset === void 0 && length === void 0 ? buf = new Uint8Array(array) : length === void 0 ? buf = new Uint8Array(array, byteOffset) : buf = new Uint8Array(array, byteOffset, length), Object.setPrototypeOf(buf, Buffer2.prototype), buf;
          }
          function fromObject(obj) {
            if (Buffer2.isBuffer(obj)) {
              let len = checked(obj.length) | 0, buf = createBuffer(len);
              return buf.length === 0 || obj.copy(buf, 0, 0, len), buf;
            }
            if (obj.length !== void 0)
              return typeof obj.length != "number" || numberIsNaN(obj.length) ? createBuffer(0) : fromArrayLike(obj);
            if (obj.type === "Buffer" && Array.isArray(obj.data))
              return fromArrayLike(obj.data);
          }
          function checked(length) {
            if (length >= K_MAX_LENGTH)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
            return length | 0;
          }
          function SlowBuffer(length) {
            return +length != length && (length = 0), Buffer2.alloc(+length);
          }
          Buffer2.isBuffer = function(b) {
            return b != null && b._isBuffer === !0 && b !== Buffer2.prototype;
          }, Buffer2.compare = function(a, b) {
            if (isInstance(a, Uint8Array) && (a = Buffer2.from(a, a.offset, a.byteLength)), isInstance(b, Uint8Array) && (b = Buffer2.from(b, b.offset, b.byteLength)), !Buffer2.isBuffer(a) || !Buffer2.isBuffer(b))
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (a === b)
              return 0;
            let x = a.length, y = b.length;
            for (let i = 0, len = Math.min(x, y); i < len; ++i)
              if (a[i] !== b[i]) {
                x = a[i], y = b[i];
                break;
              }
            return x < y ? -1 : y < x ? 1 : 0;
          }, Buffer2.isEncoding = function(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, Buffer2.concat = function(list, length) {
            if (!Array.isArray(list))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (list.length === 0)
              return Buffer2.alloc(0);
            let i;
            if (length === void 0)
              for (length = 0, i = 0; i < list.length; ++i)
                length += list[i].length;
            let buffer = Buffer2.allocUnsafe(length), pos = 0;
            for (i = 0; i < list.length; ++i) {
              let buf = list[i];
              if (isInstance(buf, Uint8Array))
                pos + buf.length > buffer.length ? (Buffer2.isBuffer(buf) || (buf = Buffer2.from(buf)), buf.copy(buffer, pos)) : Uint8Array.prototype.set.call(buffer, buf, pos);
              else if (Buffer2.isBuffer(buf))
                buf.copy(buffer, pos);
              else
                throw new TypeError('"list" argument must be an Array of Buffers');
              pos += buf.length;
            }
            return buffer;
          };
          function byteLength(string, encoding) {
            if (Buffer2.isBuffer(string))
              return string.length;
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer))
              return string.byteLength;
            if (typeof string != "string")
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
            let len = string.length, mustMatch = arguments.length > 2 && arguments[2] === !0;
            if (!mustMatch && len === 0)
              return 0;
            let loweredCase = !1;
            for (; ; )
              switch (encoding) {
                case "ascii":
                case "latin1":
                case "binary":
                  return len;
                case "utf8":
                case "utf-8":
                  return utf8ToBytes(string).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return len * 2;
                case "hex":
                  return len >>> 1;
                case "base64":
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase)
                    return mustMatch ? -1 : utf8ToBytes(string).length;
                  encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
              }
          }
          Buffer2.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            let loweredCase = !1;
            if ((start === void 0 || start < 0) && (start = 0), start > this.length || ((end === void 0 || end > this.length) && (end = this.length), end <= 0) || (end >>>= 0, start >>>= 0, end <= start))
              return "";
            for (encoding || (encoding = "utf8"); ; )
              switch (encoding) {
                case "hex":
                  return hexSlice(this, start, end);
                case "utf8":
                case "utf-8":
                  return utf8Slice(this, start, end);
                case "ascii":
                  return asciiSlice(this, start, end);
                case "latin1":
                case "binary":
                  return latin1Slice(this, start, end);
                case "base64":
                  return base64Slice(this, start, end);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = (encoding + "").toLowerCase(), loweredCase = !0;
              }
          }
          Buffer2.prototype._isBuffer = !0;
          function swap(b, n, m) {
            let i = b[n];
            b[n] = b[m], b[m] = i;
          }
          Buffer2.prototype.swap16 = function() {
            let len = this.length;
            if (len % 2 != 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let i = 0; i < len; i += 2)
              swap(this, i, i + 1);
            return this;
          }, Buffer2.prototype.swap32 = function() {
            let len = this.length;
            if (len % 4 != 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let i = 0; i < len; i += 4)
              swap(this, i, i + 3), swap(this, i + 1, i + 2);
            return this;
          }, Buffer2.prototype.swap64 = function() {
            let len = this.length;
            if (len % 8 != 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let i = 0; i < len; i += 8)
              swap(this, i, i + 7), swap(this, i + 1, i + 6), swap(this, i + 2, i + 5), swap(this, i + 3, i + 4);
            return this;
          }, Buffer2.prototype.toString = function() {
            let length = this.length;
            return length === 0 ? "" : arguments.length === 0 ? utf8Slice(this, 0, length) : slowToString.apply(this, arguments);
          }, Buffer2.prototype.toLocaleString = Buffer2.prototype.toString, Buffer2.prototype.equals = function(b) {
            if (!Buffer2.isBuffer(b))
              throw new TypeError("Argument must be a Buffer");
            return this === b ? !0 : Buffer2.compare(this, b) === 0;
          }, Buffer2.prototype.inspect = function() {
            let str = "", max = exports2.INSPECT_MAX_BYTES;
            return str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim(), this.length > max && (str += " ... "), "<Buffer " + str + ">";
          }, customInspectSymbol && (Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect), Buffer2.prototype.compare = function(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array) && (target = Buffer2.from(target, target.offset, target.byteLength)), !Buffer2.isBuffer(target))
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
            if (start === void 0 && (start = 0), end === void 0 && (end = target ? target.length : 0), thisStart === void 0 && (thisStart = 0), thisEnd === void 0 && (thisEnd = this.length), start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length)
              throw new RangeError("out of range index");
            if (thisStart >= thisEnd && start >= end)
              return 0;
            if (thisStart >= thisEnd)
              return -1;
            if (start >= end)
              return 1;
            if (start >>>= 0, end >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target)
              return 0;
            let x = thisEnd - thisStart, y = end - start, len = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end);
            for (let i = 0; i < len; ++i)
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i], y = targetCopy[i];
                break;
              }
            return x < y ? -1 : y < x ? 1 : 0;
          };
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (buffer.length === 0)
              return -1;
            if (typeof byteOffset == "string" ? (encoding = byteOffset, byteOffset = 0) : byteOffset > 2147483647 ? byteOffset = 2147483647 : byteOffset < -2147483648 && (byteOffset = -2147483648), byteOffset = +byteOffset, numberIsNaN(byteOffset) && (byteOffset = dir ? 0 : buffer.length - 1), byteOffset < 0 && (byteOffset = buffer.length + byteOffset), byteOffset >= buffer.length) {
              if (dir)
                return -1;
              byteOffset = buffer.length - 1;
            } else if (byteOffset < 0)
              if (dir)
                byteOffset = 0;
              else
                return -1;
            if (typeof val == "string" && (val = Buffer2.from(val, encoding)), Buffer2.isBuffer(val))
              return val.length === 0 ? -1 : arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            if (typeof val == "number")
              return val = val & 255, typeof Uint8Array.prototype.indexOf == "function" ? dir ? Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) : Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) : arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            throw new TypeError("val must be string, number or Buffer");
          }
          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            let indexSize = 1, arrLength = arr.length, valLength = val.length;
            if (encoding !== void 0 && (encoding = String(encoding).toLowerCase(), encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le")) {
              if (arr.length < 2 || val.length < 2)
                return -1;
              indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
            }
            function read(buf, i2) {
              return indexSize === 1 ? buf[i2] : buf.readUInt16BE(i2 * indexSize);
            }
            let i;
            if (dir) {
              let foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++)
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1 && (foundIndex = i), i - foundIndex + 1 === valLength)
                    return foundIndex * indexSize;
                } else
                  foundIndex !== -1 && (i -= i - foundIndex), foundIndex = -1;
            } else
              for (byteOffset + valLength > arrLength && (byteOffset = arrLength - valLength), i = byteOffset; i >= 0; i--) {
                let found = !0;
                for (let j = 0; j < valLength; j++)
                  if (read(arr, i + j) !== read(val, j)) {
                    found = !1;
                    break;
                  }
                if (found)
                  return i;
              }
            return -1;
          }
          Buffer2.prototype.includes = function(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          }, Buffer2.prototype.indexOf = function(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, !0);
          }, Buffer2.prototype.lastIndexOf = function(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, !1);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            let remaining = buf.length - offset;
            length ? (length = Number(length), length > remaining && (length = remaining)) : length = remaining;
            let strLen = string.length;
            length > strLen / 2 && (length = strLen / 2);
            let i;
            for (i = 0; i < length; ++i) {
              let parsed = parseInt(string.substr(i * 2, 2), 16);
              if (numberIsNaN(parsed))
                return i;
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer2.prototype.write = function(string, offset, length, encoding) {
            if (offset === void 0)
              encoding = "utf8", length = this.length, offset = 0;
            else if (length === void 0 && typeof offset == "string")
              encoding = offset, length = this.length, offset = 0;
            else if (isFinite(offset))
              offset = offset >>> 0, isFinite(length) ? (length = length >>> 0, encoding === void 0 && (encoding = "utf8")) : (encoding = length, length = void 0);
            else
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            let remaining = this.length - offset;
            if ((length === void 0 || length > remaining) && (length = remaining), string.length > 0 && (length < 0 || offset < 0) || offset > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            encoding || (encoding = "utf8");
            let loweredCase = !1;
            for (; ; )
              switch (encoding) {
                case "hex":
                  return hexWrite(this, string, offset, length);
                case "utf8":
                case "utf-8":
                  return utf8Write(this, string, offset, length);
                case "ascii":
                case "latin1":
                case "binary":
                  return asciiWrite(this, string, offset, length);
                case "base64":
                  return base64Write(this, string, offset, length);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
              }
          }, Buffer2.prototype.toJSON = function() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function base64Slice(buf, start, end) {
            return start === 0 && end === buf.length ? base64.fromByteArray(buf) : base64.fromByteArray(buf.slice(start, end));
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            let res = [], i = start;
            for (; i < end; ) {
              let firstByte = buf[i], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                let secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    firstByte < 128 && (codePoint = firstByte);
                    break;
                  case 2:
                    secondByte = buf[i + 1], (secondByte & 192) == 128 && (tempCodePoint = (firstByte & 31) << 6 | secondByte & 63, tempCodePoint > 127 && (codePoint = tempCodePoint));
                    break;
                  case 3:
                    secondByte = buf[i + 1], thirdByte = buf[i + 2], (secondByte & 192) == 128 && (thirdByte & 192) == 128 && (tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63, tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343) && (codePoint = tempCodePoint));
                    break;
                  case 4:
                    secondByte = buf[i + 1], thirdByte = buf[i + 2], fourthByte = buf[i + 3], (secondByte & 192) == 128 && (thirdByte & 192) == 128 && (fourthByte & 192) == 128 && (tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63, tempCodePoint > 65535 && tempCodePoint < 1114112 && (codePoint = tempCodePoint));
                }
              }
              codePoint === null ? (codePoint = 65533, bytesPerSequence = 1) : codePoint > 65535 && (codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), res.push(codePoint), i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          let MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            let len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH)
              return String.fromCharCode.apply(String, codePoints);
            let res = "", i = 0;
            for (; i < len; )
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            return res;
          }
          function asciiSlice(buf, start, end) {
            let ret = "";
            end = Math.min(buf.length, end);
            for (let i = start; i < end; ++i)
              ret += String.fromCharCode(buf[i] & 127);
            return ret;
          }
          function latin1Slice(buf, start, end) {
            let ret = "";
            end = Math.min(buf.length, end);
            for (let i = start; i < end; ++i)
              ret += String.fromCharCode(buf[i]);
            return ret;
          }
          function hexSlice(buf, start, end) {
            let len = buf.length;
            (!start || start < 0) && (start = 0), (!end || end < 0 || end > len) && (end = len);
            let out = "";
            for (let i = start; i < end; ++i)
              out += hexSliceLookupTable[buf[i]];
            return out;
          }
          function utf16leSlice(buf, start, end) {
            let bytes = buf.slice(start, end), res = "";
            for (let i = 0; i < bytes.length - 1; i += 2)
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            return res;
          }
          Buffer2.prototype.slice = function(start, end) {
            let len = this.length;
            start = ~~start, end = end === void 0 ? len : ~~end, start < 0 ? (start += len, start < 0 && (start = 0)) : start > len && (start = len), end < 0 ? (end += len, end < 0 && (end = 0)) : end > len && (end = len), end < start && (end = start);
            let newBuf = this.subarray(start, end);
            return Object.setPrototypeOf(newBuf, Buffer2.prototype), newBuf;
          };
          function checkOffset(offset, ext, length) {
            if (offset % 1 != 0 || offset < 0)
              throw new RangeError("offset is not uint");
            if (offset + ext > length)
              throw new RangeError("Trying to access beyond buffer length");
          }
          Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function(offset, byteLength2, noAssert) {
            offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, noAssert || checkOffset(offset, byteLength2, this.length);
            let val = this[offset], mul = 1, i = 0;
            for (; ++i < byteLength2 && (mul *= 256); )
              val += this[offset + i] * mul;
            return val;
          }, Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function(offset, byteLength2, noAssert) {
            offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, noAssert || checkOffset(offset, byteLength2, this.length);
            let val = this[offset + --byteLength2], mul = 1;
            for (; byteLength2 > 0 && (mul *= 256); )
              val += this[offset + --byteLength2] * mul;
            return val;
          }, Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 1, this.length), this[offset];
          }, Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 2, this.length), this[offset] | this[offset + 1] << 8;
          }, Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 2, this.length), this[offset] << 8 | this[offset + 1];
          }, Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 4, this.length), (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
          }, Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 4, this.length), this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          }, Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function(offset) {
            offset = offset >>> 0, validateNumber(offset, "offset");
            let first = this[offset], last = this[offset + 7];
            (first === void 0 || last === void 0) && boundsError(offset, this.length - 8);
            let lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24, hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
            return BigInt(lo) + (BigInt(hi) << BigInt(32));
          }), Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function(offset) {
            offset = offset >>> 0, validateNumber(offset, "offset");
            let first = this[offset], last = this[offset + 7];
            (first === void 0 || last === void 0) && boundsError(offset, this.length - 8);
            let hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset], lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
            return (BigInt(hi) << BigInt(32)) + BigInt(lo);
          }), Buffer2.prototype.readIntLE = function(offset, byteLength2, noAssert) {
            offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, noAssert || checkOffset(offset, byteLength2, this.length);
            let val = this[offset], mul = 1, i = 0;
            for (; ++i < byteLength2 && (mul *= 256); )
              val += this[offset + i] * mul;
            return mul *= 128, val >= mul && (val -= Math.pow(2, 8 * byteLength2)), val;
          }, Buffer2.prototype.readIntBE = function(offset, byteLength2, noAssert) {
            offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, noAssert || checkOffset(offset, byteLength2, this.length);
            let i = byteLength2, mul = 1, val = this[offset + --i];
            for (; i > 0 && (mul *= 256); )
              val += this[offset + --i] * mul;
            return mul *= 128, val >= mul && (val -= Math.pow(2, 8 * byteLength2)), val;
          }, Buffer2.prototype.readInt8 = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 1, this.length), this[offset] & 128 ? (255 - this[offset] + 1) * -1 : this[offset];
          }, Buffer2.prototype.readInt16LE = function(offset, noAssert) {
            offset = offset >>> 0, noAssert || checkOffset(offset, 2, this.length);
            let val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
          }, Buffer2.prototype.readInt16BE = function(offset, noAssert) {
            offset = offset >>> 0, noAssert || checkOffset(offset, 2, this.length);
            let val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
          }, Buffer2.prototype.readInt32LE = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 4, this.length), this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          }, Buffer2.prototype.readInt32BE = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 4, this.length), this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          }, Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function(offset) {
            offset = offset >>> 0, validateNumber(offset, "offset");
            let first = this[offset], last = this[offset + 7];
            (first === void 0 || last === void 0) && boundsError(offset, this.length - 8);
            let val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
            return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
          }), Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function(offset) {
            offset = offset >>> 0, validateNumber(offset, "offset");
            let first = this[offset], last = this[offset + 7];
            (first === void 0 || last === void 0) && boundsError(offset, this.length - 8);
            let val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
            return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
          }), Buffer2.prototype.readFloatLE = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !0, 23, 4);
          }, Buffer2.prototype.readFloatBE = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !1, 23, 4);
          }, Buffer2.prototype.readDoubleLE = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !0, 52, 8);
          }, Buffer2.prototype.readDoubleBE = function(offset, noAssert) {
            return offset = offset >>> 0, noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !1, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer2.isBuffer(buf))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min)
              throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
          }
          Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function(value, offset, byteLength2, noAssert) {
            if (value = +value, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
              let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            let mul = 1, i = 0;
            for (this[offset] = value & 255; ++i < byteLength2 && (mul *= 256); )
              this[offset + i] = value / mul & 255;
            return offset + byteLength2;
          }, Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function(value, offset, byteLength2, noAssert) {
            if (value = +value, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
              let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            let i = byteLength2 - 1, mul = 1;
            for (this[offset + i] = value & 255; --i >= 0 && (mul *= 256); )
              this[offset + i] = value / mul & 255;
            return offset + byteLength2;
          }, Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function(value, offset, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkInt(this, value, offset, 1, 255, 0), this[offset] = value & 255, offset + 1;
          }, Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function(value, offset, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
          }, Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function(value, offset, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
          }, Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function(value, offset, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = value & 255, offset + 4;
          }, Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function(value, offset, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
          };
          function wrtBigUInt64LE(buf, value, offset, min, max) {
            checkIntBI(value, min, max, buf, offset, 7);
            let lo = Number(value & BigInt(4294967295));
            buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo;
            let hi = Number(value >> BigInt(32) & BigInt(4294967295));
            return buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, offset;
          }
          function wrtBigUInt64BE(buf, value, offset, min, max) {
            checkIntBI(value, min, max, buf, offset, 7);
            let lo = Number(value & BigInt(4294967295));
            buf[offset + 7] = lo, lo = lo >> 8, buf[offset + 6] = lo, lo = lo >> 8, buf[offset + 5] = lo, lo = lo >> 8, buf[offset + 4] = lo;
            let hi = Number(value >> BigInt(32) & BigInt(4294967295));
            return buf[offset + 3] = hi, hi = hi >> 8, buf[offset + 2] = hi, hi = hi >> 8, buf[offset + 1] = hi, hi = hi >> 8, buf[offset] = hi, offset + 8;
          }
          Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function(value, offset = 0) {
            return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
          }), Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function(value, offset = 0) {
            return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
          }), Buffer2.prototype.writeIntLE = function(value, offset, byteLength2, noAssert) {
            if (value = +value, offset = offset >>> 0, !noAssert) {
              let limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            let i = 0, mul = 1, sub = 0;
            for (this[offset] = value & 255; ++i < byteLength2 && (mul *= 256); )
              value < 0 && sub === 0 && this[offset + i - 1] !== 0 && (sub = 1), this[offset + i] = (value / mul >> 0) - sub & 255;
            return offset + byteLength2;
          }, Buffer2.prototype.writeIntBE = function(value, offset, byteLength2, noAssert) {
            if (value = +value, offset = offset >>> 0, !noAssert) {
              let limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            let i = byteLength2 - 1, mul = 1, sub = 0;
            for (this[offset + i] = value & 255; --i >= 0 && (mul *= 256); )
              value < 0 && sub === 0 && this[offset + i + 1] !== 0 && (sub = 1), this[offset + i] = (value / mul >> 0) - sub & 255;
            return offset + byteLength2;
          }, Buffer2.prototype.writeInt8 = function(value, offset, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkInt(this, value, offset, 1, 127, -128), value < 0 && (value = 255 + value + 1), this[offset] = value & 255, offset + 1;
          }, Buffer2.prototype.writeInt16LE = function(value, offset, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
          }, Buffer2.prototype.writeInt16BE = function(value, offset, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
          }, Buffer2.prototype.writeInt32LE = function(value, offset, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), this[offset] = value & 255, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24, offset + 4;
          }, Buffer2.prototype.writeInt32BE = function(value, offset, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), value < 0 && (value = 4294967295 + value + 1), this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
          }, Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function(value, offset = 0) {
            return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
          }), Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function(value, offset = 0) {
            return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
          });
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
            if (offset < 0)
              throw new RangeError("Index out of range");
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22), ieee754.write(buf, value, offset, littleEndian, 23, 4), offset + 4;
          }
          Buffer2.prototype.writeFloatLE = function(value, offset, noAssert) {
            return writeFloat(this, value, offset, !0, noAssert);
          }, Buffer2.prototype.writeFloatBE = function(value, offset, noAssert) {
            return writeFloat(this, value, offset, !1, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            return value = +value, offset = offset >>> 0, noAssert || checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292), ieee754.write(buf, value, offset, littleEndian, 52, 8), offset + 8;
          }
          Buffer2.prototype.writeDoubleLE = function(value, offset, noAssert) {
            return writeDouble(this, value, offset, !0, noAssert);
          }, Buffer2.prototype.writeDoubleBE = function(value, offset, noAssert) {
            return writeDouble(this, value, offset, !1, noAssert);
          }, Buffer2.prototype.copy = function(target, targetStart, start, end) {
            if (!Buffer2.isBuffer(target))
              throw new TypeError("argument should be a Buffer");
            if (start || (start = 0), !end && end !== 0 && (end = this.length), targetStart >= target.length && (targetStart = target.length), targetStart || (targetStart = 0), end > 0 && end < start && (end = start), end === start || target.length === 0 || this.length === 0)
              return 0;
            if (targetStart < 0)
              throw new RangeError("targetStart out of bounds");
            if (start < 0 || start >= this.length)
              throw new RangeError("Index out of range");
            if (end < 0)
              throw new RangeError("sourceEnd out of bounds");
            end > this.length && (end = this.length), target.length - targetStart < end - start && (end = target.length - targetStart + start);
            let len = end - start;
            return this === target && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(targetStart, start, end) : Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart), len;
          }, Buffer2.prototype.fill = function(val, start, end, encoding) {
            if (typeof val == "string") {
              if (typeof start == "string" ? (encoding = start, start = 0, end = this.length) : typeof end == "string" && (encoding = end, end = this.length), encoding !== void 0 && typeof encoding != "string")
                throw new TypeError("encoding must be a string");
              if (typeof encoding == "string" && !Buffer2.isEncoding(encoding))
                throw new TypeError("Unknown encoding: " + encoding);
              if (val.length === 1) {
                let code = val.charCodeAt(0);
                (encoding === "utf8" && code < 128 || encoding === "latin1") && (val = code);
              }
            } else
              typeof val == "number" ? val = val & 255 : typeof val == "boolean" && (val = Number(val));
            if (start < 0 || this.length < start || this.length < end)
              throw new RangeError("Out of range index");
            if (end <= start)
              return this;
            start = start >>> 0, end = end === void 0 ? this.length : end >>> 0, val || (val = 0);
            let i;
            if (typeof val == "number")
              for (i = start; i < end; ++i)
                this[i] = val;
            else {
              let bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding), len = bytes.length;
              if (len === 0)
                throw new TypeError('The value "' + val + '" is invalid for argument "value"');
              for (i = 0; i < end - start; ++i)
                this[i + start] = bytes[i % len];
            }
            return this;
          };
          let errors = {};
          function E(sym, getMessage, Base) {
            errors[sym] = class extends Base {
              constructor() {
                super();
                Object.defineProperty(this, "message", {
                  value: getMessage.apply(this, arguments),
                  writable: !0,
                  configurable: !0
                }), this.name = `${this.name} [${sym}]`, this.stack, delete this.name;
              }
              get code() {
                return sym;
              }
              set code(value) {
                Object.defineProperty(this, "code", {
                  configurable: !0,
                  enumerable: !0,
                  value,
                  writable: !0
                });
              }
              toString() {
                return `${this.name} [${sym}]: ${this.message}`;
              }
            };
          }
          E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
            return name ? `${name} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
          }, RangeError), E("ERR_INVALID_ARG_TYPE", function(name, actual) {
            return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
          }, TypeError), E("ERR_OUT_OF_RANGE", function(str, range, input) {
            let msg = `The value of "${str}" is out of range.`, received = input;
            return Number.isInteger(input) && Math.abs(input) > 2 ** 32 ? received = addNumericalSeparator(String(input)) : typeof input == "bigint" && (received = String(input), (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) && (received = addNumericalSeparator(received)), received += "n"), msg += ` It must be ${range}. Received ${received}`, msg;
          }, RangeError);
          function addNumericalSeparator(val) {
            let res = "", i = val.length, start = val[0] === "-" ? 1 : 0;
            for (; i >= start + 4; i -= 3)
              res = `_${val.slice(i - 3, i)}${res}`;
            return `${val.slice(0, i)}${res}`;
          }
          function checkBounds(buf, offset, byteLength2) {
            validateNumber(offset, "offset"), (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) && boundsError(offset, buf.length - (byteLength2 + 1));
          }
          function checkIntBI(value, min, max, buf, offset, byteLength2) {
            if (value > max || value < min) {
              let n = typeof min == "bigint" ? "n" : "", range;
              throw byteLength2 > 3 ? min === 0 || min === BigInt(0) ? range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}` : range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}` : range = `>= ${min}${n} and <= ${max}${n}`, new errors.ERR_OUT_OF_RANGE("value", range, value);
            }
            checkBounds(buf, offset, byteLength2);
          }
          function validateNumber(value, name) {
            if (typeof value != "number")
              throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
          }
          function boundsError(value, length, type) {
            throw Math.floor(value) !== value ? (validateNumber(value, type), new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value)) : length < 0 ? new errors.ERR_BUFFER_OUT_OF_BOUNDS() : new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
          }
          let INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
          function base64clean(str) {
            if (str = str.split("=")[0], str = str.trim().replace(INVALID_BASE64_RE, ""), str.length < 2)
              return "";
            for (; str.length % 4 != 0; )
              str = str + "=";
            return str;
          }
          function utf8ToBytes(string, units) {
            units = units || 1 / 0;
            let codePoint, length = string.length, leadSurrogate = null, bytes = [];
            for (let i = 0; i < length; ++i) {
              if (codePoint = string.charCodeAt(i), codePoint > 55295 && codePoint < 57344) {
                if (!leadSurrogate) {
                  if (codePoint > 56319) {
                    (units -= 3) > -1 && bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    (units -= 3) > -1 && bytes.push(239, 191, 189);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 56320) {
                  (units -= 3) > -1 && bytes.push(239, 191, 189), leadSurrogate = codePoint;
                  continue;
                }
                codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
              } else
                leadSurrogate && (units -= 3) > -1 && bytes.push(239, 191, 189);
              if (leadSurrogate = null, codePoint < 128) {
                if ((units -= 1) < 0)
                  break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0)
                  break;
                bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0)
                  break;
                bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0)
                  break;
                bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else
                throw new Error("Invalid code point");
            }
            return bytes;
          }
          function asciiToBytes(str) {
            let byteArray = [];
            for (let i = 0; i < str.length; ++i)
              byteArray.push(str.charCodeAt(i) & 255);
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            let c, hi, lo, byteArray = [];
            for (let i = 0; i < str.length && !((units -= 2) < 0); ++i)
              c = str.charCodeAt(i), hi = c >> 8, lo = c % 256, byteArray.push(lo), byteArray.push(hi);
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            let i;
            for (i = 0; i < length && !(i + offset >= dst.length || i >= src.length); ++i)
              dst[i + offset] = src[i];
            return i;
          }
          function isInstance(obj, type) {
            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
          }
          function numberIsNaN(obj) {
            return obj !== obj;
          }
          let hexSliceLookupTable = function() {
            let alphabet = "0123456789abcdef", table = new Array(256);
            for (let i = 0; i < 16; ++i) {
              let i16 = i * 16;
              for (let j = 0; j < 16; ++j)
                table[i16 + j] = alphabet[i] + alphabet[j];
            }
            return table;
          }();
          function defineBigIntMethod(fn) {
            return typeof BigInt == "undefined" ? BufferBigIntNotDefined : fn;
          }
          function BufferBigIntNotDefined() {
            throw new Error("BigInt not supported");
          }
        },
        "./node_modules/css-loader/dist/runtime/api.js": (module3) => {
          "use strict";
          module3.exports = function(cssWithMappingToString) {
            var list = [];
            return list.toString = function() {
              return this.map(function(item) {
                var content = "", needLayer = typeof item[5] != "undefined";
                return item[4] && (content += "@supports (".concat(item[4], ") {")), item[2] && (content += "@media ".concat(item[2], " {")), needLayer && (content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {")), content += cssWithMappingToString(item), needLayer && (content += "}"), item[2] && (content += "}"), item[4] && (content += "}"), content;
              }).join("");
            }, list.i = function(modules, media, dedupe, supports, layer) {
              typeof modules == "string" && (modules = [[null, modules, void 0]]);
              var alreadyImportedModules = {};
              if (dedupe)
                for (var k = 0; k < this.length; k++) {
                  var id = this[k][0];
                  id != null && (alreadyImportedModules[id] = !0);
                }
              for (var _k = 0; _k < modules.length; _k++) {
                var item = [].concat(modules[_k]);
                dedupe && alreadyImportedModules[item[0]] || (typeof layer != "undefined" && (typeof item[5] == "undefined" || (item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}")), item[5] = layer), media && (item[2] && (item[1] = "@media ".concat(item[2], " {").concat(item[1], "}")), item[2] = media), supports && (item[4] ? (item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}"), item[4] = supports) : item[4] = "".concat(supports)), list.push(item));
              }
            }, list;
          };
        },
        "./node_modules/css-loader/dist/runtime/getUrl.js": (module3) => {
          "use strict";
          module3.exports = function(url, options) {
            return options || (options = {}), url && (url = String(url.__esModule ? url.default : url), /^['"].*['"]$/.test(url) && (url = url.slice(1, -1)), options.hash && (url += options.hash), /["'() \t\n]|(%20)/.test(url) || options.needQuotes ? '"'.concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"') : url);
          };
        },
        "./node_modules/css-loader/dist/runtime/sourceMaps.js": (module3) => {
          "use strict";
          module3.exports = function(item) {
            var content = item[1], cssMapping = item[3];
            if (!cssMapping)
              return content;
            if (typeof btoa == "function") {
              var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping)))), data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64), sourceMapping = "/*# ".concat(data, " */");
              return [content].concat([sourceMapping]).join(`
`);
            }
            return [content].join(`
`);
          };
        },
        "./node_modules/debug/src/browser.js": (module3, exports2, __webpack_require__2) => {
          exports2.formatArgs = formatArgs, exports2.save = save, exports2.load = load, exports2.useColors = useColors, exports2.storage = localstorage(), exports2.destroy = (() => {
            let warned = !1;
            return () => {
              warned || (warned = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
            };
          })(), exports2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
          function useColors() {
            return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }
          function formatArgs(args) {
            if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module3.exports.humanize(this.diff), !this.useColors)
              return;
            let c = "color: " + this.color;
            args.splice(1, 0, c, "color: inherit");
            let index = 0, lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match) => {
              match !== "%%" && (index++, match === "%c" && (lastC = index));
            }), args.splice(lastC, 0, c);
          }
          exports2.log = console.debug || console.log || (() => {
          });
          function save(namespaces) {
            try {
              namespaces ? exports2.storage.setItem("debug", namespaces) : exports2.storage.removeItem("debug");
            } catch (error) {
            }
          }
          function load() {
            let r;
            try {
              r = exports2.storage.getItem("debug");
            } catch (error) {
            }
            return !r && typeof process != "undefined" && "env" in process && (r = process.env.DEBUG), r;
          }
          function localstorage() {
            try {
              return localStorage;
            } catch (error) {
            }
          }
          module3.exports = __webpack_require__2("./node_modules/debug/src/common.js")(exports2);
          let {
            formatters
          } = module3.exports;
          formatters.j = function(v) {
            try {
              return JSON.stringify(v);
            } catch (error) {
              return "[UnexpectedJSONParseError]: " + error.message;
            }
          };
        },
        "./node_modules/debug/src/common.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          function setup(env) {
            createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = coerce, createDebug.disable = disable, createDebug.enable = enable, createDebug.enabled = enabled, createDebug.humanize = __webpack_require__2("./node_modules/ms/index.js"), createDebug.destroy = destroy, Object.keys(env).forEach((key) => {
              createDebug[key] = env[key];
            }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {};
            function selectColor(namespace) {
              let hash = 0;
              for (let i = 0; i < namespace.length; i++)
                hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;
              return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
              let prevTime, enableOverride = null, namespacesCache, enabledCache;
              function debug(...args) {
                if (!debug.enabled)
                  return;
                let self2 = debug, curr = Number(new Date()), ms = curr - (prevTime || curr);
                self2.diff = ms, self2.prev = prevTime, self2.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), typeof args[0] != "string" && args.unshift("%O");
                let index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                  if (match === "%%")
                    return "%";
                  index++;
                  let formatter = createDebug.formatters[format];
                  if (typeof formatter == "function") {
                    let val = args[index];
                    match = formatter.call(self2, val), args.splice(index, 1), index--;
                  }
                  return match;
                }), createDebug.formatArgs.call(self2, args), (self2.log || createDebug.log).apply(self2, args);
              }
              return debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), debug.extend = extend, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", {
                enumerable: !0,
                configurable: !1,
                get: () => enableOverride !== null ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace)), enabledCache),
                set: (v) => {
                  enableOverride = v;
                }
              }), typeof createDebug.init == "function" && createDebug.init(debug), debug;
            }
            function extend(namespace, delimiter) {
              let newDebug = createDebug(this.namespace + (typeof delimiter == "undefined" ? ":" : delimiter) + namespace);
              return newDebug.log = this.log, newDebug;
            }
            function enable(namespaces) {
              createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];
              let i, split = (typeof namespaces == "string" ? namespaces : "").split(/[\s,]+/), len = split.length;
              for (i = 0; i < len; i++)
                !split[i] || (namespaces = split[i].replace(/\*/g, ".*?"), namespaces[0] === "-" ? createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
            }
            function disable() {
              let namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)].join(",");
              return createDebug.enable(""), namespaces;
            }
            function enabled(name) {
              if (name[name.length - 1] === "*")
                return !0;
              let i, len;
              for (i = 0, len = createDebug.skips.length; i < len; i++)
                if (createDebug.skips[i].test(name))
                  return !1;
              for (i = 0, len = createDebug.names.length; i < len; i++)
                if (createDebug.names[i].test(name))
                  return !0;
              return !1;
            }
            function toNamespace(regexp) {
              return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
            }
            function coerce(val) {
              return val instanceof Error ? val.stack || val.message : val;
            }
            function destroy() {
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
            return createDebug.enable(createDebug.load()), createDebug;
          }
          module3.exports = setup;
        },
        "./node_modules/deep-assign/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          "use strict";
          var isObj = __webpack_require__2("./node_modules/is-obj/index.js"), hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
          function toObject(val) {
            if (val == null)
              throw new TypeError("Sources cannot be null or undefined");
            return Object(val);
          }
          function assignKey(to, from, key) {
            var val = from[key];
            if (val != null) {
              if (hasOwnProperty.call(to, key) && (to[key] === void 0 || to[key] === null))
                throw new TypeError("Cannot convert undefined or null to object (" + key + ")");
              !hasOwnProperty.call(to, key) || !isObj(val) ? to[key] = val : to[key] = assign(Object(to[key]), from[key]);
            }
          }
          function assign(to, from) {
            if (to === from)
              return to;
            from = Object(from);
            for (var key in from)
              hasOwnProperty.call(from, key) && assignKey(to, from, key);
            if (Object.getOwnPropertySymbols)
              for (var symbols = Object.getOwnPropertySymbols(from), i = 0; i < symbols.length; i++)
                propIsEnumerable.call(from, symbols[i]) && assignKey(to, from, symbols[i]);
            return to;
          }
          module3.exports = function(target) {
            target = toObject(target);
            for (var s = 1; s < arguments.length; s++)
              assign(target, arguments[s]);
            return target;
          };
        },
        "./node_modules/dtype/index.js": (module3) => {
          module3.exports = function(dtype) {
            switch (dtype) {
              case "int8":
                return Int8Array;
              case "int16":
                return Int16Array;
              case "int32":
                return Int32Array;
              case "uint8":
                return Uint8Array;
              case "uint16":
                return Uint16Array;
              case "uint32":
                return Uint32Array;
              case "float32":
                return Float32Array;
              case "float64":
                return Float64Array;
              case "array":
                return Array;
              case "uint8_clamped":
                return Uint8ClampedArray;
            }
          };
        },
        "./node_modules/global/window.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var win;
          typeof window != "undefined" ? win = window : typeof __webpack_require__2.g != "undefined" ? win = __webpack_require__2.g : typeof self != "undefined" ? win = self : win = {}, module3.exports = win;
        },
        "./node_modules/ieee754/index.js": (__unused_webpack_module, exports2) => {
          exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i];
            for (i += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
              ;
            for (m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
              ;
            if (e === 0)
              e = 1 - eBias;
            else {
              if (e === eMax)
                return m ? NaN : (s ? -1 : 1) * (1 / 0);
              m = m + Math.pow(2, mLen), e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          }, exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            for (value = Math.abs(value), isNaN(value) || value === 1 / 0 ? (m = isNaN(value) ? 1 : 0, e = eMax) : (e = Math.floor(Math.log(value) / Math.LN2), value * (c = Math.pow(2, -e)) < 1 && (e--, c *= 2), e + eBias >= 1 ? value += rt / c : value += rt * Math.pow(2, 1 - eBias), value * c >= 2 && (e++, c /= 2), e + eBias >= eMax ? (m = 0, e = eMax) : e + eBias >= 1 ? (m = (value * c - 1) * Math.pow(2, mLen), e = e + eBias) : (m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0)); mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8)
              ;
            for (e = e << mLen | m, eLen += mLen; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8)
              ;
            buffer[offset + i - d] |= s * 128;
          };
        },
        "./node_modules/is-buffer/index.js": (module3) => {
          module3.exports = function(obj) {
            return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
          };
          function isBuffer(obj) {
            return !!obj.constructor && typeof obj.constructor.isBuffer == "function" && obj.constructor.isBuffer(obj);
          }
          function isSlowBuffer(obj) {
            return typeof obj.readFloatLE == "function" && typeof obj.slice == "function" && isBuffer(obj.slice(0, 0));
          }
        },
        "./node_modules/is-function/index.js": (module3) => {
          module3.exports = isFunction;
          var toString = Object.prototype.toString;
          function isFunction(fn) {
            if (!fn)
              return !1;
            var string = toString.call(fn);
            return string === "[object Function]" || typeof fn == "function" && string !== "[object RegExp]" || typeof window != "undefined" && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
          }
        },
        "./node_modules/is-obj/index.js": (module3) => {
          "use strict";
          module3.exports = function(x) {
            var type = typeof x;
            return x !== null && (type === "object" || type === "function");
          };
        },
        "./node_modules/layout-bmfont-text/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var wordWrap = __webpack_require__2("./node_modules/word-wrapper/index.js"), xtend = __webpack_require__2("./node_modules/xtend/immutable.js"), number = __webpack_require__2("./node_modules/as-number/index.js"), X_HEIGHTS = ["x", "e", "a", "o", "n", "s", "r", "c", "u", "m", "v", "w", "z"], M_WIDTHS = ["m", "w"], CAP_HEIGHTS = ["H", "I", "N", "E", "F", "K", "L", "T", "U", "V", "W", "X", "Y", "Z"], TAB_ID = "	".charCodeAt(0), SPACE_ID = " ".charCodeAt(0), ALIGN_LEFT = 0, ALIGN_CENTER = 1, ALIGN_RIGHT = 2;
          module3.exports = function(opt) {
            return new TextLayout(opt);
          };
          function TextLayout(opt) {
            this.glyphs = [], this._measure = this.computeMetrics.bind(this), this.update(opt);
          }
          TextLayout.prototype.update = function(opt) {
            if (opt = xtend({
              measure: this._measure
            }, opt), this._opt = opt, this._opt.tabSize = number(this._opt.tabSize, 4), !opt.font)
              throw new Error("must provide a valid bitmap font");
            var glyphs = this.glyphs, text = opt.text || "", font = opt.font;
            this._setupSpaceGlyphs(font);
            var lines = wordWrap.lines(text, opt), minWidth = opt.width || 0;
            glyphs.length = 0;
            var maxLineWidth = lines.reduce(function(prev, line) {
              return Math.max(prev, line.width, minWidth);
            }, 0), x = 0, y = 0, lineHeight = number(opt.lineHeight, font.common.lineHeight), baseline = font.common.base, descender = lineHeight - baseline, letterSpacing = opt.letterSpacing || 0, height = lineHeight * lines.length - descender, align = getAlignType(this._opt.align);
            y -= height, this._width = maxLineWidth, this._height = height, this._descender = lineHeight - baseline, this._baseline = baseline, this._xHeight = getXHeight(font), this._capHeight = getCapHeight(font), this._lineHeight = lineHeight, this._ascender = lineHeight - descender - this._xHeight;
            var self2 = this;
            lines.forEach(function(line, lineIndex) {
              for (var start = line.start, end = line.end, lineWidth = line.width, lastGlyph, i = start; i < end; i++) {
                var id = text.charCodeAt(i), glyph = self2.getGlyph(font, id);
                if (glyph) {
                  lastGlyph && (x += getKerning(font, lastGlyph.id, glyph.id));
                  var tx = x;
                  align === ALIGN_CENTER ? tx += (maxLineWidth - lineWidth) / 2 : align === ALIGN_RIGHT && (tx += maxLineWidth - lineWidth), glyphs.push({
                    position: [tx, y],
                    data: glyph,
                    index: i,
                    line: lineIndex
                  }), x += glyph.xadvance + letterSpacing, lastGlyph = glyph;
                }
              }
              y += lineHeight, x = 0;
            }), this._linesTotal = lines.length;
          }, TextLayout.prototype._setupSpaceGlyphs = function(font) {
            if (this._fallbackSpaceGlyph = null, this._fallbackTabGlyph = null, !(!font.chars || font.chars.length === 0)) {
              var space = getGlyphById(font, SPACE_ID) || getMGlyph(font) || font.chars[0], tabWidth = this._opt.tabSize * space.xadvance;
              this._fallbackSpaceGlyph = space, this._fallbackTabGlyph = xtend(space, {
                x: 0,
                y: 0,
                xadvance: tabWidth,
                id: TAB_ID,
                xoffset: 0,
                yoffset: 0,
                width: 0,
                height: 0
              });
            }
          }, TextLayout.prototype.getGlyph = function(font, id) {
            var glyph = getGlyphById(font, id);
            return glyph || (id === TAB_ID ? this._fallbackTabGlyph : id === SPACE_ID ? this._fallbackSpaceGlyph : null);
          }, TextLayout.prototype.computeMetrics = function(text, start, end, width) {
            var letterSpacing = this._opt.letterSpacing || 0, font = this._opt.font, curPen = 0, curWidth = 0, count = 0, glyph, lastGlyph;
            if (!font.chars || font.chars.length === 0)
              return {
                start,
                end: start,
                width: 0
              };
            end = Math.min(text.length, end);
            for (var i = start; i < end; i++) {
              var id = text.charCodeAt(i), glyph = this.getGlyph(font, id);
              if (glyph) {
                var xoff = glyph.xoffset, kern = lastGlyph ? getKerning(font, lastGlyph.id, glyph.id) : 0;
                curPen += kern;
                var nextPen = curPen + glyph.xadvance + letterSpacing, nextWidth = curPen + glyph.width;
                if (nextWidth >= width || nextPen >= width)
                  break;
                curPen = nextPen, curWidth = nextWidth, lastGlyph = glyph;
              }
              count++;
            }
            return lastGlyph && (curWidth += lastGlyph.xoffset), {
              start,
              end: start + count,
              width: curWidth
            };
          }, ["width", "height", "descender", "ascender", "xHeight", "baseline", "capHeight", "lineHeight"].forEach(addGetter);
          function addGetter(name) {
            Object.defineProperty(TextLayout.prototype, name, {
              get: wrapper(name),
              configurable: !0
            });
          }
          function wrapper(name) {
            return new Function(["return function " + name + "() {", "  return this._" + name, "}"].join(`
`))();
          }
          function getGlyphById(font, id) {
            if (!font.chars || font.chars.length === 0)
              return null;
            var glyphIdx = findChar(font.chars, id);
            return glyphIdx >= 0 ? font.chars[glyphIdx] : null;
          }
          function getXHeight(font) {
            for (var i = 0; i < X_HEIGHTS.length; i++) {
              var id = X_HEIGHTS[i].charCodeAt(0), idx = findChar(font.chars, id);
              if (idx >= 0)
                return font.chars[idx].height;
            }
            return 0;
          }
          function getMGlyph(font) {
            for (var i = 0; i < M_WIDTHS.length; i++) {
              var id = M_WIDTHS[i].charCodeAt(0), idx = findChar(font.chars, id);
              if (idx >= 0)
                return font.chars[idx];
            }
            return 0;
          }
          function getCapHeight(font) {
            for (var i = 0; i < CAP_HEIGHTS.length; i++) {
              var id = CAP_HEIGHTS[i].charCodeAt(0), idx = findChar(font.chars, id);
              if (idx >= 0)
                return font.chars[idx].height;
            }
            return 0;
          }
          function getKerning(font, left, right) {
            if (!font.kernings || font.kernings.length === 0)
              return 0;
            for (var table = font.kernings, i = 0; i < table.length; i++) {
              var kern = table[i];
              if (kern.first === left && kern.second === right)
                return kern.amount;
            }
            return 0;
          }
          function getAlignType(align) {
            return align === "center" ? ALIGN_CENTER : align === "right" ? ALIGN_RIGHT : ALIGN_LEFT;
          }
          function findChar(array, value, start) {
            start = start || 0;
            for (var i = start; i < array.length; i++)
              if (array[i].id === value)
                return i;
            return -1;
          }
        },
        "./node_modules/load-bmfont/browser.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var Buffer2 = __webpack_require__2("./node_modules/buffer/index.js").Buffer, xhr = __webpack_require__2("./node_modules/xhr/index.js"), noop = function() {
          }, parseASCII = __webpack_require__2("./node_modules/parse-bmfont-ascii/index.js"), parseXML = __webpack_require__2("./node_modules/parse-bmfont-xml/lib/browser.js"), readBinary = __webpack_require__2("./node_modules/parse-bmfont-binary/index.js"), isBinaryFormat = __webpack_require__2("./node_modules/load-bmfont/lib/is-binary.js"), xtend = __webpack_require__2("./node_modules/xtend/immutable.js"), xml2 = function() {
            return self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
          }();
          module3.exports = function(opt, cb) {
            cb = typeof cb == "function" ? cb : noop, typeof opt == "string" ? opt = {
              uri: opt
            } : opt || (opt = {});
            var expectBinary = opt.binary;
            expectBinary && (opt = getBinaryOpts(opt)), xhr(opt, function(err, res, body) {
              if (err)
                return cb(err);
              if (!/^2/.test(res.statusCode))
                return cb(new Error("http status code: " + res.statusCode));
              if (!body)
                return cb(new Error("no body result"));
              var binary = !1;
              if (isArrayBuffer(body)) {
                var array = new Uint8Array(body);
                body = Buffer2.from(array, "binary");
              }
              isBinaryFormat(body) && (binary = !0, typeof body == "string" && (body = Buffer2.from(body, "binary"))), binary || (Buffer2.isBuffer(body) && (body = body.toString(opt.encoding)), body = body.trim());
              var result;
              try {
                var type = res.headers["content-type"];
                binary ? result = readBinary(body) : /json/.test(type) || body.charAt(0) === "{" ? result = JSON.parse(body) : /xml/.test(type) || body.charAt(0) === "<" ? result = parseXML(body) : result = parseASCII(body);
              } catch (e) {
                cb(new Error("error parsing font " + e.message)), cb = noop;
              }
              cb(null, result);
            });
          };
          function isArrayBuffer(arr) {
            var str = Object.prototype.toString;
            return str.call(arr) === "[object ArrayBuffer]";
          }
          function getBinaryOpts(opt) {
            if (xml2)
              return xtend(opt, {
                responseType: "arraybuffer"
              });
            if (typeof self.XMLHttpRequest == "undefined")
              throw new Error("your browser does not support XHR loading");
            var req = new self.XMLHttpRequest();
            return req.overrideMimeType("text/plain; charset=x-user-defined"), xtend({
              xhr: req
            }, opt);
          }
        },
        "./node_modules/load-bmfont/lib/is-binary.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var Buffer2 = __webpack_require__2("./node_modules/buffer/index.js").Buffer, equal = __webpack_require__2("./node_modules/buffer-equal/index.js"), HEADER = Buffer2.from([66, 77, 70, 3]);
          module3.exports = function(buf) {
            return typeof buf == "string" ? buf.substring(0, 3) === "BMF" : buf.length > 4 && equal(buf.slice(0, 4), HEADER);
          };
        },
        "./node_modules/ms/index.js": (module3) => {
          var s = 1e3, m = s * 60, h = m * 60, d = h * 24, w = d * 7, y = d * 365.25;
          module3.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if (type === "string" && val.length > 0)
              return parse(val);
            if (type === "number" && isFinite(val))
              return options.long ? fmtLong(val) : fmtShort(val);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
          };
          function parse(str) {
            if (str = String(str), !(str.length > 100)) {
              var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
              if (!!match) {
                var n = parseFloat(match[1]), type = (match[2] || "ms").toLowerCase();
                switch (type) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return n * y;
                  case "weeks":
                  case "week":
                  case "w":
                    return n * w;
                  case "days":
                  case "day":
                  case "d":
                    return n * d;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return n * h;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return n * m;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return n * s;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return n;
                  default:
                    return;
                }
              }
            }
          }
          function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            return msAbs >= d ? Math.round(ms / d) + "d" : msAbs >= h ? Math.round(ms / h) + "h" : msAbs >= m ? Math.round(ms / m) + "m" : msAbs >= s ? Math.round(ms / s) + "s" : ms + "ms";
          }
          function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            return msAbs >= d ? plural(ms, msAbs, d, "day") : msAbs >= h ? plural(ms, msAbs, h, "hour") : msAbs >= m ? plural(ms, msAbs, m, "minute") : msAbs >= s ? plural(ms, msAbs, s, "second") : ms + " ms";
          }
          function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= n * 1.5;
            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
          }
        },
        "./node_modules/parse-bmfont-ascii/index.js": (module3) => {
          module3.exports = function(data) {
            if (!data)
              throw new Error("no data provided");
            data = data.toString().trim();
            var output = {
              pages: [],
              chars: [],
              kernings: []
            }, lines = data.split(/\r\n?|\n/g);
            if (lines.length === 0)
              throw new Error("no data in BMFont file");
            for (var i = 0; i < lines.length; i++) {
              var lineData = splitLine(lines[i], i);
              if (!!lineData)
                if (lineData.key === "page") {
                  if (typeof lineData.data.id != "number")
                    throw new Error("malformed file at line " + i + " -- needs page id=N");
                  if (typeof lineData.data.file != "string")
                    throw new Error("malformed file at line " + i + ' -- needs page file="path"');
                  output.pages[lineData.data.id] = lineData.data.file;
                } else
                  lineData.key === "chars" || lineData.key === "kernings" || (lineData.key === "char" ? output.chars.push(lineData.data) : lineData.key === "kerning" ? output.kernings.push(lineData.data) : output[lineData.key] = lineData.data);
            }
            return output;
          };
          function splitLine(line, idx) {
            if (line = line.replace(/\t+/g, " ").trim(), !line)
              return null;
            var space = line.indexOf(" ");
            if (space === -1)
              throw new Error("no named row at line " + idx);
            var key = line.substring(0, space);
            line = line.substring(space + 1), line = line.replace(/letter=[\'\"]\S+[\'\"]/gi, ""), line = line.split("="), line = line.map(function(str) {
              return str.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
            });
            for (var data = [], i = 0; i < line.length; i++) {
              var dt = line[i];
              i === 0 ? data.push({
                key: dt[0],
                data: ""
              }) : i === line.length - 1 ? data[data.length - 1].data = parseData(dt[0]) : (data[data.length - 1].data = parseData(dt[0]), data.push({
                key: dt[1],
                data: ""
              }));
            }
            var out = {
              key,
              data: {}
            };
            return data.forEach(function(v) {
              out.data[v.key] = v.data;
            }), out;
          }
          function parseData(data) {
            return !data || data.length === 0 ? "" : data.indexOf('"') === 0 || data.indexOf("'") === 0 ? data.substring(1, data.length - 1) : data.indexOf(",") !== -1 ? parseIntList(data) : parseInt(data, 10);
          }
          function parseIntList(data) {
            return data.split(",").map(function(val) {
              return parseInt(val, 10);
            });
          }
        },
        "./node_modules/parse-bmfont-binary/index.js": (module3) => {
          var HEADER = [66, 77, 70];
          module3.exports = function(buf) {
            if (buf.length < 6)
              throw new Error("invalid buffer length for BMFont");
            var header = HEADER.every(function(byte, i2) {
              return buf.readUInt8(i2) === byte;
            });
            if (!header)
              throw new Error("BMFont missing BMF byte header");
            var i = 3, vers = buf.readUInt8(i++);
            if (vers > 3)
              throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
            for (var target = {
              kernings: [],
              chars: []
            }, b = 0; b < 5; b++)
              i += readBlock(target, buf, i);
            return target;
          };
          function readBlock(target, buf, i) {
            if (i > buf.length - 1)
              return 0;
            var blockID = buf.readUInt8(i++), blockSize = buf.readInt32LE(i);
            switch (i += 4, blockID) {
              case 1:
                target.info = readInfo(buf, i);
                break;
              case 2:
                target.common = readCommon(buf, i);
                break;
              case 3:
                target.pages = readPages(buf, i, blockSize);
                break;
              case 4:
                target.chars = readChars(buf, i, blockSize);
                break;
              case 5:
                target.kernings = readKernings(buf, i, blockSize);
                break;
            }
            return 5 + blockSize;
          }
          function readInfo(buf, i) {
            var info = {};
            info.size = buf.readInt16LE(i);
            var bitField = buf.readUInt8(i + 2);
            return info.smooth = bitField >> 7 & 1, info.unicode = bitField >> 6 & 1, info.italic = bitField >> 5 & 1, info.bold = bitField >> 4 & 1, bitField >> 3 & 1 && (info.fixedHeight = 1), info.charset = buf.readUInt8(i + 3) || "", info.stretchH = buf.readUInt16LE(i + 4), info.aa = buf.readUInt8(i + 6), info.padding = [buf.readInt8(i + 7), buf.readInt8(i + 8), buf.readInt8(i + 9), buf.readInt8(i + 10)], info.spacing = [buf.readInt8(i + 11), buf.readInt8(i + 12)], info.outline = buf.readUInt8(i + 13), info.face = readStringNT(buf, i + 14), info;
          }
          function readCommon(buf, i) {
            var common = {};
            common.lineHeight = buf.readUInt16LE(i), common.base = buf.readUInt16LE(i + 2), common.scaleW = buf.readUInt16LE(i + 4), common.scaleH = buf.readUInt16LE(i + 6), common.pages = buf.readUInt16LE(i + 8);
            var bitField = buf.readUInt8(i + 10);
            return common.packed = 0, common.alphaChnl = buf.readUInt8(i + 11), common.redChnl = buf.readUInt8(i + 12), common.greenChnl = buf.readUInt8(i + 13), common.blueChnl = buf.readUInt8(i + 14), common;
          }
          function readPages(buf, i, size) {
            for (var pages = [], text = readNameNT(buf, i), len = text.length + 1, count = size / len, c = 0; c < count; c++)
              pages[c] = buf.slice(i, i + text.length).toString("utf8"), i += len;
            return pages;
          }
          function readChars(buf, i, blockSize) {
            for (var chars = [], count = blockSize / 20, c = 0; c < count; c++) {
              var char = {}, off = c * 20;
              char.id = buf.readUInt32LE(i + 0 + off), char.x = buf.readUInt16LE(i + 4 + off), char.y = buf.readUInt16LE(i + 6 + off), char.width = buf.readUInt16LE(i + 8 + off), char.height = buf.readUInt16LE(i + 10 + off), char.xoffset = buf.readInt16LE(i + 12 + off), char.yoffset = buf.readInt16LE(i + 14 + off), char.xadvance = buf.readInt16LE(i + 16 + off), char.page = buf.readUInt8(i + 18 + off), char.chnl = buf.readUInt8(i + 19 + off), chars[c] = char;
            }
            return chars;
          }
          function readKernings(buf, i, blockSize) {
            for (var kernings = [], count = blockSize / 10, c = 0; c < count; c++) {
              var kern = {}, off = c * 10;
              kern.first = buf.readUInt32LE(i + 0 + off), kern.second = buf.readUInt32LE(i + 4 + off), kern.amount = buf.readInt16LE(i + 8 + off), kernings[c] = kern;
            }
            return kernings;
          }
          function readNameNT(buf, offset) {
            for (var pos = offset; pos < buf.length && buf[pos] !== 0; pos++)
              ;
            return buf.slice(offset, pos);
          }
          function readStringNT(buf, offset) {
            return readNameNT(buf, offset).toString("utf8");
          }
        },
        "./node_modules/parse-bmfont-xml/lib/browser.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var parseAttributes = __webpack_require__2("./node_modules/parse-bmfont-xml/lib/parse-attribs.js"), parseFromString = __webpack_require__2("./node_modules/xml-parse-from-string/index.js"), NAME_MAP = {
            scaleh: "scaleH",
            scalew: "scaleW",
            stretchh: "stretchH",
            lineheight: "lineHeight",
            alphachnl: "alphaChnl",
            redchnl: "redChnl",
            greenchnl: "greenChnl",
            bluechnl: "blueChnl"
          };
          module3.exports = function(data) {
            data = data.toString();
            var xmlRoot = parseFromString(data), output = {
              pages: [],
              chars: [],
              kernings: []
            };
            ["info", "common"].forEach(function(key) {
              var element = xmlRoot.getElementsByTagName(key)[0];
              element && (output[key] = parseAttributes(getAttribs(element)));
            });
            var pageRoot = xmlRoot.getElementsByTagName("pages")[0];
            if (!pageRoot)
              throw new Error("malformed file -- no <pages> element");
            for (var pages = pageRoot.getElementsByTagName("page"), i = 0; i < pages.length; i++) {
              var p = pages[i], id = parseInt(p.getAttribute("id"), 10), file = p.getAttribute("file");
              if (isNaN(id))
                throw new Error('malformed file -- page "id" attribute is NaN');
              if (!file)
                throw new Error('malformed file -- needs page "file" attribute');
              output.pages[parseInt(id, 10)] = file;
            }
            return ["chars", "kernings"].forEach(function(key) {
              var element = xmlRoot.getElementsByTagName(key)[0];
              if (!!element)
                for (var childTag = key.substring(0, key.length - 1), children = element.getElementsByTagName(childTag), i2 = 0; i2 < children.length; i2++) {
                  var child = children[i2];
                  output[key].push(parseAttributes(getAttribs(child)));
                }
            }), output;
          };
          function getAttribs(element) {
            var attribs = getAttribList(element);
            return attribs.reduce(function(dict, attrib) {
              var key = mapName(attrib.nodeName);
              return dict[key] = attrib.nodeValue, dict;
            }, {});
          }
          function getAttribList(element) {
            for (var attribs = [], i = 0; i < element.attributes.length; i++)
              attribs.push(element.attributes[i]);
            return attribs;
          }
          function mapName(nodeName) {
            return NAME_MAP[nodeName.toLowerCase()] || nodeName;
          }
        },
        "./node_modules/parse-bmfont-xml/lib/parse-attribs.js": (module3) => {
          var GLYPH_DESIGNER_ERROR = "chasrset";
          module3.exports = function(obj) {
            GLYPH_DESIGNER_ERROR in obj && (obj.charset = obj[GLYPH_DESIGNER_ERROR], delete obj[GLYPH_DESIGNER_ERROR]);
            for (var k in obj)
              k === "face" || k === "charset" || (k === "padding" || k === "spacing" ? obj[k] = parseIntList(obj[k]) : obj[k] = parseInt(obj[k], 10));
            return obj;
          };
          function parseIntList(data) {
            return data.split(",").map(function(val) {
              return parseInt(val, 10);
            });
          }
        },
        "./node_modules/parse-headers/parse-headers.js": (module3) => {
          var trim = function(string) {
            return string.replace(/^\s+|\s+$/g, "");
          }, isArray = function(arg) {
            return Object.prototype.toString.call(arg) === "[object Array]";
          };
          module3.exports = function(headers) {
            if (!headers)
              return {};
            for (var result = {}, headersArr = trim(headers).split(`
`), i = 0; i < headersArr.length; i++) {
              var row = headersArr[i], index = row.indexOf(":"), key = trim(row.slice(0, index)).toLowerCase(), value = trim(row.slice(index + 1));
              typeof result[key] == "undefined" ? result[key] = value : isArray(result[key]) ? result[key].push(value) : result[key] = [result[key], value];
            }
            return result;
          };
        },
        "./node_modules/quad-indices/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var dtype = __webpack_require__2("./node_modules/dtype/index.js"), anArray = __webpack_require__2("./node_modules/an-array/index.js"), isBuffer = __webpack_require__2("./node_modules/is-buffer/index.js"), CW = [0, 2, 3], CCW = [2, 1, 3];
          module3.exports = function(array, opt) {
            (!array || !(anArray(array) || isBuffer(array))) && (opt = array || {}, array = null), typeof opt == "number" ? opt = {
              count: opt
            } : opt = opt || {};
            for (var type = typeof opt.type == "string" ? opt.type : "uint16", count = typeof opt.count == "number" ? opt.count : 1, start = opt.start || 0, dir = opt.clockwise !== !1 ? CW : CCW, a = dir[0], b = dir[1], c = dir[2], numIndices = count * 6, indices = array || new (dtype(type))(numIndices), i = 0, j = 0; i < numIndices; i += 6, j += 4) {
              var x = i + start;
              indices[x + 0] = j + 0, indices[x + 1] = j + 1, indices[x + 2] = j + 2, indices[x + 3] = j + a, indices[x + 4] = j + b, indices[x + 5] = j + c;
            }
            return indices;
          };
        },
        "./node_modules/super-animejs/lib/anime.es.js": (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            default: () => __WEBPACK_DEFAULT_EXPORT__
          });
          var defaultInstanceSettings = {
            update: null,
            begin: null,
            loopBegin: null,
            changeBegin: null,
            change: null,
            changeComplete: null,
            loopComplete: null,
            complete: null,
            loop: 1,
            direction: "normal",
            autoplay: !0,
            timelineOffset: 0
          }, defaultTweenSettings = {
            duration: 1e3,
            delay: 0,
            endDelay: 0,
            easing: "easeOutElastic(1, .5)",
            round: 0
          }, validTransforms = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective"], cache = {
            CSS: {},
            springs: {}
          };
          function minMax(val, min, max) {
            return Math.min(Math.max(val, min), max);
          }
          function stringContains(str, text) {
            return str.indexOf(text) > -1;
          }
          function applyArguments(func, args) {
            return func.apply(null, args);
          }
          var hexRegex = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i, rgbPrefixRegex = /^rgb/, hslRegex = /^hsl/, is = {
            arr: function(a) {
              return Array.isArray(a);
            },
            obj: function(a) {
              return stringContains(Object.prototype.toString.call(a), "Object");
            },
            pth: function(a) {
              return is.obj(a) && a.hasOwnProperty("totalLength");
            },
            svg: function(a) {
              return a instanceof SVGElement;
            },
            inp: function(a) {
              return a instanceof HTMLInputElement;
            },
            dom: function(a) {
              return a.nodeType || is.svg(a);
            },
            str: function(a) {
              return typeof a == "string";
            },
            fnc: function(a) {
              return typeof a == "function";
            },
            und: function(a) {
              return typeof a == "undefined";
            },
            hex: function(a) {
              return hexRegex.test(a);
            },
            rgb: function(a) {
              return rgbPrefixRegex.test(a);
            },
            hsl: function(a) {
              return hslRegex.test(a);
            },
            col: function(a) {
              return is.hex(a) || is.rgb(a) || is.hsl(a);
            },
            key: function(a) {
              return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== "targets" && a !== "keyframes";
            }
          }, easingFunctionRegex = /\(([^)]+)\)/;
          function parseEasingParameters(string) {
            var match = easingFunctionRegex.exec(string);
            return match ? match[1].split(",").map(function(p) {
              return parseFloat(p);
            }) : [];
          }
          function spring(string, duration) {
            var params = parseEasingParameters(string), mass = minMax(is.und(params[0]) ? 1 : params[0], 0.1, 100), stiffness = minMax(is.und(params[1]) ? 100 : params[1], 0.1, 100), damping = minMax(is.und(params[2]) ? 10 : params[2], 0.1, 100), velocity = minMax(is.und(params[3]) ? 0 : params[3], 0.1, 100), w0 = Math.sqrt(stiffness / mass), zeta = damping / (2 * Math.sqrt(stiffness * mass)), wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0, a = 1, b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
            function solver(t) {
              var progress = duration ? duration * t / 1e3 : t;
              return zeta < 1 ? progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress)) : progress = (a + b * progress) * Math.exp(-progress * w0), t === 0 || t === 1 ? t : 1 - progress;
            }
            function getDuration() {
              var cached = cache.springs[string];
              if (cached)
                return cached;
              for (var frame = 1 / 6, elapsed = 0, rest = 0; ; )
                if (elapsed += frame, solver(elapsed) === 1) {
                  if (rest++, rest >= 16)
                    break;
                } else
                  rest = 0;
              var duration2 = elapsed * frame * 1e3;
              return cache.springs[string] = duration2, duration2;
            }
            return duration ? solver : getDuration;
          }
          function elastic(amplitude, period) {
            amplitude === void 0 && (amplitude = 1), period === void 0 && (period = 0.5);
            var a = minMax(amplitude, 1, 10), p = minMax(period, 0.1, 2);
            return function(t) {
              return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
            };
          }
          function steps(steps2) {
            return steps2 === void 0 && (steps2 = 10), function(t) {
              return Math.round(t * steps2) * (1 / steps2);
            };
          }
          var bezier = function() {
            var kSplineTableSize = 11, kSampleStepSize = 1 / (kSplineTableSize - 1);
            function A(aA1, aA2) {
              return 1 - 3 * aA2 + 3 * aA1;
            }
            function B(aA1, aA2) {
              return 3 * aA2 - 6 * aA1;
            }
            function C(aA1) {
              return 3 * aA1;
            }
            function calcBezier(aT, aA1, aA2) {
              return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
            }
            function getSlope(aT, aA1, aA2) {
              return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
            }
            function binarySubdivide(aX, aA, aB, mX1, mX2) {
              var currentX, currentT, i = 0;
              do
                currentT = aA + (aB - aA) / 2, currentX = calcBezier(currentT, mX1, mX2) - aX, currentX > 0 ? aB = currentT : aA = currentT;
              while (Math.abs(currentX) > 1e-7 && ++i < 10);
              return currentT;
            }
            function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
              for (var i = 0; i < 4; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0)
                  return aGuessT;
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
              }
              return aGuessT;
            }
            function bezier2(mX1, mY1, mX2, mY2) {
              if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1))
                return;
              var sampleValues = new Float32Array(kSplineTableSize);
              if (mX1 !== mY1 || mX2 !== mY2)
                for (var i = 0; i < kSplineTableSize; ++i)
                  sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
              function getTForX(aX) {
                for (var intervalStart = 0, currentSample = 1, lastSample = kSplineTableSize - 1; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample)
                  intervalStart += kSampleStepSize;
                --currentSample;
                var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]), guessForT = intervalStart + dist * kSampleStepSize, initialSlope = getSlope(guessForT, mX1, mX2);
                return initialSlope >= 1e-3 ? newtonRaphsonIterate(aX, guessForT, mX1, mX2) : initialSlope === 0 ? guessForT : binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
              }
              return function(x) {
                return mX1 === mY1 && mX2 === mY2 || x === 0 || x === 1 ? x : calcBezier(getTForX(x), mY1, mY2);
              };
            }
            return bezier2;
          }(), penner = function() {
            var names = ["Quad", "Cubic", "Quart", "Quint", "Sine", "Expo", "Circ", "Back", "Elastic"], curves = {
              In: [
                [0.55, 0.085, 0.68, 0.53],
                [0.55, 0.055, 0.675, 0.19],
                [0.895, 0.03, 0.685, 0.22],
                [0.755, 0.05, 0.855, 0.06],
                [0.47, 0, 0.745, 0.715],
                [0.95, 0.05, 0.795, 0.035],
                [0.6, 0.04, 0.98, 0.335],
                [0.6, -0.28, 0.735, 0.045],
                elastic
              ],
              Out: [
                [0.25, 0.46, 0.45, 0.94],
                [0.215, 0.61, 0.355, 1],
                [0.165, 0.84, 0.44, 1],
                [0.23, 1, 0.32, 1],
                [0.39, 0.575, 0.565, 1],
                [0.19, 1, 0.22, 1],
                [0.075, 0.82, 0.165, 1],
                [0.175, 0.885, 0.32, 1.275],
                function(a, p) {
                  return function(t) {
                    return 1 - elastic(a, p)(1 - t);
                  };
                }
              ],
              InOut: [
                [0.455, 0.03, 0.515, 0.955],
                [0.645, 0.045, 0.355, 1],
                [0.77, 0, 0.175, 1],
                [0.86, 0, 0.07, 1],
                [0.445, 0.05, 0.55, 0.95],
                [1, 0, 0, 1],
                [0.785, 0.135, 0.15, 0.86],
                [0.68, -0.55, 0.265, 1.55],
                function(a, p) {
                  return function(t) {
                    return t < 0.5 ? elastic(a, p)(t * 2) / 2 : 1 - elastic(a, p)(t * -2 + 2) / 2;
                  };
                }
              ]
            }, eases = {
              linear: [0.25, 0.25, 0.75, 0.75]
            };
            for (var coords in curves)
              for (var i = 0, len = curves[coords].length; i < len; i++)
                eases["ease" + coords + names[i]] = curves[coords][i];
            return eases;
          }();
          function parseEasings(easing, duration) {
            if (is.fnc(easing))
              return easing;
            var name = easing.split("(")[0], ease = penner[name], args = parseEasingParameters(easing);
            switch (name) {
              case "spring":
                return spring(easing, duration);
              case "cubicBezier":
                return applyArguments(bezier, args);
              case "steps":
                return applyArguments(steps, args);
              default:
                return is.fnc(ease) ? applyArguments(ease, args) : applyArguments(bezier, ease);
            }
          }
          function selectString(str) {
            try {
              var nodes = document.querySelectorAll(str);
              return nodes;
            } catch (e) {
              return;
            }
          }
          var auxArrayFilter = [];
          function filterArray(arr, callback) {
            for (var result = auxArrayFilter, len = arr.length, thisArg = arguments.length >= 2 ? arguments[1] : void 0, i = 0; i < len; i++)
              if (i in arr) {
                var val = arr[i];
                callback.call(thisArg, val, i, arr) && result.push(val);
              }
            return auxArrayFilter = arr, auxArrayFilter.length = 0, result;
          }
          function flattenArray(arr, result) {
            result || (result = []);
            for (var i = 0, length = arr.length; i < length; i++) {
              var value = arr[i];
              Array.isArray(value) ? flattenArray(value, result) : result.push(value);
            }
            return result;
          }
          function toArray(o) {
            return is.arr(o) ? o : (is.str(o) && (o = selectString(o) || o), o instanceof NodeList || o instanceof HTMLCollection ? [].slice.call(o) : [o]);
          }
          function arrayContains(arr, val) {
            return arr.some(function(a) {
              return a === val;
            });
          }
          function cloneObject(o) {
            var clone = {};
            for (var p in o)
              clone[p] = o[p];
            return clone;
          }
          function replaceObjectProps(o1, o2) {
            var o = cloneObject(o1);
            for (var p in o1)
              o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
            return o;
          }
          function mergeObjects(o1, o2) {
            var o = cloneObject(o1);
            for (var p in o2)
              o[p] = is.und(o1[p]) ? o2[p] : o1[p];
            return o;
          }
          var rgbRegex = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g;
          function rgbToRgba(rgbValue) {
            var rgb = rgbRegex.exec(rgbValue);
            return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
          }
          var hexToRgbaHexRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, hexToRgbaRgbRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
          function hexToRgba(hexValue) {
            var hex = hexValue.replace(hexToRgbaHexRegex, function(m, r2, g2, b2) {
              return r2 + r2 + g2 + g2 + b2 + b2;
            }), rgb = hexToRgbaRgbRegex.exec(hex), r = parseInt(rgb[1], 16), g = parseInt(rgb[2], 16), b = parseInt(rgb[3], 16);
            return "rgba(" + r + "," + g + "," + b + ",1)";
          }
          var hslToRgbaHsl1Regex = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g, hslToRgbaHsl2Regex = /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g;
          function hslToRgba(hslValue) {
            var hsl = hslToRgbaHsl1Regex.exec(hslValue) || hslToRgbaHsl2Regex.exec(hslValue), h = parseInt(hsl[1], 10) / 360, s = parseInt(hsl[2], 10) / 100, l = parseInt(hsl[3], 10) / 100, a = hsl[4] || 1;
            function hue2rgb(p2, q2, t) {
              return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p2 + (q2 - p2) * 6 * t : t < 1 / 2 ? q2 : t < 2 / 3 ? p2 + (q2 - p2) * (2 / 3 - t) * 6 : p2;
            }
            var r, g, b;
            if (s == 0)
              r = g = b = l;
            else {
              var q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
              r = hue2rgb(p, q, h + 1 / 3), g = hue2rgb(p, q, h), b = hue2rgb(p, q, h - 1 / 3);
            }
            return "rgba(" + r * 255 + "," + g * 255 + "," + b * 255 + "," + a + ")";
          }
          function colorToRgb(val) {
            if (is.rgb(val))
              return rgbToRgba(val);
            if (is.hex(val))
              return hexToRgba(val);
            if (is.hsl(val))
              return hslToRgba(val);
          }
          var unitRegex = /([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/;
          function getUnit(val) {
            var split = unitRegex.exec(val);
            if (split)
              return split[2];
          }
          function getTransformUnit(propName) {
            if (stringContains(propName, "translate") || propName === "perspective")
              return "px";
            if (stringContains(propName, "rotate") || stringContains(propName, "skew"))
              return "deg";
          }
          function getFunctionValue(val, animatable) {
            return is.fnc(val) ? val(animatable.target, animatable.id, animatable.total) : val;
          }
          function getAttribute(el, prop) {
            return el.getAttribute(prop);
          }
          function convertPxToUnit(el, value, unit) {
            var valueUnit = getUnit(value);
            if (arrayContains([unit, "deg", "rad", "turn"], valueUnit))
              return value;
            var cached = cache.CSS[value + unit];
            if (!is.und(cached))
              return cached;
            var baseline = 100, tempEl = document.createElement(el.tagName), parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
            parentEl.appendChild(tempEl), tempEl.style.position = "absolute", tempEl.style.width = baseline + unit;
            var factor = baseline / tempEl.offsetWidth;
            parentEl.removeChild(tempEl);
            var convertedUnit = factor * parseFloat(value);
            return cache.CSS[value + unit] = convertedUnit, convertedUnit;
          }
          function getCSSValue(el, prop, unit) {
            if (prop in el.style) {
              var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || "0";
              return unit ? convertPxToUnit(el, value, unit) : value;
            }
          }
          function getAnimationType(el, prop) {
            if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || is.svg(el) && el[prop]))
              return "attribute";
            if (is.dom(el) && arrayContains(validTransforms, prop))
              return "transform";
            if (is.dom(el) && prop !== "transform" && getCSSValue(el, prop))
              return "css";
            if (el[prop] != null)
              return "object";
          }
          var transformRegex = /(\w+)\(([^)]*)\)/g;
          function getElementTransforms(el) {
            if (!!is.dom(el)) {
              for (var str = el.style.transform || "", transforms = new Map(), m; m = transformRegex.exec(str); )
                transforms.set(m[1], m[2]);
              return transforms;
            }
          }
          function getTransformValue(el, propName, animatable, unit) {
            var defaultVal = stringContains(propName, "scale") ? 1 : 0 + getTransformUnit(propName), value = getElementTransforms(el).get(propName) || defaultVal;
            return animatable && (animatable.transforms.list.set(propName, value), animatable.transforms.last = propName), unit ? convertPxToUnit(el, value, unit) : value;
          }
          function getOriginalTargetValue(target, propName, unit, animatable) {
            switch (getAnimationType(target, propName)) {
              case "transform":
                return getTransformValue(target, propName, animatable, unit);
              case "css":
                return getCSSValue(target, propName, unit);
              case "attribute":
                return getAttribute(target, propName);
              default:
                return target[propName] || 0;
            }
          }
          var operatorRegex = /^(\*=|\+=|-=)/;
          function getRelativeValue(to, from) {
            var operator = operatorRegex.exec(to);
            if (!operator)
              return to;
            var u = getUnit(to) || 0, x = parseFloat(from), y = parseFloat(to.replace(operator[0], ""));
            switch (operator[0][0]) {
              case "+":
                return x + y + u;
              case "-":
                return x - y + u;
              case "*":
                return x * y + u;
            }
          }
          var whitespaceRegex = /\s/g;
          function validateValue(val, unit) {
            if (is.col(val))
              return colorToRgb(val);
            var originalUnit = getUnit(val), unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
            return unit && !whitespaceRegex.test(val) ? unitLess + unit : unitLess;
          }
          function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
          }
          function getCircleLength(el) {
            return Math.PI * 2 * getAttribute(el, "r");
          }
          function getRectLength(el) {
            return getAttribute(el, "width") * 2 + getAttribute(el, "height") * 2;
          }
          function getLineLength(el) {
            return getDistance({
              x: getAttribute(el, "x1"),
              y: getAttribute(el, "y1")
            }, {
              x: getAttribute(el, "x2"),
              y: getAttribute(el, "y2")
            });
          }
          function getPolylineLength(el) {
            for (var points = el.points, totalLength = 0, previousPos, i = 0; i < points.numberOfItems; i++) {
              var currentPos = points.getItem(i);
              i > 0 && (totalLength += getDistance(previousPos, currentPos)), previousPos = currentPos;
            }
            return totalLength;
          }
          function getPolygonLength(el) {
            var points = el.points;
            return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
          }
          function getTotalLength(el) {
            if (el.getTotalLength)
              return el.getTotalLength();
            switch (el.tagName.toLowerCase()) {
              case "circle":
                return getCircleLength(el);
              case "rect":
                return getRectLength(el);
              case "line":
                return getLineLength(el);
              case "polyline":
                return getPolylineLength(el);
              case "polygon":
                return getPolygonLength(el);
            }
          }
          function setDashoffset(el) {
            var pathLength = getTotalLength(el);
            return el.setAttribute("stroke-dasharray", pathLength), pathLength;
          }
          function getParentSvgEl(el) {
            for (var parentEl = el.parentNode; is.svg(parentEl) && (parentEl = parentEl.parentNode, !!is.svg(parentEl.parentNode)); )
              ;
            return parentEl;
          }
          function getParentSvg(pathEl, svgData) {
            var svg = svgData || {}, parentSvgEl = svg.el || getParentSvgEl(pathEl), rect = parentSvgEl.getBoundingClientRect(), viewBoxAttr = getAttribute(parentSvgEl, "viewBox"), width = rect.width, height = rect.height, viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(" ") : [0, 0, width, height]);
            return {
              el: parentSvgEl,
              viewBox,
              x: viewBox[0] / 1,
              y: viewBox[1] / 1,
              w: width / viewBox[2],
              h: height / viewBox[3]
            };
          }
          function getPath(path, percent) {
            var pathEl = is.str(path) ? selectString(path)[0] : path, p = percent || 100;
            return function(property) {
              return {
                property,
                el: pathEl,
                svg: getParentSvg(pathEl),
                totalLength: getTotalLength(pathEl) * (p / 100)
              };
            };
          }
          function getPathProgress(path, progress) {
            function point(offset) {
              offset === void 0 && (offset = 0);
              var l = progress + offset >= 1 ? progress + offset : 0;
              return path.el.getPointAtLength(l);
            }
            var svg = getParentSvg(path.el, path.svg), p = point(), p0 = point(-1), p1 = point(1);
            switch (path.property) {
              case "x":
                return (p.x - svg.x) * svg.w;
              case "y":
                return (p.y - svg.y) * svg.h;
              case "angle":
                return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
            }
          }
          var valueRegex = /-?\d*\.?\d+/g;
          function decomposeValue(val, unit) {
            var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + "";
            return {
              original: value,
              numbers: value.match(valueRegex) ? value.match(valueRegex).map(Number) : [0],
              strings: is.str(val) || unit ? value.split(valueRegex) : []
            };
          }
          function parseTargets(targets) {
            var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];
            return filterArray(targetsArray, function(item, pos, self2) {
              return self2.indexOf(item) === pos;
            });
          }
          function getAnimatables(targets) {
            var parsed = parseTargets(targets);
            return parsed.map(function(t, i) {
              return {
                target: t,
                id: i,
                total: parsed.length,
                transforms: {
                  list: getElementTransforms(t)
                }
              };
            });
          }
          var springRegex = /^spring/;
          function normalizePropertyTweens(prop, tweenSettings) {
            var settings = cloneObject(tweenSettings);
            if (springRegex.test(settings.easing) && (settings.duration = spring(settings.easing)), is.arr(prop)) {
              var l = prop.length, isFromTo = l === 2 && !is.obj(prop[0]);
              isFromTo ? prop = {
                value: prop
              } : is.fnc(tweenSettings.duration) || (settings.duration = tweenSettings.duration / l);
            }
            var propArray = is.arr(prop) ? prop : [prop];
            return propArray.map(function(v, i) {
              var obj = is.obj(v) && !is.pth(v) ? v : {
                value: v
              };
              return is.und(obj.delay) && (obj.delay = i ? 0 : tweenSettings.delay), is.und(obj.endDelay) && (obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0), obj;
            }).map(function(k) {
              return mergeObjects(k, settings);
            });
          }
          function flattenKeyframes(keyframes) {
            for (var propertyNames = filterArray(flattenArray(keyframes.map(function(key) {
              return Object.keys(key);
            })), function(p) {
              return is.key(p);
            }).reduce(function(a, b) {
              return a.indexOf(b) < 0 && a.push(b), a;
            }, []), properties = {}, loop = function(i2) {
              var propName = propertyNames[i2];
              properties[propName] = keyframes.map(function(key) {
                var newKey = {};
                for (var p in key)
                  is.key(p) ? p == propName && (newKey.value = key[p]) : newKey[p] = key[p];
                return newKey;
              });
            }, i = 0; i < propertyNames.length; i++)
              loop(i);
            return properties;
          }
          function getProperties(tweenSettings, params) {
            var properties = [], keyframes = params.keyframes;
            keyframes && (params = mergeObjects(flattenKeyframes(keyframes), params));
            for (var p in params)
              is.key(p) && properties.push({
                name: p,
                tweens: normalizePropertyTweens(params[p], tweenSettings)
              });
            return properties;
          }
          function normalizeTweenValues(tween, animatable) {
            var t = {};
            for (var p in tween) {
              var value = getFunctionValue(tween[p], animatable);
              is.arr(value) && (value = value.map(function(v) {
                return getFunctionValue(v, animatable);
              }), value.length === 1 && (value = value[0])), t[p] = value;
            }
            return t.duration = parseFloat(t.duration), t.delay = parseFloat(t.delay), t;
          }
          function normalizeTweens(prop, animatable) {
            var previousTween;
            return prop.tweens.map(function(t) {
              var tween = normalizeTweenValues(t, animatable), tweenValue = tween.value, to = is.arr(tweenValue) ? tweenValue[1] : tweenValue, toUnit = getUnit(to), originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable), previousValue = previousTween ? previousTween.to.original : originalValue, from = is.arr(tweenValue) ? tweenValue[0] : previousValue, fromUnit = getUnit(from) || getUnit(originalValue), unit = toUnit || fromUnit;
              return is.und(to) && (to = previousValue), tween.from = decomposeValue(from, unit), tween.to = decomposeValue(getRelativeValue(to, from), unit), tween.start = previousTween ? previousTween.end : 0, tween.end = tween.start + tween.delay + tween.duration + tween.endDelay, tween.easing = parseEasings(tween.easing, tween.duration), tween.isPath = is.pth(tweenValue), tween.isColor = is.col(tween.from.original), tween.isColor && (tween.round = 1), previousTween = tween, tween;
            });
          }
          var setProgressValue = {
            css: function(t, p, v) {
              return t.style[p] = v;
            },
            attribute: function(t, p, v) {
              return t.setAttribute(p, v);
            },
            object: function(t, p, v) {
              return t[p] = v;
            },
            transform: function(t, p, v, transforms, manual) {
              if (transforms.list.set(p, v), p === transforms.last || manual) {
                var str = "";
                transforms.list.forEach(function(value, prop) {
                  str += prop + "(" + value + ") ";
                }), t.style.transform = str;
              }
            }
          };
          function setTargetsValue(targets, properties) {
            for (var animatables = getAnimatables(targets), i = 0, len = animatables.length; i < len; i++) {
              var animatable = animatables[i];
              for (var property in properties) {
                var value = getFunctionValue(properties[property], animatable), target = animatable.target, valueUnit = getUnit(value), originalValue = getOriginalTargetValue(target, property, valueUnit, animatable), unit = valueUnit || getUnit(originalValue), to = getRelativeValue(validateValue(value, unit), originalValue), animType = getAnimationType(target, property);
                setProgressValue[animType](target, property, to, animatable.transforms, !0);
              }
            }
          }
          function createAnimation(animatable, prop) {
            var animType = getAnimationType(animatable.target, prop.name);
            if (animType) {
              var tweens = normalizeTweens(prop, animatable), lastTween = tweens[tweens.length - 1];
              return {
                type: animType,
                property: prop.name,
                animatable,
                tweens,
                duration: lastTween.end,
                delay: tweens[0].delay,
                endDelay: lastTween.endDelay
              };
            }
          }
          function getAnimations(animatables, properties) {
            return filterArray(flattenArray(animatables.map(function(animatable) {
              return properties.map(function(prop) {
                return createAnimation(animatable, prop);
              });
            })), function(a) {
              return !is.und(a);
            });
          }
          function getInstanceTimings(animations, tweenSettings) {
            var animLength = animations.length, getTlOffset = function(anim) {
              return anim.timelineOffset ? anim.timelineOffset : 0;
            }, timings = {};
            return timings.duration = animLength ? Math.max.apply(Math, animations.map(function(anim) {
              return getTlOffset(anim) + anim.duration;
            })) : tweenSettings.duration, timings.delay = animLength ? Math.min.apply(Math, animations.map(function(anim) {
              return getTlOffset(anim) + anim.delay;
            })) : tweenSettings.delay, timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function(anim) {
              return getTlOffset(anim) + anim.duration - anim.endDelay;
            })) : tweenSettings.endDelay, timings;
          }
          var instanceID = 0;
          function createNewInstance(params) {
            var instanceSettings = replaceObjectProps(defaultInstanceSettings, params), tweenSettings = replaceObjectProps(defaultTweenSettings, params), properties = getProperties(tweenSettings, params), animatables = getAnimatables(params.targets), animations = getAnimations(animatables, properties), timings = getInstanceTimings(animations, tweenSettings), id = instanceID;
            return instanceID++, mergeObjects(instanceSettings, {
              id,
              children: [],
              animatables,
              animations,
              duration: timings.duration,
              delay: timings.delay,
              endDelay: timings.endDelay
            });
          }
          var activeInstances = [], pausedInstances = [], raf, engine = function() {
            function play() {
              raf = requestAnimationFrame(step);
            }
            function step(t) {
              var activeInstancesLength = activeInstances.length;
              if (activeInstancesLength) {
                for (var i = 0; i < activeInstancesLength; ) {
                  var activeInstance2 = activeInstances[i];
                  if (!activeInstance2.paused)
                    activeInstance2.tick(t);
                  else {
                    var instanceIndex = activeInstances.indexOf(activeInstance2);
                    instanceIndex > -1 && (activeInstances.splice(instanceIndex, 1), activeInstancesLength = activeInstances.length);
                  }
                  i++;
                }
                play();
              } else
                raf = cancelAnimationFrame(raf);
            }
            return play;
          }();
          function handleVisibilityChange() {
            if (document.hidden) {
              for (var i = 0, len = activeInstances.length; i < len; i++)
                activeInstance[i].pause();
              pausedInstances = activeInstances.slice(0), activeInstances = [];
            } else
              for (var i$1 = 0, len$1 = pausedInstances.length; i$1 < len$1; i$1++)
                pausedInstances[i$1].play();
          }
          document.addEventListener("visibilitychange", handleVisibilityChange);
          function anime(params) {
            params === void 0 && (params = {});
            var startTime = 0, lastTime = 0, now = 0, children, childrenLength = 0, resolve = null;
            function makePromise() {
              return window.Promise && new Promise(function(_resolve) {
                return resolve = _resolve;
              });
            }
            var promise = makePromise(), instance = createNewInstance(params);
            function toggleInstanceDirection() {
              instance.reversed = !instance.reversed;
              for (var i = 0, len = children.length; i < len; i++)
                children[i].reversed = instance.reversed;
            }
            function adjustTime(time) {
              return instance.reversed ? instance.duration - time : time;
            }
            function resetTime() {
              startTime = 0, lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
            }
            function seekCild(time, child) {
              child && child.seek(time - child.timelineOffset);
            }
            function syncInstanceChildren(time) {
              if (instance.reversePlayback)
                for (var i$1 = childrenLength; i$1--; )
                  seekCild(time, children[i$1]);
              else
                for (var i = 0; i < childrenLength; i++)
                  seekCild(time, children[i]);
            }
            function setAnimationsProgress(insTime) {
              for (var i = 0, animations = instance.animations, animationsLength = animations.length; i < animationsLength; ) {
                var anim = animations[i], animatable = anim.animatable, tweens = anim.tweens, tweenLength = tweens.length - 1, tween = tweens[tweenLength];
                tweenLength && (tween = filterArray(tweens, function(t) {
                  return insTime < t.end;
                })[0] || tween);
                for (var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration, eased = isNaN(elapsed) ? 1 : tween.easing(elapsed), strings = tween.to.strings, round = tween.round, numbers = [], toNumbersLength = tween.to.numbers.length, progress = void 0, n = 0; n < toNumbersLength; n++) {
                  var value = void 0, toNumber = tween.to.numbers[n], fromNumber = tween.from.numbers[n] || 0;
                  tween.isPath ? value = getPathProgress(tween.value, eased * toNumber) : value = fromNumber + eased * (toNumber - fromNumber), round && (tween.isColor && n > 2 || (value = Math.round(value * round) / round)), numbers.push(value);
                }
                var stringsLength = strings.length;
                if (!stringsLength)
                  progress = numbers[0];
                else {
                  progress = strings[0];
                  for (var s = 0; s < stringsLength; s++) {
                    var a = strings[s], b = strings[s + 1], n$1 = numbers[s];
                    isNaN(n$1) || (b ? progress += n$1 + b : progress += n$1 + " ");
                  }
                }
                setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms), anim.currentValue = progress, i++;
              }
            }
            function setCallback(cb) {
              instance[cb] && !instance.passThrough && instance[cb](instance);
            }
            function countIteration() {
              instance.remaining && instance.remaining !== !0 && instance.remaining--;
            }
            function setInstanceProgress(engineTime) {
              var insDuration = instance.duration, insDelay = instance.delay, insEndDelay = insDuration - instance.endDelay, insTime = adjustTime(engineTime);
              instance.progress = minMax(insTime / insDuration * 100, 0, 100), instance.reversePlayback = insTime < instance.currentTime, children && syncInstanceChildren(insTime), !instance.began && instance.currentTime > 0 && (instance.began = !0, setCallback("begin"), setCallback("loopBegin")), insTime <= insDelay && instance.currentTime !== 0 && setAnimationsProgress(0), (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) && setAnimationsProgress(insDuration), insTime > insDelay && insTime < insEndDelay ? (instance.changeBegan || (instance.changeBegan = !0, instance.changeCompleted = !1, setCallback("changeBegin")), setCallback("change"), setAnimationsProgress(insTime)) : instance.changeBegan && (instance.changeCompleted = !0, instance.changeBegan = !1, setCallback("changeComplete")), instance.currentTime = minMax(insTime, 0, insDuration), instance.began && setCallback("update"), engineTime >= insDuration && (lastTime = 0, countIteration(), instance.remaining ? (startTime = now, setCallback("loopComplete"), setCallback("loopBegin"), instance.direction === "alternate" && toggleInstanceDirection()) : (instance.paused = !0, instance.completed || (instance.completed = !0, setCallback("loopComplete"), setCallback("complete"), "Promise" in window && (resolve(), promise = makePromise()))));
            }
            return instance.reset = function() {
              var direction = instance.direction;
              instance.passThrough = !1, instance.currentTime = 0, instance.progress = 0, instance.paused = !0, instance.began = !1, instance.changeBegan = !1, instance.completed = !1, instance.changeCompleted = !1, instance.reversePlayback = !1, instance.reversed = direction === "reverse", instance.remaining = instance.loop, children = instance.children, childrenLength = children.length;
              for (var i = childrenLength; i--; )
                instance.children[i].reset();
              (instance.reversed && instance.loop !== !0 || direction === "alternate" && instance.loop === 1) && instance.remaining++, setAnimationsProgress(0);
            }, instance.set = function(targets, properties) {
              return setTargetsValue(targets, properties), instance;
            }, instance.tick = function(t) {
              now = t, startTime || (startTime = now), setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
            }, instance.seek = function(time) {
              setInstanceProgress(adjustTime(time));
            }, instance.pause = function() {
              instance.paused = !0, resetTime();
            }, instance.play = function() {
              !instance.paused || (instance.paused = !1, activeInstances.push(instance), resetTime(), raf || engine());
            }, instance.reverse = function() {
              toggleInstanceDirection(), resetTime();
            }, instance.restart = function() {
              instance.reset(), instance.play();
            }, instance.finished = promise, instance.reset(), instance.autoplay && instance.play(), instance;
          }
          function removeTargetsFromAnimations(targetsArray, animations) {
            for (var a = animations.length; a--; )
              arrayContains(targetsArray, animations[a].animatable.target) && animations.splice(a, 1);
          }
          function removeTargets(targets) {
            for (var targetsArray = parseTargets(targets), i = activeInstances.length; i--; ) {
              var instance = activeInstances[i], animations = instance.animations, children = instance.children;
              removeTargetsFromAnimations(targetsArray, animations);
              for (var c = children.length; c--; ) {
                var child = children[c], childAnimations = child.animations;
                removeTargetsFromAnimations(targetsArray, childAnimations), !childAnimations.length && !child.children.length && children.splice(c, 1);
              }
              !animations.length && !children.length && instance.pause();
            }
          }
          function stagger(val, params) {
            params === void 0 && (params = {});
            var direction = params.direction || "normal", easing = params.easing ? parseEasings(params.easing) : null, grid = params.grid, axis = params.axis, fromIndex = params.from || 0, fromFirst = fromIndex === "first", fromCenter = fromIndex === "center", fromLast = fromIndex === "last", isRange = is.arr(val), val1 = parseFloat(isRange ? val[0] : val), val2 = isRange ? parseFloat(val[1]) : 0, unit = getUnit(isRange ? val[1] : val) || 0, start = params.start || 0 + (isRange ? val1 : 0), values = [], maxValue = 0;
            return function(el, i, t) {
              if (fromFirst && (fromIndex = 0), fromCenter && (fromIndex = (t - 1) / 2), fromLast && (fromIndex = t - 1), !values.length) {
                for (var index = 0; index < t; index++) {
                  if (!grid)
                    values.push(Math.abs(fromIndex - index));
                  else {
                    var fromX = fromCenter ? (grid[0] - 1) / 2 : fromIndex % grid[0], fromY = fromCenter ? (grid[1] - 1) / 2 : Math.floor(fromIndex / grid[0]), toX = index % grid[0], toY = Math.floor(index / grid[0]), distanceX = fromX - toX, distanceY = fromY - toY, value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                    axis === "x" && (value = -distanceX), axis === "y" && (value = -distanceY), values.push(value);
                  }
                  maxValue = Math.max.apply(Math, values);
                }
                easing && (values = values.map(function(val3) {
                  return easing(val3 / maxValue) * maxValue;
                })), direction === "reverse" && (values = values.map(function(val3) {
                  return axis ? val3 < 0 ? val3 * -1 : -val3 : Math.abs(maxValue - val3);
                }));
              }
              var spacing = isRange ? (val2 - val1) / maxValue : val1;
              return start + spacing * (Math.round(values[i] * 100) / 100) + unit;
            };
          }
          function timeline(params) {
            params === void 0 && (params = {});
            var tl = anime(params);
            return tl.duration = 0, tl.add = function(instanceParams, timelineOffset) {
              var tlIndex = activeInstances.indexOf(tl), children = tl.children;
              tlIndex > -1 && activeInstances.splice(tlIndex, 1);
              function passThrough(ins2) {
                ins2.passThrough = !0;
              }
              for (var i = 0; i < children.length; i++)
                passThrough(children[i]);
              var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
              insParams.targets = insParams.targets || params.targets;
              var tlDuration = tl.duration;
              insParams.autoplay = !1, insParams.direction = tl.direction, insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration), passThrough(tl), tl.seek(insParams.timelineOffset);
              var ins = anime(insParams);
              passThrough(ins), children.push(ins);
              var timings = getInstanceTimings(children, params);
              return tl.delay = timings.delay, tl.endDelay = timings.endDelay, tl.duration = timings.duration, tl.seek(0), tl.reset(), tl.autoplay && tl.play(), tl;
            }, tl;
          }
          anime.version = "3.0.0", anime.speed = 1, anime.running = activeInstances, anime.remove = removeTargets, anime.get = getOriginalTargetValue, anime.set = setTargetsValue, anime.convertPx = convertPxToUnit, anime.path = getPath, anime.setDashoffset = setDashoffset, anime.stagger = stagger, anime.timeline = timeline, anime.easing = parseEasings, anime.penner = penner, anime.random = function(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
          };
          let __WEBPACK_DEFAULT_EXPORT__ = anime;
        },
        "./node_modules/three-bmfont-text/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var createLayout = __webpack_require__2("./node_modules/layout-bmfont-text/index.js"), createIndices = __webpack_require__2("./node_modules/quad-indices/index.js"), vertices = __webpack_require__2("./node_modules/three-bmfont-text/lib/vertices.js"), utils = __webpack_require__2("./node_modules/three-bmfont-text/lib/utils.js");
          module3.exports = function(opt) {
            return new TextGeometry(opt);
          };
          class TextGeometry extends THREE.BufferGeometry {
            constructor(opt) {
              super();
              typeof opt == "string" && (opt = {
                text: opt
              }), this._opt = Object.assign({}, opt), opt && this.update(opt);
            }
            update(opt) {
              if (typeof opt == "string" && (opt = {
                text: opt
              }), opt = Object.assign({}, this._opt, opt), !opt.font)
                throw new TypeError("must specify a { font } in options");
              this.layout = createLayout(opt);
              var flipY = opt.flipY !== !1, font = opt.font, texWidth = font.common.scaleW, texHeight = font.common.scaleH, glyphs = this.layout.glyphs.filter(function(glyph) {
                var bitmap = glyph.data;
                return bitmap.width * bitmap.height > 0;
              });
              this.visibleGlyphs = glyphs;
              var positions = vertices.positions(glyphs), uvs = vertices.uvs(glyphs, texWidth, texHeight, flipY), indices = createIndices([], {
                clockwise: !0,
                type: "uint16",
                count: glyphs.length
              });
              if (this.setIndex(indices), this.setAttribute("position", new THREE.BufferAttribute(positions, 2)), this.setAttribute("uv", new THREE.BufferAttribute(uvs, 2)), !opt.multipage && "page" in this.attributes)
                this.removeAttribute("page");
              else if (opt.multipage) {
                var pages = vertices.pages(glyphs);
                this.setAttribute("page", new THREE.BufferAttribute(pages, 1));
              }
              this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere();
            }
            computeBoundingSphere() {
              this.boundingSphere === null && (this.boundingSphere = new THREE.Sphere());
              var positions = this.attributes.position.array, itemSize = this.attributes.position.itemSize;
              if (!positions || !itemSize || positions.length < 2) {
                this.boundingSphere.radius = 0, this.boundingSphere.center.set(0, 0, 0);
                return;
              }
              utils.computeSphere(positions, this.boundingSphere), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.');
            }
            computeBoundingBox() {
              this.boundingBox === null && (this.boundingBox = new THREE.Box3());
              var bbox = this.boundingBox, positions = this.attributes.position.array, itemSize = this.attributes.position.itemSize;
              if (!positions || !itemSize || positions.length < 2) {
                bbox.makeEmpty();
                return;
              }
              utils.computeBox(positions, bbox);
            }
          }
        },
        "./node_modules/three-bmfont-text/lib/utils.js": (module3) => {
          var itemSize = 2, box = {
            min: [0, 0],
            max: [0, 0]
          };
          function bounds(positions) {
            var count = positions.length / itemSize;
            box.min[0] = positions[0], box.min[1] = positions[1], box.max[0] = positions[0], box.max[1] = positions[1];
            for (var i = 0; i < count; i++) {
              var x = positions[i * itemSize + 0], y = positions[i * itemSize + 1];
              box.min[0] = Math.min(x, box.min[0]), box.min[1] = Math.min(y, box.min[1]), box.max[0] = Math.max(x, box.max[0]), box.max[1] = Math.max(y, box.max[1]);
            }
          }
          module3.exports.computeBox = function(positions, output) {
            bounds(positions), output.min.set(box.min[0], box.min[1], 0), output.max.set(box.max[0], box.max[1], 0);
          }, module3.exports.computeSphere = function(positions, output) {
            bounds(positions);
            var minX = box.min[0], minY = box.min[1], maxX = box.max[0], maxY = box.max[1], width = maxX - minX, height = maxY - minY, length = Math.sqrt(width * width + height * height);
            output.center.set(minX + width / 2, minY + height / 2, 0), output.radius = length / 2;
          };
        },
        "./node_modules/three-bmfont-text/lib/vertices.js": (module3) => {
          module3.exports.pages = function(glyphs) {
            var pages2 = new Float32Array(glyphs.length * 4 * 1), i = 0;
            return glyphs.forEach(function(glyph) {
              var id = glyph.data.page || 0;
              pages2[i++] = id, pages2[i++] = id, pages2[i++] = id, pages2[i++] = id;
            }), pages2;
          }, module3.exports.uvs = function(glyphs, texWidth, texHeight, flipY) {
            var uvs2 = new Float32Array(glyphs.length * 4 * 2), i = 0;
            return glyphs.forEach(function(glyph) {
              var bitmap = glyph.data, bw = bitmap.x + bitmap.width, bh = bitmap.y + bitmap.height, u0 = bitmap.x / texWidth, v1 = bitmap.y / texHeight, u1 = bw / texWidth, v0 = bh / texHeight;
              flipY && (v1 = (texHeight - bitmap.y) / texHeight, v0 = (texHeight - bh) / texHeight), uvs2[i++] = u0, uvs2[i++] = v1, uvs2[i++] = u0, uvs2[i++] = v0, uvs2[i++] = u1, uvs2[i++] = v0, uvs2[i++] = u1, uvs2[i++] = v1;
            }), uvs2;
          }, module3.exports.positions = function(glyphs) {
            var positions2 = new Float32Array(glyphs.length * 4 * 2), i = 0;
            return glyphs.forEach(function(glyph) {
              var bitmap = glyph.data, x = glyph.position[0] + bitmap.xoffset, y = glyph.position[1] + bitmap.yoffset, w = bitmap.width, h = bitmap.height;
              positions2[i++] = x, positions2[i++] = y, positions2[i++] = x, positions2[i++] = y + h, positions2[i++] = x + w, positions2[i++] = y + h, positions2[i++] = x + w, positions2[i++] = y;
            }), positions2;
          };
        },
        "./node_modules/webvr-polyfill/build/webvr-polyfill.js": function(module3, __unused_webpack_exports, __webpack_require__2) {
          (function(global, factory) {
            module3.exports = factory();
          })(this, function() {
            "use strict";
            var commonjsGlobal = typeof window != "undefined" ? window : typeof __webpack_require__2.g != "undefined" ? __webpack_require__2.g : typeof self != "undefined" ? self : {};
            function unwrapExports(x) {
              return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
            }
            function createCommonjsModule(fn, module4) {
              return module4 = {
                exports: {}
              }, fn(module4, module4.exports), module4.exports;
            }
            var isMobile = function() {
              return /Android/i.test(navigator.userAgent) || /iPhone|iPad|iPod/i.test(navigator.userAgent);
            }, copyArray = function(source, dest) {
              for (var i = 0, n = source.length; i < n; i++)
                dest[i] = source[i];
            }, extend = function(dest, src2) {
              for (var key in src2)
                src2.hasOwnProperty(key) && (dest[key] = src2[key]);
              return dest;
            }, cardboardVrDisplay = createCommonjsModule(function(module4, exports2) {
              (function(global, factory) {
                module4.exports = factory();
              })(commonjsGlobal, function() {
                var classCallCheck = function(instance, Constructor) {
                  if (!(instance instanceof Constructor))
                    throw new TypeError("Cannot call a class as a function");
                }, createClass = function() {
                  function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  return function(Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
                  };
                }(), slicedToArray = function() {
                  function sliceIterator(arr, i) {
                    var _arr = [], _n = !0, _d = !1, _e = void 0;
                    try {
                      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
                        ;
                    } catch (err) {
                      _d = !0, _e = err;
                    } finally {
                      try {
                        !_n && _i.return && _i.return();
                      } finally {
                        if (_d)
                          throw _e;
                      }
                    }
                    return _arr;
                  }
                  return function(arr, i) {
                    if (Array.isArray(arr))
                      return arr;
                    if (Symbol.iterator in Object(arr))
                      return sliceIterator(arr, i);
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                  };
                }(), MIN_TIMESTEP = 1e-3, MAX_TIMESTEP = 1, dataUri = function(mimeType, svg) {
                  return "data:" + mimeType + "," + encodeURIComponent(svg);
                }, lerp = function(a, b, t) {
                  return a + (b - a) * t;
                }, isIOS = function() {
                  var isIOS2 = /iPad|iPhone|iPod/.test(navigator.platform);
                  return function() {
                    return isIOS2;
                  };
                }(), isWebViewAndroid = function() {
                  var isWebViewAndroid2 = navigator.userAgent.indexOf("Version") !== -1 && navigator.userAgent.indexOf("Android") !== -1 && navigator.userAgent.indexOf("Chrome") !== -1;
                  return function() {
                    return isWebViewAndroid2;
                  };
                }(), isSafari = function() {
                  var isSafari2 = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                  return function() {
                    return isSafari2;
                  };
                }(), isFirefoxAndroid = function() {
                  var isFirefoxAndroid2 = navigator.userAgent.indexOf("Firefox") !== -1 && navigator.userAgent.indexOf("Android") !== -1;
                  return function() {
                    return isFirefoxAndroid2;
                  };
                }(), getChromeVersion = function() {
                  var match = navigator.userAgent.match(/.*Chrome\/([0-9]+)/), value = match ? parseInt(match[1], 10) : null;
                  return function() {
                    return value;
                  };
                }(), isSafariWithoutDeviceMotion = function() {
                  var value = !1;
                  return value = isIOS() && isSafari() && navigator.userAgent.indexOf("13_4") !== -1, function() {
                    return value;
                  };
                }(), isChromeWithoutDeviceMotion = function() {
                  var value = !1;
                  if (getChromeVersion() === 65) {
                    var match = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
                    if (match) {
                      var _match$1$split = match[1].split("."), _match$1$split2 = slicedToArray(_match$1$split, 4), major = _match$1$split2[0], minor = _match$1$split2[1], branch = _match$1$split2[2], build = _match$1$split2[3];
                      value = parseInt(branch, 10) === 3325 && parseInt(build, 10) < 148;
                    }
                  }
                  return function() {
                    return value;
                  };
                }(), isR7 = function() {
                  var isR72 = navigator.userAgent.indexOf("R7 Build") !== -1;
                  return function() {
                    return isR72;
                  };
                }(), isLandscapeMode = function() {
                  var rtn = window.orientation == 90 || window.orientation == -90;
                  return isR7() ? !rtn : rtn;
                }, isTimestampDeltaValid = function(timestampDeltaS) {
                  return !(isNaN(timestampDeltaS) || timestampDeltaS <= MIN_TIMESTEP || timestampDeltaS > MAX_TIMESTEP);
                }, getScreenWidth = function() {
                  return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
                }, getScreenHeight = function() {
                  return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
                }, requestFullscreen = function(element) {
                  if (isWebViewAndroid())
                    return !1;
                  if (element.requestFullscreen)
                    element.requestFullscreen();
                  else if (element.webkitRequestFullscreen)
                    element.webkitRequestFullscreen();
                  else if (element.mozRequestFullScreen)
                    element.mozRequestFullScreen();
                  else if (element.msRequestFullscreen)
                    element.msRequestFullscreen();
                  else
                    return !1;
                  return !0;
                }, exitFullscreen = function() {
                  if (document.exitFullscreen)
                    document.exitFullscreen();
                  else if (document.webkitExitFullscreen)
                    document.webkitExitFullscreen();
                  else if (document.mozCancelFullScreen)
                    document.mozCancelFullScreen();
                  else if (document.msExitFullscreen)
                    document.msExitFullscreen();
                  else
                    return !1;
                  return !0;
                }, getFullscreenElement = function() {
                  return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
                }, linkProgram = function(gl, vertexSource, fragmentSource, attribLocationMap) {
                  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
                  gl.shaderSource(vertexShader, vertexSource), gl.compileShader(vertexShader);
                  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                  gl.shaderSource(fragmentShader, fragmentSource), gl.compileShader(fragmentShader);
                  var program = gl.createProgram();
                  gl.attachShader(program, vertexShader), gl.attachShader(program, fragmentShader);
                  for (var attribName in attribLocationMap)
                    gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);
                  return gl.linkProgram(program), gl.deleteShader(vertexShader), gl.deleteShader(fragmentShader), program;
                }, getProgramUniforms = function(gl, program) {
                  for (var uniforms = {}, uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), uniformName = "", i = 0; i < uniformCount; i++) {
                    var uniformInfo = gl.getActiveUniform(program, i);
                    uniformName = uniformInfo.name.replace("[0]", ""), uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
                  }
                  return uniforms;
                }, orthoMatrix = function(out, left, right, bottom, top, near, far) {
                  var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
                  return out[0] = -2 * lr, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = -2 * bt, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 2 * nf, out[11] = 0, out[12] = (left + right) * lr, out[13] = (top + bottom) * bt, out[14] = (far + near) * nf, out[15] = 1, out;
                }, isMobile2 = function() {
                  var check = !1;
                  return function(a) {
                    (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) && (check = !0);
                  }(navigator.userAgent || navigator.vendor || window.opera), check;
                }, extend2 = function(dest, src2) {
                  for (var key in src2)
                    src2.hasOwnProperty(key) && (dest[key] = src2[key]);
                  return dest;
                }, safariCssSizeWorkaround = function(canvas) {
                  if (isIOS()) {
                    var width = canvas.style.width, height = canvas.style.height;
                    canvas.style.width = parseInt(width) + 1 + "px", canvas.style.height = parseInt(height) + "px", setTimeout(function() {
                      canvas.style.width = width, canvas.style.height = height;
                    }, 100);
                  }
                  window.canvas = canvas;
                }, frameDataFromPose = function() {
                  var piOver180 = Math.PI / 180, rad45 = Math.PI * 0.25;
                  function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
                    var upTan = Math.tan(fov ? fov.upDegrees * piOver180 : rad45), downTan = Math.tan(fov ? fov.downDegrees * piOver180 : rad45), leftTan = Math.tan(fov ? fov.leftDegrees * piOver180 : rad45), rightTan = Math.tan(fov ? fov.rightDegrees * piOver180 : rad45), xScale = 2 / (leftTan + rightTan), yScale = 2 / (upTan + downTan);
                    return out[0] = xScale, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = yScale, out[6] = 0, out[7] = 0, out[8] = -((leftTan - rightTan) * xScale * 0.5), out[9] = (upTan - downTan) * yScale * 0.5, out[10] = far / (near - far), out[11] = -1, out[12] = 0, out[13] = 0, out[14] = far * near / (near - far), out[15] = 0, out;
                  }
                  function mat4_fromRotationTranslation(out, q, v) {
                    var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                    return out[0] = 1 - (yy + zz), out[1] = xy + wz, out[2] = xz - wy, out[3] = 0, out[4] = xy - wz, out[5] = 1 - (xx + zz), out[6] = yz + wx, out[7] = 0, out[8] = xz + wy, out[9] = yz - wx, out[10] = 1 - (xx + yy), out[11] = 0, out[12] = v[0], out[13] = v[1], out[14] = v[2], out[15] = 1, out;
                  }
                  function mat4_translate(out, a, v) {
                    var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
                    return a === out ? (out[12] = a[0] * x + a[4] * y + a[8] * z + a[12], out[13] = a[1] * x + a[5] * y + a[9] * z + a[13], out[14] = a[2] * x + a[6] * y + a[10] * z + a[14], out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]) : (a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], out[0] = a00, out[1] = a01, out[2] = a02, out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a[12], out[13] = a01 * x + a11 * y + a21 * z + a[13], out[14] = a02 * x + a12 * y + a22 * z + a[14], out[15] = a03 * x + a13 * y + a23 * z + a[15]), out;
                  }
                  function mat4_invert(out, a) {
                    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                    return det ? (det = 1 / det, out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det, out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det, out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det, out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det, out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det, out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det, out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det, out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det, out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det, out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det, out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det, out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det, out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det, out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det, out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det, out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det, out) : null;
                  }
                  var defaultOrientation = new Float32Array([0, 0, 0, 1]), defaultPosition = new Float32Array([0, 0, 0]);
                  function updateEyeMatrices(projection, view, pose, fov, offset, vrDisplay) {
                    mat4_perspectiveFromFieldOfView(projection, fov || null, vrDisplay.depthNear, vrDisplay.depthFar);
                    var orientation = pose.orientation || defaultOrientation, position = pose.position || defaultPosition;
                    mat4_fromRotationTranslation(view, orientation, position), offset && mat4_translate(view, view, offset), mat4_invert(view, view);
                  }
                  return function(frameData, pose, vrDisplay) {
                    return !frameData || !pose ? !1 : (frameData.pose = pose, frameData.timestamp = pose.timestamp, updateEyeMatrices(frameData.leftProjectionMatrix, frameData.leftViewMatrix, pose, vrDisplay._getFieldOfView("left"), vrDisplay._getEyeOffset("left"), vrDisplay), updateEyeMatrices(frameData.rightProjectionMatrix, frameData.rightViewMatrix, pose, vrDisplay._getFieldOfView("right"), vrDisplay._getEyeOffset("right"), vrDisplay), !0);
                  };
                }(), isInsideCrossOriginIFrame = function() {
                  var isFramed = window.self !== window.top, refOrigin = getOriginFromUrl(document.referrer), thisOrigin = getOriginFromUrl(window.location.href);
                  return isFramed && refOrigin !== thisOrigin;
                }, getOriginFromUrl = function(url) {
                  var domainIdx, protoSepIdx = url.indexOf("://");
                  protoSepIdx !== -1 ? domainIdx = protoSepIdx + 3 : domainIdx = 0;
                  var domainEndIdx = url.indexOf("/", domainIdx);
                  return domainEndIdx === -1 && (domainEndIdx = url.length), url.substring(0, domainEndIdx);
                }, getQuaternionAngle = function(quat) {
                  if (quat.w > 1)
                    return console.warn("getQuaternionAngle: w > 1"), 0;
                  var angle = 2 * Math.acos(quat.w);
                  return angle;
                }, warnOnce = function() {
                  var observedWarnings = {};
                  return function(key, message) {
                    observedWarnings[key] === void 0 && (console.warn("webvr-polyfill: " + message), observedWarnings[key] = !0);
                  };
                }(), deprecateWarning = function(deprecated, suggested) {
                  var alternative = suggested ? "Please use " + suggested + " instead." : "";
                  warnOnce(deprecated, deprecated + " has been deprecated. This may not work on native WebVR displays. " + alternative);
                };
                function WGLUPreserveGLState(gl, bindings, callback) {
                  if (!bindings) {
                    callback(gl);
                    return;
                  }
                  for (var boundValues = [], activeTexture = null, i = 0; i < bindings.length; ++i) {
                    var binding = bindings[i];
                    switch (binding) {
                      case gl.TEXTURE_BINDING_2D:
                      case gl.TEXTURE_BINDING_CUBE_MAP:
                        var textureUnit = bindings[++i];
                        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
                          console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit"), boundValues.push(null, null);
                          break;
                        }
                        activeTexture || (activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE)), gl.activeTexture(textureUnit), boundValues.push(gl.getParameter(binding), null);
                        break;
                      case gl.ACTIVE_TEXTURE:
                        activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE), boundValues.push(null);
                        break;
                      default:
                        boundValues.push(gl.getParameter(binding));
                        break;
                    }
                  }
                  callback(gl);
                  for (var i = 0; i < bindings.length; ++i) {
                    var binding = bindings[i], boundValue = boundValues[i];
                    switch (binding) {
                      case gl.ACTIVE_TEXTURE:
                        break;
                      case gl.ARRAY_BUFFER_BINDING:
                        gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
                        break;
                      case gl.COLOR_CLEAR_VALUE:
                        gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
                        break;
                      case gl.COLOR_WRITEMASK:
                        gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
                        break;
                      case gl.CURRENT_PROGRAM:
                        gl.useProgram(boundValue);
                        break;
                      case gl.ELEMENT_ARRAY_BUFFER_BINDING:
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
                        break;
                      case gl.FRAMEBUFFER_BINDING:
                        gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
                        break;
                      case gl.RENDERBUFFER_BINDING:
                        gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
                        break;
                      case gl.TEXTURE_BINDING_2D:
                        var textureUnit = bindings[++i];
                        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
                          break;
                        gl.activeTexture(textureUnit), gl.bindTexture(gl.TEXTURE_2D, boundValue);
                        break;
                      case gl.TEXTURE_BINDING_CUBE_MAP:
                        var textureUnit = bindings[++i];
                        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
                          break;
                        gl.activeTexture(textureUnit), gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
                        break;
                      case gl.VIEWPORT:
                        gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
                        break;
                      case gl.BLEND:
                      case gl.CULL_FACE:
                      case gl.DEPTH_TEST:
                      case gl.SCISSOR_TEST:
                      case gl.STENCIL_TEST:
                        boundValue ? gl.enable(binding) : gl.disable(binding);
                        break;
                      default:
                        console.log("No GL restore behavior for 0x" + binding.toString(16));
                        break;
                    }
                    activeTexture && gl.activeTexture(activeTexture);
                  }
                }
                var glPreserveState = WGLUPreserveGLState, distortionVS = ["attribute vec2 position;", "attribute vec3 texCoord;", "varying vec2 vTexCoord;", "uniform vec4 viewportOffsetScale[2];", "void main() {", "  vec4 viewport = viewportOffsetScale[int(texCoord.z)];", "  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;", "  gl_Position = vec4( position, 1.0, 1.0 );", "}"].join(`
`), distortionFS = ["precision mediump float;", "uniform sampler2D diffuse;", "varying vec2 vTexCoord;", "void main() {", "  gl_FragColor = texture2D(diffuse, vTexCoord);", "}"].join(`
`);
                function CardboardDistorter(gl, cardboardUI, bufferScale, dirtySubmitFrameBindings) {
                  this.gl = gl, this.cardboardUI = cardboardUI, this.bufferScale = bufferScale, this.dirtySubmitFrameBindings = dirtySubmitFrameBindings, this.ctxAttribs = gl.getContextAttributes(), this.instanceExt = gl.getExtension("ANGLE_instanced_arrays"), this.meshWidth = 20, this.meshHeight = 20, this.bufferWidth = gl.drawingBufferWidth, this.bufferHeight = gl.drawingBufferHeight, this.realBindFramebuffer = gl.bindFramebuffer, this.realEnable = gl.enable, this.realDisable = gl.disable, this.realColorMask = gl.colorMask, this.realClearColor = gl.clearColor, this.realViewport = gl.viewport, isIOS() || (this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, "width"), this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, "height")), this.isPatched = !1, this.lastBoundFramebuffer = null, this.cullFace = !1, this.depthTest = !1, this.blend = !1, this.scissorTest = !1, this.stencilTest = !1, this.viewport = [0, 0, 0, 0], this.colorMask = [!0, !0, !0, !0], this.clearColor = [0, 0, 0, 0], this.attribs = {
                    position: 0,
                    texCoord: 1
                  }, this.program = linkProgram(gl, distortionVS, distortionFS, this.attribs), this.uniforms = getProgramUniforms(gl, this.program), this.viewportOffsetScale = new Float32Array(8), this.setTextureBounds(), this.vertexBuffer = gl.createBuffer(), this.indexBuffer = gl.createBuffer(), this.indexCount = 0, this.renderTarget = gl.createTexture(), this.framebuffer = gl.createFramebuffer(), this.depthStencilBuffer = null, this.depthBuffer = null, this.stencilBuffer = null, this.ctxAttribs.depth && this.ctxAttribs.stencil ? this.depthStencilBuffer = gl.createRenderbuffer() : this.ctxAttribs.depth ? this.depthBuffer = gl.createRenderbuffer() : this.ctxAttribs.stencil && (this.stencilBuffer = gl.createRenderbuffer()), this.patch(), this.onResize();
                }
                CardboardDistorter.prototype.destroy = function() {
                  var gl = this.gl;
                  this.unpatch(), gl.deleteProgram(this.program), gl.deleteBuffer(this.vertexBuffer), gl.deleteBuffer(this.indexBuffer), gl.deleteTexture(this.renderTarget), gl.deleteFramebuffer(this.framebuffer), this.depthStencilBuffer && gl.deleteRenderbuffer(this.depthStencilBuffer), this.depthBuffer && gl.deleteRenderbuffer(this.depthBuffer), this.stencilBuffer && gl.deleteRenderbuffer(this.stencilBuffer), this.cardboardUI && this.cardboardUI.destroy();
                }, CardboardDistorter.prototype.onResize = function() {
                  var gl = this.gl, self2 = this, glState = [gl.RENDERBUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0];
                  glPreserveState(gl, glState, function(gl2) {
                    self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, null), self2.scissorTest && self2.realDisable.call(gl2, gl2.SCISSOR_TEST), self2.realColorMask.call(gl2, !0, !0, !0, !0), self2.realViewport.call(gl2, 0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight), self2.realClearColor.call(gl2, 0, 0, 0, 1), gl2.clear(gl2.COLOR_BUFFER_BIT), self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.framebuffer), gl2.bindTexture(gl2.TEXTURE_2D, self2.renderTarget), gl2.texImage2D(gl2.TEXTURE_2D, 0, self2.ctxAttribs.alpha ? gl2.RGBA : gl2.RGB, self2.bufferWidth, self2.bufferHeight, 0, self2.ctxAttribs.alpha ? gl2.RGBA : gl2.RGB, gl2.UNSIGNED_BYTE, null), gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.LINEAR), gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.LINEAR), gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE), gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE), gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, self2.renderTarget, 0), self2.ctxAttribs.depth && self2.ctxAttribs.stencil ? (gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.depthStencilBuffer), gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.DEPTH_STENCIL, self2.bufferWidth, self2.bufferHeight), gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.DEPTH_STENCIL_ATTACHMENT, gl2.RENDERBUFFER, self2.depthStencilBuffer)) : self2.ctxAttribs.depth ? (gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.depthBuffer), gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.DEPTH_COMPONENT16, self2.bufferWidth, self2.bufferHeight), gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.DEPTH_ATTACHMENT, gl2.RENDERBUFFER, self2.depthBuffer)) : self2.ctxAttribs.stencil && (gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.stencilBuffer), gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.STENCIL_INDEX8, self2.bufferWidth, self2.bufferHeight), gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.STENCIL_ATTACHMENT, gl2.RENDERBUFFER, self2.stencilBuffer)), !gl2.checkFramebufferStatus(gl2.FRAMEBUFFER) === gl2.FRAMEBUFFER_COMPLETE && console.error("Framebuffer incomplete!"), self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.lastBoundFramebuffer), self2.scissorTest && self2.realEnable.call(gl2, gl2.SCISSOR_TEST), self2.realColorMask.apply(gl2, self2.colorMask), self2.realViewport.apply(gl2, self2.viewport), self2.realClearColor.apply(gl2, self2.clearColor);
                  }), this.cardboardUI && this.cardboardUI.onResize();
                }, CardboardDistorter.prototype.patch = function() {
                  if (!this.isPatched) {
                    var self2 = this, canvas = this.gl.canvas, gl = this.gl;
                    isIOS() || (canvas.width = getScreenWidth() * this.bufferScale, canvas.height = getScreenHeight() * this.bufferScale, Object.defineProperty(canvas, "width", {
                      configurable: !0,
                      enumerable: !0,
                      get: function() {
                        return self2.bufferWidth;
                      },
                      set: function(value) {
                        self2.bufferWidth = value, self2.realCanvasWidth.set.call(canvas, value), self2.onResize();
                      }
                    }), Object.defineProperty(canvas, "height", {
                      configurable: !0,
                      enumerable: !0,
                      get: function() {
                        return self2.bufferHeight;
                      },
                      set: function(value) {
                        self2.bufferHeight = value, self2.realCanvasHeight.set.call(canvas, value), self2.onResize();
                      }
                    })), this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING), this.lastBoundFramebuffer == null && (this.lastBoundFramebuffer = this.framebuffer, this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer)), this.gl.bindFramebuffer = function(target, framebuffer) {
                      self2.lastBoundFramebuffer = framebuffer || self2.framebuffer, self2.realBindFramebuffer.call(gl, target, self2.lastBoundFramebuffer);
                    }, this.cullFace = gl.getParameter(gl.CULL_FACE), this.depthTest = gl.getParameter(gl.DEPTH_TEST), this.blend = gl.getParameter(gl.BLEND), this.scissorTest = gl.getParameter(gl.SCISSOR_TEST), this.stencilTest = gl.getParameter(gl.STENCIL_TEST), gl.enable = function(pname) {
                      switch (pname) {
                        case gl.CULL_FACE:
                          self2.cullFace = !0;
                          break;
                        case gl.DEPTH_TEST:
                          self2.depthTest = !0;
                          break;
                        case gl.BLEND:
                          self2.blend = !0;
                          break;
                        case gl.SCISSOR_TEST:
                          self2.scissorTest = !0;
                          break;
                        case gl.STENCIL_TEST:
                          self2.stencilTest = !0;
                          break;
                      }
                      self2.realEnable.call(gl, pname);
                    }, gl.disable = function(pname) {
                      switch (pname) {
                        case gl.CULL_FACE:
                          self2.cullFace = !1;
                          break;
                        case gl.DEPTH_TEST:
                          self2.depthTest = !1;
                          break;
                        case gl.BLEND:
                          self2.blend = !1;
                          break;
                        case gl.SCISSOR_TEST:
                          self2.scissorTest = !1;
                          break;
                        case gl.STENCIL_TEST:
                          self2.stencilTest = !1;
                          break;
                      }
                      self2.realDisable.call(gl, pname);
                    }, this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK), gl.colorMask = function(r, g, b, a) {
                      self2.colorMask[0] = r, self2.colorMask[1] = g, self2.colorMask[2] = b, self2.colorMask[3] = a, self2.realColorMask.call(gl, r, g, b, a);
                    }, this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE), gl.clearColor = function(r, g, b, a) {
                      self2.clearColor[0] = r, self2.clearColor[1] = g, self2.clearColor[2] = b, self2.clearColor[3] = a, self2.realClearColor.call(gl, r, g, b, a);
                    }, this.viewport = gl.getParameter(gl.VIEWPORT), gl.viewport = function(x, y, w, h) {
                      self2.viewport[0] = x, self2.viewport[1] = y, self2.viewport[2] = w, self2.viewport[3] = h, self2.realViewport.call(gl, x, y, w, h);
                    }, this.isPatched = !0, safariCssSizeWorkaround(canvas);
                  }
                }, CardboardDistorter.prototype.unpatch = function() {
                  if (!!this.isPatched) {
                    var gl = this.gl, canvas = this.gl.canvas;
                    isIOS() || (Object.defineProperty(canvas, "width", this.realCanvasWidth), Object.defineProperty(canvas, "height", this.realCanvasHeight)), canvas.width = this.bufferWidth, canvas.height = this.bufferHeight, gl.bindFramebuffer = this.realBindFramebuffer, gl.enable = this.realEnable, gl.disable = this.realDisable, gl.colorMask = this.realColorMask, gl.clearColor = this.realClearColor, gl.viewport = this.realViewport, this.lastBoundFramebuffer == this.framebuffer && gl.bindFramebuffer(gl.FRAMEBUFFER, null), this.isPatched = !1, setTimeout(function() {
                      safariCssSizeWorkaround(canvas);
                    }, 1);
                  }
                }, CardboardDistorter.prototype.setTextureBounds = function(leftBounds, rightBounds) {
                  leftBounds || (leftBounds = [0, 0, 0.5, 1]), rightBounds || (rightBounds = [0.5, 0, 0.5, 1]), this.viewportOffsetScale[0] = leftBounds[0], this.viewportOffsetScale[1] = leftBounds[1], this.viewportOffsetScale[2] = leftBounds[2], this.viewportOffsetScale[3] = leftBounds[3], this.viewportOffsetScale[4] = rightBounds[0], this.viewportOffsetScale[5] = rightBounds[1], this.viewportOffsetScale[6] = rightBounds[2], this.viewportOffsetScale[7] = rightBounds[3];
                }, CardboardDistorter.prototype.submitFrame = function() {
                  var gl = this.gl, self2 = this, glState = [];
                  if (this.dirtySubmitFrameBindings || glState.push(gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0), glPreserveState(gl, glState, function(gl2) {
                    self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, null);
                    var positionDivisor = 0, texCoordDivisor = 0;
                    self2.instanceExt && (positionDivisor = gl2.getVertexAttrib(self2.attribs.position, self2.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE), texCoordDivisor = gl2.getVertexAttrib(self2.attribs.texCoord, self2.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)), self2.cullFace && self2.realDisable.call(gl2, gl2.CULL_FACE), self2.depthTest && self2.realDisable.call(gl2, gl2.DEPTH_TEST), self2.blend && self2.realDisable.call(gl2, gl2.BLEND), self2.scissorTest && self2.realDisable.call(gl2, gl2.SCISSOR_TEST), self2.stencilTest && self2.realDisable.call(gl2, gl2.STENCIL_TEST), self2.realColorMask.call(gl2, !0, !0, !0, !0), self2.realViewport.call(gl2, 0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight), (self2.ctxAttribs.alpha || isIOS()) && (self2.realClearColor.call(gl2, 0, 0, 0, 1), gl2.clear(gl2.COLOR_BUFFER_BIT)), gl2.useProgram(self2.program), gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, self2.indexBuffer), gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer), gl2.enableVertexAttribArray(self2.attribs.position), gl2.enableVertexAttribArray(self2.attribs.texCoord), gl2.vertexAttribPointer(self2.attribs.position, 2, gl2.FLOAT, !1, 20, 0), gl2.vertexAttribPointer(self2.attribs.texCoord, 3, gl2.FLOAT, !1, 20, 8), self2.instanceExt && (positionDivisor != 0 && self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.position, 0), texCoordDivisor != 0 && self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.texCoord, 0)), gl2.activeTexture(gl2.TEXTURE0), gl2.uniform1i(self2.uniforms.diffuse, 0), gl2.bindTexture(gl2.TEXTURE_2D, self2.renderTarget), gl2.uniform4fv(self2.uniforms.viewportOffsetScale, self2.viewportOffsetScale), gl2.drawElements(gl2.TRIANGLES, self2.indexCount, gl2.UNSIGNED_SHORT, 0), self2.cardboardUI && self2.cardboardUI.renderNoState(), self2.realBindFramebuffer.call(self2.gl, gl2.FRAMEBUFFER, self2.framebuffer), self2.ctxAttribs.preserveDrawingBuffer || (self2.realClearColor.call(gl2, 0, 0, 0, 0), gl2.clear(gl2.COLOR_BUFFER_BIT)), self2.dirtySubmitFrameBindings || self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.lastBoundFramebuffer), self2.cullFace && self2.realEnable.call(gl2, gl2.CULL_FACE), self2.depthTest && self2.realEnable.call(gl2, gl2.DEPTH_TEST), self2.blend && self2.realEnable.call(gl2, gl2.BLEND), self2.scissorTest && self2.realEnable.call(gl2, gl2.SCISSOR_TEST), self2.stencilTest && self2.realEnable.call(gl2, gl2.STENCIL_TEST), self2.realColorMask.apply(gl2, self2.colorMask), self2.realViewport.apply(gl2, self2.viewport), (self2.ctxAttribs.alpha || !self2.ctxAttribs.preserveDrawingBuffer) && self2.realClearColor.apply(gl2, self2.clearColor), self2.instanceExt && (positionDivisor != 0 && self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.position, positionDivisor), texCoordDivisor != 0 && self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.texCoord, texCoordDivisor));
                  }), isIOS()) {
                    var canvas = gl.canvas;
                    (canvas.width != self2.bufferWidth || canvas.height != self2.bufferHeight) && (self2.bufferWidth = canvas.width, self2.bufferHeight = canvas.height, self2.onResize());
                  }
                }, CardboardDistorter.prototype.updateDeviceInfo = function(deviceInfo) {
                  var gl = this.gl, self2 = this, glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
                  glPreserveState(gl, glState, function(gl2) {
                    var vertices = self2.computeMeshVertices_(self2.meshWidth, self2.meshHeight, deviceInfo);
                    if (gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer), gl2.bufferData(gl2.ARRAY_BUFFER, vertices, gl2.STATIC_DRAW), !self2.indexCount) {
                      var indices = self2.computeMeshIndices_(self2.meshWidth, self2.meshHeight);
                      gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, self2.indexBuffer), gl2.bufferData(gl2.ELEMENT_ARRAY_BUFFER, indices, gl2.STATIC_DRAW), self2.indexCount = indices.length;
                    }
                  });
                }, CardboardDistorter.prototype.computeMeshVertices_ = function(width, height, deviceInfo) {
                  for (var vertices = new Float32Array(2 * width * height * 5), lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles(), noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles(), viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum), vidx = 0, e = 0; e < 2; e++) {
                    for (var j = 0; j < height; j++)
                      for (var i = 0; i < width; i++, vidx++) {
                        var u = i / (width - 1), v = j / (height - 1), s = u, t = v, x = lerp(lensFrustum[0], lensFrustum[2], u), y = lerp(lensFrustum[3], lensFrustum[1], v), d = Math.sqrt(x * x + y * y), r = deviceInfo.distortion.distortInverse(d), p = x * r / d, q = y * r / d;
                        u = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]), v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]), u = (viewport.x + u * viewport.width - 0.5) * 2, v = (viewport.y + v * viewport.height - 0.5) * 2, vertices[vidx * 5 + 0] = u, vertices[vidx * 5 + 1] = v, vertices[vidx * 5 + 2] = s, vertices[vidx * 5 + 3] = t, vertices[vidx * 5 + 4] = e;
                      }
                    var w = lensFrustum[2] - lensFrustum[0];
                    lensFrustum[0] = -(w + lensFrustum[0]), lensFrustum[2] = w - lensFrustum[2], w = noLensFrustum[2] - noLensFrustum[0], noLensFrustum[0] = -(w + noLensFrustum[0]), noLensFrustum[2] = w - noLensFrustum[2], viewport.x = 1 - (viewport.x + viewport.width);
                  }
                  return vertices;
                }, CardboardDistorter.prototype.computeMeshIndices_ = function(width, height) {
                  for (var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6), halfwidth = width / 2, halfheight = height / 2, vidx = 0, iidx = 0, e = 0; e < 2; e++)
                    for (var j = 0; j < height; j++)
                      for (var i = 0; i < width; i++, vidx++)
                        i == 0 || j == 0 || (i <= halfwidth == j <= halfheight ? (indices[iidx++] = vidx, indices[iidx++] = vidx - width - 1, indices[iidx++] = vidx - width, indices[iidx++] = vidx - width - 1, indices[iidx++] = vidx, indices[iidx++] = vidx - 1) : (indices[iidx++] = vidx - 1, indices[iidx++] = vidx - width, indices[iidx++] = vidx, indices[iidx++] = vidx - width, indices[iidx++] = vidx - 1, indices[iidx++] = vidx - width - 1));
                  return indices;
                }, CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function(proto, attrName) {
                  var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
                  return (descriptor.get === void 0 || descriptor.set === void 0) && (descriptor.configurable = !0, descriptor.enumerable = !0, descriptor.get = function() {
                    return this.getAttribute(attrName);
                  }, descriptor.set = function(val) {
                    this.setAttribute(attrName, val);
                  }), descriptor;
                };
                var uiVS = ["attribute vec2 position;", "uniform mat4 projectionMat;", "void main() {", "  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );", "}"].join(`
`), uiFS = ["precision mediump float;", "uniform vec4 color;", "void main() {", "  gl_FragColor = color;", "}"].join(`
`), DEG2RAD = Math.PI / 180, kAnglePerGearSection = 60, kOuterRimEndAngle = 12, kInnerRimBeginAngle = 20, kOuterRadius = 1, kMiddleRadius = 0.75, kInnerRadius = 0.3125, kCenterLineThicknessDp = 4, kButtonWidthDp = 28, kTouchSlopFactor = 1.5;
                function CardboardUI(gl) {
                  this.gl = gl, this.attribs = {
                    position: 0
                  }, this.program = linkProgram(gl, uiVS, uiFS, this.attribs), this.uniforms = getProgramUniforms(gl, this.program), this.vertexBuffer = gl.createBuffer(), this.gearOffset = 0, this.gearVertexCount = 0, this.arrowOffset = 0, this.arrowVertexCount = 0, this.projMat = new Float32Array(16), this.listener = null, this.onResize();
                }
                CardboardUI.prototype.destroy = function() {
                  var gl = this.gl;
                  this.listener && gl.canvas.removeEventListener("click", this.listener, !1), gl.deleteProgram(this.program), gl.deleteBuffer(this.vertexBuffer);
                }, CardboardUI.prototype.listen = function(optionsCallback, backCallback) {
                  var canvas = this.gl.canvas;
                  this.listener = function(event) {
                    var midline = canvas.clientWidth / 2, buttonSize = kButtonWidthDp * kTouchSlopFactor;
                    event.clientX > midline - buttonSize && event.clientX < midline + buttonSize && event.clientY > canvas.clientHeight - buttonSize ? optionsCallback(event) : event.clientX < buttonSize && event.clientY < buttonSize && backCallback(event);
                  }, canvas.addEventListener("click", this.listener, !1);
                }, CardboardUI.prototype.onResize = function() {
                  var gl = this.gl, self2 = this, glState = [gl.ARRAY_BUFFER_BINDING];
                  glPreserveState(gl, glState, function(gl2) {
                    var vertices = [], midline = gl2.drawingBufferWidth / 2, physicalPixels = Math.max(screen.width, screen.height) * window.devicePixelRatio, scalingRatio = gl2.drawingBufferWidth / physicalPixels, dps = scalingRatio * window.devicePixelRatio, lineWidth = kCenterLineThicknessDp * dps / 2, buttonSize = kButtonWidthDp * kTouchSlopFactor * dps, buttonScale = kButtonWidthDp * dps / 2, buttonBorder = (kButtonWidthDp * kTouchSlopFactor - kButtonWidthDp) * dps;
                    vertices.push(midline - lineWidth, buttonSize), vertices.push(midline - lineWidth, gl2.drawingBufferHeight), vertices.push(midline + lineWidth, buttonSize), vertices.push(midline + lineWidth, gl2.drawingBufferHeight), self2.gearOffset = vertices.length / 2;
                    function addGearSegment(theta, r) {
                      var angle = (90 - theta) * DEG2RAD, x = Math.cos(angle), y = Math.sin(angle);
                      vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale), vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
                    }
                    for (var i = 0; i <= 6; i++) {
                      var segmentTheta = i * kAnglePerGearSection;
                      addGearSegment(segmentTheta, kOuterRadius), addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius), addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius), addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius), addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
                    }
                    self2.gearVertexCount = vertices.length / 2 - self2.gearOffset, self2.arrowOffset = vertices.length / 2;
                    function addArrowVertex(x, y) {
                      vertices.push(buttonBorder + x, gl2.drawingBufferHeight - buttonBorder - y);
                    }
                    var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);
                    addArrowVertex(0, buttonScale), addArrowVertex(buttonScale, 0), addArrowVertex(buttonScale + angledLineWidth, angledLineWidth), addArrowVertex(angledLineWidth, buttonScale + angledLineWidth), addArrowVertex(angledLineWidth, buttonScale - angledLineWidth), addArrowVertex(0, buttonScale), addArrowVertex(buttonScale, buttonScale * 2), addArrowVertex(buttonScale + angledLineWidth, buttonScale * 2 - angledLineWidth), addArrowVertex(angledLineWidth, buttonScale - angledLineWidth), addArrowVertex(0, buttonScale), addArrowVertex(angledLineWidth, buttonScale - lineWidth), addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth), addArrowVertex(angledLineWidth, buttonScale + lineWidth), addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth), self2.arrowVertexCount = vertices.length / 2 - self2.arrowOffset, gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer), gl2.bufferData(gl2.ARRAY_BUFFER, new Float32Array(vertices), gl2.STATIC_DRAW);
                  });
                }, CardboardUI.prototype.render = function() {
                  var gl = this.gl, self2 = this, glState = [gl.CULL_FACE, gl.DEPTH_TEST, gl.BLEND, gl.SCISSOR_TEST, gl.STENCIL_TEST, gl.COLOR_WRITEMASK, gl.VIEWPORT, gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING];
                  glPreserveState(gl, glState, function(gl2) {
                    gl2.disable(gl2.CULL_FACE), gl2.disable(gl2.DEPTH_TEST), gl2.disable(gl2.BLEND), gl2.disable(gl2.SCISSOR_TEST), gl2.disable(gl2.STENCIL_TEST), gl2.colorMask(!0, !0, !0, !0), gl2.viewport(0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight), self2.renderNoState();
                  });
                }, CardboardUI.prototype.renderNoState = function() {
                  var gl = this.gl;
                  gl.useProgram(this.program), gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), gl.enableVertexAttribArray(this.attribs.position), gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, !1, 8, 0), gl.uniform4f(this.uniforms.color, 1, 1, 1, 1), orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024), gl.uniformMatrix4fv(this.uniforms.projectionMat, !1, this.projMat), gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4), gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount), gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
                };
                function Distortion(coefficients) {
                  this.coefficients = coefficients;
                }
                Distortion.prototype.distortInverse = function(radius) {
                  for (var r0 = 0, r1 = 1, dr0 = radius - this.distort(r0); Math.abs(r1 - r0) > 1e-4; ) {
                    var dr1 = radius - this.distort(r1), r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
                    r0 = r1, r1 = r2, dr0 = dr1;
                  }
                  return r1;
                }, Distortion.prototype.distort = function(radius) {
                  for (var r2 = radius * radius, ret = 0, i = 0; i < this.coefficients.length; i++)
                    ret = r2 * (ret + this.coefficients[i]);
                  return (ret + 1) * radius;
                };
                var degToRad = Math.PI / 180, radToDeg = 180 / Math.PI, Vector3 = function(x, y, z) {
                  this.x = x || 0, this.y = y || 0, this.z = z || 0;
                };
                Vector3.prototype = {
                  constructor: Vector3,
                  set: function(x, y, z) {
                    return this.x = x, this.y = y, this.z = z, this;
                  },
                  copy: function(v) {
                    return this.x = v.x, this.y = v.y, this.z = v.z, this;
                  },
                  length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                  },
                  normalize: function() {
                    var scalar = this.length();
                    if (scalar !== 0) {
                      var invScalar = 1 / scalar;
                      this.multiplyScalar(invScalar);
                    } else
                      this.x = 0, this.y = 0, this.z = 0;
                    return this;
                  },
                  multiplyScalar: function(scalar) {
                    this.x *= scalar, this.y *= scalar, this.z *= scalar;
                  },
                  applyQuaternion: function(q) {
                    var x = this.x, y = this.y, z = this.z, qx = q.x, qy = q.y, qz = q.z, qw = q.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
                    return this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx, this;
                  },
                  dot: function(v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z;
                  },
                  crossVectors: function(a, b) {
                    var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
                    return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, this;
                  }
                };
                var Quaternion = function(x, y, z, w) {
                  this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w !== void 0 ? w : 1;
                };
                Quaternion.prototype = {
                  constructor: Quaternion,
                  set: function(x, y, z, w) {
                    return this.x = x, this.y = y, this.z = z, this.w = w, this;
                  },
                  copy: function(quaternion) {
                    return this.x = quaternion.x, this.y = quaternion.y, this.z = quaternion.z, this.w = quaternion.w, this;
                  },
                  setFromEulerXYZ: function(x, y, z) {
                    var c1 = Math.cos(x / 2), c2 = Math.cos(y / 2), c3 = Math.cos(z / 2), s1 = Math.sin(x / 2), s2 = Math.sin(y / 2), s3 = Math.sin(z / 2);
                    return this.x = s1 * c2 * c3 + c1 * s2 * s3, this.y = c1 * s2 * c3 - s1 * c2 * s3, this.z = c1 * c2 * s3 + s1 * s2 * c3, this.w = c1 * c2 * c3 - s1 * s2 * s3, this;
                  },
                  setFromEulerYXZ: function(x, y, z) {
                    var c1 = Math.cos(x / 2), c2 = Math.cos(y / 2), c3 = Math.cos(z / 2), s1 = Math.sin(x / 2), s2 = Math.sin(y / 2), s3 = Math.sin(z / 2);
                    return this.x = s1 * c2 * c3 + c1 * s2 * s3, this.y = c1 * s2 * c3 - s1 * c2 * s3, this.z = c1 * c2 * s3 - s1 * s2 * c3, this.w = c1 * c2 * c3 + s1 * s2 * s3, this;
                  },
                  setFromAxisAngle: function(axis, angle) {
                    var halfAngle = angle / 2, s = Math.sin(halfAngle);
                    return this.x = axis.x * s, this.y = axis.y * s, this.z = axis.z * s, this.w = Math.cos(halfAngle), this;
                  },
                  multiply: function(q) {
                    return this.multiplyQuaternions(this, q);
                  },
                  multiplyQuaternions: function(a, b) {
                    var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w, qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
                    return this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby, this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz, this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx, this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz, this;
                  },
                  inverse: function() {
                    return this.x *= -1, this.y *= -1, this.z *= -1, this.normalize(), this;
                  },
                  normalize: function() {
                    var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                    return l === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (l = 1 / l, this.x = this.x * l, this.y = this.y * l, this.z = this.z * l, this.w = this.w * l), this;
                  },
                  slerp: function(qb, t) {
                    if (t === 0)
                      return this;
                    if (t === 1)
                      return this.copy(qb);
                    var x = this.x, y = this.y, z = this.z, w = this.w, cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
                    if (cosHalfTheta < 0 ? (this.w = -qb.w, this.x = -qb.x, this.y = -qb.y, this.z = -qb.z, cosHalfTheta = -cosHalfTheta) : this.copy(qb), cosHalfTheta >= 1)
                      return this.w = w, this.x = x, this.y = y, this.z = z, this;
                    var halfTheta = Math.acos(cosHalfTheta), sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
                    if (Math.abs(sinHalfTheta) < 1e-3)
                      return this.w = 0.5 * (w + this.w), this.x = 0.5 * (x + this.x), this.y = 0.5 * (y + this.y), this.z = 0.5 * (z + this.z), this;
                    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
                    return this.w = w * ratioA + this.w * ratioB, this.x = x * ratioA + this.x * ratioB, this.y = y * ratioA + this.y * ratioB, this.z = z * ratioA + this.z * ratioB, this;
                  },
                  setFromUnitVectors: function() {
                    var v1, r, EPS = 1e-6;
                    return function(vFrom, vTo) {
                      return v1 === void 0 && (v1 = new Vector3()), r = vFrom.dot(vTo) + 1, r < EPS ? (r = 0, Math.abs(vFrom.x) > Math.abs(vFrom.z) ? v1.set(-vFrom.y, vFrom.x, 0) : v1.set(0, -vFrom.z, vFrom.y)) : v1.crossVectors(vFrom, vTo), this.x = v1.x, this.y = v1.y, this.z = v1.z, this.w = r, this.normalize(), this;
                    };
                  }()
                };
                function Device(params) {
                  this.width = params.width || getScreenWidth(), this.height = params.height || getScreenHeight(), this.widthMeters = params.widthMeters, this.heightMeters = params.heightMeters, this.bevelMeters = params.bevelMeters;
                }
                var DEFAULT_ANDROID = new Device({
                  widthMeters: 0.11,
                  heightMeters: 0.062,
                  bevelMeters: 4e-3
                }), DEFAULT_IOS = new Device({
                  widthMeters: 0.1038,
                  heightMeters: 0.0584,
                  bevelMeters: 4e-3
                }), Viewers = {
                  CardboardV1: new CardboardViewer({
                    id: "CardboardV1",
                    label: "Cardboard I/O 2014",
                    fov: 40,
                    interLensDistance: 0.06,
                    baselineLensDistance: 0.035,
                    screenLensDistance: 0.042,
                    distortionCoefficients: [0.441, 0.156],
                    inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 1559834e-9]
                  }),
                  CardboardV2: new CardboardViewer({
                    id: "CardboardV2",
                    label: "Cardboard I/O 2015",
                    fov: 60,
                    interLensDistance: 0.064,
                    baselineLensDistance: 0.035,
                    screenLensDistance: 0.039,
                    distortionCoefficients: [0.34, 0.55],
                    inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 9177956e-9, -9904169e-10, 6183535e-11, -16981803e-13]
                  })
                };
                function DeviceInfo(deviceParams, additionalViewers) {
                  this.viewer = Viewers.CardboardV2, this.updateDeviceParams(deviceParams), this.distortion = new Distortion(this.viewer.distortionCoefficients);
                  for (var i = 0; i < additionalViewers.length; i++) {
                    var viewer = additionalViewers[i];
                    Viewers[viewer.id] = new CardboardViewer(viewer);
                  }
                }
                DeviceInfo.prototype.updateDeviceParams = function(deviceParams) {
                  this.device = this.determineDevice_(deviceParams) || this.device;
                }, DeviceInfo.prototype.getDevice = function() {
                  return this.device;
                }, DeviceInfo.prototype.setViewer = function(viewer) {
                  this.viewer = viewer, this.distortion = new Distortion(this.viewer.distortionCoefficients);
                }, DeviceInfo.prototype.determineDevice_ = function(deviceParams) {
                  if (!deviceParams)
                    return isIOS() ? (console.warn("Using fallback iOS device measurements."), DEFAULT_IOS) : (console.warn("Using fallback Android device measurements."), DEFAULT_ANDROID);
                  var METERS_PER_INCH = 0.0254, metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi, metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi, width = getScreenWidth(), height = getScreenHeight();
                  return new Device({
                    widthMeters: metersPerPixelX * width,
                    heightMeters: metersPerPixelY * height,
                    bevelMeters: deviceParams.bevelMm * 1e-3
                  });
                }, DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function() {
                  var viewer = this.viewer, device = this.device, distortion = this.distortion, eyeToScreenDistance = viewer.screenLensDistance, outerDist = (device.widthMeters - viewer.interLensDistance) / 2, innerDist = viewer.interLensDistance / 2, bottomDist = viewer.baselineLensDistance - device.bevelMeters, topDist = device.heightMeters - bottomDist, outerAngle = radToDeg * Math.atan(distortion.distort(outerDist / eyeToScreenDistance)), innerAngle = radToDeg * Math.atan(distortion.distort(innerDist / eyeToScreenDistance)), bottomAngle = radToDeg * Math.atan(distortion.distort(bottomDist / eyeToScreenDistance)), topAngle = radToDeg * Math.atan(distortion.distort(topDist / eyeToScreenDistance));
                  return {
                    leftDegrees: Math.min(outerAngle, viewer.fov),
                    rightDegrees: Math.min(innerAngle, viewer.fov),
                    downDegrees: Math.min(bottomAngle, viewer.fov),
                    upDegrees: Math.min(topAngle, viewer.fov)
                  };
                }, DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function() {
                  var viewer = this.viewer, device = this.device, distortion = this.distortion, fovLeft = Math.tan(-degToRad * viewer.fov), fovTop = Math.tan(degToRad * viewer.fov), fovRight = Math.tan(degToRad * viewer.fov), fovBottom = Math.tan(-degToRad * viewer.fov), halfWidth = device.widthMeters / 4, halfHeight = device.heightMeters / 2, verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight, centerX = viewer.interLensDistance / 2 - halfWidth, centerY = -verticalLensOffset, centerZ = viewer.screenLensDistance, screenLeft = distortion.distort((centerX - halfWidth) / centerZ), screenTop = distortion.distort((centerY + halfHeight) / centerZ), screenRight = distortion.distort((centerX + halfWidth) / centerZ), screenBottom = distortion.distort((centerY - halfHeight) / centerZ), result = new Float32Array(4);
                  return result[0] = Math.max(fovLeft, screenLeft), result[1] = Math.min(fovTop, screenTop), result[2] = Math.min(fovRight, screenRight), result[3] = Math.max(fovBottom, screenBottom), result;
                }, DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function() {
                  var viewer = this.viewer, device = this.device, distortion = this.distortion, result = new Float32Array(4), fovLeft = distortion.distortInverse(Math.tan(-degToRad * viewer.fov)), fovTop = distortion.distortInverse(Math.tan(degToRad * viewer.fov)), fovRight = distortion.distortInverse(Math.tan(degToRad * viewer.fov)), fovBottom = distortion.distortInverse(Math.tan(-degToRad * viewer.fov)), halfWidth = device.widthMeters / 4, halfHeight = device.heightMeters / 2, verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight, centerX = viewer.interLensDistance / 2 - halfWidth, centerY = -verticalLensOffset, centerZ = viewer.screenLensDistance, screenLeft = (centerX - halfWidth) / centerZ, screenTop = (centerY + halfHeight) / centerZ, screenRight = (centerX + halfWidth) / centerZ, screenBottom = (centerY - halfHeight) / centerZ;
                  return result[0] = Math.max(fovLeft, screenLeft), result[1] = Math.min(fovTop, screenTop), result[2] = Math.min(fovRight, screenRight), result[3] = Math.max(fovBottom, screenBottom), result;
                }, DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function(undistortedFrustum) {
                  var viewer = this.viewer, device = this.device, dist = viewer.screenLensDistance, eyeX = (device.widthMeters - viewer.interLensDistance) / 2, eyeY = viewer.baselineLensDistance - device.bevelMeters, left = (undistortedFrustum[0] * dist + eyeX) / device.widthMeters, top = (undistortedFrustum[1] * dist + eyeY) / device.heightMeters, right = (undistortedFrustum[2] * dist + eyeX) / device.widthMeters, bottom = (undistortedFrustum[3] * dist + eyeY) / device.heightMeters;
                  return {
                    x: left,
                    y: bottom,
                    width: right - left,
                    height: top - bottom
                  };
                }, DeviceInfo.prototype.getFieldOfViewLeftEye = function(opt_isUndistorted) {
                  return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
                }, DeviceInfo.prototype.getFieldOfViewRightEye = function(opt_isUndistorted) {
                  var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
                  return {
                    leftDegrees: fov.rightDegrees,
                    rightDegrees: fov.leftDegrees,
                    upDegrees: fov.upDegrees,
                    downDegrees: fov.downDegrees
                  };
                }, DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function() {
                  var p = this.getUndistortedParams_();
                  return {
                    leftDegrees: radToDeg * Math.atan(p.outerDist),
                    rightDegrees: radToDeg * Math.atan(p.innerDist),
                    downDegrees: radToDeg * Math.atan(p.bottomDist),
                    upDegrees: radToDeg * Math.atan(p.topDist)
                  };
                }, DeviceInfo.prototype.getUndistortedViewportLeftEye = function() {
                  var p = this.getUndistortedParams_(), viewer = this.viewer, device = this.device, eyeToScreenDistance = viewer.screenLensDistance, screenWidth = device.widthMeters / eyeToScreenDistance, screenHeight = device.heightMeters / eyeToScreenDistance, xPxPerTanAngle = device.width / screenWidth, yPxPerTanAngle = device.height / screenHeight, x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle), y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
                  return {
                    x,
                    y,
                    width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
                    height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
                  };
                }, DeviceInfo.prototype.getUndistortedParams_ = function() {
                  var viewer = this.viewer, device = this.device, distortion = this.distortion, eyeToScreenDistance = viewer.screenLensDistance, halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance, screenWidth = device.widthMeters / eyeToScreenDistance, screenHeight = device.heightMeters / eyeToScreenDistance, eyePosX = screenWidth / 2 - halfLensDistance, eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance, maxFov = viewer.fov, viewerMax = distortion.distortInverse(Math.tan(degToRad * maxFov)), outerDist = Math.min(eyePosX, viewerMax), innerDist = Math.min(halfLensDistance, viewerMax), bottomDist = Math.min(eyePosY, viewerMax), topDist = Math.min(screenHeight - eyePosY, viewerMax);
                  return {
                    outerDist,
                    innerDist,
                    topDist,
                    bottomDist,
                    eyePosX,
                    eyePosY
                  };
                };
                function CardboardViewer(params) {
                  this.id = params.id, this.label = params.label, this.fov = params.fov, this.interLensDistance = params.interLensDistance, this.baselineLensDistance = params.baselineLensDistance, this.screenLensDistance = params.screenLensDistance, this.distortionCoefficients = params.distortionCoefficients, this.inverseCoefficients = params.inverseCoefficients;
                }
                DeviceInfo.Viewers = Viewers;
                var format = 1, last_updated = "2019-11-09T17:36:14Z", devices = [{
                  type: "android",
                  rules: [{
                    mdmh: "asus/*/Nexus 7/*"
                  }, {
                    ua: "Nexus 7"
                  }],
                  dpi: [320.8, 323],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "asus/*/ASUS_X00PD/*"
                  }, {
                    ua: "ASUS_X00PD"
                  }],
                  dpi: 245,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "asus/*/ASUS_X008D/*"
                  }, {
                    ua: "ASUS_X008D"
                  }],
                  dpi: 282,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "asus/*/ASUS_Z00AD/*"
                  }, {
                    ua: "ASUS_Z00AD"
                  }],
                  dpi: [403, 404.6],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Google/*/Pixel 2 XL/*"
                  }, {
                    ua: "Pixel 2 XL"
                  }],
                  dpi: 537.9,
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Google/*/Pixel 3 XL/*"
                  }, {
                    ua: "Pixel 3 XL"
                  }],
                  dpi: [558.5, 553.8],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Google/*/Pixel XL/*"
                  }, {
                    ua: "Pixel XL"
                  }],
                  dpi: [537.9, 533],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Google/*/Pixel 3/*"
                  }, {
                    ua: "Pixel 3"
                  }],
                  dpi: 442.4,
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Google/*/Pixel 2/*"
                  }, {
                    ua: "Pixel 2"
                  }],
                  dpi: 441,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Google/*/Pixel/*"
                  }, {
                    ua: "Pixel"
                  }],
                  dpi: [432.6, 436.7],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "HTC/*/HTC6435LVW/*"
                  }, {
                    ua: "HTC6435LVW"
                  }],
                  dpi: [449.7, 443.3],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "HTC/*/HTC One XL/*"
                  }, {
                    ua: "HTC One XL"
                  }],
                  dpi: [315.3, 314.6],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "htc/*/Nexus 9/*"
                  }, {
                    ua: "Nexus 9"
                  }],
                  dpi: 289,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "HTC/*/HTC One M9/*"
                  }, {
                    ua: "HTC One M9"
                  }],
                  dpi: [442.5, 443.3],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "HTC/*/HTC One_M8/*"
                  }, {
                    ua: "HTC One_M8"
                  }],
                  dpi: [449.7, 447.4],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "HTC/*/HTC One/*"
                  }, {
                    ua: "HTC One"
                  }],
                  dpi: 472.8,
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Huawei/*/Nexus 6P/*"
                  }, {
                    ua: "Nexus 6P"
                  }],
                  dpi: [515.1, 518],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Huawei/*/BLN-L24/*"
                  }, {
                    ua: "HONORBLN-L24"
                  }],
                  dpi: 480,
                  bw: 4,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Huawei/*/BKL-L09/*"
                  }, {
                    ua: "BKL-L09"
                  }],
                  dpi: 403,
                  bw: 3.47,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LENOVO/*/Lenovo PB2-690Y/*"
                  }, {
                    ua: "Lenovo PB2-690Y"
                  }],
                  dpi: [457.2, 454.713],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LGE/*/Nexus 5X/*"
                  }, {
                    ua: "Nexus 5X"
                  }],
                  dpi: [422, 419.9],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LGE/*/LGMS345/*"
                  }, {
                    ua: "LGMS345"
                  }],
                  dpi: [221.7, 219.1],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LGE/*/LG-D800/*"
                  }, {
                    ua: "LG-D800"
                  }],
                  dpi: [422, 424.1],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LGE/*/LG-D850/*"
                  }, {
                    ua: "LG-D850"
                  }],
                  dpi: [537.9, 541.9],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LGE/*/VS985 4G/*"
                  }, {
                    ua: "VS985 4G"
                  }],
                  dpi: [537.9, 535.6],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LGE/*/Nexus 5/*"
                  }, {
                    ua: "Nexus 5 B"
                  }],
                  dpi: [442.4, 444.8],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LGE/*/Nexus 4/*"
                  }, {
                    ua: "Nexus 4"
                  }],
                  dpi: [319.8, 318.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LGE/*/LG-P769/*"
                  }, {
                    ua: "LG-P769"
                  }],
                  dpi: [240.6, 247.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LGE/*/LGMS323/*"
                  }, {
                    ua: "LGMS323"
                  }],
                  dpi: [206.6, 204.6],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "LGE/*/LGLS996/*"
                  }, {
                    ua: "LGLS996"
                  }],
                  dpi: [403.4, 401.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Micromax/*/4560MMX/*"
                  }, {
                    ua: "4560MMX"
                  }],
                  dpi: [240, 219.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Micromax/*/A250/*"
                  }, {
                    ua: "Micromax A250"
                  }],
                  dpi: [480, 446.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Micromax/*/Micromax AQ4501/*"
                  }, {
                    ua: "Micromax AQ4501"
                  }],
                  dpi: 240,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/G5/*"
                  }, {
                    ua: "Moto G (5) Plus"
                  }],
                  dpi: [403.4, 403],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/DROID RAZR/*"
                  }, {
                    ua: "DROID RAZR"
                  }],
                  dpi: [368.1, 256.7],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT830C/*"
                  }, {
                    ua: "XT830C"
                  }],
                  dpi: [254, 255.9],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT1021/*"
                  }, {
                    ua: "XT1021"
                  }],
                  dpi: [254, 256.7],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT1023/*"
                  }, {
                    ua: "XT1023"
                  }],
                  dpi: [254, 256.7],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT1028/*"
                  }, {
                    ua: "XT1028"
                  }],
                  dpi: [326.6, 327.6],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT1034/*"
                  }, {
                    ua: "XT1034"
                  }],
                  dpi: [326.6, 328.4],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT1053/*"
                  }, {
                    ua: "XT1053"
                  }],
                  dpi: [315.3, 316.1],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT1562/*"
                  }, {
                    ua: "XT1562"
                  }],
                  dpi: [403.4, 402.7],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/Nexus 6/*"
                  }, {
                    ua: "Nexus 6 B"
                  }],
                  dpi: [494.3, 489.7],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT1063/*"
                  }, {
                    ua: "XT1063"
                  }],
                  dpi: [295, 296.6],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT1064/*"
                  }, {
                    ua: "XT1064"
                  }],
                  dpi: [295, 295.6],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT1092/*"
                  }, {
                    ua: "XT1092"
                  }],
                  dpi: [422, 424.1],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/XT1095/*"
                  }, {
                    ua: "XT1095"
                  }],
                  dpi: [422, 423.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "motorola/*/G4/*"
                  }, {
                    ua: "Moto G (4)"
                  }],
                  dpi: 401,
                  bw: 4,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/A0001/*"
                  }, {
                    ua: "A0001"
                  }],
                  dpi: [403.4, 401],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONE E1001/*"
                  }, {
                    ua: "ONE E1001"
                  }],
                  dpi: [442.4, 441.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONE E1003/*"
                  }, {
                    ua: "ONE E1003"
                  }],
                  dpi: [442.4, 441.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONE E1005/*"
                  }, {
                    ua: "ONE E1005"
                  }],
                  dpi: [442.4, 441.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONE A2001/*"
                  }, {
                    ua: "ONE A2001"
                  }],
                  dpi: [391.9, 405.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONE A2003/*"
                  }, {
                    ua: "ONE A2003"
                  }],
                  dpi: [391.9, 405.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONE A2005/*"
                  }, {
                    ua: "ONE A2005"
                  }],
                  dpi: [391.9, 405.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONEPLUS A3000/*"
                  }, {
                    ua: "ONEPLUS A3000"
                  }],
                  dpi: 401,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONEPLUS A3003/*"
                  }, {
                    ua: "ONEPLUS A3003"
                  }],
                  dpi: 401,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONEPLUS A3010/*"
                  }, {
                    ua: "ONEPLUS A3010"
                  }],
                  dpi: 401,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONEPLUS A5000/*"
                  }, {
                    ua: "ONEPLUS A5000 "
                  }],
                  dpi: [403.411, 399.737],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONE A5010/*"
                  }, {
                    ua: "ONEPLUS A5010"
                  }],
                  dpi: [403, 400],
                  bw: 2,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONEPLUS A6000/*"
                  }, {
                    ua: "ONEPLUS A6000"
                  }],
                  dpi: 401,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONEPLUS A6003/*"
                  }, {
                    ua: "ONEPLUS A6003"
                  }],
                  dpi: 401,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONEPLUS A6010/*"
                  }, {
                    ua: "ONEPLUS A6010"
                  }],
                  dpi: 401,
                  bw: 2,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OnePlus/*/ONEPLUS A6013/*"
                  }, {
                    ua: "ONEPLUS A6013"
                  }],
                  dpi: 401,
                  bw: 2,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "OPPO/*/X909/*"
                  }, {
                    ua: "X909"
                  }],
                  dpi: [442.4, 444.1],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/GT-I9082/*"
                  }, {
                    ua: "GT-I9082"
                  }],
                  dpi: [184.7, 185.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G360P/*"
                  }, {
                    ua: "SM-G360P"
                  }],
                  dpi: [196.7, 205.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/Nexus S/*"
                  }, {
                    ua: "Nexus S"
                  }],
                  dpi: [234.5, 229.8],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/GT-I9300/*"
                  }, {
                    ua: "GT-I9300"
                  }],
                  dpi: [304.8, 303.9],
                  bw: 5,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-T230NU/*"
                  }, {
                    ua: "SM-T230NU"
                  }],
                  dpi: 216,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SGH-T399/*"
                  }, {
                    ua: "SGH-T399"
                  }],
                  dpi: [217.7, 231.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SGH-M919/*"
                  }, {
                    ua: "SGH-M919"
                  }],
                  dpi: [440.8, 437.7],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-N9005/*"
                  }, {
                    ua: "SM-N9005"
                  }],
                  dpi: [386.4, 387],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SAMSUNG-SM-N900A/*"
                  }, {
                    ua: "SAMSUNG-SM-N900A"
                  }],
                  dpi: [386.4, 387.7],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/GT-I9500/*"
                  }, {
                    ua: "GT-I9500"
                  }],
                  dpi: [442.5, 443.3],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/GT-I9505/*"
                  }, {
                    ua: "GT-I9505"
                  }],
                  dpi: 439.4,
                  bw: 4,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G900F/*"
                  }, {
                    ua: "SM-G900F"
                  }],
                  dpi: [415.6, 431.6],
                  bw: 5,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G900M/*"
                  }, {
                    ua: "SM-G900M"
                  }],
                  dpi: [415.6, 431.6],
                  bw: 5,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G800F/*"
                  }, {
                    ua: "SM-G800F"
                  }],
                  dpi: 326.8,
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G906S/*"
                  }, {
                    ua: "SM-G906S"
                  }],
                  dpi: [562.7, 572.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/GT-I9300/*"
                  }, {
                    ua: "GT-I9300"
                  }],
                  dpi: [306.7, 304.8],
                  bw: 5,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-T535/*"
                  }, {
                    ua: "SM-T535"
                  }],
                  dpi: [142.6, 136.4],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-N920C/*"
                  }, {
                    ua: "SM-N920C"
                  }],
                  dpi: [515.1, 518.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-N920P/*"
                  }, {
                    ua: "SM-N920P"
                  }],
                  dpi: [386.3655, 390.144],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-N920W8/*"
                  }, {
                    ua: "SM-N920W8"
                  }],
                  dpi: [515.1, 518.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/GT-I9300I/*"
                  }, {
                    ua: "GT-I9300I"
                  }],
                  dpi: [304.8, 305.8],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/GT-I9195/*"
                  }, {
                    ua: "GT-I9195"
                  }],
                  dpi: [249.4, 256.7],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SPH-L520/*"
                  }, {
                    ua: "SPH-L520"
                  }],
                  dpi: [249.4, 255.9],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SAMSUNG-SGH-I717/*"
                  }, {
                    ua: "SAMSUNG-SGH-I717"
                  }],
                  dpi: 285.8,
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SPH-D710/*"
                  }, {
                    ua: "SPH-D710"
                  }],
                  dpi: [217.7, 204.2],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/GT-N7100/*"
                  }, {
                    ua: "GT-N7100"
                  }],
                  dpi: 265.1,
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SCH-I605/*"
                  }, {
                    ua: "SCH-I605"
                  }],
                  dpi: 265.1,
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/Galaxy Nexus/*"
                  }, {
                    ua: "Galaxy Nexus"
                  }],
                  dpi: [315.3, 314.2],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-N910H/*"
                  }, {
                    ua: "SM-N910H"
                  }],
                  dpi: [515.1, 518],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-N910C/*"
                  }, {
                    ua: "SM-N910C"
                  }],
                  dpi: [515.2, 520.2],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G130M/*"
                  }, {
                    ua: "SM-G130M"
                  }],
                  dpi: [165.9, 164.8],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G928I/*"
                  }, {
                    ua: "SM-G928I"
                  }],
                  dpi: [515.1, 518.4],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G920F/*"
                  }, {
                    ua: "SM-G920F"
                  }],
                  dpi: 580.6,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G920P/*"
                  }, {
                    ua: "SM-G920P"
                  }],
                  dpi: [522.5, 577],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G925F/*"
                  }, {
                    ua: "SM-G925F"
                  }],
                  dpi: 580.6,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G925V/*"
                  }, {
                    ua: "SM-G925V"
                  }],
                  dpi: [522.5, 576.6],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G930F/*"
                  }, {
                    ua: "SM-G930F"
                  }],
                  dpi: 576.6,
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G935F/*"
                  }, {
                    ua: "SM-G935F"
                  }],
                  dpi: 533,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G950F/*"
                  }, {
                    ua: "SM-G950F"
                  }],
                  dpi: [562.707, 565.293],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G955U/*"
                  }, {
                    ua: "SM-G955U"
                  }],
                  dpi: [522.514, 525.762],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G955F/*"
                  }, {
                    ua: "SM-G955F"
                  }],
                  dpi: [522.514, 525.762],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G960F/*"
                  }, {
                    ua: "SM-G960F"
                  }],
                  dpi: [569.575, 571.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G9600/*"
                  }, {
                    ua: "SM-G9600"
                  }],
                  dpi: [569.575, 571.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G960T/*"
                  }, {
                    ua: "SM-G960T"
                  }],
                  dpi: [569.575, 571.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G960N/*"
                  }, {
                    ua: "SM-G960N"
                  }],
                  dpi: [569.575, 571.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G960U/*"
                  }, {
                    ua: "SM-G960U"
                  }],
                  dpi: [569.575, 571.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G9608/*"
                  }, {
                    ua: "SM-G9608"
                  }],
                  dpi: [569.575, 571.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G960FD/*"
                  }, {
                    ua: "SM-G960FD"
                  }],
                  dpi: [569.575, 571.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G960W/*"
                  }, {
                    ua: "SM-G960W"
                  }],
                  dpi: [569.575, 571.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G965F/*"
                  }, {
                    ua: "SM-G965F"
                  }],
                  dpi: 529,
                  bw: 2,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Sony/*/C6903/*"
                  }, {
                    ua: "C6903"
                  }],
                  dpi: [442.5, 443.3],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Sony/*/D6653/*"
                  }, {
                    ua: "D6653"
                  }],
                  dpi: [428.6, 427.6],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Sony/*/E6653/*"
                  }, {
                    ua: "E6653"
                  }],
                  dpi: [428.6, 425.7],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Sony/*/E6853/*"
                  }, {
                    ua: "E6853"
                  }],
                  dpi: [403.4, 401.9],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Sony/*/SGP321/*"
                  }, {
                    ua: "SGP321"
                  }],
                  dpi: [224.7, 224.1],
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "TCT/*/ALCATEL ONE TOUCH Fierce/*"
                  }, {
                    ua: "ALCATEL ONE TOUCH Fierce"
                  }],
                  dpi: [240, 247.5],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "THL/*/thl 5000/*"
                  }, {
                    ua: "thl 5000"
                  }],
                  dpi: [480, 443.3],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Fly/*/IQ4412/*"
                  }, {
                    ua: "IQ4412"
                  }],
                  dpi: 307.9,
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "ZTE/*/ZTE Blade L2/*"
                  }, {
                    ua: "ZTE Blade L2"
                  }],
                  dpi: 240,
                  bw: 3,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "BENEVE/*/VR518/*"
                  }, {
                    ua: "VR518"
                  }],
                  dpi: 480,
                  bw: 3,
                  ac: 500
                }, {
                  type: "ios",
                  rules: [{
                    res: [640, 960]
                  }],
                  dpi: [325.1, 328.4],
                  bw: 4,
                  ac: 1e3
                }, {
                  type: "ios",
                  rules: [{
                    res: [640, 1136]
                  }],
                  dpi: [317.1, 320.2],
                  bw: 3,
                  ac: 1e3
                }, {
                  type: "ios",
                  rules: [{
                    res: [750, 1334]
                  }],
                  dpi: 326.4,
                  bw: 4,
                  ac: 1e3
                }, {
                  type: "ios",
                  rules: [{
                    res: [1242, 2208]
                  }],
                  dpi: [453.6, 458.4],
                  bw: 4,
                  ac: 1e3
                }, {
                  type: "ios",
                  rules: [{
                    res: [1125, 2001]
                  }],
                  dpi: [410.9, 415.4],
                  bw: 4,
                  ac: 1e3
                }, {
                  type: "ios",
                  rules: [{
                    res: [1125, 2436]
                  }],
                  dpi: 458,
                  bw: 4,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Huawei/*/EML-L29/*"
                  }, {
                    ua: "EML-L29"
                  }],
                  dpi: 428,
                  bw: 3.45,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "Nokia/*/Nokia 7.1/*"
                  }, {
                    ua: "Nokia 7.1"
                  }],
                  dpi: [432, 431.9],
                  bw: 3,
                  ac: 500
                }, {
                  type: "ios",
                  rules: [{
                    res: [1242, 2688]
                  }],
                  dpi: 458,
                  bw: 4,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G570M/*"
                  }, {
                    ua: "SM-G570M"
                  }],
                  dpi: 320,
                  bw: 3.684,
                  ac: 1e3
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G970F/*"
                  }, {
                    ua: "SM-G970F"
                  }],
                  dpi: 438,
                  bw: 2.281,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G973F/*"
                  }, {
                    ua: "SM-G973F"
                  }],
                  dpi: 550,
                  bw: 2.002,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G975F/*"
                  }, {
                    ua: "SM-G975F"
                  }],
                  dpi: 522,
                  bw: 2.054,
                  ac: 500
                }, {
                  type: "android",
                  rules: [{
                    mdmh: "samsung/*/SM-G977F/*"
                  }, {
                    ua: "SM-G977F"
                  }],
                  dpi: 505,
                  bw: 2.334,
                  ac: 500
                }, {
                  type: "ios",
                  rules: [{
                    res: [828, 1792]
                  }],
                  dpi: 326,
                  bw: 5,
                  ac: 500
                }], DPDB_CACHE = {
                  format,
                  last_updated,
                  devices
                };
                function Dpdb(url, onDeviceParamsUpdated) {
                  if (this.dpdb = DPDB_CACHE, this.recalculateDeviceParams_(), url) {
                    this.onDeviceParamsUpdated = onDeviceParamsUpdated;
                    var xhr = new XMLHttpRequest(), obj = this;
                    xhr.open("GET", url, !0), xhr.addEventListener("load", function() {
                      obj.loading = !1, xhr.status >= 200 && xhr.status <= 299 ? (obj.dpdb = JSON.parse(xhr.response), obj.recalculateDeviceParams_()) : console.error("Error loading online DPDB!");
                    }), xhr.send();
                  }
                }
                Dpdb.prototype.getDeviceParams = function() {
                  return this.deviceParams;
                }, Dpdb.prototype.recalculateDeviceParams_ = function() {
                  var newDeviceParams = this.calcDeviceParams_();
                  newDeviceParams ? (this.deviceParams = newDeviceParams, this.onDeviceParamsUpdated && this.onDeviceParamsUpdated(this.deviceParams)) : console.error("Failed to recalculate device parameters.");
                }, Dpdb.prototype.calcDeviceParams_ = function() {
                  var db = this.dpdb;
                  if (!db)
                    return console.error("DPDB not available."), null;
                  if (db.format != 1)
                    return console.error("DPDB has unexpected format version."), null;
                  if (!db.devices || !db.devices.length)
                    return console.error("DPDB does not have a devices section."), null;
                  var userAgent = navigator.userAgent || navigator.vendor || window.opera, width = getScreenWidth(), height = getScreenHeight();
                  if (!db.devices)
                    return console.error("DPDB has no devices section."), null;
                  for (var i = 0; i < db.devices.length; i++) {
                    var device = db.devices[i];
                    if (!device.rules) {
                      console.warn("Device[" + i + "] has no rules section.");
                      continue;
                    }
                    if (device.type != "ios" && device.type != "android") {
                      console.warn("Device[" + i + "] has invalid type.");
                      continue;
                    }
                    if (isIOS() == (device.type == "ios")) {
                      for (var matched = !1, j = 0; j < device.rules.length; j++) {
                        var rule = device.rules[j];
                        if (this.ruleMatches_(rule, userAgent, width, height)) {
                          matched = !0;
                          break;
                        }
                      }
                      if (!!matched) {
                        var xdpi = device.dpi[0] || device.dpi, ydpi = device.dpi[1] || device.dpi;
                        return new DeviceParams({
                          xdpi,
                          ydpi,
                          bevelMm: device.bw
                        });
                      }
                    }
                  }
                  return console.warn("No DPDB device match."), null;
                }, Dpdb.prototype.ruleMatches_ = function(rule, ua, screenWidth, screenHeight) {
                  if (!rule.ua && !rule.res || (rule.ua && rule.ua.substring(0, 2) === "SM" && (rule.ua = rule.ua.substring(0, 7)), rule.ua && ua.indexOf(rule.ua) < 0))
                    return !1;
                  if (rule.res) {
                    if (!rule.res[0] || !rule.res[1])
                      return !1;
                    var resX = rule.res[0], resY = rule.res[1];
                    if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) || Math.max(screenWidth, screenHeight) != Math.max(resX, resY))
                      return !1;
                  }
                  return !0;
                };
                function DeviceParams(params) {
                  this.xdpi = params.xdpi, this.ydpi = params.ydpi, this.bevelMm = params.bevelMm;
                }
                function SensorSample(sample, timestampS) {
                  this.set(sample, timestampS);
                }
                SensorSample.prototype.set = function(sample, timestampS) {
                  this.sample = sample, this.timestampS = timestampS;
                }, SensorSample.prototype.copy = function(sensorSample) {
                  this.set(sensorSample.sample, sensorSample.timestampS);
                };
                function ComplementaryFilter(kFilter, isDebug) {
                  this.kFilter = kFilter, this.isDebug = isDebug, this.currentAccelMeasurement = new SensorSample(), this.currentGyroMeasurement = new SensorSample(), this.previousGyroMeasurement = new SensorSample(), isIOS() ? this.filterQ = new Quaternion(-1, 0, 0, 1) : this.filterQ = new Quaternion(1, 0, 0, 1), this.previousFilterQ = new Quaternion(), this.previousFilterQ.copy(this.filterQ), this.accelQ = new Quaternion(), this.isOrientationInitialized = !1, this.estimatedGravity = new Vector3(), this.measuredGravity = new Vector3(), this.gyroIntegralQ = new Quaternion();
                }
                ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
                  this.currentAccelMeasurement.set(vector, timestampS);
                }, ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
                  this.currentGyroMeasurement.set(vector, timestampS);
                  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
                  isTimestampDeltaValid(deltaT) && this.run_(), this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
                }, ComplementaryFilter.prototype.run_ = function() {
                  if (!this.isOrientationInitialized) {
                    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample), this.previousFilterQ.copy(this.accelQ), this.isOrientationInitialized = !0;
                    return;
                  }
                  var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS, gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
                  this.gyroIntegralQ.multiply(gyroDeltaQ), this.filterQ.copy(this.previousFilterQ), this.filterQ.multiply(gyroDeltaQ);
                  var invFilterQ = new Quaternion();
                  invFilterQ.copy(this.filterQ), invFilterQ.inverse(), this.estimatedGravity.set(0, 0, -1), this.estimatedGravity.applyQuaternion(invFilterQ), this.estimatedGravity.normalize(), this.measuredGravity.copy(this.currentAccelMeasurement.sample), this.measuredGravity.normalize();
                  var deltaQ = new Quaternion();
                  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity), deltaQ.inverse(), this.isDebug && console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)", radToDeg * getQuaternionAngle(deltaQ), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
                  var targetQ = new Quaternion();
                  targetQ.copy(this.filterQ), targetQ.multiply(deltaQ), this.filterQ.slerp(targetQ, 1 - this.kFilter), this.previousFilterQ.copy(this.filterQ);
                }, ComplementaryFilter.prototype.getOrientation = function() {
                  return this.filterQ;
                }, ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
                  var normAccel = new Vector3();
                  normAccel.copy(accel), normAccel.normalize();
                  var quat = new Quaternion();
                  return quat.setFromUnitVectors(new Vector3(0, 0, -1), normAccel), quat.inverse(), quat;
                }, ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
                  var quat = new Quaternion(), axis = new Vector3();
                  return axis.copy(gyro), axis.normalize(), quat.setFromAxisAngle(axis, gyro.length() * dt), quat;
                };
                function PosePredictor(predictionTimeS, isDebug) {
                  this.predictionTimeS = predictionTimeS, this.isDebug = isDebug, this.previousQ = new Quaternion(), this.previousTimestampS = null, this.deltaQ = new Quaternion(), this.outQ = new Quaternion();
                }
                PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
                  if (!this.previousTimestampS)
                    return this.previousQ.copy(currentQ), this.previousTimestampS = timestampS, currentQ;
                  var axis = new Vector3();
                  axis.copy(gyro), axis.normalize();
                  var angularSpeed = gyro.length();
                  if (angularSpeed < degToRad * 20)
                    return this.isDebug && console.log("Moving slowly, at %s deg/s: no prediction", (radToDeg * angularSpeed).toFixed(1)), this.outQ.copy(currentQ), this.previousQ.copy(currentQ), this.outQ;
                  var predictAngle = angularSpeed * this.predictionTimeS;
                  return this.deltaQ.setFromAxisAngle(axis, predictAngle), this.outQ.copy(this.previousQ), this.outQ.multiply(this.deltaQ), this.previousQ.copy(currentQ), this.previousTimestampS = timestampS, this.outQ;
                };
                function FusionPoseSensor(kFilter, predictionTime, yawOnly, isDebug) {
                  this.yawOnly = yawOnly, this.accelerometer = new Vector3(), this.gyroscope = new Vector3(), this.filter = new ComplementaryFilter(kFilter, isDebug), this.posePredictor = new PosePredictor(predictionTime, isDebug), this.isFirefoxAndroid = isFirefoxAndroid(), this.isIOS = isIOS();
                  var chromeVersion = getChromeVersion();
                  this.isDeviceMotionInRadians = !this.isIOS && chromeVersion && chromeVersion < 66, this.isWithoutDeviceMotion = isChromeWithoutDeviceMotion() || isSafariWithoutDeviceMotion(), this.filterToWorldQ = new Quaternion(), isIOS() ? this.filterToWorldQ.setFromAxisAngle(new Vector3(1, 0, 0), Math.PI / 2) : this.filterToWorldQ.setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2), this.inverseWorldToScreenQ = new Quaternion(), this.worldToScreenQ = new Quaternion(), this.originalPoseAdjustQ = new Quaternion(), this.originalPoseAdjustQ.setFromAxisAngle(new Vector3(0, 0, 1), -window.orientation * Math.PI / 180), this.setScreenTransform_(), isLandscapeMode() && this.filterToWorldQ.multiply(this.inverseWorldToScreenQ), this.resetQ = new Quaternion(), this.orientationOut_ = new Float32Array(4), this.start();
                }
                FusionPoseSensor.prototype.getPosition = function() {
                  return null;
                }, FusionPoseSensor.prototype.getOrientation = function() {
                  var orientation = void 0;
                  if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
                    this.deviceOrientationFixQ = this.deviceOrientationFixQ || function() {
                      var z = new Quaternion().setFromAxisAngle(new Vector3(0, 0, -1), 0), y = new Quaternion();
                      return window.orientation === -90 ? y.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / -2) : y.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / 2), z.multiply(y);
                    }(), this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function() {
                      var q = new Quaternion();
                      return q.setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2), q;
                    }(), orientation = this._deviceOrientationQ;
                    var out = new Quaternion();
                    return out.copy(orientation), out.multiply(this.deviceOrientationFilterToWorldQ), out.multiply(this.resetQ), out.multiply(this.worldToScreenQ), out.multiplyQuaternions(this.deviceOrientationFixQ, out), this.yawOnly && (out.x = 0, out.z = 0, out.normalize()), this.orientationOut_[0] = out.x, this.orientationOut_[1] = out.y, this.orientationOut_[2] = out.z, this.orientationOut_[3] = out.w, this.orientationOut_;
                  } else {
                    var filterOrientation = this.filter.getOrientation();
                    orientation = this.posePredictor.getPrediction(filterOrientation, this.gyroscope, this.previousTimestampS);
                  }
                  var out = new Quaternion();
                  return out.copy(this.filterToWorldQ), out.multiply(this.resetQ), out.multiply(orientation), out.multiply(this.worldToScreenQ), this.yawOnly && (out.x = 0, out.z = 0, out.normalize()), this.orientationOut_[0] = out.x, this.orientationOut_[1] = out.y, this.orientationOut_[2] = out.z, this.orientationOut_[3] = out.w, this.orientationOut_;
                }, FusionPoseSensor.prototype.resetPose = function() {
                  this.resetQ.copy(this.filter.getOrientation()), this.resetQ.x = 0, this.resetQ.y = 0, this.resetQ.z *= -1, this.resetQ.normalize(), isLandscapeMode() && this.resetQ.multiply(this.inverseWorldToScreenQ), this.resetQ.multiply(this.originalPoseAdjustQ);
                }, FusionPoseSensor.prototype.onDeviceOrientation_ = function(e) {
                  this._deviceOrientationQ = this._deviceOrientationQ || new Quaternion();
                  var alpha = e.alpha, beta = e.beta, gamma = e.gamma;
                  alpha = (alpha || 0) * Math.PI / 180, beta = (beta || 0) * Math.PI / 180, gamma = (gamma || 0) * Math.PI / 180, this._deviceOrientationQ.setFromEulerYXZ(beta, alpha, -gamma);
                }, FusionPoseSensor.prototype.onDeviceMotion_ = function(deviceMotion) {
                  this.updateDeviceMotion_(deviceMotion);
                }, FusionPoseSensor.prototype.updateDeviceMotion_ = function(deviceMotion) {
                  var accGravity = deviceMotion.accelerationIncludingGravity, rotRate = deviceMotion.rotationRate, timestampS = deviceMotion.timeStamp / 1e3, deltaS = timestampS - this.previousTimestampS;
                  if (deltaS < 0) {
                    warnOnce("fusion-pose-sensor:invalid:non-monotonic", "Invalid timestamps detected: non-monotonic timestamp from devicemotion"), this.previousTimestampS = timestampS;
                    return;
                  } else if (deltaS <= MIN_TIMESTEP || deltaS > MAX_TIMESTEP) {
                    warnOnce("fusion-pose-sensor:invalid:outside-threshold", "Invalid timestamps detected: Timestamp from devicemotion outside expected range."), this.previousTimestampS = timestampS;
                    return;
                  }
                  this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z), rotRate && (isR7() ? this.gyroscope.set(-rotRate.beta, rotRate.alpha, rotRate.gamma) : this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma), this.isDeviceMotionInRadians || this.gyroscope.multiplyScalar(Math.PI / 180), this.filter.addGyroMeasurement(this.gyroscope, timestampS)), this.filter.addAccelMeasurement(this.accelerometer, timestampS), this.previousTimestampS = timestampS;
                }, FusionPoseSensor.prototype.onOrientationChange_ = function(screenOrientation) {
                  this.setScreenTransform_();
                }, FusionPoseSensor.prototype.onMessage_ = function(event) {
                  var message = event.data;
                  if (!(!message || !message.type)) {
                    var type = message.type.toLowerCase();
                    type === "devicemotion" && this.updateDeviceMotion_(message.deviceMotionEvent);
                  }
                }, FusionPoseSensor.prototype.setScreenTransform_ = function() {
                  switch (this.worldToScreenQ.set(0, 0, 0, 1), window.orientation) {
                    case 0:
                      break;
                    case 90:
                      this.worldToScreenQ.setFromAxisAngle(new Vector3(0, 0, 1), -Math.PI / 2);
                      break;
                    case -90:
                      this.worldToScreenQ.setFromAxisAngle(new Vector3(0, 0, 1), Math.PI / 2);
                      break;
                    case 180:
                      break;
                  }
                  this.inverseWorldToScreenQ.copy(this.worldToScreenQ), this.inverseWorldToScreenQ.inverse();
                }, FusionPoseSensor.prototype.start = function() {
                  this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this), this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this), this.onMessageCallback_ = this.onMessage_.bind(this), this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this), isIOS() && isInsideCrossOriginIFrame() && window.addEventListener("message", this.onMessageCallback_), window.addEventListener("orientationchange", this.onOrientationChangeCallback_), this.isWithoutDeviceMotion ? window.addEventListener("deviceorientation", this.onDeviceOrientationCallback_) : window.addEventListener("devicemotion", this.onDeviceMotionCallback_);
                }, FusionPoseSensor.prototype.stop = function() {
                  window.removeEventListener("devicemotion", this.onDeviceMotionCallback_), window.removeEventListener("deviceorientation", this.onDeviceOrientationCallback_), window.removeEventListener("orientationchange", this.onOrientationChangeCallback_), window.removeEventListener("message", this.onMessageCallback_);
                };
                var SENSOR_FREQUENCY = 60, X_AXIS = new Vector3(1, 0, 0), Z_AXIS = new Vector3(0, 0, 1), SENSOR_TO_VR = new Quaternion();
                SENSOR_TO_VR.setFromAxisAngle(X_AXIS, -Math.PI / 2), SENSOR_TO_VR.multiply(new Quaternion().setFromAxisAngle(Z_AXIS, Math.PI / 2));
                var PoseSensor = function() {
                  function PoseSensor2(config2) {
                    classCallCheck(this, PoseSensor2), this.config = config2, this.sensor = null, this.fusionSensor = null, this._out = new Float32Array(4), this.api = null, this.errors = [], this._sensorQ = new Quaternion(), this._outQ = new Quaternion(), this._onSensorRead = this._onSensorRead.bind(this), this._onSensorError = this._onSensorError.bind(this), this.init();
                  }
                  return createClass(PoseSensor2, [{
                    key: "init",
                    value: function() {
                      var sensor = null;
                      try {
                        sensor = new RelativeOrientationSensor({
                          frequency: SENSOR_FREQUENCY,
                          referenceFrame: "screen"
                        }), sensor.addEventListener("error", this._onSensorError);
                      } catch (error) {
                        this.errors.push(error), error.name === "SecurityError" ? (console.error("Cannot construct sensors due to the Feature Policy"), console.warn('Attempting to fall back using "devicemotion"; however this will fail in the future without correct permissions.'), this.useDeviceMotion()) : error.name === "ReferenceError" ? this.useDeviceMotion() : console.error(error);
                      }
                      sensor && (this.api = "sensor", this.sensor = sensor, this.sensor.addEventListener("reading", this._onSensorRead), this.sensor.start());
                    }
                  }, {
                    key: "useDeviceMotion",
                    value: function() {
                      this.api = "devicemotion", this.fusionSensor = new FusionPoseSensor(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG), this.sensor && (this.sensor.removeEventListener("reading", this._onSensorRead), this.sensor.removeEventListener("error", this._onSensorError), this.sensor = null);
                    }
                  }, {
                    key: "getOrientation",
                    value: function() {
                      if (this.fusionSensor)
                        return this.fusionSensor.getOrientation();
                      if (!this.sensor || !this.sensor.quaternion)
                        return this._out[0] = this._out[1] = this._out[2] = 0, this._out[3] = 1, this._out;
                      var q = this.sensor.quaternion;
                      this._sensorQ.set(q[0], q[1], q[2], q[3]);
                      var out = this._outQ;
                      return out.copy(SENSOR_TO_VR), out.multiply(this._sensorQ), this.config.YAW_ONLY && (out.x = out.z = 0, out.normalize()), this._out[0] = out.x, this._out[1] = out.y, this._out[2] = out.z, this._out[3] = out.w, this._out;
                    }
                  }, {
                    key: "_onSensorError",
                    value: function(event) {
                      this.errors.push(event.error), event.error.name === "NotAllowedError" ? console.error("Permission to access sensor was denied") : event.error.name === "NotReadableError" ? console.error("Sensor could not be read") : console.error(event.error), this.useDeviceMotion();
                    }
                  }, {
                    key: "_onSensorRead",
                    value: function() {
                    }
                  }]), PoseSensor2;
                }(), rotateInstructionsAsset = "<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>";
                function RotateInstructions() {
                  this.loadIcon_();
                  var overlay = document.createElement("div"), s = overlay.style;
                  s.position = "fixed", s.top = 0, s.right = 0, s.bottom = 0, s.left = 0, s.backgroundColor = "gray", s.fontFamily = "sans-serif", s.zIndex = 1e6;
                  var img = document.createElement("img");
                  img.src = this.icon;
                  var s = img.style;
                  s.marginLeft = "25%", s.marginTop = "25%", s.width = "50%", overlay.appendChild(img);
                  var text = document.createElement("div"), s = text.style;
                  s.textAlign = "center", s.fontSize = "16px", s.lineHeight = "24px", s.margin = "24px 25%", s.width = "50%", text.innerHTML = "Place your phone into your Cardboard viewer.", overlay.appendChild(text);
                  var snackbar = document.createElement("div"), s = snackbar.style;
                  s.backgroundColor = "#CFD8DC", s.position = "fixed", s.bottom = 0, s.width = "100%", s.height = "48px", s.padding = "14px 24px", s.boxSizing = "border-box", s.color = "#656A6B", overlay.appendChild(snackbar);
                  var snackbarText = document.createElement("div");
                  snackbarText.style.float = "left", snackbarText.innerHTML = "No Cardboard viewer?";
                  var snackbarButton = document.createElement("a");
                  snackbarButton.href = "https://www.google.com/get/cardboard/get-cardboard/", snackbarButton.innerHTML = "get one", snackbarButton.target = "_blank";
                  var s = snackbarButton.style;
                  s.float = "right", s.fontWeight = 600, s.textTransform = "uppercase", s.borderLeft = "1px solid gray", s.paddingLeft = "24px", s.textDecoration = "none", s.color = "#656A6B", snackbar.appendChild(snackbarText), snackbar.appendChild(snackbarButton), this.overlay = overlay, this.text = text, this.hide();
                }
                RotateInstructions.prototype.show = function(parent) {
                  !parent && !this.overlay.parentElement ? document.body.appendChild(this.overlay) : parent && (this.overlay.parentElement && this.overlay.parentElement != parent && this.overlay.parentElement.removeChild(this.overlay), parent.appendChild(this.overlay)), this.overlay.style.display = "block";
                  var img = this.overlay.querySelector("img"), s = img.style;
                  isLandscapeMode() ? (s.width = "20%", s.marginLeft = "40%", s.marginTop = "3%") : (s.width = "50%", s.marginLeft = "25%", s.marginTop = "25%");
                }, RotateInstructions.prototype.hide = function() {
                  this.overlay.style.display = "none";
                }, RotateInstructions.prototype.showTemporarily = function(ms, parent) {
                  this.show(parent), this.timer = setTimeout(this.hide.bind(this), ms);
                }, RotateInstructions.prototype.disableShowTemporarily = function() {
                  clearTimeout(this.timer);
                }, RotateInstructions.prototype.update = function() {
                  this.disableShowTemporarily(), !isLandscapeMode() && isMobile2() ? this.show() : this.hide();
                }, RotateInstructions.prototype.loadIcon_ = function() {
                  this.icon = dataUri("image/svg+xml", rotateInstructionsAsset);
                };
                var DEFAULT_VIEWER = "CardboardV1", VIEWER_KEY = "WEBVR_CARDBOARD_VIEWER", CLASS_NAME = "webvr-polyfill-viewer-selector";
                function ViewerSelector(defaultViewer) {
                  try {
                    this.selectedKey = localStorage.getItem(VIEWER_KEY);
                  } catch (error) {
                    console.error("Failed to load viewer profile: %s", error);
                  }
                  this.selectedKey || (this.selectedKey = defaultViewer || DEFAULT_VIEWER), this.dialog = this.createDialog_(DeviceInfo.Viewers), this.root = null, this.onChangeCallbacks_ = [];
                }
                ViewerSelector.prototype.show = function(root) {
                  this.root = root, root.appendChild(this.dialog);
                  var selected = this.dialog.querySelector("#" + this.selectedKey);
                  selected.checked = !0, this.dialog.style.display = "block";
                }, ViewerSelector.prototype.hide = function() {
                  this.root && this.root.contains(this.dialog) && this.root.removeChild(this.dialog), this.dialog.style.display = "none";
                }, ViewerSelector.prototype.getCurrentViewer = function() {
                  return DeviceInfo.Viewers[this.selectedKey];
                }, ViewerSelector.prototype.getSelectedKey_ = function() {
                  var input = this.dialog.querySelector("input[name=field]:checked");
                  return input ? input.id : null;
                }, ViewerSelector.prototype.onChange = function(cb) {
                  this.onChangeCallbacks_.push(cb);
                }, ViewerSelector.prototype.fireOnChange_ = function(viewer) {
                  for (var i = 0; i < this.onChangeCallbacks_.length; i++)
                    this.onChangeCallbacks_[i](viewer);
                }, ViewerSelector.prototype.onSave_ = function() {
                  if (this.selectedKey = this.getSelectedKey_(), !this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
                    console.error("ViewerSelector.onSave_: this should never happen!");
                    return;
                  }
                  this.fireOnChange_(DeviceInfo.Viewers[this.selectedKey]);
                  try {
                    localStorage.setItem(VIEWER_KEY, this.selectedKey);
                  } catch (error) {
                    console.error("Failed to save viewer profile: %s", error);
                  }
                  this.hide();
                }, ViewerSelector.prototype.createDialog_ = function(options) {
                  var container = document.createElement("div");
                  container.classList.add(CLASS_NAME), container.style.display = "none";
                  var overlay = document.createElement("div"), s = overlay.style;
                  s.position = "fixed", s.left = 0, s.top = 0, s.width = "100%", s.height = "100%", s.background = "rgba(0, 0, 0, 0.3)", overlay.addEventListener("click", this.hide.bind(this));
                  var width = 280, dialog = document.createElement("div"), s = dialog.style;
                  s.boxSizing = "border-box", s.position = "fixed", s.top = "24px", s.left = "50%", s.marginLeft = -width / 2 + "px", s.width = width + "px", s.padding = "24px", s.overflow = "hidden", s.background = "#fafafa", s.fontFamily = "'Roboto', sans-serif", s.boxShadow = "0px 5px 20px #666", dialog.appendChild(this.createH1_("Select your viewer"));
                  for (var id in options)
                    dialog.appendChild(this.createChoice_(id, options[id].label));
                  return dialog.appendChild(this.createButton_("Save", this.onSave_.bind(this))), container.appendChild(overlay), container.appendChild(dialog), container;
                }, ViewerSelector.prototype.createH1_ = function(name) {
                  var h1 = document.createElement("h1"), s = h1.style;
                  return s.color = "black", s.fontSize = "20px", s.fontWeight = "bold", s.marginTop = 0, s.marginBottom = "24px", h1.innerHTML = name, h1;
                }, ViewerSelector.prototype.createChoice_ = function(id, name) {
                  var div = document.createElement("div");
                  div.style.marginTop = "8px", div.style.color = "black";
                  var input = document.createElement("input");
                  input.style.fontSize = "30px", input.setAttribute("id", id), input.setAttribute("type", "radio"), input.setAttribute("value", id), input.setAttribute("name", "field");
                  var label = document.createElement("label");
                  return label.style.marginLeft = "4px", label.setAttribute("for", id), label.innerHTML = name, div.appendChild(input), div.appendChild(label), div;
                }, ViewerSelector.prototype.createButton_ = function(label, onclick) {
                  var button = document.createElement("button");
                  button.innerHTML = label;
                  var s = button.style;
                  return s.float = "right", s.textTransform = "uppercase", s.color = "#1094f7", s.fontSize = "14px", s.letterSpacing = 0, s.border = 0, s.background = "none", s.marginTop = "16px", button.addEventListener("click", onclick), button;
                };
                var commonjsGlobal$$1 = typeof window != "undefined" ? window : typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : {};
                function unwrapExports$$1(x) {
                  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
                }
                function createCommonjsModule$$1(fn, module5) {
                  return module5 = {
                    exports: {}
                  }, fn(module5, module5.exports), module5.exports;
                }
                var NoSleep = createCommonjsModule$$1(function(module5, exports3) {
                  (function(root, factory) {
                    module5.exports = factory();
                  })(commonjsGlobal$$1, function() {
                    return function(modules) {
                      var installedModules = {};
                      function __nested_webpack_require_167216__(moduleId) {
                        if (installedModules[moduleId])
                          return installedModules[moduleId].exports;
                        var module6 = installedModules[moduleId] = {
                          i: moduleId,
                          l: !1,
                          exports: {}
                        };
                        return modules[moduleId].call(module6.exports, module6, module6.exports, __nested_webpack_require_167216__), module6.l = !0, module6.exports;
                      }
                      return __nested_webpack_require_167216__.m = modules, __nested_webpack_require_167216__.c = installedModules, __nested_webpack_require_167216__.d = function(exports4, name, getter) {
                        __nested_webpack_require_167216__.o(exports4, name) || Object.defineProperty(exports4, name, {
                          configurable: !1,
                          enumerable: !0,
                          get: getter
                        });
                      }, __nested_webpack_require_167216__.n = function(module6) {
                        var getter = module6 && module6.__esModule ? function() {
                          return module6.default;
                        } : function() {
                          return module6;
                        };
                        return __nested_webpack_require_167216__.d(getter, "a", getter), getter;
                      }, __nested_webpack_require_167216__.o = function(object, property) {
                        return Object.prototype.hasOwnProperty.call(object, property);
                      }, __nested_webpack_require_167216__.p = "", __nested_webpack_require_167216__(__nested_webpack_require_167216__.s = 0);
                    }([function(module6, exports4, __nested_webpack_require_168841__) {
                      var _createClass = function() {
                        function defineProperties(target, props) {
                          for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                          }
                        }
                        return function(Constructor, protoProps, staticProps) {
                          return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
                        };
                      }();
                      function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor))
                          throw new TypeError("Cannot call a class as a function");
                      }
                      var mediaFile = __nested_webpack_require_168841__(1), oldIOS = typeof navigator != "undefined" && parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) < 10 && !window.MSStream, NoSleep2 = function() {
                        function NoSleep3() {
                          _classCallCheck(this, NoSleep3), oldIOS ? this.noSleepTimer = null : (this.noSleepVideo = document.createElement("video"), this.noSleepVideo.setAttribute("playsinline", ""), this.noSleepVideo.setAttribute("src", mediaFile), this.noSleepVideo.addEventListener("timeupdate", function(e) {
                            this.noSleepVideo.currentTime > 0.5 && (this.noSleepVideo.currentTime = Math.random());
                          }.bind(this)));
                        }
                        return _createClass(NoSleep3, [{
                          key: "enable",
                          value: function() {
                            oldIOS ? (this.disable(), this.noSleepTimer = window.setInterval(function() {
                              window.location.href = "/", window.setTimeout(window.stop, 0);
                            }, 15e3)) : this.noSleepVideo.play();
                          }
                        }, {
                          key: "disable",
                          value: function() {
                            oldIOS ? this.noSleepTimer && (window.clearInterval(this.noSleepTimer), this.noSleepTimer = null) : this.noSleepVideo.pause();
                          }
                        }]), NoSleep3;
                      }();
                      module6.exports = NoSleep2;
                    }, function(module6, exports4, __webpack_require__3) {
                      module6.exports = "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA=";
                    }]);
                  });
                }), NoSleep$1 = unwrapExports$$1(NoSleep), nextDisplayId = 1e3, defaultLeftBounds = [0, 0, 0.5, 1], defaultRightBounds = [0.5, 0, 0.5, 1], raf = window.requestAnimationFrame, caf = window.cancelAnimationFrame;
                function VRFrameData() {
                  this.leftProjectionMatrix = new Float32Array(16), this.leftViewMatrix = new Float32Array(16), this.rightProjectionMatrix = new Float32Array(16), this.rightViewMatrix = new Float32Array(16), this.pose = null;
                }
                function VRDisplayCapabilities(config2) {
                  Object.defineProperties(this, {
                    hasPosition: {
                      writable: !1,
                      enumerable: !0,
                      value: config2.hasPosition
                    },
                    hasExternalDisplay: {
                      writable: !1,
                      enumerable: !0,
                      value: config2.hasExternalDisplay
                    },
                    canPresent: {
                      writable: !1,
                      enumerable: !0,
                      value: config2.canPresent
                    },
                    maxLayers: {
                      writable: !1,
                      enumerable: !0,
                      value: config2.maxLayers
                    },
                    hasOrientation: {
                      enumerable: !0,
                      get: function() {
                        return deprecateWarning("VRDisplayCapabilities.prototype.hasOrientation", "VRDisplay.prototype.getFrameData"), config2.hasOrientation;
                      }
                    }
                  });
                }
                function VRDisplay(config2) {
                  config2 = config2 || {};
                  var USE_WAKELOCK = "wakelock" in config2 ? config2.wakelock : !0;
                  this.isPolyfilled = !0, this.displayId = nextDisplayId++, this.displayName = "", this.depthNear = 0.01, this.depthFar = 1e4, this.isPresenting = !1, Object.defineProperty(this, "isConnected", {
                    get: function() {
                      return deprecateWarning("VRDisplay.prototype.isConnected", "VRDisplayCapabilities.prototype.hasExternalDisplay"), !1;
                    }
                  }), this.capabilities = new VRDisplayCapabilities({
                    hasPosition: !1,
                    hasOrientation: !1,
                    hasExternalDisplay: !1,
                    canPresent: !1,
                    maxLayers: 1
                  }), this.stageParameters = null, this.waitingForPresent_ = !1, this.layer_ = null, this.originalParent_ = null, this.fullscreenElement_ = null, this.fullscreenWrapper_ = null, this.fullscreenElementCachedStyle_ = null, this.fullscreenEventTarget_ = null, this.fullscreenChangeHandler_ = null, this.fullscreenErrorHandler_ = null, USE_WAKELOCK && isMobile2() && (this.wakelock_ = new NoSleep$1());
                }
                VRDisplay.prototype.getFrameData = function(frameData) {
                  return frameDataFromPose(frameData, this._getPose(), this);
                }, VRDisplay.prototype.getPose = function() {
                  return deprecateWarning("VRDisplay.prototype.getPose", "VRDisplay.prototype.getFrameData"), this._getPose();
                }, VRDisplay.prototype.resetPose = function() {
                  return deprecateWarning("VRDisplay.prototype.resetPose"), this._resetPose();
                }, VRDisplay.prototype.getImmediatePose = function() {
                  return deprecateWarning("VRDisplay.prototype.getImmediatePose", "VRDisplay.prototype.getFrameData"), this._getPose();
                }, VRDisplay.prototype.requestAnimationFrame = function(callback) {
                  return raf(callback);
                }, VRDisplay.prototype.cancelAnimationFrame = function(id) {
                  return caf(id);
                }, VRDisplay.prototype.wrapForFullscreen = function(element) {
                  if (isIOS())
                    return element;
                  if (!this.fullscreenWrapper_) {
                    this.fullscreenWrapper_ = document.createElement("div");
                    var cssProperties = ["height: " + Math.min(screen.height, screen.width) + "px !important", "top: 0 !important", "left: 0 !important", "right: 0 !important", "border: 0", "margin: 0", "padding: 0", "z-index: 999999 !important", "position: fixed"];
                    this.fullscreenWrapper_.setAttribute("style", cssProperties.join("; ") + ";"), this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper");
                  }
                  if (this.fullscreenElement_ == element)
                    return this.fullscreenWrapper_;
                  if (this.fullscreenElement_ && (this.originalParent_ ? this.originalParent_.appendChild(this.fullscreenElement_) : this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_)), this.fullscreenElement_ = element, this.originalParent_ = element.parentElement, this.originalParent_ || document.body.appendChild(element), !this.fullscreenWrapper_.parentElement) {
                    var parent = this.fullscreenElement_.parentElement;
                    parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_), parent.removeChild(this.fullscreenElement_);
                  }
                  this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild), this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute("style");
                  var self2 = this;
                  function applyFullscreenElementStyle() {
                    if (!!self2.fullscreenElement_) {
                      var cssProperties2 = ["position: absolute", "top: 0", "left: 0", "width: " + Math.max(screen.width, screen.height) + "px", "height: " + Math.min(screen.height, screen.width) + "px", "border: 0", "margin: 0", "padding: 0"];
                      self2.fullscreenElement_.setAttribute("style", cssProperties2.join("; ") + ";");
                    }
                  }
                  return applyFullscreenElementStyle(), this.fullscreenWrapper_;
                }, VRDisplay.prototype.removeFullscreenWrapper = function() {
                  if (!!this.fullscreenElement_) {
                    var element = this.fullscreenElement_;
                    this.fullscreenElementCachedStyle_ ? element.setAttribute("style", this.fullscreenElementCachedStyle_) : element.removeAttribute("style"), this.fullscreenElement_ = null, this.fullscreenElementCachedStyle_ = null;
                    var parent = this.fullscreenWrapper_.parentElement;
                    return this.fullscreenWrapper_.removeChild(element), this.originalParent_ === parent ? parent.insertBefore(element, this.fullscreenWrapper_) : this.originalParent_ && this.originalParent_.appendChild(element), parent.removeChild(this.fullscreenWrapper_), element;
                  }
                }, VRDisplay.prototype.requestPresent = function(layers) {
                  var wasPresenting = this.isPresenting, self2 = this;
                  return layers instanceof Array || (deprecateWarning("VRDisplay.prototype.requestPresent with non-array argument", "an array of VRLayers as the first argument"), layers = [layers]), new Promise(function(resolve, reject) {
                    if (!self2.capabilities.canPresent) {
                      reject(new Error("VRDisplay is not capable of presenting."));
                      return;
                    }
                    if (layers.length == 0 || layers.length > self2.capabilities.maxLayers) {
                      reject(new Error("Invalid number of layers."));
                      return;
                    }
                    var incomingLayer = layers[0];
                    if (!incomingLayer.source) {
                      resolve();
                      return;
                    }
                    var leftBounds = incomingLayer.leftBounds || defaultLeftBounds, rightBounds = incomingLayer.rightBounds || defaultRightBounds;
                    if (wasPresenting) {
                      var layer = self2.layer_;
                      layer.source !== incomingLayer.source && (layer.source = incomingLayer.source);
                      for (var i = 0; i < 4; i++)
                        layer.leftBounds[i] = leftBounds[i], layer.rightBounds[i] = rightBounds[i];
                      self2.wrapForFullscreen(self2.layer_.source), self2.updatePresent_(), resolve();
                      return;
                    }
                    if (self2.layer_ = {
                      predistorted: incomingLayer.predistorted,
                      source: incomingLayer.source,
                      leftBounds: leftBounds.slice(0),
                      rightBounds: rightBounds.slice(0)
                    }, self2.waitingForPresent_ = !1, self2.layer_ && self2.layer_.source) {
                      var fullscreenElement = self2.wrapForFullscreen(self2.layer_.source), onFullscreenChange = function() {
                        var actualFullscreenElement = getFullscreenElement();
                        self2.isPresenting = fullscreenElement === actualFullscreenElement, self2.isPresenting ? (screen.orientation && screen.orientation.lock && screen.orientation.lock("landscape-primary").catch(function(error) {
                          console.error("screen.orientation.lock() failed due to", error.message);
                        }), self2.waitingForPresent_ = !1, self2.beginPresent_(), resolve()) : (screen.orientation && screen.orientation.unlock && screen.orientation.unlock(), self2.removeFullscreenWrapper(), self2.disableWakeLock(), self2.endPresent_(), self2.removeFullscreenListeners_()), self2.fireVRDisplayPresentChange_();
                      }, onFullscreenError = function() {
                        !self2.waitingForPresent_ || (self2.removeFullscreenWrapper(), self2.removeFullscreenListeners_(), self2.disableWakeLock(), self2.waitingForPresent_ = !1, self2.isPresenting = !1, reject(new Error("Unable to present.")));
                      };
                      self2.addFullscreenListeners_(fullscreenElement, onFullscreenChange, onFullscreenError), requestFullscreen(fullscreenElement) ? (self2.enableWakeLock(), self2.waitingForPresent_ = !0) : (isIOS() || isWebViewAndroid()) && (self2.enableWakeLock(), self2.isPresenting = !0, self2.beginPresent_(), self2.fireVRDisplayPresentChange_(), resolve());
                    }
                    !self2.waitingForPresent_ && !isIOS() && (exitFullscreen(), reject(new Error("Unable to present.")));
                  });
                }, VRDisplay.prototype.exitPresent = function() {
                  var wasPresenting = this.isPresenting, self2 = this;
                  return this.isPresenting = !1, this.layer_ = null, this.disableWakeLock(), new Promise(function(resolve, reject) {
                    wasPresenting ? (!exitFullscreen() && isIOS() && (self2.endPresent_(), self2.fireVRDisplayPresentChange_()), isWebViewAndroid() && (self2.removeFullscreenWrapper(), self2.removeFullscreenListeners_(), self2.endPresent_(), self2.fireVRDisplayPresentChange_()), resolve()) : reject(new Error("Was not presenting to VRDisplay."));
                  });
                }, VRDisplay.prototype.getLayers = function() {
                  return this.layer_ ? [this.layer_] : [];
                }, VRDisplay.prototype.fireVRDisplayPresentChange_ = function() {
                  var event = new CustomEvent("vrdisplaypresentchange", {
                    detail: {
                      display: this
                    }
                  });
                  window.dispatchEvent(event);
                }, VRDisplay.prototype.fireVRDisplayConnect_ = function() {
                  var event = new CustomEvent("vrdisplayconnect", {
                    detail: {
                      display: this
                    }
                  });
                  window.dispatchEvent(event);
                }, VRDisplay.prototype.addFullscreenListeners_ = function(element, changeHandler, errorHandler) {
                  this.removeFullscreenListeners_(), this.fullscreenEventTarget_ = element, this.fullscreenChangeHandler_ = changeHandler, this.fullscreenErrorHandler_ = errorHandler, changeHandler && (document.fullscreenEnabled ? element.addEventListener("fullscreenchange", changeHandler, !1) : document.webkitFullscreenEnabled ? element.addEventListener("webkitfullscreenchange", changeHandler, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenchange", changeHandler, !1) : document.msFullscreenEnabled && element.addEventListener("msfullscreenchange", changeHandler, !1)), errorHandler && (document.fullscreenEnabled ? element.addEventListener("fullscreenerror", errorHandler, !1) : document.webkitFullscreenEnabled ? element.addEventListener("webkitfullscreenerror", errorHandler, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenerror", errorHandler, !1) : document.msFullscreenEnabled && element.addEventListener("msfullscreenerror", errorHandler, !1));
                }, VRDisplay.prototype.removeFullscreenListeners_ = function() {
                  if (!!this.fullscreenEventTarget_) {
                    var element = this.fullscreenEventTarget_;
                    if (this.fullscreenChangeHandler_) {
                      var changeHandler = this.fullscreenChangeHandler_;
                      element.removeEventListener("fullscreenchange", changeHandler, !1), element.removeEventListener("webkitfullscreenchange", changeHandler, !1), document.removeEventListener("mozfullscreenchange", changeHandler, !1), element.removeEventListener("msfullscreenchange", changeHandler, !1);
                    }
                    if (this.fullscreenErrorHandler_) {
                      var errorHandler = this.fullscreenErrorHandler_;
                      element.removeEventListener("fullscreenerror", errorHandler, !1), element.removeEventListener("webkitfullscreenerror", errorHandler, !1), document.removeEventListener("mozfullscreenerror", errorHandler, !1), element.removeEventListener("msfullscreenerror", errorHandler, !1);
                    }
                    this.fullscreenEventTarget_ = null, this.fullscreenChangeHandler_ = null, this.fullscreenErrorHandler_ = null;
                  }
                }, VRDisplay.prototype.enableWakeLock = function() {
                  this.wakelock_ && this.wakelock_.enable();
                }, VRDisplay.prototype.disableWakeLock = function() {
                  this.wakelock_ && this.wakelock_.disable();
                }, VRDisplay.prototype.beginPresent_ = function() {
                }, VRDisplay.prototype.endPresent_ = function() {
                }, VRDisplay.prototype.submitFrame = function(pose) {
                }, VRDisplay.prototype.getEyeParameters = function(whichEye) {
                  return null;
                };
                var config = {
                  ADDITIONAL_VIEWERS: [],
                  DEFAULT_VIEWER: "",
                  MOBILE_WAKE_LOCK: !0,
                  DEBUG: !1,
                  DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
                  K_FILTER: 0.98,
                  PREDICTION_TIME_S: 0.04,
                  CARDBOARD_UI_DISABLED: !1,
                  ROTATE_INSTRUCTIONS_DISABLED: !1,
                  YAW_ONLY: !1,
                  BUFFER_SCALE: 0.5,
                  DIRTY_SUBMIT_FRAME_BINDINGS: !1
                }, Eye = {
                  LEFT: "left",
                  RIGHT: "right"
                };
                function CardboardVRDisplay2(config$$1) {
                  var defaults = extend2({}, config);
                  config$$1 = extend2(defaults, config$$1 || {}), VRDisplay.call(this, {
                    wakelock: config$$1.MOBILE_WAKE_LOCK
                  }), this.config = config$$1, this.displayName = "Cardboard VRDisplay", this.capabilities = new VRDisplayCapabilities({
                    hasPosition: !1,
                    hasOrientation: !0,
                    hasExternalDisplay: !1,
                    canPresent: !0,
                    maxLayers: 1
                  }), this.stageParameters = null, this.bufferScale_ = this.config.BUFFER_SCALE, this.poseSensor_ = new PoseSensor(this.config), this.distorter_ = null, this.cardboardUI_ = null, this.dpdb_ = new Dpdb(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this)), this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams(), config$$1.ADDITIONAL_VIEWERS), this.viewerSelector_ = new ViewerSelector(config$$1.DEFAULT_VIEWER), this.viewerSelector_.onChange(this.onViewerChanged_.bind(this)), this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer()), this.config.ROTATE_INSTRUCTIONS_DISABLED || (this.rotateInstructions_ = new RotateInstructions()), isIOS() && window.addEventListener("resize", this.onResize_.bind(this));
                }
                return CardboardVRDisplay2.prototype = Object.create(VRDisplay.prototype), CardboardVRDisplay2.prototype._getPose = function() {
                  return {
                    position: null,
                    orientation: this.poseSensor_.getOrientation(),
                    linearVelocity: null,
                    linearAcceleration: null,
                    angularVelocity: null,
                    angularAcceleration: null
                  };
                }, CardboardVRDisplay2.prototype._resetPose = function() {
                  this.poseSensor_.resetPose && this.poseSensor_.resetPose();
                }, CardboardVRDisplay2.prototype._getFieldOfView = function(whichEye) {
                  var fieldOfView;
                  if (whichEye == Eye.LEFT)
                    fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
                  else if (whichEye == Eye.RIGHT)
                    fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
                  else
                    return console.error("Invalid eye provided: %s", whichEye), null;
                  return fieldOfView;
                }, CardboardVRDisplay2.prototype._getEyeOffset = function(whichEye) {
                  var offset;
                  if (whichEye == Eye.LEFT)
                    offset = [-this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
                  else if (whichEye == Eye.RIGHT)
                    offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
                  else
                    return console.error("Invalid eye provided: %s", whichEye), null;
                  return offset;
                }, CardboardVRDisplay2.prototype.getEyeParameters = function(whichEye) {
                  var offset = this._getEyeOffset(whichEye), fieldOfView = this._getFieldOfView(whichEye), eyeParams = {
                    offset,
                    renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
                    renderHeight: this.deviceInfo_.device.height * this.bufferScale_
                  };
                  return Object.defineProperty(eyeParams, "fieldOfView", {
                    enumerable: !0,
                    get: function() {
                      return deprecateWarning("VRFieldOfView", "VRFrameData's projection matrices"), fieldOfView;
                    }
                  }), eyeParams;
                }, CardboardVRDisplay2.prototype.onDeviceParamsUpdated_ = function(newParams) {
                  this.config.DEBUG && console.log("DPDB reported that device params were updated."), this.deviceInfo_.updateDeviceParams(newParams), this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_);
                }, CardboardVRDisplay2.prototype.updateBounds_ = function() {
                  this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds) && this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
                }, CardboardVRDisplay2.prototype.beginPresent_ = function() {
                  var gl = this.layer_.source.getContext("webgl");
                  gl || (gl = this.layer_.source.getContext("experimental-webgl")), gl || (gl = this.layer_.source.getContext("webgl2")), !!gl && (this.layer_.predistorted ? this.config.CARDBOARD_UI_DISABLED || (gl.canvas.width = getScreenWidth() * this.bufferScale_, gl.canvas.height = getScreenHeight() * this.bufferScale_, this.cardboardUI_ = new CardboardUI(gl)) : (this.config.CARDBOARD_UI_DISABLED || (this.cardboardUI_ = new CardboardUI(gl)), this.distorter_ = new CardboardDistorter(gl, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS), this.distorter_.updateDeviceInfo(this.deviceInfo_)), this.cardboardUI_ && this.cardboardUI_.listen(function(e) {
                    this.viewerSelector_.show(this.layer_.source.parentElement), e.stopPropagation(), e.preventDefault();
                  }.bind(this), function(e) {
                    this.exitPresent(), e.stopPropagation(), e.preventDefault();
                  }.bind(this)), this.rotateInstructions_ && (isLandscapeMode() && isMobile2() ? this.rotateInstructions_.showTemporarily(3e3, this.layer_.source.parentElement) : this.rotateInstructions_.update()), this.orientationHandler = this.onOrientationChange_.bind(this), window.addEventListener("orientationchange", this.orientationHandler), this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this), window.addEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler), this.fireVRDisplayDeviceParamsChange_());
                }, CardboardVRDisplay2.prototype.endPresent_ = function() {
                  this.distorter_ && (this.distorter_.destroy(), this.distorter_ = null), this.cardboardUI_ && (this.cardboardUI_.destroy(), this.cardboardUI_ = null), this.rotateInstructions_ && this.rotateInstructions_.hide(), this.viewerSelector_.hide(), window.removeEventListener("orientationchange", this.orientationHandler), window.removeEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
                }, CardboardVRDisplay2.prototype.updatePresent_ = function() {
                  this.endPresent_(), this.beginPresent_();
                }, CardboardVRDisplay2.prototype.submitFrame = function(pose) {
                  if (this.distorter_)
                    this.updateBounds_(), this.distorter_.submitFrame();
                  else if (this.cardboardUI_ && this.layer_) {
                    var gl = this.layer_.source.getContext("webgl");
                    gl || (gl = this.layer_.source.getContext("experimental-webgl")), gl || (gl = this.layer_.source.getContext("webgl2"));
                    var canvas = gl.canvas;
                    (canvas.width != this.lastWidth || canvas.height != this.lastHeight) && this.cardboardUI_.onResize(), this.lastWidth = canvas.width, this.lastHeight = canvas.height, this.cardboardUI_.render();
                  }
                }, CardboardVRDisplay2.prototype.onOrientationChange_ = function(e) {
                  this.viewerSelector_.hide(), this.rotateInstructions_ && this.rotateInstructions_.update(), this.onResize_();
                }, CardboardVRDisplay2.prototype.onResize_ = function(e) {
                  if (this.layer_) {
                    var gl = this.layer_.source.getContext("webgl");
                    gl || (gl = this.layer_.source.getContext("experimental-webgl")), gl || (gl = this.layer_.source.getContext("webgl2"));
                    var cssProperties = ["position: absolute", "top: 0", "left: 0", "width: 100vw", "height: 100vh", "border: 0", "margin: 0", "padding: 0px", "box-sizing: content-box"];
                    gl.canvas.setAttribute("style", cssProperties.join("; ") + ";"), safariCssSizeWorkaround(gl.canvas);
                  }
                }, CardboardVRDisplay2.prototype.onViewerChanged_ = function(viewer) {
                  this.deviceInfo_.setViewer(viewer), this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_), this.fireVRDisplayDeviceParamsChange_();
                }, CardboardVRDisplay2.prototype.fireVRDisplayDeviceParamsChange_ = function() {
                  var event = new CustomEvent("vrdisplaydeviceparamschange", {
                    detail: {
                      vrdisplay: this,
                      deviceInfo: this.deviceInfo_
                    }
                  });
                  window.dispatchEvent(event);
                }, CardboardVRDisplay2.VRFrameData = VRFrameData, CardboardVRDisplay2.VRDisplay = VRDisplay, CardboardVRDisplay2;
              });
            }), CardboardVRDisplay = unwrapExports(cardboardVrDisplay), version = "0.10.12", DefaultConfig = {
              ADDITIONAL_VIEWERS: [],
              DEFAULT_VIEWER: "",
              PROVIDE_MOBILE_VRDISPLAY: !0,
              MOBILE_WAKE_LOCK: !0,
              DEBUG: !1,
              DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
              K_FILTER: 0.98,
              PREDICTION_TIME_S: 0.04,
              CARDBOARD_UI_DISABLED: !1,
              ROTATE_INSTRUCTIONS_DISABLED: !1,
              YAW_ONLY: !1,
              BUFFER_SCALE: 0.5,
              DIRTY_SUBMIT_FRAME_BINDINGS: !1
            };
            function WebVRPolyfill(config) {
              this.config = extend(extend({}, DefaultConfig), config), this.polyfillDisplays = [], this.enabled = !1, this.hasNative = "getVRDisplays" in navigator, this.native = {}, this.native.getVRDisplays = navigator.getVRDisplays, this.native.VRFrameData = window.VRFrameData, this.native.VRDisplay = window.VRDisplay, (!this.hasNative || this.config.PROVIDE_MOBILE_VRDISPLAY && isMobile()) && (this.enable(), this.getVRDisplays().then(function(displays) {
                displays && displays[0] && displays[0].fireVRDisplayConnect_ && displays[0].fireVRDisplayConnect_();
              }));
            }
            WebVRPolyfill.prototype.getPolyfillDisplays = function() {
              if (this._polyfillDisplaysPopulated)
                return this.polyfillDisplays;
              if (isMobile()) {
                var vrDisplay = new CardboardVRDisplay({
                  ADDITIONAL_VIEWERS: this.config.ADDITIONAL_VIEWERS,
                  DEFAULT_VIEWER: this.config.DEFAULT_VIEWER,
                  MOBILE_WAKE_LOCK: this.config.MOBILE_WAKE_LOCK,
                  DEBUG: this.config.DEBUG,
                  DPDB_URL: this.config.DPDB_URL,
                  CARDBOARD_UI_DISABLED: this.config.CARDBOARD_UI_DISABLED,
                  K_FILTER: this.config.K_FILTER,
                  PREDICTION_TIME_S: this.config.PREDICTION_TIME_S,
                  ROTATE_INSTRUCTIONS_DISABLED: this.config.ROTATE_INSTRUCTIONS_DISABLED,
                  YAW_ONLY: this.config.YAW_ONLY,
                  BUFFER_SCALE: this.config.BUFFER_SCALE,
                  DIRTY_SUBMIT_FRAME_BINDINGS: this.config.DIRTY_SUBMIT_FRAME_BINDINGS
                });
                this.polyfillDisplays.push(vrDisplay);
              }
              return this._polyfillDisplaysPopulated = !0, this.polyfillDisplays;
            }, WebVRPolyfill.prototype.enable = function() {
              if (this.enabled = !0, this.hasNative && this.native.VRFrameData) {
                var NativeVRFrameData = this.native.VRFrameData, nativeFrameData = new this.native.VRFrameData(), nativeGetFrameData = this.native.VRDisplay.prototype.getFrameData;
                window.VRDisplay.prototype.getFrameData = function(frameData) {
                  if (frameData instanceof NativeVRFrameData) {
                    nativeGetFrameData.call(this, frameData);
                    return;
                  }
                  nativeGetFrameData.call(this, nativeFrameData), frameData.pose = nativeFrameData.pose, copyArray(nativeFrameData.leftProjectionMatrix, frameData.leftProjectionMatrix), copyArray(nativeFrameData.rightProjectionMatrix, frameData.rightProjectionMatrix), copyArray(nativeFrameData.leftViewMatrix, frameData.leftViewMatrix), copyArray(nativeFrameData.rightViewMatrix, frameData.rightViewMatrix);
                };
              }
              navigator.getVRDisplays = this.getVRDisplays.bind(this), window.VRDisplay = CardboardVRDisplay.VRDisplay, window.VRFrameData = CardboardVRDisplay.VRFrameData;
            }, WebVRPolyfill.prototype.getVRDisplays = function() {
              var _this = this, config = this.config;
              return this.hasNative ? this.native.getVRDisplays.call(navigator).then(function(nativeDisplays) {
                return nativeDisplays.length > 0 ? nativeDisplays : _this.getPolyfillDisplays();
              }) : Promise.resolve(this.getPolyfillDisplays());
            }, WebVRPolyfill.version = version, WebVRPolyfill.VRFrameData = CardboardVRDisplay.VRFrameData, WebVRPolyfill.VRDisplay = CardboardVRDisplay.VRDisplay;
            var webvrPolyfill = Object.freeze({
              default: WebVRPolyfill
            }), require$$0 = webvrPolyfill && WebVRPolyfill || webvrPolyfill;
            typeof commonjsGlobal != "undefined" && commonjsGlobal.window && (commonjsGlobal.document || (commonjsGlobal.document = commonjsGlobal.window.document), commonjsGlobal.navigator || (commonjsGlobal.navigator = commonjsGlobal.window.navigator));
            var src = require$$0;
            return src;
          });
        },
        "./node_modules/word-wrapper/index.js": (module3) => {
          var newline = /\n/, newlineChar = `
`, whitespace = /\s/;
          module3.exports = function(text, opt) {
            var lines = module3.exports.lines(text, opt);
            return lines.map(function(line) {
              return text.substring(line.start, line.end);
            }).join(`
`);
          }, module3.exports.lines = function(text, opt) {
            if (opt = opt || {}, opt.width === 0 && opt.mode !== "nowrap")
              return [];
            text = text || "";
            var width = typeof opt.width == "number" ? opt.width : Number.MAX_VALUE, start = Math.max(0, opt.start || 0), end = typeof opt.end == "number" ? opt.end : text.length, mode = opt.mode, measure = opt.measure || monospace;
            return mode === "pre" ? pre(measure, text, start, end, width) : greedy(measure, text, start, end, width, mode);
          };
          function idxOf(text, chr, start, end) {
            var idx = text.indexOf(chr, start);
            return idx === -1 || idx > end ? end : idx;
          }
          function isWhitespace(chr) {
            return whitespace.test(chr);
          }
          function pre(measure, text, start, end, width) {
            for (var lines = [], lineStart = start, i = start; i < end && i < text.length; i++) {
              var chr = text.charAt(i), isNewline = newline.test(chr);
              if (isNewline || i === end - 1) {
                var lineEnd = isNewline ? i : i + 1, measured = measure(text, lineStart, lineEnd, width);
                lines.push(measured), lineStart = i + 1;
              }
            }
            return lines;
          }
          function greedy(measure, text, start, end, width, mode) {
            var lines = [], testWidth = width;
            for (mode === "nowrap" && (testWidth = Number.MAX_VALUE); start < end && start < text.length; ) {
              for (var newLine = idxOf(text, newlineChar, start, end); start < newLine && isWhitespace(text.charAt(start)); )
                start++;
              var measured = measure(text, start, newLine, testWidth), lineEnd = start + (measured.end - measured.start), nextStart = lineEnd + newlineChar.length;
              if (lineEnd < newLine) {
                for (; lineEnd > start && !isWhitespace(text.charAt(lineEnd)); )
                  lineEnd--;
                if (lineEnd === start)
                  nextStart > start + newlineChar.length && nextStart--, lineEnd = nextStart;
                else
                  for (nextStart = lineEnd; lineEnd > start && isWhitespace(text.charAt(lineEnd - newlineChar.length)); )
                    lineEnd--;
              }
              if (lineEnd >= start) {
                var result = measure(text, start, lineEnd, testWidth);
                lines.push(result);
              }
              start = nextStart;
            }
            return lines;
          }
          function monospace(text, start, end, width) {
            var glyphs = Math.min(width, end - start);
            return {
              start,
              end: start + glyphs
            };
          }
        },
        "./node_modules/xhr/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          "use strict";
          var window2 = __webpack_require__2("./node_modules/global/window.js"), isFunction = __webpack_require__2("./node_modules/is-function/index.js"), parseHeaders = __webpack_require__2("./node_modules/parse-headers/parse-headers.js"), xtend = __webpack_require__2("./node_modules/xtend/immutable.js");
          module3.exports = createXHR, module3.exports.default = createXHR, createXHR.XMLHttpRequest = window2.XMLHttpRequest || noop, createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window2.XDomainRequest, forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
            createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
              return options = initParams(uri, options, callback), options.method = method.toUpperCase(), _createXHR(options);
            };
          });
          function forEachArray(array, iterator) {
            for (var i = 0; i < array.length; i++)
              iterator(array[i]);
          }
          function isEmpty(obj) {
            for (var i in obj)
              if (obj.hasOwnProperty(i))
                return !1;
            return !0;
          }
          function initParams(uri, options, callback) {
            var params = uri;
            return isFunction(options) ? (callback = options, typeof uri == "string" && (params = {
              uri
            })) : params = xtend(options, {
              uri
            }), params.callback = callback, params;
          }
          function createXHR(uri, options, callback) {
            return options = initParams(uri, options, callback), _createXHR(options);
          }
          function _createXHR(options) {
            if (typeof options.callback == "undefined")
              throw new Error("callback argument missing");
            var called = !1, callback = function(err, response, body2) {
              called || (called = !0, options.callback(err, response, body2));
            };
            function readystatechange() {
              xhr.readyState === 4 && setTimeout(loadFunc, 0);
            }
            function getBody() {
              var body2 = void 0;
              if (xhr.response ? body2 = xhr.response : body2 = xhr.responseText || getXml(xhr), isJson)
                try {
                  body2 = JSON.parse(body2);
                } catch (e) {
                }
              return body2;
            }
            function errorFunc(evt) {
              return clearTimeout(timeoutTimer), evt instanceof Error || (evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"))), evt.statusCode = 0, callback(evt, failureResponse);
            }
            function loadFunc() {
              if (!aborted) {
                var status;
                clearTimeout(timeoutTimer), options.useXDR && xhr.status === void 0 ? status = 200 : status = xhr.status === 1223 ? 204 : xhr.status;
                var response = failureResponse, err = null;
                return status !== 0 ? (response = {
                  body: getBody(),
                  statusCode: status,
                  method,
                  headers: {},
                  url: uri,
                  rawRequest: xhr
                }, xhr.getAllResponseHeaders && (response.headers = parseHeaders(xhr.getAllResponseHeaders()))) : err = new Error("Internal XMLHttpRequest Error"), callback(err, response, response.body);
              }
            }
            var xhr = options.xhr || null;
            xhr || (options.cors || options.useXDR ? xhr = new createXHR.XDomainRequest() : xhr = new createXHR.XMLHttpRequest());
            var key, aborted, uri = xhr.url = options.uri || options.url, method = xhr.method = options.method || "GET", body = options.body || options.data, headers = xhr.headers = options.headers || {}, sync = !!options.sync, isJson = !1, timeoutTimer, failureResponse = {
              body: void 0,
              headers: {},
              statusCode: 0,
              method,
              url: uri,
              rawRequest: xhr
            };
            if ("json" in options && options.json !== !1 && (isJson = !0, headers.accept || headers.Accept || (headers.Accept = "application/json"), method !== "GET" && method !== "HEAD" && (headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"), body = JSON.stringify(options.json === !0 ? body : options.json))), xhr.onreadystatechange = readystatechange, xhr.onload = loadFunc, xhr.onerror = errorFunc, xhr.onprogress = function() {
            }, xhr.onabort = function() {
              aborted = !0;
            }, xhr.ontimeout = errorFunc, xhr.open(method, uri, !sync, options.username, options.password), sync || (xhr.withCredentials = !!options.withCredentials), !sync && options.timeout > 0 && (timeoutTimer = setTimeout(function() {
              if (!aborted) {
                aborted = !0, xhr.abort("timeout");
                var e = new Error("XMLHttpRequest timeout");
                e.code = "ETIMEDOUT", errorFunc(e);
              }
            }, options.timeout)), xhr.setRequestHeader)
              for (key in headers)
                headers.hasOwnProperty(key) && xhr.setRequestHeader(key, headers[key]);
            else if (options.headers && !isEmpty(options.headers))
              throw new Error("Headers cannot be set on an XDomainRequest object");
            return "responseType" in options && (xhr.responseType = options.responseType), "beforeSend" in options && typeof options.beforeSend == "function" && options.beforeSend(xhr), xhr.send(body || null), xhr;
          }
          function getXml(xhr) {
            try {
              if (xhr.responseType === "document")
                return xhr.responseXML;
              var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
              if (xhr.responseType === "" && !firefoxBugTakenEffect)
                return xhr.responseXML;
            } catch (e) {
            }
            return null;
          }
          function noop() {
          }
        },
        "./node_modules/xml-parse-from-string/index.js": (module3) => {
          module3.exports = function() {
            return typeof self.DOMParser != "undefined" ? function(str) {
              var parser = new self.DOMParser();
              return parser.parseFromString(str, "application/xml");
            } : typeof self.ActiveXObject != "undefined" && new self.ActiveXObject("Microsoft.XMLDOM") ? function(str) {
              var xmlDoc = new self.ActiveXObject("Microsoft.XMLDOM");
              return xmlDoc.async = "false", xmlDoc.loadXML(str), xmlDoc;
            } : function(str) {
              var div = document.createElement("div");
              return div.innerHTML = str, div;
            };
          }();
        },
        "./node_modules/xtend/immutable.js": (module3) => {
          module3.exports = extend;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function extend() {
            for (var target = {}, i = 0; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source)
                hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
          }
        },
        "./src/components/anchored.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, utils = __webpack_require__2("./src/utils/index.js"), warn = utils.debug("components:anchored:warn");
          module3.exports.Component = registerComponent("anchored", {
            schema: {
              persistent: {
                default: !1
              }
            },
            init: function() {
              var sceneEl = this.el.sceneEl, webxrData = sceneEl.getAttribute("webxr"), optionalFeaturesArray = webxrData.optionalFeatures;
              optionalFeaturesArray.indexOf("anchors") === -1 && (optionalFeaturesArray.push("anchors"), this.el.sceneEl.setAttribute("webxr", webxrData)), this.auxQuaternion = new THREE.Quaternion(), this.onEnterVR = this.onEnterVR.bind(this), this.el.sceneEl.addEventListener("enter-vr", this.onEnterVR);
            },
            onEnterVR: function() {
              this.anchor = void 0, this.requestPersistentAnchorPending = this.data.persistent, this.requestAnchorPending = !this.data.persistent;
            },
            tick: function() {
              var sceneEl = this.el.sceneEl, xrManager = sceneEl.renderer.xr, frame, refSpace, pose, object3D = this.el.object3D;
              !sceneEl.is("ar-mode") && !sceneEl.is("vr-mode") || (!this.anchor && this.requestPersistentAnchorPending && this.restorePersistentAnchor(), !this.anchor && this.requestAnchorPending && this.createAnchor(), !!this.anchor && (frame = sceneEl.frame, refSpace = xrManager.getReferenceSpace(), pose = frame.getPose(this.anchor.anchorSpace, refSpace), object3D.matrix.elements = pose.transform.matrix, object3D.matrix.decompose(object3D.position, object3D.rotation, object3D.scale)));
            },
            createAnchor: async function(position, quaternion) {
              var sceneEl = this.el.sceneEl, xrManager = sceneEl.renderer.xr, frame, referenceSpace, anchorPose, anchor, object3D = this.el.object3D;
              if (position = position || object3D.position, quaternion = quaternion || this.auxQuaternion.setFromEuler(object3D.rotation), !anchorsSupported(sceneEl)) {
                warn("This browser doesn't support the WebXR anchors module");
                return;
              }
              this.anchor && this.deleteAnchor(), frame = sceneEl.frame, referenceSpace = xrManager.getReferenceSpace(), anchorPose = new XRRigidTransform({
                x: position.x,
                y: position.y,
                z: position.z
              }, {
                x: quaternion.x,
                y: quaternion.y,
                z: quaternion.z,
                w: quaternion.w
              }), this.requestAnchorPending = !1, anchor = await frame.createAnchor(anchorPose, referenceSpace), this.data.persistent && (this.el.id ? (this.persistentHandle = await anchor.requestPersistentHandle(), localStorage.setItem(this.el.id, this.persistentHandle)) : warn("The anchor won't be persisted because the entity has no assigned id.")), sceneEl.object3D.attach(this.el.object3D), this.anchor = anchor;
            },
            restorePersistentAnchor: async function() {
              var xrManager = this.el.sceneEl.renderer.xr, session = xrManager.getSession(), persistentAnchors = session.persistentAnchors, storedPersistentHandle;
              if (this.requestPersistentAnchorPending = !1, !this.el.id) {
                warn("The entity associated to the persistent anchor cannot be retrieved because it doesn't have an assigned id."), this.requestAnchorPending = !0;
                return;
              }
              if (persistentAnchors) {
                storedPersistentHandle = localStorage.getItem(this.el.id);
                for (var i = 0; i < persistentAnchors.length; ++i)
                  if (storedPersistentHandle === persistentAnchors[i]) {
                    this.anchor = await session.restorePersistentAnchor(persistentAnchors[i]), this.anchor && (this.persistentHandle = persistentAnchors[i]);
                    break;
                  }
                this.anchor || (this.requestAnchorPending = !0);
              } else
                this.requestPersistentAnchorPending = !0;
            },
            deleteAnchor: function() {
              var xrManager, session, anchor = this.anchor;
              !anchor || (xrManager = this.el.sceneEl.renderer.xr, session = xrManager.getSession(), anchor.delete(), this.el.sceneEl.object3D.add(this.el.object3D), this.persistentHandle && session.deletePersistentAnchor(this.persistentHandle), this.anchor = void 0);
            }
          });
          function anchorsSupported(sceneEl) {
            var xrManager = sceneEl.renderer.xr, session = xrManager.getSession();
            return session && session.restorePersistentAnchor;
          }
        },
        "./src/components/animation.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var anime = __webpack_require__2("./node_modules/super-animejs/lib/anime.es.js").default, components = __webpack_require__2("./src/core/component.js").components, registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js"), colorHelperFrom = new THREE3.Color(), colorHelperTo = new THREE3.Color(), getComponentProperty = utils.entity.getComponentProperty, setComponentProperty = utils.entity.setComponentProperty, splitCache = {}, TYPE_COLOR = "color", PROP_POSITION = "position", PROP_ROTATION = "rotation", PROP_SCALE = "scale", STRING_COMPONENTS = "components", STRING_OBJECT3D = "object3D";
          module3.exports.Component = registerComponent("animation", {
            schema: {
              autoplay: {
                default: !0
              },
              delay: {
                default: 0
              },
              dir: {
                default: ""
              },
              dur: {
                default: 1e3
              },
              easing: {
                default: "easeInQuad"
              },
              elasticity: {
                default: 400
              },
              enabled: {
                default: !0
              },
              from: {
                default: ""
              },
              loop: {
                default: 0,
                parse: function(value) {
                  return value === !0 || value === "true" ? !0 : value === !1 || value === "false" ? !1 : parseInt(value, 10);
                }
              },
              property: {
                default: ""
              },
              startEvents: {
                type: "array"
              },
              pauseEvents: {
                type: "array"
              },
              resumeEvents: {
                type: "array"
              },
              round: {
                default: !1
              },
              to: {
                default: ""
              },
              type: {
                default: ""
              },
              isRawProperty: {
                default: !1
              }
            },
            multiple: !0,
            init: function() {
              var self2 = this;
              this.eventDetail = {
                name: this.attrName
              }, this.time = 0, this.animation = null, this.animationIsPlaying = !1, this.onStartEvent = this.onStartEvent.bind(this), this.beginAnimation = this.beginAnimation.bind(this), this.pauseAnimation = this.pauseAnimation.bind(this), this.resumeAnimation = this.resumeAnimation.bind(this), this.fromColor = {}, this.toColor = {}, this.targets = {}, this.targetsArray = [], this.updateConfigForDefault = this.updateConfigForDefault.bind(this), this.updateConfigForRawColor = this.updateConfigForRawColor.bind(this), this.config = {
                complete: function() {
                  self2.animationIsPlaying = !1, self2.el.emit("animationcomplete", self2.eventDetail, !1), self2.id && self2.el.emit("animationcomplete__" + self2.id, self2.eventDetail, !1);
                }
              };
            },
            update: function(oldData) {
              var config = this.config, data = this.data;
              this.animationIsPlaying = !1, !!this.data.enabled && (!data.property || (config.autoplay = !1, config.direction = data.dir, config.duration = data.dur, config.easing = data.easing, config.elasticity = data.elasticity, config.loop = data.loop, config.round = data.round, this.createAndStartAnimation()));
            },
            tick: function(t, dt) {
              !this.animationIsPlaying || (this.time += dt, this.animation.tick(this.time));
            },
            remove: function() {
              this.pauseAnimation(), this.removeEventListeners();
            },
            pause: function() {
              this.paused = !0, this.pausedWasPlaying = this.animationIsPlaying, this.pauseAnimation(), this.removeEventListeners();
            },
            play: function() {
              !this.paused || (this.paused = !1, this.addEventListeners(), this.pausedWasPlaying && (this.resumeAnimation(), this.pausedWasPlaying = !1));
            },
            createAndStartAnimation: function() {
              var data = this.data;
              if (this.updateConfig(), this.animationIsPlaying = !1, this.animation = anime(this.config), this.animation.began = !0, this.removeEventListeners(), this.addEventListeners(), !(!data.autoplay || data.startEvents && data.startEvents.length)) {
                if (data.delay) {
                  setTimeout(this.beginAnimation, data.delay);
                  return;
                }
                this.beginAnimation();
              }
            },
            beginAnimation: function() {
              this.updateConfig(), this.animation.began = !0, this.time = 0, this.animationIsPlaying = !0, this.stopRelatedAnimations(), this.el.emit("animationbegin", this.eventDetail, !1);
            },
            pauseAnimation: function() {
              this.animationIsPlaying = !1;
            },
            resumeAnimation: function() {
              this.animationIsPlaying = !0;
            },
            onStartEvent: function() {
              if (!!this.data.enabled) {
                if (this.updateConfig(), this.animation && this.animation.pause(), this.animation = anime(this.config), this.data.delay) {
                  setTimeout(this.beginAnimation, this.data.delay);
                  return;
                }
                this.beginAnimation();
              }
            },
            updateConfigForRawColor: function() {
              var config = this.config, data = this.data, el = this.el, from, key, to;
              if (!this.waitComponentInitRawProperty(this.updateConfigForRawColor)) {
                from = data.from === "" ? getRawProperty(el, data.property) : data.from, to = data.to, this.setColorConfig(from, to), from = this.fromColor, to = this.toColor, this.targetsArray.length = 0, this.targetsArray.push(from), config.targets = this.targetsArray;
                for (key in to)
                  config[key] = to[key];
                config.update = function() {
                  var lastValue = {};
                  return function(anim) {
                    var value;
                    value = anim.animatables[0].target, !(value.r === lastValue.r && value.g === lastValue.g && value.b === lastValue.b) && setRawProperty(el, data.property, value, data.type);
                  };
                }();
              }
            },
            updateConfigForDefault: function() {
              var config = this.config, data = this.data, el = this.el, from, isBoolean, isNumber, to;
              this.waitComponentInitRawProperty(this.updateConfigForDefault) || (data.from === "" ? from = isRawProperty(data) ? getRawProperty(el, data.property) : getComponentProperty(el, data.property) : from = data.from, to = data.to, isNumber = !isNaN(from || to), isNumber ? (from = parseFloat(from), to = parseFloat(to)) : (from = from && from.toString(), to = to && to.toString()), isBoolean = data.to === "true" || data.to === "false" || data.to === !0 || data.to === !1, isBoolean && (from = data.from === "true" || data.from === !0 ? 1 : 0, to = data.to === "true" || data.to === !0 ? 1 : 0), this.targets.aframeProperty = from, config.targets = this.targets, config.aframeProperty = to, config.update = function() {
                var lastValue;
                return function(anim) {
                  var value;
                  value = anim.animatables[0].target.aframeProperty, value !== lastValue && (lastValue = value, isBoolean && (value = value >= 1), isRawProperty(data) ? setRawProperty(el, data.property, value, data.type) : setComponentProperty(el, data.property, value));
                };
              }());
            },
            updateConfigForVector: function() {
              var config = this.config, data = this.data, el = this.el, key, from, to;
              from = data.from !== "" ? utils.coordinates.parse(data.from) : getComponentProperty(el, data.property), to = utils.coordinates.parse(data.to), data.property === PROP_ROTATION && (toRadians(from), toRadians(to)), this.targetsArray.length = 0, this.targetsArray.push(from), config.targets = this.targetsArray;
              for (key in to)
                config[key] = to[key];
              if (data.property === PROP_POSITION || data.property === PROP_ROTATION || data.property === PROP_SCALE) {
                config.update = function() {
                  var lastValue = {};
                  return function(anim) {
                    var value = anim.animatables[0].target;
                    value.x === lastValue.x && value.y === lastValue.y && value.z === lastValue.z || (lastValue.x = value.x, lastValue.y = value.y, lastValue.z = value.z, el.object3D[data.property].set(value.x, value.y, value.z));
                  };
                }();
                return;
              }
              config.update = function() {
                var lastValue = {};
                return function(anim) {
                  var value = anim.animatables[0].target;
                  value.x === lastValue.x && value.y === lastValue.y && value.z === lastValue.z || (lastValue.x = value.x, lastValue.y = value.y, lastValue.z = value.z, setComponentProperty(el, data.property, value));
                };
              }();
            },
            updateConfig: function() {
              var propType;
              propType = getPropertyType(this.el, this.data.property), isRawProperty(this.data) && this.data.type === TYPE_COLOR ? this.updateConfigForRawColor() : propType === "vec2" || propType === "vec3" || propType === "vec4" ? this.updateConfigForVector() : this.updateConfigForDefault();
            },
            waitComponentInitRawProperty: function(cb) {
              var componentName, data = this.data, el = this.el, self2 = this;
              return data.from !== "" || !data.property.startsWith(STRING_COMPONENTS) || (componentName = splitDot(data.property)[1], el.components[componentName]) ? !1 : (el.addEventListener("componentinitialized", function wait(evt) {
                evt.detail.name === componentName && (cb(), self2.animation = anime(self2.config), el.removeEventListener("componentinitialized", wait));
              }), !0);
            },
            stopRelatedAnimations: function() {
              var component, componentName;
              for (componentName in this.el.components)
                component = this.el.components[componentName], componentName !== this.attrName && component.name === "animation" && (!component.animationIsPlaying || component.data.property === this.data.property && (component.animationIsPlaying = !1));
            },
            addEventListeners: function() {
              var data = this.data, el = this.el;
              addEventListeners(el, data.startEvents, this.onStartEvent), addEventListeners(el, data.pauseEvents, this.pauseAnimation), addEventListeners(el, data.resumeEvents, this.resumeAnimation);
            },
            removeEventListeners: function() {
              var data = this.data, el = this.el;
              removeEventListeners(el, data.startEvents, this.onStartEvent), removeEventListeners(el, data.pauseEvents, this.pauseAnimation), removeEventListeners(el, data.resumeEvents, this.resumeAnimation);
            },
            setColorConfig: function(from, to) {
              colorHelperFrom.set(from), colorHelperTo.set(to), from = this.fromColor, to = this.toColor, from.r = colorHelperFrom.r, from.g = colorHelperFrom.g, from.b = colorHelperFrom.b, to.r = colorHelperTo.r, to.g = colorHelperTo.g, to.b = colorHelperTo.b;
            }
          });
          function getPropertyType(el, property) {
            var component, componentName, split, propertyName;
            return split = property.split("."), componentName = split[0], propertyName = split[1], component = el.components[componentName] || components[componentName], !component || propertyName && !component.schema[propertyName] ? null : propertyName ? component.schema[propertyName].type : component.schema.type;
          }
          function toRadians(obj) {
            obj.x = THREE3.MathUtils.degToRad(obj.x), obj.y = THREE3.MathUtils.degToRad(obj.y), obj.z = THREE3.MathUtils.degToRad(obj.z);
          }
          function addEventListeners(el, eventNames, handler) {
            var i;
            for (i = 0; i < eventNames.length; i++)
              el.addEventListener(eventNames[i], handler);
          }
          function removeEventListeners(el, eventNames, handler) {
            var i;
            for (i = 0; i < eventNames.length; i++)
              el.removeEventListener(eventNames[i], handler);
          }
          function getRawProperty(el, path) {
            var i, split, value;
            for (split = splitDot(path), value = el, i = 0; i < split.length; i++)
              value = value[split[i]];
            if (value === void 0)
              throw console.log(el), new Error("[animation] property (" + path + ") could not be found");
            return value;
          }
          function setRawProperty(el, path, value, type) {
            var i, split, propertyName, targetValue;
            for (path.startsWith("object3D.rotation") && (value = THREE3.MathUtils.degToRad(value)), split = splitDot(path), targetValue = el, i = 0; i < split.length - 1; i++)
              targetValue = targetValue[split[i]];
            if (propertyName = split[split.length - 1], type === TYPE_COLOR) {
              "r" in targetValue[propertyName] ? (targetValue[propertyName].r = value.r, targetValue[propertyName].g = value.g, targetValue[propertyName].b = value.b) : (targetValue[propertyName].x = value.r, targetValue[propertyName].y = value.g, targetValue[propertyName].z = value.b);
              return;
            }
            targetValue[propertyName] = value;
          }
          function splitDot(path) {
            return path in splitCache || (splitCache[path] = path.split(".")), splitCache[path];
          }
          function isRawProperty(data) {
            return data.isRawProperty || data.property.startsWith(STRING_COMPONENTS) || data.property.startsWith(STRING_OBJECT3D);
          }
        },
        "./src/components/camera.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js");
          module3.exports.Component = registerComponent("camera", {
            schema: {
              active: {
                default: !0
              },
              far: {
                default: 1e4
              },
              fov: {
                default: 80,
                min: 0
              },
              near: {
                default: 5e-3,
                min: 0
              },
              spectator: {
                default: !1
              },
              zoom: {
                default: 1,
                min: 0
              }
            },
            init: function() {
              var camera, el = this.el;
              camera = this.camera = new THREE3.PerspectiveCamera(), el.setObject3D("camera", camera);
            },
            update: function(oldData) {
              var data = this.data, camera = this.camera;
              camera.aspect = data.aspect || window.innerWidth / window.innerHeight, camera.far = data.far, camera.fov = data.fov, camera.near = data.near, camera.zoom = data.zoom, camera.updateProjectionMatrix(), this.updateActiveCamera(oldData), this.updateSpectatorCamera(oldData);
            },
            updateActiveCamera: function(oldData) {
              var data = this.data, el = this.el, system = this.system;
              oldData && oldData.active === data.active || data.spectator || (data.active && system.activeCameraEl !== el ? system.setActiveCamera(el) : !data.active && system.activeCameraEl === el && system.disableActiveCamera());
            },
            updateSpectatorCamera: function(oldData) {
              var data = this.data, el = this.el, system = this.system;
              oldData && oldData.spectator === data.spectator || (data.spectator && system.spectatorCameraEl !== el ? system.setSpectatorCamera(el) : !data.spectator && system.spectatorCameraEl === el && system.disableSpectatorCamera());
            },
            remove: function() {
              this.el.removeObject3D("camera");
            }
          });
        },
        "./src/components/cursor.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, utils = __webpack_require__2("./src/utils/index.js"), EVENTS = {
            CLICK: "click",
            FUSING: "fusing",
            MOUSEENTER: "mouseenter",
            MOUSEDOWN: "mousedown",
            MOUSELEAVE: "mouseleave",
            MOUSEUP: "mouseup"
          }, STATES = {
            FUSING: "cursor-fusing",
            HOVERING: "cursor-hovering",
            HOVERED: "cursor-hovered"
          }, CANVAS_EVENTS = {
            DOWN: ["mousedown", "touchstart"],
            UP: ["mouseup", "touchend"]
          }, WEBXR_EVENTS = {
            DOWN: ["selectstart"],
            UP: ["selectend"]
          }, CANVAS_HOVER_CLASS = "a-mouse-cursor-hover";
          module3.exports.Component = registerComponent("cursor", {
            dependencies: ["raycaster"],
            schema: {
              downEvents: {
                default: []
              },
              fuse: {
                default: utils.device.isMobile()
              },
              fuseTimeout: {
                default: 1500,
                min: 0
              },
              mouseCursorStylesEnabled: {
                default: !0
              },
              upEvents: {
                default: []
              },
              rayOrigin: {
                default: "entity",
                oneOf: ["mouse", "entity", "xrselect"]
              }
            },
            after: ["tracked-controls"],
            multiple: !0,
            init: function() {
              var self2 = this;
              this.fuseTimeout = void 0, this.cursorDownEl = null, this.intersectedEl = null, this.canvasBounds = document.body.getBoundingClientRect(), this.isCursorDown = !1, this.activeXRInput = null, this.updateCanvasBounds = utils.debounce(function() {
                self2.canvasBounds = self2.el.sceneEl.canvas.getBoundingClientRect();
              }, 500), this.eventDetail = {}, this.intersectedEventDetail = {
                cursorEl: this.el
              }, this.onCursorDown = this.onCursorDown.bind(this), this.onCursorUp = this.onCursorUp.bind(this), this.onIntersection = this.onIntersection.bind(this), this.onIntersectionCleared = this.onIntersectionCleared.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onEnterVR = this.onEnterVR.bind(this);
            },
            update: function(oldData) {
              this.data.rayOrigin !== oldData.rayOrigin && this.updateMouseEventListeners();
            },
            tick: function() {
              var frame = this.el.sceneEl.frame, inputSource = this.activeXRInput;
              this.data.rayOrigin === "xrselect" && frame && inputSource && this.onMouseMove({
                frame,
                inputSource,
                type: "fakeselectevent"
              });
            },
            play: function() {
              this.addEventListeners();
            },
            pause: function() {
              this.removeEventListeners();
            },
            remove: function() {
              var el = this.el;
              el.removeState(STATES.HOVERING), el.removeState(STATES.FUSING), clearTimeout(this.fuseTimeout), this.intersectedEl && this.intersectedEl.removeState(STATES.HOVERED), this.removeEventListeners();
            },
            addEventListeners: function() {
              var canvas, data = this.data, el = this.el, self2 = this;
              function addCanvasListeners() {
                canvas = el.sceneEl.canvas, !(data.downEvents.length || data.upEvents.length) && (CANVAS_EVENTS.DOWN.forEach(function(downEvent) {
                  canvas.addEventListener(downEvent, self2.onCursorDown, {
                    passive: !1
                  });
                }), CANVAS_EVENTS.UP.forEach(function(upEvent) {
                  canvas.addEventListener(upEvent, self2.onCursorUp, {
                    passive: !1
                  });
                }));
              }
              canvas = el.sceneEl.canvas, canvas ? addCanvasListeners() : el.sceneEl.addEventListener("render-target-loaded", addCanvasListeners), data.downEvents.forEach(function(downEvent) {
                el.addEventListener(downEvent, self2.onCursorDown);
              }), data.upEvents.forEach(function(upEvent) {
                el.addEventListener(upEvent, self2.onCursorUp);
              }), el.addEventListener("raycaster-intersection", this.onIntersection), el.addEventListener("raycaster-closest-entity-changed", this.onIntersection), el.addEventListener("raycaster-intersection-cleared", this.onIntersectionCleared), el.sceneEl.addEventListener("rendererresize", this.updateCanvasBounds), el.sceneEl.addEventListener("enter-vr", this.onEnterVR), window.addEventListener("resize", this.updateCanvasBounds), window.addEventListener("scroll", this.updateCanvasBounds), this.updateMouseEventListeners();
            },
            removeEventListeners: function() {
              var canvas, data = this.data, el = this.el, self2 = this;
              canvas = el.sceneEl.canvas, canvas && !data.downEvents.length && !data.upEvents.length && (CANVAS_EVENTS.DOWN.forEach(function(downEvent) {
                canvas.removeEventListener(downEvent, self2.onCursorDown);
              }), CANVAS_EVENTS.UP.forEach(function(upEvent) {
                canvas.removeEventListener(upEvent, self2.onCursorUp);
              })), data.downEvents.forEach(function(downEvent) {
                el.removeEventListener(downEvent, self2.onCursorDown);
              }), data.upEvents.forEach(function(upEvent) {
                el.removeEventListener(upEvent, self2.onCursorUp);
              }), el.removeEventListener("raycaster-intersection", this.onIntersection), el.removeEventListener("raycaster-intersection-cleared", this.onIntersectionCleared), canvas.removeEventListener("mousemove", this.onMouseMove), canvas.removeEventListener("touchstart", this.onMouseMove), canvas.removeEventListener("touchmove", this.onMouseMove), el.sceneEl.removeEventListener("rendererresize", this.updateCanvasBounds), el.sceneEl.removeEventListener("enter-vr", this.onEnterVR), window.removeEventListener("resize", this.updateCanvasBounds), window.removeEventListener("scroll", this.updateCanvasBounds);
            },
            updateMouseEventListeners: function() {
              var canvas, el = this.el;
              canvas = el.sceneEl.canvas, canvas.removeEventListener("mousemove", this.onMouseMove), canvas.removeEventListener("touchmove", this.onMouseMove), el.setAttribute("raycaster", "useWorldCoordinates", !1), this.data.rayOrigin === "mouse" && (canvas.addEventListener("mousemove", this.onMouseMove), canvas.addEventListener("touchmove", this.onMouseMove, {
                passive: !1
              }), el.setAttribute("raycaster", "useWorldCoordinates", !0), this.updateCanvasBounds());
            },
            onMouseMove: function() {
              var direction = new THREE.Vector3(), mouse = new THREE.Vector2(), origin = new THREE.Vector3(), rayCasterConfig = {
                origin,
                direction
              };
              return function(evt) {
                var bounds = this.canvasBounds, camera = this.el.sceneEl.camera, left, point, top, frame, inputSource, referenceSpace, pose, transform;
                camera.parent.updateMatrixWorld(), evt.type === "touchmove" || evt.type === "touchstart" ? point = evt.touches.item(0) : point = evt, left = point.clientX - bounds.left, top = point.clientY - bounds.top, mouse.x = left / bounds.width * 2 - 1, mouse.y = -(top / bounds.height) * 2 + 1, this.data.rayOrigin === "xrselect" && (evt.type === "selectstart" || evt.type === "fakeselectevent") ? (frame = evt.frame, inputSource = evt.inputSource, referenceSpace = this.el.renderer.xr.getReferenceSpace(), pose = frame.getPose(inputSource.targetRaySpace, referenceSpace), transform = pose.transform, direction.set(0, 0, -1), direction.applyQuaternion(transform.orientation), origin.copy(transform.position)) : evt.type === "fakeselectout" ? (direction.set(0, 1, 0), origin.set(0, 9999, 0)) : camera && camera.isPerspectiveCamera ? (origin.setFromMatrixPosition(camera.matrixWorld), direction.set(mouse.x, mouse.y, 0.5).unproject(camera).sub(origin).normalize()) : camera && camera.isOrthographicCamera ? (origin.set(mouse.x, mouse.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera), direction.set(0, 0, -1).transformDirection(camera.matrixWorld)) : console.error("AFRAME.Raycaster: Unsupported camera type: " + camera.type), this.el.setAttribute("raycaster", rayCasterConfig), evt.type === "touchmove" && evt.preventDefault();
              };
            }(),
            onCursorDown: function(evt) {
              this.isCursorDown = !0, this.data.rayOrigin === "mouse" && evt.type === "touchstart" && (this.onMouseMove(evt), this.el.components.raycaster.checkIntersections(), evt.preventDefault()), this.data.rayOrigin === "xrselect" && evt.type === "selectstart" && (this.activeXRInput = evt.inputSource, this.onMouseMove(evt), this.el.components.raycaster.checkIntersections(), this.el.components.raycaster.intersectedEls.length && this.el.sceneEl.components["ar-hit-test"] !== void 0 && this.el.sceneEl.getAttribute("ar-hit-test").enabled && (this.el.sceneEl.setAttribute("ar-hit-test", "enabled", !1), this.reenableARHitTest = !0)), this.twoWayEmit(EVENTS.MOUSEDOWN, evt), this.cursorDownEl = this.intersectedEl;
            },
            onCursorUp: function(evt) {
              if (!!this.isCursorDown) {
                this.isCursorDown = !1;
                var data = this.data;
                this.twoWayEmit(EVENTS.MOUSEUP, evt), this.reenableARHitTest === !0 && (this.el.sceneEl.setAttribute("ar-hit-test", "enabled", !0), this.reenableARHitTest = void 0), this.cursorDownEl && this.cursorDownEl !== this.intersectedEl && (this.intersectedEventDetail.intersection = null, this.cursorDownEl.emit(EVENTS.MOUSEUP, this.intersectedEventDetail)), (!data.fuse || data.rayOrigin === "mouse" || data.rayOrigin === "xrselect") && this.intersectedEl && this.cursorDownEl === this.intersectedEl && this.twoWayEmit(EVENTS.CLICK, evt), data.rayOrigin === "xrselect" && this.activeXRInput === evt.inputSource && this.onMouseMove({
                  type: "fakeselectout"
                }), this.activeXRInput = null, this.cursorDownEl = null, evt.type === "touchend" && evt.preventDefault();
              }
            },
            onIntersection: function(evt) {
              var currentIntersection, cursorEl = this.el, index, intersectedEl, intersection;
              index = evt.detail.els[0] === cursorEl ? 1 : 0, intersection = evt.detail.intersections[index], intersectedEl = evt.detail.els[index], !!intersectedEl && this.intersectedEl !== intersectedEl && (this.intersectedEl && (currentIntersection = this.el.components.raycaster.getIntersection(this.intersectedEl), currentIntersection && currentIntersection.distance <= intersection.distance) || (this.clearCurrentIntersection(!0), this.setIntersection(intersectedEl, intersection)));
            },
            onIntersectionCleared: function(evt) {
              var clearedEls = evt.detail.clearedEls;
              clearedEls.indexOf(this.intersectedEl) !== -1 && this.clearCurrentIntersection();
            },
            onEnterVR: function() {
              this.clearCurrentIntersection(!0);
              var xrSession = this.el.sceneEl.xrSession, self2 = this;
              !xrSession || this.data.rayOrigin !== "mouse" && (WEBXR_EVENTS.DOWN.forEach(function(downEvent) {
                xrSession.addEventListener(downEvent, self2.onCursorDown);
              }), WEBXR_EVENTS.UP.forEach(function(upEvent) {
                xrSession.addEventListener(upEvent, self2.onCursorUp);
              }));
            },
            setIntersection: function(intersectedEl, intersection) {
              var cursorEl = this.el, data = this.data, self2 = this;
              this.intersectedEl !== intersectedEl && (this.intersectedEl = intersectedEl, cursorEl.addState(STATES.HOVERING), intersectedEl.addState(STATES.HOVERED), this.twoWayEmit(EVENTS.MOUSEENTER), this.data.mouseCursorStylesEnabled && this.data.rayOrigin === "mouse" && this.el.sceneEl.canvas.classList.add(CANVAS_HOVER_CLASS), !(data.fuseTimeout === 0 || !data.fuse || data.rayOrigin === "xrselect" || data.rayOrigin === "mouse") && (cursorEl.addState(STATES.FUSING), this.twoWayEmit(EVENTS.FUSING), this.fuseTimeout = setTimeout(function() {
                cursorEl.removeState(STATES.FUSING), self2.twoWayEmit(EVENTS.CLICK);
              }, data.fuseTimeout)));
            },
            clearCurrentIntersection: function(ignoreRemaining) {
              var index, intersection, intersections, cursorEl = this.el;
              !this.intersectedEl || (this.intersectedEl.removeState(STATES.HOVERED), cursorEl.removeState(STATES.HOVERING), cursorEl.removeState(STATES.FUSING), this.twoWayEmit(EVENTS.MOUSELEAVE), this.data.mouseCursorStylesEnabled && this.data.rayOrigin === "mouse" && this.el.sceneEl.canvas.classList.remove(CANVAS_HOVER_CLASS), this.intersectedEl = null, clearTimeout(this.fuseTimeout), ignoreRemaining !== !0 && (intersections = this.el.components.raycaster.intersections, intersections.length !== 0 && (index = intersections[0].object.el === cursorEl ? 1 : 0, intersection = intersections[index], !!intersection && this.setIntersection(intersection.object.el, intersection))));
            },
            twoWayEmit: function(evtName, originalEvent) {
              var el = this.el, intersectedEl = this.intersectedEl, intersection;
              function addOriginalEvent(detail, evt) {
                originalEvent instanceof MouseEvent ? detail.mouseEvent = originalEvent : typeof TouchEvent != "undefined" && originalEvent instanceof TouchEvent && (detail.touchEvent = originalEvent);
              }
              intersection = this.el.components.raycaster.getIntersection(intersectedEl), this.eventDetail.intersectedEl = intersectedEl, this.eventDetail.intersection = intersection, addOriginalEvent(this.eventDetail, originalEvent), el.emit(evtName, this.eventDetail), !!intersectedEl && (this.intersectedEventDetail.intersection = intersection, addOriginalEvent(this.intersectedEventDetail, originalEvent), intersectedEl.emit(evtName, this.intersectedEventDetail));
            }
          });
        },
        "./src/components/generic-tracked-controller-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged, onButtonEvent = trackedControlsUtils.onButtonEvent, GAMEPAD_ID_PREFIX = "generic", INPUT_MAPPING = {
            axes: {
              touchpad: [0, 1],
              thumbstick: [2, 3]
            },
            buttons: ["trigger", "squeeze", "touchpad", "thumbstick"]
          };
          module3.exports.Component = registerComponent("generic-tracked-controller-controls", {
            schema: {
              hand: {
                default: ""
              },
              defaultModel: {
                default: !0
              },
              defaultModelColor: {
                default: "gray"
              },
              orientationOffset: {
                type: "vec3"
              },
              disabled: {
                default: !1
              }
            },
            after: ["tracked-controls"],
            mapping: INPUT_MAPPING,
            bindMethods: function() {
              this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
            },
            init: function() {
              var self2 = this;
              this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(evt) {
                onButtonEvent(evt.detail.id, "down", self2);
              }, this.onButtonUp = function(evt) {
                onButtonEvent(evt.detail.id, "up", self2);
              }, this.onButtonTouchStart = function(evt) {
                onButtonEvent(evt.detail.id, "touchstart", self2);
              }, this.onButtonTouchEnd = function(evt) {
                onButtonEvent(evt.detail.id, "touchend", self2);
              }, this.controllerPresent = !1, this.wasControllerConnected = !1, this.lastControllerCheck = 0, this.bindMethods(), this.el.addEventListener("controllerconnected", function(evt) {
                evt.detail.name !== self2.name && (self2.wasControllerConnected = !0, self2.removeEventListeners(), self2.removeControllersUpdateListener());
              });
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("buttonchanged", this.onButtonChanged), el.addEventListener("buttondown", this.onButtonDown), el.addEventListener("buttonup", this.onButtonUp), el.addEventListener("touchstart", this.onButtonTouchStart), el.addEventListener("touchend", this.onButtonTouchEnd), el.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0;
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("buttonchanged", this.onButtonChanged), el.removeEventListener("buttondown", this.onButtonDown), el.removeEventListener("buttonup", this.onButtonUp), el.removeEventListener("touchstart", this.onButtonTouchStart), el.removeEventListener("touchend", this.onButtonTouchEnd), el.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1;
            },
            checkIfControllerPresent: function() {
              var data = this.data, hand = data.hand ? data.hand : void 0;
              checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {
                hand,
                iterateControllerProfiles: !0
              });
            },
            play: function() {
              this.wasControllerConnected || (this.checkIfControllerPresent(), this.addControllersUpdateListener());
            },
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            injectTrackedControls: function() {
              var el = this.el, data = this.data;
              if (this.el.components["tracked-controls"]) {
                this.removeEventListeners();
                return;
              }
              el.setAttribute("tracked-controls", {
                hand: data.hand,
                idPrefix: GAMEPAD_ID_PREFIX,
                orientationOffset: data.orientationOffset,
                iterateControllerProfiles: !0
              }), !!this.data.defaultModel && this.initDefaultModel();
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              !this.wasControllerConnected || this.checkIfControllerPresent();
            },
            onButtonChanged: function(evt) {
              var button = this.mapping.buttons[evt.detail.id];
              !button || this.el.emit(button + "changed", evt.detail.state);
            },
            onAxisMoved: function(evt) {
              emitIfAxesChanged(this, this.mapping.axes, evt);
            },
            initDefaultModel: function() {
              var modelEl = this.modelEl = document.createElement("a-entity");
              modelEl.setAttribute("geometry", {
                primitive: "sphere",
                radius: 0.03
              }), modelEl.setAttribute("material", {
                color: this.data.color
              }), this.el.appendChild(modelEl), this.el.emit("controllermodelready", {
                name: "generic-tracked-controller-controls",
                model: this.modelEl,
                rayOrigin: {
                  origin: {
                    x: 0,
                    y: 0,
                    z: -0.01
                  },
                  direction: {
                    x: 0,
                    y: 0,
                    z: -1
                  }
                }
              });
            }
          });
        },
        "./src/components/geometry.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var geometries = __webpack_require__2("./src/core/geometry.js").geometries, geometryNames = __webpack_require__2("./src/core/geometry.js").geometryNames, registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), dummyGeometry = new THREE3.BufferGeometry();
          module3.exports.Component = registerComponent("geometry", {
            schema: {
              buffer: {
                default: !0
              },
              primitive: {
                default: "box",
                oneOf: geometryNames,
                schemaChange: !0
              },
              skipCache: {
                default: !1
              }
            },
            init: function() {
              this.geometry = null;
            },
            update: function(previousData) {
              var data = this.data, el = this.el, mesh, system = this.system;
              this.geometry && (system.unuseGeometry(previousData), this.geometry = null), this.geometry = system.getOrCreateGeometry(data), mesh = el.getObject3D("mesh"), mesh ? mesh.geometry = this.geometry : (mesh = new THREE3.Mesh(), mesh.geometry = this.geometry, this.el.getAttribute("material") || (mesh.material = new THREE3.MeshStandardMaterial({
                color: Math.random() * 16777215,
                metalness: 0,
                roughness: 0.5
              })), el.setObject3D("mesh", mesh));
            },
            remove: function() {
              this.system.unuseGeometry(this.data), this.el.getObject3D("mesh").geometry = dummyGeometry, this.geometry = null;
            },
            updateSchema: function(data) {
              var currentGeometryType = this.oldData && this.oldData.primitive, newGeometryType = data.primitive, schema = geometries[newGeometryType] && geometries[newGeometryType].schema;
              if (!schema)
                throw new Error("Unknown geometry schema `" + newGeometryType + "`");
              currentGeometryType && currentGeometryType === newGeometryType || this.extendSchema(schema);
            }
          });
        },
        "./src/components/gltf-model.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js"), warn = utils.debug("components:gltf-model:warn");
          module3.exports.Component = registerComponent("gltf-model", {
            schema: {
              type: "model"
            },
            init: function() {
              var self2 = this, dracoLoader = this.system.getDRACOLoader(), meshoptDecoder = this.system.getMeshoptDecoder(), ktxLoader = this.system.getKTX2Loader();
              this.model = null, this.loader = new THREE3.GLTFLoader(), dracoLoader && this.loader.setDRACOLoader(dracoLoader), meshoptDecoder ? this.ready = meshoptDecoder.then(function(meshoptDecoder2) {
                self2.loader.setMeshoptDecoder(meshoptDecoder2);
              }) : this.ready = Promise.resolve(), ktxLoader && this.loader.setKTX2Loader(ktxLoader);
            },
            update: function() {
              var self2 = this, el = this.el, src = this.data;
              !src || (this.remove(), this.ready.then(function() {
                self2.loader.load(src, function(gltfModel) {
                  self2.model = gltfModel.scene || gltfModel.scenes[0], self2.model.animations = gltfModel.animations, el.setObject3D("mesh", self2.model), el.emit("model-loaded", {
                    format: "gltf",
                    model: self2.model
                  });
                }, void 0, function(error) {
                  var message = error && error.message ? error.message : "Failed to load glTF model";
                  warn(message), el.emit("model-error", {
                    format: "gltf",
                    src
                  });
                });
              }));
            },
            remove: function() {
              !this.model || this.el.removeObject3D("mesh");
            }
          });
        },
        "./src/components/grabbable.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent;
          registerComponent("grabbable", {
            init: function() {
              this.el.setAttribute("obb-collider", "centerModel: true");
            }
          });
        },
        "./src/components/hand-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, MODEL_URLS = {
            toonLeft: AFRAME_CDN_ROOT + "controllers/hands/leftHand.glb",
            toonRight: AFRAME_CDN_ROOT + "controllers/hands/rightHand.glb",
            lowPolyLeft: AFRAME_CDN_ROOT + "controllers/hands/leftHandLow.glb",
            lowPolyRight: AFRAME_CDN_ROOT + "controllers/hands/rightHandLow.glb",
            highPolyLeft: AFRAME_CDN_ROOT + "controllers/hands/leftHandHigh.glb",
            highPolyRight: AFRAME_CDN_ROOT + "controllers/hands/rightHandHigh.glb"
          }, ANIMATIONS = {
            open: "Open",
            point: "Point",
            pointThumb: "Point + Thumb",
            fist: "Fist",
            hold: "Hold",
            thumbUp: "Thumb Up"
          }, EVENTS = {};
          EVENTS[ANIMATIONS.fist] = "grip", EVENTS[ANIMATIONS.thumbUp] = "pistol", EVENTS[ANIMATIONS.point] = "pointing", module3.exports.Component = registerComponent("hand-controls", {
            schema: {
              color: {
                default: "white",
                type: "color"
              },
              hand: {
                default: "left"
              },
              handModelStyle: {
                default: "lowPoly",
                oneOf: ["lowPoly", "highPoly", "toon"]
              }
            },
            after: ["tracked-controls"],
            init: function() {
              var self2 = this, el = this.el;
              this.pressedButtons = {}, this.touchedButtons = {}, this.loader = new THREE.GLTFLoader(), this.loader.setCrossOrigin("anonymous"), this.onGripDown = function() {
                self2.handleButton("grip", "down");
              }, this.onGripUp = function() {
                self2.handleButton("grip", "up");
              }, this.onTrackpadDown = function() {
                self2.handleButton("trackpad", "down");
              }, this.onTrackpadUp = function() {
                self2.handleButton("trackpad", "up");
              }, this.onTrackpadTouchStart = function() {
                self2.handleButton("trackpad", "touchstart");
              }, this.onTrackpadTouchEnd = function() {
                self2.handleButton("trackpad", "touchend");
              }, this.onTriggerDown = function() {
                self2.handleButton("trigger", "down");
              }, this.onTriggerUp = function() {
                self2.handleButton("trigger", "up");
              }, this.onTriggerTouchStart = function() {
                self2.handleButton("trigger", "touchstart");
              }, this.onTriggerTouchEnd = function() {
                self2.handleButton("trigger", "touchend");
              }, this.onGripTouchStart = function() {
                self2.handleButton("grip", "touchstart");
              }, this.onGripTouchEnd = function() {
                self2.handleButton("grip", "touchend");
              }, this.onThumbstickDown = function() {
                self2.handleButton("thumbstick", "down");
              }, this.onThumbstickUp = function() {
                self2.handleButton("thumbstick", "up");
              }, this.onAorXTouchStart = function() {
                self2.handleButton("AorX", "touchstart");
              }, this.onAorXTouchEnd = function() {
                self2.handleButton("AorX", "touchend");
              }, this.onBorYTouchStart = function() {
                self2.handleButton("BorY", "touchstart");
              }, this.onBorYTouchEnd = function() {
                self2.handleButton("BorY", "touchend");
              }, this.onSurfaceTouchStart = function() {
                self2.handleButton("surface", "touchstart");
              }, this.onSurfaceTouchEnd = function() {
                self2.handleButton("surface", "touchend");
              }, this.onControllerConnected = this.onControllerConnected.bind(this), this.onControllerDisconnected = this.onControllerDisconnected.bind(this), el.addEventListener("controllerconnected", this.onControllerConnected), el.addEventListener("controllerdisconnected", this.onControllerDisconnected), el.object3D.visible = !1;
            },
            play: function() {
              this.addEventListeners();
            },
            pause: function() {
              this.removeEventListeners();
            },
            tick: function(time, delta) {
              var mesh = this.el.getObject3D("mesh");
              !mesh || !mesh.mixer || mesh.mixer.update(delta / 1e3);
            },
            onControllerConnected: function() {
              this.el.object3D.visible = !0;
            },
            onControllerDisconnected: function() {
              this.el.object3D.visible = !1;
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("gripdown", this.onGripDown), el.addEventListener("gripup", this.onGripUp), el.addEventListener("trackpaddown", this.onTrackpadDown), el.addEventListener("trackpadup", this.onTrackpadUp), el.addEventListener("trackpadtouchstart", this.onTrackpadTouchStart), el.addEventListener("trackpadtouchend", this.onTrackpadTouchEnd), el.addEventListener("triggerdown", this.onTriggerDown), el.addEventListener("triggerup", this.onTriggerUp), el.addEventListener("triggertouchstart", this.onTriggerTouchStart), el.addEventListener("triggertouchend", this.onTriggerTouchEnd), el.addEventListener("griptouchstart", this.onGripTouchStart), el.addEventListener("griptouchend", this.onGripTouchEnd), el.addEventListener("thumbstickdown", this.onThumbstickDown), el.addEventListener("thumbstickup", this.onThumbstickUp), el.addEventListener("abuttontouchstart", this.onAorXTouchStart), el.addEventListener("abuttontouchend", this.onAorXTouchEnd), el.addEventListener("bbuttontouchstart", this.onBorYTouchStart), el.addEventListener("bbuttontouchend", this.onBorYTouchEnd), el.addEventListener("xbuttontouchstart", this.onAorXTouchStart), el.addEventListener("xbuttontouchend", this.onAorXTouchEnd), el.addEventListener("ybuttontouchstart", this.onBorYTouchStart), el.addEventListener("ybuttontouchend", this.onBorYTouchEnd), el.addEventListener("surfacetouchstart", this.onSurfaceTouchStart), el.addEventListener("surfacetouchend", this.onSurfaceTouchEnd);
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("gripdown", this.onGripDown), el.removeEventListener("gripup", this.onGripUp), el.removeEventListener("trackpaddown", this.onTrackpadDown), el.removeEventListener("trackpadup", this.onTrackpadUp), el.removeEventListener("trackpadtouchstart", this.onTrackpadTouchStart), el.removeEventListener("trackpadtouchend", this.onTrackpadTouchEnd), el.removeEventListener("triggerdown", this.onTriggerDown), el.removeEventListener("triggerup", this.onTriggerUp), el.removeEventListener("triggertouchstart", this.onTriggerTouchStart), el.removeEventListener("triggertouchend", this.onTriggerTouchEnd), el.removeEventListener("griptouchstart", this.onGripTouchStart), el.removeEventListener("griptouchend", this.onGripTouchEnd), el.removeEventListener("thumbstickdown", this.onThumbstickDown), el.removeEventListener("thumbstickup", this.onThumbstickUp), el.removeEventListener("abuttontouchstart", this.onAorXTouchStart), el.removeEventListener("abuttontouchend", this.onAorXTouchEnd), el.removeEventListener("bbuttontouchstart", this.onBorYTouchStart), el.removeEventListener("bbuttontouchend", this.onBorYTouchEnd), el.removeEventListener("xbuttontouchstart", this.onAorXTouchStart), el.removeEventListener("xbuttontouchend", this.onAorXTouchEnd), el.removeEventListener("ybuttontouchstart", this.onBorYTouchStart), el.removeEventListener("ybuttontouchend", this.onBorYTouchEnd), el.removeEventListener("surfacetouchstart", this.onSurfaceTouchStart), el.removeEventListener("surfacetouchend", this.onSurfaceTouchEnd);
            },
            update: function(previousHand) {
              var controlConfiguration, el = this.el, hand = this.data.hand, handModelStyle = this.data.handModelStyle, handColor = this.data.color, self2 = this;
              if (controlConfiguration = {
                hand,
                model: !1
              }, hand !== previousHand) {
                var handmodelUrl = MODEL_URLS[handModelStyle + hand.charAt(0).toUpperCase() + hand.slice(1)];
                this.loader.load(handmodelUrl, function(gltf) {
                  var mesh = gltf.scene.children[0], handModelOrientationZ = hand === "left" ? Math.PI / 2 : -Math.PI / 2, handModelOrientationX = el.sceneEl.hasWebXR ? -Math.PI / 2 : 0;
                  mesh.mixer = new THREE.AnimationMixer(mesh), self2.clips = gltf.animations, el.setObject3D("mesh", mesh), mesh.traverse(function(object) {
                    !object.isMesh || (object.material.color = new THREE.Color(handColor));
                  }), mesh.position.set(0, 0, 0), mesh.rotation.set(handModelOrientationX, 0, handModelOrientationZ), el.setAttribute("magicleap-controls", controlConfiguration), el.setAttribute("vive-controls", controlConfiguration), el.setAttribute("oculus-touch-controls", controlConfiguration), el.setAttribute("pico-controls", controlConfiguration), el.setAttribute("windows-motion-controls", controlConfiguration), el.setAttribute("hp-mixed-reality-controls", controlConfiguration);
                });
              }
            },
            remove: function() {
              this.el.removeObject3D("mesh");
            },
            handleButton: function(button, evt) {
              var lastGesture, isPressed = evt === "down", isTouched = evt === "touchstart";
              if (evt.indexOf("touch") === 0) {
                if (isTouched === this.touchedButtons[button])
                  return;
                this.touchedButtons[button] = isTouched;
              } else {
                if (isPressed === this.pressedButtons[button])
                  return;
                this.pressedButtons[button] = isPressed;
              }
              lastGesture = this.gesture, this.gesture = this.determineGesture(), this.gesture !== lastGesture && (this.animateGesture(this.gesture, lastGesture), this.emitGestureEvents(this.gesture, lastGesture));
            },
            determineGesture: function() {
              var gesture, isGripActive = this.pressedButtons.grip, isSurfaceActive = this.pressedButtons.surface || this.touchedButtons.surface, isTrackpadActive = this.pressedButtons.trackpad || this.touchedButtons.trackpad, isTriggerActive = this.pressedButtons.trigger || this.touchedButtons.trigger, isABXYActive = this.touchedButtons.AorX || this.touchedButtons.BorY, isVive = isViveController(this.el.components["tracked-controls"]);
              return isVive ? isGripActive || isTriggerActive ? gesture = ANIMATIONS.fist : isTrackpadActive && (gesture = ANIMATIONS.point) : isGripActive ? isSurfaceActive || isABXYActive || isTrackpadActive ? gesture = isTriggerActive ? ANIMATIONS.fist : ANIMATIONS.point : gesture = isTriggerActive ? ANIMATIONS.thumbUp : ANIMATIONS.pointThumb : isTriggerActive && (gesture = ANIMATIONS.hold), gesture;
            },
            getClip: function(gesture) {
              var clip, i;
              for (i = 0; i < this.clips.length; i++)
                if (clip = this.clips[i], clip.name === gesture)
                  return clip;
            },
            animateGesture: function(gesture, lastGesture) {
              if (gesture) {
                this.playAnimation(gesture || ANIMATIONS.open, lastGesture, !1);
                return;
              }
              this.playAnimation(lastGesture, lastGesture, !0);
            },
            emitGestureEvents: function(gesture, lastGesture) {
              var el = this.el, eventName;
              lastGesture !== gesture && (eventName = getGestureEventName(lastGesture, !1), eventName && el.emit(eventName), eventName = getGestureEventName(gesture, !0), eventName && el.emit(eventName));
            },
            playAnimation: function(gesture, lastGesture, reverse) {
              var clip, fromAction, mesh = this.el.getObject3D("mesh"), toAction;
              if (!!mesh) {
                if (clip = this.getClip(gesture), toAction = mesh.mixer.clipAction(clip), reverse) {
                  toAction.paused = !1, toAction.timeScale = -1;
                  return;
                }
                if (toAction.clampWhenFinished = !0, toAction.loop = THREE.LoopOnce, toAction.repetitions = 0, toAction.timeScale = 1, toAction.time = 0, toAction.weight = 1, !lastGesture) {
                  mesh.mixer.stopAllAction(), toAction.play();
                  return;
                }
                clip = this.getClip(lastGesture), toAction.reset(), toAction.play(), fromAction = mesh.mixer.clipAction(clip), fromAction.crossFadeTo(toAction, 0.15, !0);
              }
            }
          });
          function getGestureEventName(gesture, active) {
            var eventName;
            if (!!gesture) {
              if (eventName = EVENTS[gesture], eventName === "grip")
                return eventName + (active ? "close" : "open");
              if (eventName === "point")
                return eventName + (active ? "up" : "down");
              if (eventName === "pointing" || eventName === "pistol")
                return eventName + (active ? "start" : "end");
            }
          }
          function isViveController(trackedControls) {
            var controller = trackedControls && trackedControls.controller, isVive = controller && (controller.id && controller.id.indexOf("OpenVR ") === 0 || controller.profiles && controller.profiles[0] && controller.profiles[0] === "htc-vive");
            return isVive;
          }
        },
        "./src/components/hand-tracking-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, AEntity = __webpack_require__2("./src/core/a-entity.js").AEntity, trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, LEFT_HAND_MODEL_URL = AFRAME_CDN_ROOT + "controllers/oculus-hands/v4/left.glb", RIGHT_HAND_MODEL_URL = AFRAME_CDN_ROOT + "controllers/oculus-hands/v4/right.glb", JOINTS = ["wrist", "thumb-metacarpal", "thumb-phalanx-proximal", "thumb-phalanx-distal", "thumb-tip", "index-finger-metacarpal", "index-finger-phalanx-proximal", "index-finger-phalanx-intermediate", "index-finger-phalanx-distal", "index-finger-tip", "middle-finger-metacarpal", "middle-finger-phalanx-proximal", "middle-finger-phalanx-intermediate", "middle-finger-phalanx-distal", "middle-finger-tip", "ring-finger-metacarpal", "ring-finger-phalanx-proximal", "ring-finger-phalanx-intermediate", "ring-finger-phalanx-distal", "ring-finger-tip", "pinky-finger-metacarpal", "pinky-finger-phalanx-proximal", "pinky-finger-phalanx-intermediate", "pinky-finger-phalanx-distal", "pinky-finger-tip"], WRIST_INDEX = 0, THUMB_TIP_INDEX = 4, INDEX_TIP_INDEX = 9, PINCH_START_DISTANCE = 0.015, PINCH_END_PERCENTAGE = 0.1;
          module3.exports.Component = registerComponent("hand-tracking-controls", {
            schema: {
              hand: {
                default: "right",
                oneOf: ["left", "right"]
              },
              modelStyle: {
                default: "mesh",
                oneOf: ["dots", "mesh"]
              },
              modelColor: {
                default: "white"
              },
              modelOpacity: {
                default: 1
              }
            },
            after: ["tracked-controls"],
            bindMethods: function() {
              this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this);
            },
            addEventListeners: function() {
              this.el.addEventListener("model-loaded", this.onModelLoaded);
              for (var i = 0; i < this.jointEls.length; ++i)
                this.jointEls[i].object3D.visible = !0;
            },
            removeEventListeners: function() {
              this.el.removeEventListener("model-loaded", this.onModelLoaded);
              for (var i = 0; i < this.jointEls.length; ++i)
                this.jointEls[i].object3D.visible = !1;
            },
            init: function() {
              var sceneEl = this.el.sceneEl, webxrData = sceneEl.getAttribute("webxr"), optionalFeaturesArray = webxrData.optionalFeatures;
              optionalFeaturesArray.indexOf("hand-tracking") === -1 && (optionalFeaturesArray.push("hand-tracking"), sceneEl.setAttribute("webxr", webxrData)), this.wristObject3D = new THREE.Object3D(), this.el.sceneEl.object3D.add(this.wristObject3D), this.onModelLoaded = this.onModelLoaded.bind(this), this.onChildAttached = this.onChildAttached.bind(this), this.jointEls = [], this.controllerPresent = !1, this.isPinched = !1, this.pinchEventDetail = {
                position: new THREE.Vector3(),
                wristRotation: new THREE.Quaternion()
              }, this.indexTipPosition = new THREE.Vector3(), this.hasPoses = !1, this.jointPoses = new Float32Array(16 * JOINTS.length), this.jointRadii = new Float32Array(JOINTS.length), this.bindMethods(), this.updateReferenceSpace = this.updateReferenceSpace.bind(this), this.el.sceneEl.addEventListener("enter-vr", this.updateReferenceSpace), this.el.sceneEl.addEventListener("exit-vr", this.updateReferenceSpace), this.el.addEventListener("child-attached", this.onChildAttached), this.el.object3D.visible = !1, this.wristObject3D.visible = !1;
            },
            onChildAttached: function(evt) {
              this.addChildEntity(evt.detail.el);
            },
            update: function() {
              this.updateModelMaterial();
            },
            updateModelMaterial: function() {
              var jointEls = this.jointEls, skinnedMesh = this.skinnedMesh, transparent = this.data.modelOpacity !== 1;
              skinnedMesh && (this.skinnedMesh.material.color.set(this.data.modelColor), this.skinnedMesh.material.transparent = transparent, this.skinnedMesh.material.opacity = this.data.modelOpacity);
              for (var i = 0; i < jointEls.length; i++)
                jointEls[i].setAttribute("material", {
                  color: this.data.modelColor,
                  transparent,
                  opacity: this.data.modelOpacity
                });
            },
            updateReferenceSpace: function() {
              var self2 = this, xrSession = this.el.sceneEl.xrSession;
              if (this.referenceSpace = void 0, !!xrSession) {
                var referenceSpaceType = self2.el.sceneEl.systems.webxr.sessionReferenceSpaceType;
                xrSession.requestReferenceSpace(referenceSpaceType).then(function(referenceSpace) {
                  self2.referenceSpace = referenceSpace;
                }).catch(function(error) {
                  throw self2.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(referenceSpaceType, "tracked-controls-webxr uses reference space " + referenceSpaceType), error;
                });
              }
            },
            checkIfControllerPresent: function() {
              var data = this.data, hand = data.hand ? data.hand : void 0;
              checkControllerPresentAndSetup(this, "", {
                hand,
                iterateControllerProfiles: !0,
                handTracking: !0
              });
            },
            play: function() {
              this.checkIfControllerPresent(), this.addControllersUpdateListener();
            },
            tick: function() {
              var sceneEl = this.el.sceneEl, controller = this.el.components["tracked-controls"] && this.el.components["tracked-controls"].controller, frame = sceneEl.frame, trackedControlsWebXR = this.el.components["tracked-controls-webxr"], referenceSpace = this.referenceSpace;
              !controller || !frame || !referenceSpace || !trackedControlsWebXR || (this.hasPoses = !1, controller.hand && (this.el.object3D.position.set(0, 0, 0), this.el.object3D.rotation.set(0, 0, 0), this.hasPoses = frame.fillPoses(controller.hand.values(), referenceSpace, this.jointPoses) && frame.fillJointRadii(controller.hand.values(), this.jointRadii), this.updateHandModel(), this.detectGesture(), this.updateWristObject()));
            },
            updateWristObject: function() {
              var jointPose = new THREE.Matrix4();
              return function() {
                var wristObject3D = this.wristObject3D;
                !wristObject3D || !this.hasPoses || (jointPose.fromArray(this.jointPoses, WRIST_INDEX * 16), wristObject3D.position.setFromMatrixPosition(jointPose), wristObject3D.quaternion.setFromRotationMatrix(jointPose));
              };
            }(),
            updateHandModel: function() {
              this.data.modelStyle === "dots" && this.updateHandDotsModel(), this.data.modelStyle === "mesh" && this.updateHandMeshModel();
            },
            getBone: function(name) {
              for (var bones = this.bones, i = 0; i < bones.length; i++)
                if (bones[i].name === name)
                  return bones[i];
              return null;
            },
            updateHandMeshModel: function() {
              var jointPose = new THREE.Matrix4();
              return function() {
                var i = 0, jointPoses = this.jointPoses, controller = this.el.components["tracked-controls"] && this.el.components["tracked-controls"].controller;
                if (!(!controller || !this.mesh) && (this.mesh.visible = !1, !!this.hasPoses))
                  for (var inputjoint of controller.hand.values()) {
                    var bone = this.getBone(inputjoint.jointName);
                    bone != null && (this.mesh.visible = !0, jointPose.fromArray(jointPoses, i * 16), bone.position.setFromMatrixPosition(jointPose), bone.quaternion.setFromRotationMatrix(jointPose)), i++;
                  }
              };
            }(),
            updateHandDotsModel: function() {
              for (var jointPoses = this.jointPoses, jointRadii = this.jointRadii, controller = this.el.components["tracked-controls"] && this.el.components["tracked-controls"].controller, jointEl, object3D, i = 0; i < controller.hand.size; i++)
                jointEl = this.jointEls[i], object3D = jointEl.object3D, jointEl.object3D.visible = this.hasPoses, !!this.hasPoses && (object3D.matrix.fromArray(jointPoses, i * 16), object3D.matrix.decompose(object3D.position, object3D.rotation, object3D.scale), jointEl.setAttribute("scale", {
                  x: jointRadii[i],
                  y: jointRadii[i],
                  z: jointRadii[i]
                }));
            },
            detectGesture: function() {
              this.detectPinch();
            },
            detectPinch: function() {
              var thumbTipPosition = new THREE.Vector3(), jointPose = new THREE.Matrix4();
              return function() {
                var indexTipPosition = this.indexTipPosition, pinchEventDetail = this.pinchEventDetail;
                if (!!this.hasPoses) {
                  thumbTipPosition.setFromMatrixPosition(jointPose.fromArray(this.jointPoses, THUMB_TIP_INDEX * 16)), indexTipPosition.setFromMatrixPosition(jointPose.fromArray(this.jointPoses, INDEX_TIP_INDEX * 16)), pinchEventDetail.wristRotation.setFromRotationMatrix(jointPose.fromArray(this.jointPoses, WRIST_INDEX * 16));
                  var distance = indexTipPosition.distanceTo(thumbTipPosition);
                  distance < PINCH_START_DISTANCE && this.isPinched === !1 && (this.isPinched = !0, this.pinchDistance = distance, pinchEventDetail.position.copy(indexTipPosition).add(thumbTipPosition).multiplyScalar(0.5), this.el.emit("pinchstarted", pinchEventDetail)), distance > this.pinchDistance + this.pinchDistance * PINCH_END_PERCENTAGE && this.isPinched === !0 && (this.isPinched = !1, pinchEventDetail.position.copy(indexTipPosition).add(thumbTipPosition).multiplyScalar(0.5), this.el.emit("pinchended", pinchEventDetail)), this.isPinched && (pinchEventDetail.position.copy(indexTipPosition).add(thumbTipPosition).multiplyScalar(0.5), this.el.emit("pinchmoved", pinchEventDetail));
                }
              };
            }(),
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            injectTrackedControls: function() {
              var el = this.el, data = this.data;
              if (el.setAttribute("tracked-controls", {
                id: "",
                hand: data.hand,
                iterateControllerProfiles: !0,
                handTrackingEnabled: !0
              }), this.mesh) {
                this.mesh !== el.getObject3D("mesh") && el.setObject3D("mesh", this.mesh);
                return;
              }
              this.initDefaultModel();
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              var el = this.el, controller;
              this.checkIfControllerPresent(), controller = el.components["tracked-controls"] && el.components["tracked-controls"].controller, !!this.mesh && controller && controller.hand && controller.hand instanceof XRHand && el.setObject3D("mesh", this.mesh);
            },
            initDefaultModel: function() {
              var data = this.data;
              data.modelStyle === "dots" && this.initDotsModel(), data.modelStyle === "mesh" && this.initMeshHandModel(), this.el.object3D.visible = !0, this.wristObject3D.visible = !0;
            },
            initDotsModel: function() {
              if (this.jointEls.length === 0) {
                for (var i = 0; i < JOINTS.length; ++i) {
                  var jointEl = this.jointEl = document.createElement("a-entity");
                  jointEl.setAttribute("geometry", {
                    primitive: "sphere",
                    radius: 1
                  }), jointEl.object3D.visible = !1, this.el.appendChild(jointEl), this.jointEls.push(jointEl);
                }
                this.updateModelMaterial();
              }
            },
            initMeshHandModel: function() {
              var modelURL = this.data.hand === "left" ? LEFT_HAND_MODEL_URL : RIGHT_HAND_MODEL_URL;
              this.el.setAttribute("gltf-model", modelURL);
            },
            onModelLoaded: function() {
              var mesh = this.mesh = this.el.getObject3D("mesh").children[0], skinnedMesh = this.skinnedMesh = mesh.getObjectByProperty("type", "SkinnedMesh");
              !this.skinnedMesh || (this.bones = skinnedMesh.skeleton.bones, this.el.removeObject3D("mesh"), mesh.position.set(0, 0, 0), mesh.rotation.set(0, 0, 0), skinnedMesh.frustumCulled = !1, skinnedMesh.material = new THREE.MeshStandardMaterial(), this.updateModelMaterial(), this.setupChildrenEntities(), this.el.setObject3D("mesh", mesh));
            },
            setupChildrenEntities: function() {
              for (var childrenEls = this.el.children, i = 0; i < childrenEls.length; ++i)
                childrenEls[i] instanceof AEntity && this.addChildEntity(childrenEls[i]);
            },
            addChildEntity: function(childEl) {
              childEl instanceof AEntity && this.wristObject3D.add(childEl.object3D);
            }
          });
        },
        "./src/components/hand-tracking-grab-controls.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js");
          registerComponent("hand-tracking-grab-controls", {
            schema: {
              hand: {
                default: "right",
                oneOf: ["left", "right"]
              },
              color: {
                type: "color",
                default: "white"
              },
              hoverColor: {
                type: "color",
                default: "#538df1"
              },
              hoverEnabled: {
                default: !1
              }
            },
            init: function() {
              var el = this.el, data = this.data, trackedObject3DVariable;
              data.hand === "right" ? trackedObject3DVariable = "components.hand-tracking-controls.bones.3" : trackedObject3DVariable = "components.hand-tracking-controls.bones.21", el.setAttribute("hand-tracking-controls", {
                hand: data.hand
              }), el.setAttribute("obb-collider", {
                trackedObject3D: trackedObject3DVariable,
                size: 0.04
              }), this.auxMatrix = new THREE3.Matrix4(), this.auxQuaternion = new THREE3.Quaternion(), this.auxQuaternion2 = new THREE3.Quaternion(), this.auxVector = new THREE3.Vector3(), this.auxVector2 = new THREE3.Vector3(), this.grabbingObjectPosition = new THREE3.Vector3(), this.grabbedObjectPosition = new THREE3.Vector3(), this.grabbedObjectPositionDelta = new THREE3.Vector3(), this.grabDeltaPosition = new THREE3.Vector3(), this.grabInitialRotation = new THREE3.Quaternion(), this.onCollisionStarted = this.onCollisionStarted.bind(this), this.el.addEventListener("obbcollisionstarted", this.onCollisionStarted), this.onCollisionEnded = this.onCollisionEnded.bind(this), this.el.addEventListener("obbcollisionended", this.onCollisionEnded), this.onPinchStarted = this.onPinchStarted.bind(this), this.el.addEventListener("pinchstarted", this.onPinchStarted), this.onPinchEnded = this.onPinchEnded.bind(this), this.el.addEventListener("pinchended", this.onPinchEnded), this.onPinchMoved = this.onPinchMoved.bind(this), this.el.addEventListener("pinchmoved", this.onPinchMoved);
            },
            transferEntityOwnership: function() {
              for (var grabbingElComponent, grabbingEls = this.el.sceneEl.querySelectorAll("[hand-tracking-grab-controls]"), i = 0; i < grabbingEls.length; ++i)
                grabbingElComponent = grabbingEls[i].components["hand-tracking-grab-controls"], grabbingElComponent !== this && this.grabbedEl && this.grabbedEl === grabbingElComponent.grabbedEl && grabbingElComponent.releaseGrabbedEntity();
              return !1;
            },
            onCollisionStarted: function(evt) {
              var withEl = evt.detail.withEl;
              this.collidedEl || !withEl.getAttribute("grabbable") || (this.collidedEl = withEl, this.grabbingObject3D = evt.detail.trackedObject3D, this.data.hoverEnabled && this.el.setAttribute("hand-tracking-controls", "modelColor", this.data.hoverColor));
            },
            onCollisionEnded: function() {
              this.collidedEl = void 0, !this.grabbedEl && (this.grabbingObject3D = void 0, this.data.hoverEnabled && this.el.setAttribute("hand-tracking-controls", "modelColor", this.data.color));
            },
            onPinchStarted: function(evt) {
              !this.collidedEl || (this.pinchPosition = evt.detail.position, this.wristRotation = evt.detail.wristRotation, this.grabbedEl = this.collidedEl, this.transferEntityOwnership(), this.grab());
            },
            onPinchEnded: function() {
              this.releaseGrabbedEntity();
            },
            onPinchMoved: function(evt) {
              this.wristRotation = evt.detail.wristRotation;
            },
            releaseGrabbedEntity: function() {
              var grabbedEl = this.grabbedEl;
              !grabbedEl || (grabbedEl.object3D.updateMatrixWorld = this.originalUpdateMatrixWorld, grabbedEl.object3D.matrixAutoUpdate = !0, grabbedEl.object3D.matrixWorldAutoUpdate = !0, grabbedEl.object3D.matrixWorld.decompose(this.auxVector, this.auxQuaternion, this.auxVector2), grabbedEl.object3D.position.copy(this.auxVector), grabbedEl.object3D.quaternion.copy(this.auxQuaternion), this.el.emit("grabended", {
                grabbedEl
              }), this.grabbedEl = void 0);
            },
            grab: function() {
              var grabbedEl = this.grabbedEl, grabbedObjectWorldPosition;
              grabbedObjectWorldPosition = grabbedEl.object3D.getWorldPosition(this.grabbedObjectPosition), this.grabDeltaPosition.copy(grabbedObjectWorldPosition).sub(this.pinchPosition), this.grabInitialRotation.copy(this.auxQuaternion.copy(this.wristRotation).invert()), this.originalUpdateMatrixWorld = grabbedEl.object3D.updateMatrixWorld, grabbedEl.object3D.updateMatrixWorld = function() {
              }, grabbedEl.object3D.updateMatrixWorldChildren = function(force) {
                for (var children = this.children, i = 0, l = children.length; i < l; i++) {
                  var child = children[i];
                  (child.matrixWorldAutoUpdate === !0 || force === !0) && child.updateMatrixWorld(!0);
                }
              }, grabbedEl.object3D.matrixAutoUpdate = !1, grabbedEl.object3D.matrixWorldAutoUpdate = !1, this.el.emit("grabstarted", {
                grabbedEl
              });
            },
            tock: function() {
              var auxMatrix = this.auxMatrix, auxQuaternion = this.auxQuaternion, auxQuaternion2 = this.auxQuaternion2, grabbedObject3D, grabbedEl = this.grabbedEl;
              !grabbedEl || (grabbedObject3D = grabbedEl.object3D, grabbedObject3D.getWorldQuaternion(auxQuaternion2), grabbedObject3D.matrixWorld.identity(), auxMatrix.identity(), auxMatrix.makeTranslation(this.pinchPosition), grabbedObject3D.matrixWorld.multiply(auxMatrix), auxMatrix.identity(), auxMatrix.makeRotationFromQuaternion(auxQuaternion.copy(this.wristRotation).multiply(this.grabInitialRotation)), grabbedObject3D.matrixWorld.multiply(auxMatrix), auxMatrix.identity(), auxMatrix.makeTranslation(this.grabDeltaPosition), grabbedObject3D.matrixWorld.multiply(auxMatrix), auxMatrix.identity(), auxMatrix.makeRotationFromQuaternion(auxQuaternion2), grabbedObject3D.matrixWorld.multiply(auxMatrix), auxMatrix.makeScale(grabbedEl.object3D.scale.x, grabbedEl.object3D.scale.y, grabbedEl.object3D.scale.z), grabbedObject3D.matrixWorld.multiply(auxMatrix), grabbedObject3D.updateMatrixWorldChildren());
            }
          });
        },
        "./src/components/hide-on-enter-ar.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var register = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = register("hide-on-enter-ar", {
            init: function() {
              var self2 = this;
              this.el.sceneEl.addEventListener("enter-vr", function() {
                self2.el.sceneEl.is("ar-mode") && (self2.el.object3D.visible = !1);
              }), this.el.sceneEl.addEventListener("exit-vr", function() {
                self2.el.object3D.visible = !0;
              });
            }
          });
        },
        "./src/components/hide-on-enter-vr.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var register = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = register("hide-on-enter-vr", {
            init: function() {
              var self2 = this;
              this.el.sceneEl.addEventListener("enter-vr", function() {
                self2.el.sceneEl.is("vr-mode") && (self2.el.object3D.visible = !1);
              }), this.el.sceneEl.addEventListener("exit-vr", function() {
                self2.el.object3D.visible = !0;
              });
            }
          });
        },
        "./src/components/hp-mixed-reality-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged, onButtonEvent = trackedControlsUtils.onButtonEvent, GAMEPAD_ID = "hp-mixed-reality", AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, HP_MIXED_REALITY_MODEL_GLB_BASE_URL = AFRAME_CDN_ROOT + "controllers/hp/mixed-reality/", HP_MIXED_REALITY_POSITION_OFFSET = {
            x: 0,
            y: 0,
            z: 0.06
          }, HP_MIXED_REALITY_ROTATION_OFFSET = {
            _x: Math.PI / 4,
            _y: 0,
            _z: 0,
            _order: "XYZ"
          }, INPUT_MAPPING_WEBXR = {
            left: {
              axes: {
                touchpad: [2, 3]
              },
              buttons: ["trigger", "grip", "none", "thumbstick", "xbutton", "ybutton"]
            },
            right: {
              axes: {
                touchpad: [2, 3]
              },
              buttons: ["trigger", "grip", "none", "thumbstick", "abutton", "bbutton"]
            }
          };
          module3.exports.Component = registerComponent("hp-mixed-reality-controls", {
            schema: {
              hand: {
                default: "none"
              },
              model: {
                default: !0
              },
              orientationOffset: {
                type: "vec3"
              }
            },
            mapping: INPUT_MAPPING_WEBXR,
            init: function() {
              var self2 = this;
              this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(evt) {
                onButtonEvent(evt.detail.id, "down", self2, self2.data.hand);
              }, this.onButtonUp = function(evt) {
                onButtonEvent(evt.detail.id, "up", self2, self2.data.hand);
              }, this.onButtonTouchEnd = function(evt) {
                onButtonEvent(evt.detail.id, "touchend", self2, self2.data.hand);
              }, this.onButtonTouchStart = function(evt) {
                onButtonEvent(evt.detail.id, "touchstart", self2, self2.data.hand);
              }, this.previousButtonValues = {}, this.bindMethods();
            },
            update: function() {
              var data = this.data;
              this.controllerIndex = data.hand === "right" ? 0 : data.hand === "left" ? 1 : 2;
            },
            play: function() {
              this.checkIfControllerPresent(), this.addControllersUpdateListener();
            },
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            bindMethods: function() {
              this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("buttonchanged", this.onButtonChanged), el.addEventListener("buttondown", this.onButtonDown), el.addEventListener("buttonup", this.onButtonUp), el.addEventListener("touchstart", this.onButtonTouchStart), el.addEventListener("touchend", this.onButtonTouchEnd), el.addEventListener("axismove", this.onAxisMoved), el.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0;
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("buttonchanged", this.onButtonChanged), el.removeEventListener("buttondown", this.onButtonDown), el.removeEventListener("buttonup", this.onButtonUp), el.removeEventListener("touchstart", this.onButtonTouchStart), el.removeEventListener("touchend", this.onButtonTouchEnd), el.removeEventListener("axismove", this.onAxisMoved), el.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1;
            },
            checkIfControllerPresent: function() {
              var data = this.data;
              checkControllerPresentAndSetup(this, GAMEPAD_ID, {
                index: this.controllerIndex,
                hand: data.hand
              });
            },
            injectTrackedControls: function() {
              var el = this.el, data = this.data;
              el.setAttribute("tracked-controls", {
                idPrefix: GAMEPAD_ID,
                hand: data.hand,
                controller: this.controllerIndex,
                orientationOffset: data.orientationOffset
              }), !!this.data.model && this.el.setAttribute("gltf-model", HP_MIXED_REALITY_MODEL_GLB_BASE_URL + this.data.hand + ".glb");
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              this.checkIfControllerPresent();
            },
            onButtonChanged: function(evt) {
              var button = this.mapping[this.data.hand].buttons[evt.detail.id], analogValue;
              !button || (button === "trigger" && (analogValue = evt.detail.state.value, console.log("analog value of trigger press: " + analogValue)), this.el.emit(button + "changed", evt.detail.state));
            },
            onModelLoaded: function(evt) {
              var controllerObject3D = evt.detail.model;
              !this.data.model || (controllerObject3D.position.copy(HP_MIXED_REALITY_POSITION_OFFSET), controllerObject3D.rotation.copy(HP_MIXED_REALITY_ROTATION_OFFSET), this.el.emit("controllermodelready", {
                name: "hp-mixed-reality-controls",
                model: this.data.model,
                rayOrigin: new THREE3.Vector3(0, 0, 0)
              }));
            },
            onAxisMoved: function(evt) {
              emitIfAxesChanged(this, this.mapping.axes, evt);
            }
          });
        },
        "./src/components/index.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2("./src/components/animation.js"), __webpack_require__2("./src/components/anchored.js"), __webpack_require__2("./src/components/camera.js"), __webpack_require__2("./src/components/cursor.js"), __webpack_require__2("./src/components/geometry.js"), __webpack_require__2("./src/components/generic-tracked-controller-controls.js"), __webpack_require__2("./src/components/gltf-model.js"), __webpack_require__2("./src/components/grabbable.js"), __webpack_require__2("./src/components/hand-tracking-controls.js"), __webpack_require__2("./src/components/hand-tracking-grab-controls.js"), __webpack_require__2("./src/components/hand-controls.js"), __webpack_require__2("./src/components/hide-on-enter-ar.js"), __webpack_require__2("./src/components/hide-on-enter-vr.js"), __webpack_require__2("./src/components/hp-mixed-reality-controls.js"), __webpack_require__2("./src/components/layer.js"), __webpack_require__2("./src/components/laser-controls.js"), __webpack_require__2("./src/components/light.js"), __webpack_require__2("./src/components/line.js"), __webpack_require__2("./src/components/link.js"), __webpack_require__2("./src/components/look-controls.js"), __webpack_require__2("./src/components/magicleap-controls.js"), __webpack_require__2("./src/components/material.js"), __webpack_require__2("./src/components/obb-collider.js"), __webpack_require__2("./src/components/obj-model.js"), __webpack_require__2("./src/components/oculus-go-controls.js"), __webpack_require__2("./src/components/oculus-touch-controls.js"), __webpack_require__2("./src/components/pico-controls.js"), __webpack_require__2("./src/components/position.js"), __webpack_require__2("./src/components/raycaster.js"), __webpack_require__2("./src/components/rotation.js"), __webpack_require__2("./src/components/scale.js"), __webpack_require__2("./src/components/shadow.js"), __webpack_require__2("./src/components/sound.js"), __webpack_require__2("./src/components/text.js"), __webpack_require__2("./src/components/tracked-controls.js"), __webpack_require__2("./src/components/tracked-controls-webvr.js"), __webpack_require__2("./src/components/tracked-controls-webxr.js"), __webpack_require__2("./src/components/visible.js"), __webpack_require__2("./src/components/valve-index-controls.js"), __webpack_require__2("./src/components/vive-controls.js"), __webpack_require__2("./src/components/vive-focus-controls.js"), __webpack_require__2("./src/components/wasd-controls.js"), __webpack_require__2("./src/components/windows-motion-controls.js"), __webpack_require__2("./src/components/scene/ar-hit-test.js"), __webpack_require__2("./src/components/scene/background.js"), __webpack_require__2("./src/components/scene/debug.js"), __webpack_require__2("./src/components/scene/device-orientation-permission-ui.js"), __webpack_require__2("./src/components/scene/embedded.js"), __webpack_require__2("./src/components/scene/inspector.js"), __webpack_require__2("./src/components/scene/fog.js"), __webpack_require__2("./src/components/scene/keyboard-shortcuts.js"), __webpack_require__2("./src/components/scene/pool.js"), __webpack_require__2("./src/components/scene/real-world-meshing.js"), __webpack_require__2("./src/components/scene/reflection.js"), __webpack_require__2("./src/components/scene/screenshot.js"), __webpack_require__2("./src/components/scene/stats.js"), __webpack_require__2("./src/components/scene/xr-mode-ui.js");
        },
        "./src/components/laser-controls.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, utils = __webpack_require__2("./src/utils/index.js");
          registerComponent("laser-controls", {
            schema: {
              hand: {
                default: "right"
              },
              model: {
                default: !0
              },
              defaultModelColor: {
                type: "color",
                default: "grey"
              }
            },
            init: function() {
              var config = this.config, data = this.data, el = this.el, self2 = this, controlsConfiguration = {
                hand: data.hand,
                model: data.model
              };
              el.setAttribute("hp-mixed-reality-controls", controlsConfiguration), el.setAttribute("magicleap-controls", controlsConfiguration), el.setAttribute("oculus-go-controls", controlsConfiguration), el.setAttribute("oculus-touch-controls", controlsConfiguration), el.setAttribute("pico-controls", controlsConfiguration), el.setAttribute("valve-index-controls", controlsConfiguration), el.setAttribute("vive-controls", controlsConfiguration), el.setAttribute("vive-focus-controls", controlsConfiguration), el.setAttribute("windows-motion-controls", controlsConfiguration), el.setAttribute("generic-tracked-controller-controls", {
                hand: controlsConfiguration.hand
              }), el.addEventListener("controllerconnected", createRay), el.addEventListener("controllerdisconnected", hideRay), el.addEventListener("controllermodelready", function(evt) {
                createRay(evt), self2.modelReady = !0;
              });
              function createRay(evt) {
                var controllerConfig = config[evt.detail.name];
                if (!!controllerConfig) {
                  var raycasterConfig = utils.extend({
                    showLine: !0
                  }, controllerConfig.raycaster || {});
                  evt.detail.rayOrigin && (raycasterConfig.origin = evt.detail.rayOrigin.origin, raycasterConfig.direction = evt.detail.rayOrigin.direction, raycasterConfig.showLine = !0), evt.detail.rayOrigin || !self2.modelReady ? el.setAttribute("raycaster", raycasterConfig) : el.setAttribute("raycaster", "showLine", !0), el.setAttribute("cursor", utils.extend({
                    fuse: !1
                  }, controllerConfig.cursor));
                }
              }
              function hideRay(evt) {
                var controllerConfig = config[evt.detail.name];
                !controllerConfig || el.setAttribute("raycaster", "showLine", !1);
              }
            },
            config: {
              "generic-tracked-controller-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"]
                }
              },
              "hp-mixed-reality-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"]
                },
                raycaster: {
                  origin: {
                    x: 0,
                    y: 0,
                    z: 0
                  }
                }
              },
              "magicleap-controls": {
                cursor: {
                  downEvents: ["trackpaddown", "triggerdown"],
                  upEvents: ["trackpadup", "triggerup"]
                }
              },
              "oculus-go-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"]
                },
                raycaster: {
                  origin: {
                    x: 0,
                    y: 5e-4,
                    z: 0
                  }
                }
              },
              "oculus-touch-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"]
                },
                raycaster: {
                  origin: {
                    x: 0,
                    y: 0,
                    z: 0
                  }
                }
              },
              "pico-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"]
                }
              },
              "valve-index-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"]
                }
              },
              "vive-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"]
                }
              },
              "vive-focus-controls": {
                cursor: {
                  downEvents: ["trackpaddown", "triggerdown"],
                  upEvents: ["trackpadup", "triggerup"]
                }
              },
              "windows-motion-controls": {
                cursor: {
                  downEvents: ["triggerdown"],
                  upEvents: ["triggerup"]
                },
                raycaster: {
                  showLine: !1
                }
              }
            }
          });
        },
        "./src/components/layer.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, utils = __webpack_require__2("./src/utils/index.js"), warn = utils.debug("components:layer:warn");
          module3.exports.Component = registerComponent("layer", {
            schema: {
              type: {
                default: "quad",
                oneOf: ["quad", "monocubemap", "stereocubemap"]
              },
              src: {
                type: "map"
              },
              rotateCubemap: {
                default: !1
              },
              width: {
                default: 0
              },
              height: {
                default: 0
              }
            },
            init: function() {
              var gl = this.el.sceneEl.renderer.getContext();
              this.quaternion = new THREE.Quaternion(), this.position = new THREE.Vector3(), this.bindMethods(), this.needsRedraw = !1, this.frameBuffer = gl.createFramebuffer();
              var webxrData = this.el.sceneEl.getAttribute("webxr"), requiredFeaturesArray = webxrData.requiredFeatures;
              requiredFeaturesArray.indexOf("layers") === -1 && (requiredFeaturesArray.push("layers"), this.el.sceneEl.setAttribute("webxr", webxrData)), this.el.sceneEl.addEventListener("enter-vr", this.onEnterVR), this.el.sceneEl.addEventListener("exit-vr", this.onExitVR);
            },
            bindMethods: function() {
              this.onRequestedReferenceSpace = this.onRequestedReferenceSpace.bind(this), this.onEnterVR = this.onEnterVR.bind(this), this.onExitVR = this.onExitVR.bind(this);
            },
            update: function(oldData) {
              this.data.src !== oldData.src && this.updateSrc();
            },
            updateSrc: function() {
              var type = this.data.type;
              if (this.texture = void 0, type === "quad") {
                this.loadQuadImage();
                return;
              }
              if (type === "monocubemap" || type === "stereocubemap") {
                this.loadCubeMapImages();
                return;
              }
            },
            loadCubeMapImages: function() {
              var glayer, xrGLFactory = this.xrGLFactory, frame = this.el.sceneEl.frame, src = this.data.src, type = this.data.type;
              this.visibilityChanged = !1, !!this.layer && (type !== "monocubemap" && type !== "stereocubemap" || (src.complete ? this.pendingCubeMapUpdate = !1 : this.pendingCubeMapUpdate = !0, this.loadingScreen ? this.loadingScreen = !1 : this.loadingScreen = !0, type === "monocubemap" ? (glayer = xrGLFactory.getSubImage(this.layer, frame), this.loadCubeMapImage(glayer.colorTexture, src, 0)) : (glayer = xrGLFactory.getSubImage(this.layer, frame, "left"), this.loadCubeMapImage(glayer.colorTexture, src, 0), glayer = xrGLFactory.getSubImage(this.layer, frame, "right"), this.loadCubeMapImage(glayer.colorTexture, src, 6))));
            },
            loadQuadImage: function() {
              var src = this.data.src, self2 = this;
              this.el.sceneEl.systems.material.loadTexture(src, {
                src
              }, function(texture) {
                self2.el.sceneEl.renderer.initTexture(texture), self2.texture = texture, src.tagName === "VIDEO" && setTimeout(function() {
                  self2.textureIsVideo = !0;
                }, 1e3), self2.layer && (self2.layer.height = self2.data.height / 2 || self2.texture.image.height / 1e3, self2.layer.width = self2.data.width / 2 || self2.texture.image.width / 1e3, self2.needsRedraw = !0), self2.updateQuadPanel();
              });
            },
            preGenerateCubeMapTextures: function(src, callback) {
              this.data.type === "monocubemap" ? this.generateCubeMapTextures(src, 0, callback) : (this.generateCubeMapTextures(src, 0, callback), this.generateCubeMapTextures(src, 6, callback));
            },
            generateCubeMapTextures: function(src, faceOffset, callback) {
              for (var data = this.data, cubeFaceSize = this.cubeFaceSize, textureSourceCubeFaceSize = Math.min(src.width, src.height), cubefaceTextures = [], imgTmp0, imgTmp2, i = 0; i < 6; i++) {
                var tempCanvas = document.createElement("CANVAS");
                tempCanvas.width = tempCanvas.height = cubeFaceSize;
                var tempCanvasContext = tempCanvas.getContext("2d");
                data.rotateCubemap && (i === 2 || i === 3) && (tempCanvasContext.save(), tempCanvasContext.translate(cubeFaceSize, cubeFaceSize), tempCanvasContext.rotate(Math.PI)), tempCanvasContext.drawImage(src, (i + faceOffset) * textureSourceCubeFaceSize, 0, textureSourceCubeFaceSize, textureSourceCubeFaceSize, 0, 0, cubeFaceSize, cubeFaceSize), tempCanvasContext.restore(), callback && callback(), cubefaceTextures.push(tempCanvas);
              }
              return data.rotateCubemap && (imgTmp0 = cubefaceTextures[0], imgTmp2 = cubefaceTextures[1], cubefaceTextures[0] = imgTmp2, cubefaceTextures[1] = imgTmp0, imgTmp0 = cubefaceTextures[4], imgTmp2 = cubefaceTextures[5], cubefaceTextures[4] = imgTmp2, cubefaceTextures[5] = imgTmp0), callback && callback(), cubefaceTextures;
            },
            loadCubeMapImage: function(layerColorTexture, src, faceOffset) {
              var gl = this.el.sceneEl.renderer.getContext(), cubefaceTextures;
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !1), gl.bindTexture(gl.TEXTURE_CUBE_MAP, layerColorTexture), !src.complete || this.loadingScreen ? cubefaceTextures = this.loadingScreenImages : cubefaceTextures = this.generateCubeMapTextures(src, faceOffset);
              var errorCode = 0;
              cubefaceTextures.forEach(function(canvas, i) {
                gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas), errorCode = gl.getError();
              }), errorCode !== 0 && console.log("renderingError, WebGL Error Code: " + errorCode), gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            },
            tick: function() {
              !this.el.sceneEl.xrSession || (!this.layer && (this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode")) && this.initLayer(), this.updateTransform(), this.data.src.complete && (this.pendingCubeMapUpdate || this.loadingScreen || this.visibilityChanged) && this.loadCubeMapImages(), !(!this.needsRedraw && !this.layer.needsRedraw && !this.textureIsVideo) && (this.data.type === "quad" && this.draw(), this.needsRedraw = !1));
            },
            initLayer: function() {
              var self2 = this, type = this.data.type;
              if (this.el.sceneEl.xrSession.onvisibilitychange = function(evt) {
                self2.visibilityChanged = evt.session.visibilityState !== "hidden";
              }, type === "quad") {
                this.initQuadLayer();
                return;
              }
              if (type === "monocubemap" || type === "stereocubemap") {
                this.initCubeMapLayer();
                return;
              }
            },
            initQuadLayer: function() {
              var sceneEl = this.el.sceneEl, gl = sceneEl.renderer.getContext(), xrGLFactory = this.xrGLFactory = new XRWebGLBinding(sceneEl.xrSession, gl);
              !this.texture || (this.layer = xrGLFactory.createQuadLayer({
                space: this.referenceSpace,
                viewPixelHeight: 2048,
                viewPixelWidth: 2048,
                height: this.data.height / 2 || this.texture.image.height / 1e3,
                width: this.data.width / 2 || this.texture.image.width / 1e3
              }), this.initLoadingScreenImages(), sceneEl.renderer.xr.addLayer(this.layer));
            },
            initCubeMapLayer: function() {
              var src = this.data.src, sceneEl = this.el.sceneEl, gl = sceneEl.renderer.getContext(), glSizeLimit = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE), cubeFaceSize = this.cubeFaceSize = Math.min(glSizeLimit, Math.min(src.width, src.height)), xrGLFactory = this.xrGLFactory = new XRWebGLBinding(sceneEl.xrSession, gl);
              this.layer = xrGLFactory.createCubeLayer({
                space: this.referenceSpace,
                viewPixelWidth: cubeFaceSize,
                viewPixelHeight: cubeFaceSize,
                layout: this.data.type === "monocubemap" ? "mono" : "stereo",
                isStatic: !1
              }), this.initLoadingScreenImages(), this.loadCubeMapImages(), sceneEl.renderer.xr.addLayer(this.layer);
            },
            initLoadingScreenImages: function() {
              for (var cubeFaceSize = this.cubeFaceSize, loadingScreenImages = this.loadingScreenImages = [], i = 0; i < 6; i++) {
                var tempCanvas = document.createElement("CANVAS");
                tempCanvas.width = tempCanvas.height = cubeFaceSize;
                var tempCanvasContext = tempCanvas.getContext("2d");
                tempCanvas.width = tempCanvas.height = cubeFaceSize, tempCanvasContext.fillStyle = "black", tempCanvasContext.fillRect(0, 0, cubeFaceSize, cubeFaceSize), i !== 2 && i !== 3 && (tempCanvasContext.translate(cubeFaceSize, 0), tempCanvasContext.scale(-1, 1), tempCanvasContext.fillStyle = "white", tempCanvasContext.font = "30px Arial", tempCanvasContext.fillText("Loading", cubeFaceSize / 2, cubeFaceSize / 2)), loadingScreenImages.push(tempCanvas);
              }
            },
            destroyLayer: function() {
              !this.layer || (this.el.sceneEl.renderer.xr.removeLayer(this.layer), this.layer.destroy(), this.layer = void 0);
            },
            toggleCompositorLayer: function() {
              this.enableCompositorLayer(!this.layerEnabled);
            },
            enableCompositorLayer: function(enable) {
              this.layerEnabled = enable, this.quadPanelEl.object3D.visible = !this.layerEnabled;
            },
            updateQuadPanel: function() {
              var quadPanelEl = this.quadPanelEl;
              this.quadPanelEl || (quadPanelEl = this.quadPanelEl = document.createElement("a-entity"), this.el.appendChild(quadPanelEl)), quadPanelEl.setAttribute("material", {
                shader: "flat",
                src: this.data.src,
                transparent: !0
              }), quadPanelEl.setAttribute("geometry", {
                primitive: "plane",
                height: this.data.height || this.texture.image.height / 1e3,
                width: this.data.width || this.texture.image.height / 1e3
              });
            },
            draw: function() {
              var sceneEl = this.el.sceneEl, gl = this.el.sceneEl.renderer.getContext(), glayer = this.xrGLFactory.getSubImage(this.layer, sceneEl.frame), texture = sceneEl.renderer.properties.get(this.texture).__webglTexture, previousFrameBuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
              gl.viewport(glayer.viewport.x, glayer.viewport.y, glayer.viewport.width, glayer.viewport.height), gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glayer.colorTexture, 0), blitTexture(gl, texture, glayer, this.data.src), gl.bindFramebuffer(gl.FRAMEBUFFER, previousFrameBuffer);
            },
            updateTransform: function() {
              var el = this.el, position = this.position, quaternion = this.quaternion;
              el.object3D.updateMatrixWorld(), position.setFromMatrixPosition(el.object3D.matrixWorld), quaternion.setFromRotationMatrix(el.object3D.matrixWorld), this.layerEnabled || position.set(0, 0, 1e8), this.layer.transform = new XRRigidTransform(position, quaternion);
            },
            onEnterVR: function() {
              var sceneEl = this.el.sceneEl, xrSession = sceneEl.xrSession;
              if (!sceneEl.hasWebXR || !XRWebGLBinding || !xrSession) {
                warn("The layer component requires WebXR and the layers API enabled");
                return;
              }
              xrSession.requestReferenceSpace("local-floor").then(this.onRequestedReferenceSpace), this.layerEnabled = !0, this.quadPanelEl && (this.quadPanelEl.object3D.visible = !1), this.data.src.play && this.data.src.play();
            },
            onExitVR: function() {
              this.quadPanelEl && (this.quadPanelEl.object3D.visible = !0), this.destroyLayer();
            },
            onRequestedReferenceSpace: function(referenceSpace) {
              this.referenceSpace = referenceSpace;
            }
          });
          function blitTexture(gl, texture, subImage, textureEl) {
            var xrReadFramebuffer = gl.createFramebuffer(), x1offset = subImage.viewport.x, y1offset = subImage.viewport.y, x2offset = subImage.viewport.x + subImage.viewport.width, y2offset = subImage.viewport.y + subImage.viewport.height;
            textureEl.tagName === "VIDEO" && (gl.bindTexture(gl.TEXTURE_2D, texture), gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, textureEl.width, textureEl.height, gl.RGB, gl.UNSIGNED_BYTE, textureEl)), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, xrReadFramebuffer), gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0), gl.readBuffer(gl.COLOR_ATTACHMENT0), gl.blitFramebuffer(0, 0, textureEl.width, textureEl.height, x1offset, y1offset, x2offset, y2offset, gl.COLOR_BUFFER_BIT, gl.NEAREST), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null), gl.deleteFramebuffer(xrReadFramebuffer);
          }
        },
        "./src/components/light.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var utils = __webpack_require__2("./src/utils/index.js"), diff = utils.diff, debug = __webpack_require__2("./src/utils/debug.js"), registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), mathUtils = __webpack_require__2("./src/utils/math.js"), degToRad = THREE3.MathUtils.degToRad, warn = debug("components:light:warn"), CubeLoader = new THREE3.CubeTextureLoader(), probeCache = {};
          module3.exports.Component = registerComponent("light", {
            schema: {
              angle: {
                default: 60,
                if: {
                  type: ["spot"]
                }
              },
              color: {
                type: "color",
                if: {
                  type: ["ambient", "directional", "hemisphere", "point", "spot"]
                }
              },
              envMap: {
                default: "",
                if: {
                  type: ["probe"]
                }
              },
              groundColor: {
                type: "color",
                if: {
                  type: ["hemisphere"]
                }
              },
              decay: {
                default: 1,
                if: {
                  type: ["point", "spot"]
                }
              },
              distance: {
                default: 0,
                min: 0,
                if: {
                  type: ["point", "spot"]
                }
              },
              intensity: {
                default: 1,
                min: 0,
                if: {
                  type: ["ambient", "directional", "hemisphere", "point", "spot", "probe"]
                }
              },
              penumbra: {
                default: 0,
                min: 0,
                max: 1,
                if: {
                  type: ["spot"]
                }
              },
              type: {
                default: "directional",
                oneOf: ["ambient", "directional", "hemisphere", "point", "spot", "probe"],
                schemaChange: !0
              },
              target: {
                type: "selector",
                if: {
                  type: ["spot", "directional"]
                }
              },
              castShadow: {
                default: !1,
                if: {
                  type: ["point", "spot", "directional"]
                }
              },
              shadowBias: {
                default: 0,
                if: {
                  castShadow: !0
                }
              },
              shadowCameraFar: {
                default: 500,
                if: {
                  castShadow: !0
                }
              },
              shadowCameraFov: {
                default: 90,
                if: {
                  castShadow: !0
                }
              },
              shadowCameraNear: {
                default: 0.5,
                if: {
                  castShadow: !0
                }
              },
              shadowCameraTop: {
                default: 5,
                if: {
                  castShadow: !0
                }
              },
              shadowCameraRight: {
                default: 5,
                if: {
                  castShadow: !0
                }
              },
              shadowCameraBottom: {
                default: -5,
                if: {
                  castShadow: !0
                }
              },
              shadowCameraLeft: {
                default: -5,
                if: {
                  castShadow: !0
                }
              },
              shadowCameraVisible: {
                default: !1,
                if: {
                  castShadow: !0
                }
              },
              shadowCameraAutomatic: {
                default: "",
                if: {
                  type: ["directional"]
                }
              },
              shadowMapHeight: {
                default: 512,
                if: {
                  castShadow: !0
                }
              },
              shadowMapWidth: {
                default: 512,
                if: {
                  castShadow: !0
                }
              },
              shadowRadius: {
                default: 1,
                if: {
                  castShadow: !0
                }
              }
            },
            init: function() {
              var el = this.el;
              this.light = null, this.defaultTarget = null, this.system.registerLight(el);
            },
            update: function(oldData) {
              var data = this.data, diffData = diff(data, oldData), light = this.light, self2 = this;
              if (light && !("type" in diffData)) {
                var shadowsLoaded = !1;
                Object.keys(diffData).forEach(function(key) {
                  var value = data[key];
                  switch (key) {
                    case "color": {
                      light.color.set(value);
                      break;
                    }
                    case "groundColor": {
                      light.groundColor.set(value);
                      break;
                    }
                    case "angle": {
                      light.angle = degToRad(value);
                      break;
                    }
                    case "target": {
                      value === null ? (data.type === "spot" || data.type === "directional") && (light.target = self2.defaultTarget) : value.hasLoaded ? self2.onSetTarget(value, light) : value.addEventListener("loaded", self2.onSetTarget.bind(self2, value, light));
                      break;
                    }
                    case "envMap":
                      self2.updateProbeMap(data, light);
                      break;
                    case "castShadow":
                    case "shadowBias":
                    case "shadowCameraFar":
                    case "shadowCameraFov":
                    case "shadowCameraNear":
                    case "shadowCameraTop":
                    case "shadowCameraRight":
                    case "shadowCameraBottom":
                    case "shadowCameraLeft":
                    case "shadowCameraVisible":
                    case "shadowMapHeight":
                    case "shadowMapWidth":
                    case "shadowRadius":
                      shadowsLoaded || (self2.updateShadow(), shadowsLoaded = !0);
                      break;
                    case "shadowCameraAutomatic":
                      data.shadowCameraAutomatic ? self2.shadowCameraAutomaticEls = Array.from(document.querySelectorAll(data.shadowCameraAutomatic)) : self2.shadowCameraAutomaticEls = [];
                      break;
                    default:
                      light[key] = value;
                  }
                });
                return;
              }
              this.setLight(this.data), this.updateShadow();
            },
            tick: function() {
              var bbox = new THREE3.Box3(), normal = new THREE3.Vector3(), cameraWorldPosition = new THREE3.Vector3(), tempMat = new THREE3.Matrix4(), sphere = new THREE3.Sphere(), tempVector = new THREE3.Vector3();
              return function() {
                if (!!(this.data.type === "directional" && this.light.shadow && this.light.shadow.camera instanceof THREE3.OrthographicCamera && this.shadowCameraAutomaticEls.length)) {
                  var camera = this.light.shadow.camera;
                  camera.getWorldDirection(normal), camera.getWorldPosition(cameraWorldPosition), tempMat.copy(camera.matrixWorld), tempMat.invert(), camera.near = 1, camera.left = 1e5, camera.right = -1e5, camera.top = -1e5, camera.bottom = 1e5, this.shadowCameraAutomaticEls.forEach(function(el) {
                    bbox.setFromObject(el.object3D), bbox.getBoundingSphere(sphere);
                    var distanceToPlane = mathUtils.distanceOfPointFromPlane(cameraWorldPosition, normal, sphere.center), pointOnCameraPlane = mathUtils.nearestPointInPlane(cameraWorldPosition, normal, sphere.center, tempVector), pointInXYPlane = pointOnCameraPlane.applyMatrix4(tempMat);
                    camera.near = Math.min(-distanceToPlane - sphere.radius - 1, camera.near), camera.left = Math.min(-sphere.radius + pointInXYPlane.x, camera.left), camera.right = Math.max(sphere.radius + pointInXYPlane.x, camera.right), camera.top = Math.max(sphere.radius + pointInXYPlane.y, camera.top), camera.bottom = Math.min(-sphere.radius + pointInXYPlane.y, camera.bottom);
                  }), camera.updateProjectionMatrix();
                }
              };
            }(),
            setLight: function(data) {
              var el = this.el, newLight = this.getLight(data);
              newLight && (this.light && el.removeObject3D("light"), this.light = newLight, this.light.el = el, el.setObject3D("light", this.light), (data.type === "spot" || data.type === "directional" || data.type === "hemisphere") && el.getObject3D("light").translateY(-1), data.type === "spot" && (el.setObject3D("light-target", this.defaultTarget), el.getObject3D("light-target").position.set(0, 0, -1)), data.shadowCameraAutomatic ? this.shadowCameraAutomaticEls = Array.from(document.querySelectorAll(data.shadowCameraAutomatic)) : this.shadowCameraAutomaticEls = []);
            },
            updateShadow: function() {
              var el = this.el, data = this.data, light = this.light;
              light.castShadow = data.castShadow;
              var cameraHelper = el.getObject3D("cameraHelper");
              if (data.shadowCameraVisible && !cameraHelper ? el.setObject3D("cameraHelper", new THREE3.CameraHelper(light.shadow.camera)) : !data.shadowCameraVisible && cameraHelper && el.removeObject3D("cameraHelper"), !data.castShadow)
                return light;
              light.shadow.bias = data.shadowBias, light.shadow.radius = data.shadowRadius, light.shadow.mapSize.height = data.shadowMapHeight, light.shadow.mapSize.width = data.shadowMapWidth, light.shadow.camera.near = data.shadowCameraNear, light.shadow.camera.far = data.shadowCameraFar, light.shadow.camera instanceof THREE3.OrthographicCamera ? (light.shadow.camera.top = data.shadowCameraTop, light.shadow.camera.right = data.shadowCameraRight, light.shadow.camera.bottom = data.shadowCameraBottom, light.shadow.camera.left = data.shadowCameraLeft) : light.shadow.camera.fov = data.shadowCameraFov, light.shadow.camera.updateProjectionMatrix(), cameraHelper && cameraHelper.update();
            },
            getLight: function(data) {
              var angle = data.angle, color = new THREE3.Color(data.color);
              color = color.getHex();
              var decay = data.decay, distance = data.distance, groundColor = new THREE3.Color(data.groundColor);
              groundColor = groundColor.getHex();
              var intensity = data.intensity, type = data.type, target = data.target, light = null;
              switch (type.toLowerCase()) {
                case "ambient":
                  return new THREE3.AmbientLight(color, intensity);
                case "directional":
                  return light = new THREE3.DirectionalLight(color, intensity), this.defaultTarget = light.target, target && (target.hasLoaded ? this.onSetTarget(target, light) : target.addEventListener("loaded", this.onSetTarget.bind(this, target, light))), light;
                case "hemisphere":
                  return new THREE3.HemisphereLight(color, groundColor, intensity);
                case "point":
                  return new THREE3.PointLight(color, intensity, distance, decay);
                case "spot":
                  return light = new THREE3.SpotLight(color, intensity, distance, degToRad(angle), data.penumbra, decay), this.defaultTarget = light.target, target && (target.hasLoaded ? this.onSetTarget(target, light) : target.addEventListener("loaded", this.onSetTarget.bind(this, target, light))), light;
                case "probe":
                  return light = new THREE3.LightProbe(), this.updateProbeMap(data, light), light;
                default:
                  warn("%s is not a valid light type. Choose from ambient, directional, hemisphere, point, spot.", type);
              }
            },
            updateProbeMap: function(data, light) {
              data.envMap || light.copy(new THREE3.LightProbe()), probeCache[data.envMap] instanceof window.Promise && probeCache[data.envMap].then(function(tempLightProbe) {
                light.copy(tempLightProbe);
              }), probeCache[data.envMap] instanceof THREE3.LightProbe && light.copy(probeCache[data.envMap]), probeCache[data.envMap] = new window.Promise(function(resolve) {
                utils.srcLoader.validateCubemapSrc(data.envMap, function(urls) {
                  CubeLoader.load(urls, function(cube) {
                    var tempLightProbe = THREE3.LightProbeGenerator.fromCubeTexture(cube);
                    probeCache[data.envMap] = tempLightProbe, light.copy(tempLightProbe);
                  });
                });
              });
            },
            onSetTarget: function(targetEl, light) {
              light.target = targetEl.object3D;
            },
            remove: function() {
              var el = this.el;
              el.removeObject3D("light"), el.getObject3D("cameraHelper") && el.removeObject3D("cameraHelper");
            }
          });
        },
        "./src/components/line.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = registerComponent("line", {
            schema: {
              start: {
                type: "vec3",
                default: {
                  x: 0,
                  y: 0,
                  z: 0
                }
              },
              end: {
                type: "vec3",
                default: {
                  x: 0,
                  y: 0,
                  z: 0
                }
              },
              color: {
                type: "color",
                default: "#74BEC1"
              },
              opacity: {
                type: "number",
                default: 1
              },
              visible: {
                default: !0
              }
            },
            multiple: !0,
            init: function() {
              var data = this.data, geometry, material;
              material = this.material = new THREE.LineBasicMaterial({
                color: data.color,
                opacity: data.opacity,
                transparent: data.opacity < 1,
                visible: data.visible
              }), geometry = this.geometry = new THREE.BufferGeometry(), geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(2 * 3), 3)), this.line = new THREE.Line(geometry, material), this.el.setObject3D(this.attrName, this.line);
            },
            update: function(oldData) {
              var data = this.data, geometry = this.geometry, geoNeedsUpdate = !1, material = this.material, positionArray = geometry.attributes.position.array;
              isEqualVec3(data.start, oldData.start) || (positionArray[0] = data.start.x, positionArray[1] = data.start.y, positionArray[2] = data.start.z, geoNeedsUpdate = !0), isEqualVec3(data.end, oldData.end) || (positionArray[3] = data.end.x, positionArray[4] = data.end.y, positionArray[5] = data.end.z, geoNeedsUpdate = !0), geoNeedsUpdate && (geometry.attributes.position.needsUpdate = !0, geometry.computeBoundingSphere()), material.color.setStyle(data.color), material.opacity = data.opacity, material.transparent = data.opacity < 1, material.visible = data.visible;
            },
            remove: function() {
              this.el.removeObject3D(this.attrName, this.line);
            }
          });
          function isEqualVec3(a, b) {
            return !a || !b ? !1 : a.x === b.x && a.y === b.y && a.z === b.z;
          }
        },
        "./src/components/link.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, registerShader = __webpack_require__2("./src/core/shader.js").registerShader, THREE3 = __webpack_require__2("./src/lib/three.js");
          module3.exports.Component = registerComponent("link", {
            schema: {
              backgroundColor: {
                default: "red",
                type: "color"
              },
              borderColor: {
                default: "white",
                type: "color"
              },
              highlighted: {
                default: !1
              },
              highlightedColor: {
                default: "#24CAFF",
                type: "color"
              },
              href: {
                default: ""
              },
              image: {
                type: "asset"
              },
              on: {
                default: "click"
              },
              peekMode: {
                default: !1
              },
              title: {
                default: ""
              },
              titleColor: {
                default: "white",
                type: "color"
              },
              visualAspectEnabled: {
                default: !1
              }
            },
            init: function() {
              this.navigate = this.navigate.bind(this), this.previousQuaternion = void 0, this.quaternionClone = new THREE3.Quaternion(), this.hiddenEls = [];
            },
            update: function(oldData) {
              var data = this.data, el = this.el, backgroundColor, strokeColor;
              !data.visualAspectEnabled || (this.initVisualAspect(), backgroundColor = data.highlighted ? data.highlightedColor : data.backgroundColor, strokeColor = data.highlighted ? data.highlightedColor : data.borderColor, el.setAttribute("material", "backgroundColor", backgroundColor), el.setAttribute("material", "strokeColor", strokeColor), data.on !== oldData.on && this.updateEventListener(), oldData.peekMode !== void 0 && data.peekMode !== oldData.peekMode && this.updatePeekMode(), !(!data.image || oldData.image === data.image) && el.setAttribute("material", "pano", typeof data.image == "string" ? data.image : data.image.src));
            },
            updatePeekMode: function() {
              var el = this.el, sphereEl = this.sphereEl;
              this.data.peekMode ? (this.hideAll(), el.getObject3D("mesh").visible = !1, sphereEl.setAttribute("visible", !0)) : (this.showAll(), el.getObject3D("mesh").visible = !0, sphereEl.setAttribute("visible", !1));
            },
            play: function() {
              this.updateEventListener();
            },
            pause: function() {
              this.removeEventListener();
            },
            updateEventListener: function() {
              var el = this.el;
              !el.isPlaying || (this.removeEventListener(), el.addEventListener(this.data.on, this.navigate));
            },
            removeEventListener: function() {
              var on = this.data.on;
              !on || this.el.removeEventListener(on, this.navigate);
            },
            initVisualAspect: function() {
              var el = this.el, semiSphereEl, sphereEl, textEl;
              !this.data.visualAspectEnabled || this.visualAspectInitialized || (textEl = this.textEl = this.textEl || document.createElement("a-entity"), sphereEl = this.sphereEl = this.sphereEl || document.createElement("a-entity"), semiSphereEl = this.semiSphereEl = this.semiSphereEl || document.createElement("a-entity"), el.setAttribute("geometry", {
                primitive: "circle",
                radius: 1,
                segments: 64
              }), el.setAttribute("material", {
                shader: "portal",
                pano: this.data.image,
                side: "double"
              }), textEl.setAttribute("text", {
                color: this.data.titleColor,
                align: "center",
                font: "kelsonsans",
                value: this.data.title || this.data.href,
                width: 4
              }), textEl.setAttribute("position", "0 1.5 0"), el.appendChild(textEl), semiSphereEl.setAttribute("geometry", {
                primitive: "sphere",
                radius: 1,
                phiStart: 0,
                segmentsWidth: 64,
                segmentsHeight: 64,
                phiLength: 180,
                thetaStart: 0,
                thetaLength: 360
              }), semiSphereEl.setAttribute("material", {
                shader: "portal",
                borderEnabled: 0,
                pano: this.data.image,
                side: "back"
              }), semiSphereEl.setAttribute("rotation", "0 180 0"), semiSphereEl.setAttribute("position", "0 0 0"), semiSphereEl.setAttribute("visible", !1), el.appendChild(semiSphereEl), sphereEl.setAttribute("geometry", {
                primitive: "sphere",
                radius: 10,
                segmentsWidth: 64,
                segmentsHeight: 64
              }), sphereEl.setAttribute("material", {
                shader: "portal",
                borderEnabled: 0,
                pano: this.data.image,
                side: "back"
              }), sphereEl.setAttribute("visible", !1), el.appendChild(sphereEl), this.visualAspectInitialized = !0);
            },
            navigate: function() {
              window.location = this.data.href;
            },
            tick: function() {
              var cameraWorldPosition = new THREE3.Vector3(), elWorldPosition = new THREE3.Vector3(), quaternion = new THREE3.Quaternion(), scale = new THREE3.Vector3();
              return function() {
                var el = this.el, object3D = el.object3D, camera = el.sceneEl.camera, cameraPortalOrientation, distance, textEl = this.textEl;
                if (!!this.data.visualAspectEnabled)
                  if (object3D.updateMatrixWorld(), camera.parent.updateMatrixWorld(), camera.updateMatrixWorld(), object3D.matrix.decompose(elWorldPosition, quaternion, scale), elWorldPosition.setFromMatrixPosition(object3D.matrixWorld), cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld), distance = elWorldPosition.distanceTo(cameraWorldPosition), distance > 20)
                    this.previousQuaternion || (this.quaternionClone.copy(quaternion), this.previousQuaternion = this.quaternionClone), object3D.lookAt(cameraWorldPosition);
                  else {
                    if (cameraPortalOrientation = this.calculateCameraPortalOrientation(), distance < 0.5) {
                      if (this.semiSphereEl.getAttribute("visible") === !0)
                        return;
                      textEl.setAttribute("text", "width", 1.5), cameraPortalOrientation <= 0 ? (textEl.setAttribute("position", "0 0 0.75"), textEl.setAttribute("rotation", "0 180 0"), this.semiSphereEl.setAttribute("rotation", "0 0 0")) : (textEl.setAttribute("position", "0 0 -0.75"), textEl.setAttribute("rotation", "0 0 0"), this.semiSphereEl.setAttribute("rotation", "0 180 0")), el.getObject3D("mesh").visible = !1, this.semiSphereEl.setAttribute("visible", !0), this.peekCameraPortalOrientation = cameraPortalOrientation;
                    } else
                      cameraPortalOrientation <= 0 ? textEl.setAttribute("rotation", "0 180 0") : textEl.setAttribute("rotation", "0 0 0"), textEl.setAttribute("text", "width", 5), textEl.setAttribute("position", "0 1.5 0"), el.getObject3D("mesh").visible = !0, this.semiSphereEl.setAttribute("visible", !1), this.peekCameraPortalOrientation = void 0;
                    this.previousQuaternion && (object3D.quaternion.copy(this.previousQuaternion), this.previousQuaternion = void 0);
                  }
              };
            }(),
            hideAll: function() {
              var el = this.el, hiddenEls = this.hiddenEls, self2 = this;
              hiddenEls.length > 0 || el.sceneEl.object3D.traverse(function(object) {
                object && object.el && object.el.hasAttribute("link-controls") || !object.el || object === el.sceneEl.object3D || object.el === el || object.el === self2.sphereEl || object.el === el.sceneEl.cameraEl || object.el.getAttribute("visible") === !1 || object.el === self2.textEl || object.el === self2.semiSphereEl || (object.el.setAttribute("visible", !1), hiddenEls.push(object.el));
              });
            },
            showAll: function() {
              this.hiddenEls.forEach(function(el) {
                el.setAttribute("visible", !0);
              }), this.hiddenEls = [];
            },
            calculateCameraPortalOrientation: function() {
              var mat4 = new THREE3.Matrix4(), cameraPosition = new THREE3.Vector3(), portalNormal = new THREE3.Vector3(0, 0, 1), portalPosition = new THREE3.Vector3(0, 0, 0);
              return function() {
                var el = this.el, camera = el.sceneEl.camera;
                return cameraPosition.set(0, 0, 0), portalNormal.set(0, 0, 1), portalPosition.set(0, 0, 0), el.object3D.matrixWorld.extractRotation(mat4), portalNormal.applyMatrix4(mat4), el.object3D.updateMatrixWorld(), el.object3D.localToWorld(portalPosition), camera.parent.parent.updateMatrixWorld(), camera.parent.updateMatrixWorld(), camera.updateMatrixWorld(), camera.localToWorld(cameraPosition), cameraPosition.sub(portalPosition).normalize(), portalNormal.normalize(), Math.sign(portalNormal.dot(cameraPosition));
              };
            }(),
            remove: function() {
              this.removeEventListener();
            }
          }), registerShader("portal", {
            schema: {
              borderEnabled: {
                default: 1,
                type: "int",
                is: "uniform"
              },
              backgroundColor: {
                default: "red",
                type: "color",
                is: "uniform"
              },
              pano: {
                type: "map",
                is: "uniform"
              },
              strokeColor: {
                default: "white",
                type: "color",
                is: "uniform"
              }
            },
            vertexShader: ["vec3 portalPosition;", "varying vec3 vWorldPosition;", "varying float vDistanceToCenter;", "varying float vDistance;", "void main() {", "vDistanceToCenter = clamp(length(position - vec3(0.0, 0.0, 0.0)), 0.0, 1.0);", "portalPosition = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;", "vDistance = length(portalPosition - cameraPosition);", "vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;", "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join(`
`),
            fragmentShader: ["#define RECIPROCAL_PI2 0.15915494", "uniform sampler2D pano;", "uniform vec3 strokeColor;", "uniform vec3 backgroundColor;", "uniform float borderEnabled;", "varying float vDistanceToCenter;", "varying float vDistance;", "varying vec3 vWorldPosition;", "void main() {", "vec3 direction = normalize(vWorldPosition - cameraPosition);", "vec2 sampleUV;", "float borderThickness = clamp(exp(-vDistance / 50.0), 0.6, 0.95);", "sampleUV.y = clamp(direction.y * 0.5  + 0.5, 0.0, 1.0);", "sampleUV.x = atan(direction.z, -direction.x) * -RECIPROCAL_PI2 + 0.5;", "if (vDistanceToCenter > borderThickness && borderEnabled == 1.0) {", "gl_FragColor = vec4(strokeColor, 1.0);", "} else {", "gl_FragColor = mix(texture2D(pano, sampleUV), vec4(backgroundColor, 1.0), clamp(pow((vDistance / 15.0), 2.0), 0.0, 1.0));", "}", "}"].join(`
`)
          });
        },
        "./src/components/look-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js"), PI_2 = Math.PI / 2;
          module3.exports.Component = registerComponent("look-controls", {
            dependencies: ["position", "rotation"],
            schema: {
              enabled: {
                default: !0
              },
              magicWindowTrackingEnabled: {
                default: !0
              },
              pointerLockEnabled: {
                default: !1
              },
              reverseMouseDrag: {
                default: !1
              },
              reverseTouchDrag: {
                default: !1
              },
              touchEnabled: {
                default: !0
              },
              mouseEnabled: {
                default: !0
              }
            },
            init: function() {
              this.deltaYaw = 0, this.previousHMDPosition = new THREE3.Vector3(), this.hmdQuaternion = new THREE3.Quaternion(), this.magicWindowAbsoluteEuler = new THREE3.Euler(), this.magicWindowDeltaEuler = new THREE3.Euler(), this.position = new THREE3.Vector3(), this.magicWindowObject = new THREE3.Object3D(), this.rotation = {}, this.deltaRotation = {}, this.savedPose = null, this.pointerLocked = !1, this.setupMouseControls(), this.bindMethods(), this.previousMouseEvent = {}, this.setupMagicWindowControls(), this.savedPose = {
                position: new THREE3.Vector3(),
                rotation: new THREE3.Euler()
              }, (this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode")) && this.onEnterVR();
            },
            setupMagicWindowControls: function() {
              var magicWindowControls, data = this.data;
              (utils.device.isMobile() || utils.device.isMobileDeviceRequestingDesktopSite()) && (magicWindowControls = this.magicWindowControls = new THREE3.DeviceOrientationControls(this.magicWindowObject), typeof DeviceOrientationEvent != "undefined" && DeviceOrientationEvent.requestPermission && (magicWindowControls.enabled = !1, this.el.sceneEl.components["device-orientation-permission-ui"].permissionGranted ? magicWindowControls.enabled = data.magicWindowTrackingEnabled : this.el.sceneEl.addEventListener("deviceorientationpermissiongranted", function() {
                magicWindowControls.enabled = data.magicWindowTrackingEnabled;
              })));
            },
            update: function(oldData) {
              var data = this.data;
              data.enabled !== oldData.enabled && this.updateGrabCursor(data.enabled), oldData && !data.magicWindowTrackingEnabled && oldData.magicWindowTrackingEnabled && (this.magicWindowAbsoluteEuler.set(0, 0, 0), this.magicWindowDeltaEuler.set(0, 0, 0)), this.magicWindowControls && (this.magicWindowControls.enabled = data.magicWindowTrackingEnabled), oldData && !data.pointerLockEnabled !== oldData.pointerLockEnabled && (this.removeEventListeners(), this.addEventListeners(), this.pointerLocked && this.exitPointerLock());
            },
            tick: function(t) {
              var data = this.data;
              !data.enabled || this.updateOrientation();
            },
            play: function() {
              this.addEventListeners();
            },
            pause: function() {
              this.removeEventListeners(), this.pointerLocked && this.exitPointerLock();
            },
            remove: function() {
              this.removeEventListeners(), this.pointerLocked && this.exitPointerLock();
            },
            bindMethods: function() {
              this.onMouseDown = this.onMouseDown.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onMouseUp = this.onMouseUp.bind(this), this.onTouchStart = this.onTouchStart.bind(this), this.onTouchMove = this.onTouchMove.bind(this), this.onTouchEnd = this.onTouchEnd.bind(this), this.onEnterVR = this.onEnterVR.bind(this), this.onExitVR = this.onExitVR.bind(this), this.onPointerLockChange = this.onPointerLockChange.bind(this), this.onPointerLockError = this.onPointerLockError.bind(this);
            },
            setupMouseControls: function() {
              this.mouseDown = !1, this.pitchObject = new THREE3.Object3D(), this.yawObject = new THREE3.Object3D(), this.yawObject.position.y = 10, this.yawObject.add(this.pitchObject);
            },
            addEventListeners: function() {
              var sceneEl = this.el.sceneEl, canvasEl = sceneEl.canvas;
              if (!canvasEl) {
                sceneEl.addEventListener("render-target-loaded", this.addEventListeners.bind(this));
                return;
              }
              canvasEl.addEventListener("mousedown", this.onMouseDown, !1), window.addEventListener("mousemove", this.onMouseMove, !1), window.addEventListener("mouseup", this.onMouseUp, !1), canvasEl.addEventListener("touchstart", this.onTouchStart, {
                passive: !0
              }), window.addEventListener("touchmove", this.onTouchMove, {
                passive: !0
              }), window.addEventListener("touchend", this.onTouchEnd, {
                passive: !0
              }), sceneEl.addEventListener("enter-vr", this.onEnterVR), sceneEl.addEventListener("exit-vr", this.onExitVR), this.data.pointerLockEnabled && (document.addEventListener("pointerlockchange", this.onPointerLockChange, !1), document.addEventListener("mozpointerlockchange", this.onPointerLockChange, !1), document.addEventListener("pointerlockerror", this.onPointerLockError, !1));
            },
            removeEventListeners: function() {
              var sceneEl = this.el.sceneEl, canvasEl = sceneEl && sceneEl.canvas;
              !canvasEl || (canvasEl.removeEventListener("mousedown", this.onMouseDown), window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup", this.onMouseUp), canvasEl.removeEventListener("touchstart", this.onTouchStart), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchEnd), sceneEl.removeEventListener("enter-vr", this.onEnterVR), sceneEl.removeEventListener("exit-vr", this.onExitVR), document.removeEventListener("pointerlockchange", this.onPointerLockChange, !1), document.removeEventListener("mozpointerlockchange", this.onPointerLockChange, !1), document.removeEventListener("pointerlockerror", this.onPointerLockError, !1));
            },
            updateOrientation: function() {
              var object3D = this.el.object3D, pitchObject = this.pitchObject, yawObject = this.yawObject, sceneEl = this.el.sceneEl;
              (sceneEl.is("vr-mode") || sceneEl.is("ar-mode")) && sceneEl.checkHeadsetConnected() || (this.updateMagicWindowOrientation(), object3D.rotation.x = this.magicWindowDeltaEuler.x + pitchObject.rotation.x, object3D.rotation.y = this.magicWindowDeltaEuler.y + yawObject.rotation.y, object3D.rotation.z = this.magicWindowDeltaEuler.z);
            },
            updateMagicWindowOrientation: function() {
              var magicWindowAbsoluteEuler = this.magicWindowAbsoluteEuler, magicWindowDeltaEuler = this.magicWindowDeltaEuler;
              this.magicWindowControls && this.magicWindowControls.enabled && (this.magicWindowControls.update(), magicWindowAbsoluteEuler.setFromQuaternion(this.magicWindowObject.quaternion, "YXZ"), !this.previousMagicWindowYaw && magicWindowAbsoluteEuler.y !== 0 && (this.previousMagicWindowYaw = magicWindowAbsoluteEuler.y), this.previousMagicWindowYaw && (magicWindowDeltaEuler.x = magicWindowAbsoluteEuler.x, magicWindowDeltaEuler.y += magicWindowAbsoluteEuler.y - this.previousMagicWindowYaw, magicWindowDeltaEuler.z = magicWindowAbsoluteEuler.z, this.previousMagicWindowYaw = magicWindowAbsoluteEuler.y));
            },
            onMouseMove: function(evt) {
              var direction, movementX, movementY, pitchObject = this.pitchObject, previousMouseEvent = this.previousMouseEvent, yawObject = this.yawObject;
              !this.data.enabled || !this.mouseDown && !this.pointerLocked || (this.pointerLocked ? (movementX = evt.movementX || evt.mozMovementX || 0, movementY = evt.movementY || evt.mozMovementY || 0) : (movementX = evt.screenX - previousMouseEvent.screenX, movementY = evt.screenY - previousMouseEvent.screenY), this.previousMouseEvent.screenX = evt.screenX, this.previousMouseEvent.screenY = evt.screenY, direction = this.data.reverseMouseDrag ? 1 : -1, yawObject.rotation.y += movementX * 2e-3 * direction, pitchObject.rotation.x += movementY * 2e-3 * direction, pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x)));
            },
            onMouseDown: function(evt) {
              var sceneEl = this.el.sceneEl;
              if (!(!this.data.enabled || !this.data.mouseEnabled || (sceneEl.is("vr-mode") || sceneEl.is("ar-mode")) && sceneEl.checkHeadsetConnected()) && evt.button === 0) {
                var canvasEl = sceneEl && sceneEl.canvas;
                this.mouseDown = !0, this.previousMouseEvent.screenX = evt.screenX, this.previousMouseEvent.screenY = evt.screenY, this.showGrabbingCursor(), this.data.pointerLockEnabled && !this.pointerLocked && (canvasEl.requestPointerLock ? canvasEl.requestPointerLock() : canvasEl.mozRequestPointerLock && canvasEl.mozRequestPointerLock());
              }
            },
            showGrabbingCursor: function() {
              this.el.sceneEl.canvas.style.cursor = "grabbing";
            },
            hideGrabbingCursor: function() {
              this.el.sceneEl.canvas.style.cursor = "";
            },
            onMouseUp: function() {
              this.mouseDown = !1, this.hideGrabbingCursor();
            },
            onTouchStart: function(evt) {
              evt.touches.length !== 1 || !this.data.touchEnabled || this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode") || (this.touchStart = {
                x: evt.touches[0].pageX,
                y: evt.touches[0].pageY
              }, this.touchStarted = !0);
            },
            onTouchMove: function(evt) {
              var direction, canvas = this.el.sceneEl.canvas, deltaY, yawObject = this.yawObject;
              !this.touchStarted || !this.data.touchEnabled || (deltaY = 2 * Math.PI * (evt.touches[0].pageX - this.touchStart.x) / canvas.clientWidth, direction = this.data.reverseTouchDrag ? 1 : -1, yawObject.rotation.y -= deltaY * 0.5 * direction, this.touchStart = {
                x: evt.touches[0].pageX,
                y: evt.touches[0].pageY
              });
            },
            onTouchEnd: function() {
              this.touchStarted = !1;
            },
            onEnterVR: function() {
              var sceneEl = this.el.sceneEl;
              !sceneEl.checkHeadsetConnected() || (this.saveCameraPose(), this.el.object3D.position.set(0, 0, 0), this.el.object3D.rotation.set(0, 0, 0), sceneEl.hasWebXR && (this.el.object3D.matrixAutoUpdate = !1, this.el.object3D.updateMatrix()));
            },
            onExitVR: function() {
              !this.el.sceneEl.checkHeadsetConnected() || (this.restoreCameraPose(), this.previousHMDPosition.set(0, 0, 0), this.el.object3D.matrixAutoUpdate = !0);
            },
            onPointerLockChange: function() {
              this.pointerLocked = !!(document.pointerLockElement || document.mozPointerLockElement);
            },
            onPointerLockError: function() {
              this.pointerLocked = !1;
            },
            exitPointerLock: function() {
              document.exitPointerLock(), this.pointerLocked = !1;
            },
            updateGrabCursor: function(enabled) {
              var sceneEl = this.el.sceneEl;
              function enableGrabCursor() {
                sceneEl.canvas.classList.add("a-grab-cursor");
              }
              function disableGrabCursor() {
                sceneEl.canvas.classList.remove("a-grab-cursor");
              }
              if (!sceneEl.canvas) {
                enabled ? sceneEl.addEventListener("render-target-loaded", enableGrabCursor) : sceneEl.addEventListener("render-target-loaded", disableGrabCursor);
                return;
              }
              if (enabled) {
                enableGrabCursor();
                return;
              }
              disableGrabCursor();
            },
            saveCameraPose: function() {
              var el = this.el;
              this.savedPose.position.copy(el.object3D.position), this.savedPose.rotation.copy(el.object3D.rotation), this.hasSavedPose = !0;
            },
            restoreCameraPose: function() {
              var el = this.el, savedPose = this.savedPose;
              !this.hasSavedPose || (el.object3D.position.copy(savedPose.position), el.object3D.rotation.copy(savedPose.rotation), this.hasSavedPose = !1);
            }
          });
        },
        "./src/components/magicleap-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged, onButtonEvent = trackedControlsUtils.onButtonEvent, GAMEPAD_ID_PREFIX = "magicleap", GAMEPAD_ID_SUFFIX = "-one", GAMEPAD_ID_COMPOSITE = GAMEPAD_ID_PREFIX + GAMEPAD_ID_SUFFIX, AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, MAGICLEAP_CONTROLLER_MODEL_GLB_URL = AFRAME_CDN_ROOT + "controllers/magicleap/magicleap-one-controller.glb", INPUT_MAPPING_WEBXR = {
            axes: {
              touchpad: [0, 1]
            },
            buttons: ["trigger", "grip", "touchpad", "menu"]
          };
          module3.exports.Component = registerComponent("magicleap-controls", {
            schema: {
              hand: {
                default: "none"
              },
              model: {
                default: !0
              },
              orientationOffset: {
                type: "vec3"
              }
            },
            mapping: INPUT_MAPPING_WEBXR,
            init: function() {
              var self2 = this;
              this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(evt) {
                onButtonEvent(evt.detail.id, "down", self2);
              }, this.onButtonUp = function(evt) {
                onButtonEvent(evt.detail.id, "up", self2);
              }, this.onButtonTouchEnd = function(evt) {
                onButtonEvent(evt.detail.id, "touchend", self2);
              }, this.onButtonTouchStart = function(evt) {
                onButtonEvent(evt.detail.id, "touchstart", self2);
              }, this.previousButtonValues = {}, this.bindMethods();
            },
            update: function() {
              var data = this.data;
              this.controllerIndex = data.hand === "right" ? 0 : data.hand === "left" ? 1 : 2;
            },
            play: function() {
              this.checkIfControllerPresent(), this.addControllersUpdateListener();
            },
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            bindMethods: function() {
              this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("buttonchanged", this.onButtonChanged), el.addEventListener("buttondown", this.onButtonDown), el.addEventListener("buttonup", this.onButtonUp), el.addEventListener("touchstart", this.onButtonTouchStart), el.addEventListener("touchend", this.onButtonTouchEnd), el.addEventListener("axismove", this.onAxisMoved), el.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0;
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("buttonchanged", this.onButtonChanged), el.removeEventListener("buttondown", this.onButtonDown), el.removeEventListener("buttonup", this.onButtonUp), el.removeEventListener("touchstart", this.onButtonTouchStart), el.removeEventListener("touchend", this.onButtonTouchEnd), el.removeEventListener("axismove", this.onAxisMoved), el.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1;
            },
            checkIfControllerPresent: function() {
              var data = this.data;
              checkControllerPresentAndSetup(this, GAMEPAD_ID_COMPOSITE, {
                index: this.controllerIndex,
                hand: data.hand
              });
            },
            injectTrackedControls: function() {
              var el = this.el, data = this.data;
              el.setAttribute("tracked-controls", {
                idPrefix: GAMEPAD_ID_COMPOSITE,
                hand: data.hand,
                controller: this.controllerIndex,
                orientationOffset: data.orientationOffset
              }), !!this.data.model && this.el.setAttribute("gltf-model", MAGICLEAP_CONTROLLER_MODEL_GLB_URL);
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              this.checkIfControllerPresent();
            },
            onButtonChanged: function(evt) {
              var button = this.mapping.buttons[evt.detail.id], analogValue;
              !button || (button === "trigger" && (analogValue = evt.detail.state.value, console.log("analog value of trigger press: " + analogValue)), this.el.emit(button + "changed", evt.detail.state));
            },
            onModelLoaded: function(evt) {
              var controllerObject3D = evt.detail.model;
              controllerObject3D.scale.set(0.01, 0.01, 0.01);
            },
            onAxisMoved: function(evt) {
              emitIfAxesChanged(this, this.mapping.axes, evt);
            },
            updateModel: function(buttonName, evtName) {
            },
            setButtonColor: function(buttonName, color) {
            }
          });
        },
        "./src/components/material.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var utils = __webpack_require__2("./src/utils/index.js"), component = __webpack_require__2("./src/core/component.js"), THREE3 = __webpack_require__2("./src/lib/three.js"), shader = __webpack_require__2("./src/core/shader.js"), error = utils.debug("components:material:error"), registerComponent = component.registerComponent, shaders = shader.shaders, shaderNames = shader.shaderNames;
          module3.exports.Component = registerComponent("material", {
            schema: {
              alphaTest: {
                default: 0,
                min: 0,
                max: 1
              },
              depthTest: {
                default: !0
              },
              depthWrite: {
                default: !0
              },
              flatShading: {
                default: !1
              },
              npot: {
                default: !1
              },
              offset: {
                type: "vec2",
                default: {
                  x: 0,
                  y: 0
                }
              },
              opacity: {
                default: 1,
                min: 0,
                max: 1
              },
              repeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              shader: {
                default: "standard",
                oneOf: shaderNames,
                schemaChange: !0
              },
              side: {
                default: "front",
                oneOf: ["front", "back", "double"]
              },
              transparent: {
                default: !1
              },
              vertexColorsEnabled: {
                default: !1
              },
              visible: {
                default: !0
              },
              blending: {
                default: "normal",
                oneOf: ["none", "normal", "additive", "subtractive", "multiply"]
              },
              dithering: {
                default: !0
              },
              anisotropy: {
                default: 0,
                min: 0
              }
            },
            init: function() {
              this.material = null;
            },
            update: function(oldData) {
              var data = this.data;
              (!this.shader || data.shader !== oldData.shader) && this.updateShader(data.shader), this.shader.update(this.data), this.updateMaterial(oldData);
            },
            updateSchema: function(data) {
              var currentShader, newShader, schema, shader2;
              newShader = data && data.shader, currentShader = this.oldData && this.oldData.shader, shader2 = newShader || currentShader, schema = shaders[shader2] && shaders[shader2].schema, schema || error("Unknown shader schema " + shader2), !(currentShader && newShader === currentShader) && (this.extendSchema(schema), this.updateBehavior());
            },
            updateBehavior: function() {
              var key, sceneEl = this.el.sceneEl, schema = this.schema, self2 = this, tickProperties;
              function tickTime(time, delta) {
                var key2;
                for (key2 in tickProperties)
                  tickProperties[key2] = time;
                self2.shader.update(tickProperties);
              }
              this.tick = void 0, tickProperties = {};
              for (key in schema)
                schema[key].type === "time" && (this.tick = tickTime, tickProperties[key] = !0);
              !sceneEl || (this.tick ? sceneEl.addBehavior(this) : sceneEl.removeBehavior(this));
            },
            updateShader: function(shaderName) {
              var data = this.data, Shader = shaders[shaderName] && shaders[shaderName].Shader, shaderInstance;
              if (!Shader)
                throw new Error("Unknown shader " + shaderName);
              shaderInstance = this.shader = new Shader(), shaderInstance.el = this.el, shaderInstance.init(data), this.setMaterial(shaderInstance.material), this.updateSchema(data);
            },
            updateMaterial: function(oldData) {
              var data = this.data, material = this.material, oldDataHasKeys;
              material.alphaTest = data.alphaTest, material.depthTest = data.depthTest !== !1, material.depthWrite = data.depthWrite !== !1, material.opacity = data.opacity, material.flatShading = data.flatShading, material.side = parseSide(data.side), material.transparent = data.transparent !== !1 || data.opacity < 1, material.vertexColors = data.vertexColorsEnabled, material.visible = data.visible, material.blending = parseBlending(data.blending), material.dithering = data.dithering;
              for (oldDataHasKeys in oldData)
                break;
              oldDataHasKeys && (oldData.alphaTest !== data.alphaTest || oldData.side !== data.side || oldData.vertexColorsEnabled !== data.vertexColorsEnabled) && (material.needsUpdate = !0);
            },
            remove: function() {
              var defaultMaterial = new THREE3.MeshBasicMaterial(), material = this.material, object3D = this.el.getObject3D("mesh");
              object3D && (object3D.material = defaultMaterial), disposeMaterial(material, this.system);
            },
            setMaterial: function(material) {
              var el = this.el, mesh, system = this.system;
              this.material && disposeMaterial(this.material, system), this.material = material, system.registerMaterial(material), mesh = el.getObject3D("mesh"), mesh ? mesh.material = material : el.addEventListener("object3dset", function waitForMesh(evt) {
                evt.detail.type !== "mesh" || evt.target !== el || (el.getObject3D("mesh").material = material, el.removeEventListener("object3dset", waitForMesh));
              });
            }
          });
          function parseSide(side) {
            switch (side) {
              case "back":
                return THREE3.BackSide;
              case "double":
                return THREE3.DoubleSide;
              default:
                return THREE3.FrontSide;
            }
          }
          function parseBlending(blending) {
            switch (blending) {
              case "none":
                return THREE3.NoBlending;
              case "additive":
                return THREE3.AdditiveBlending;
              case "subtractive":
                return THREE3.SubtractiveBlending;
              case "multiply":
                return THREE3.MultiplyBlending;
              default:
                return THREE3.NormalBlending;
            }
          }
          function disposeMaterial(material, system) {
            material.dispose(), system.unregisterMaterial(material), Object.keys(material).filter(function(propName) {
              return material[propName] && material[propName].isTexture;
            }).forEach(function(mapName) {
              material[mapName].dispose();
            });
          }
        },
        "./src/components/obb-collider.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js");
          registerComponent("obb-collider", {
            schema: {
              size: {
                default: 0
              },
              trackedObject3D: {
                default: ""
              },
              minimumColliderDimension: {
                default: 0.02
              },
              centerModel: {
                default: !1
              }
            },
            init: function() {
              this.previousScale = new THREE3.Vector3().copy(this.el.object3D.scale), this.auxEuler = new THREE3.Euler(), this.boundingBox = new THREE3.Box3(), this.boundingBoxSize = new THREE3.Vector3(), this.updateCollider = this.updateCollider.bind(this), this.onModelLoaded = this.onModelLoaded.bind(this), this.updateBoundingBox = this.updateBoundingBox.bind(this), this.el.addEventListener("model-loaded", this.onModelLoaded), this.updateCollider(), this.system.addCollider(this.el);
            },
            remove: function() {
              this.system.removeCollider(this.el);
            },
            update: function() {
              this.data.trackedObject3D && (this.trackedObject3DPath = this.data.trackedObject3D.split("."));
            },
            onModelLoaded: function() {
              this.data.centerModel && this.centerModel(), this.updateCollider();
            },
            centerModel: function() {
              var el = this.el, model = el.components["gltf-model"] && el.components["gltf-model"].model, box, center;
              !model || (this.el.removeObject3D("mesh"), box = new THREE3.Box3().setFromObject(model), center = box.getCenter(new THREE3.Vector3()), model.position.x += model.position.x - center.x, model.position.y += model.position.y - center.y, model.position.z += model.position.z - center.z, this.el.setObject3D("mesh", model));
            },
            updateCollider: function() {
              var el = this.el, boundingBoxSize = this.boundingBoxSize, aabb = this.aabb = this.aabb || new THREE3.OBB();
              if (this.obb = this.obb || new THREE3.OBB(), !el.hasLoaded) {
                el.addEventListener("loaded", this.updateCollider);
                return;
              }
              this.updateBoundingBox(), aabb.halfSize.copy(boundingBoxSize).multiplyScalar(0.5), this.el.sceneEl.systems["obb-collider"].data.showColliders && this.showCollider();
            },
            showCollider: function() {
              this.updateColliderMesh(), this.renderColliderMesh.visible = !0;
            },
            updateColliderMesh: function() {
              var renderColliderMesh = this.renderColliderMesh, boundingBoxSize = this.boundingBoxSize;
              if (!renderColliderMesh) {
                this.initColliderMesh();
                return;
              }
              renderColliderMesh.geometry.dispose(), renderColliderMesh.geometry = new THREE3.BoxGeometry(boundingBoxSize.x, boundingBoxSize.y, boundingBoxSize.z);
            },
            hideCollider: function() {
              !this.renderColliderMesh || (this.renderColliderMesh.visible = !1);
            },
            initColliderMesh: function() {
              var boundingBoxSize, renderColliderGeometry, renderColliderMesh;
              boundingBoxSize = this.boundingBoxSize, renderColliderGeometry = this.renderColliderGeometry = new THREE3.BoxGeometry(boundingBoxSize.x, boundingBoxSize.y, boundingBoxSize.z), renderColliderMesh = this.renderColliderMesh = new THREE3.Mesh(renderColliderGeometry, new THREE3.MeshLambertMaterial({
                color: 65280,
                side: THREE3.DoubleSide
              })), renderColliderMesh.matrixAutoUpdate = !1, renderColliderMesh.matrixWorldAutoUpdate = !1, renderColliderMesh.updateMatrixWorld = function() {
              }, this.el.sceneEl.object3D.add(renderColliderMesh);
            },
            updateBoundingBox: function() {
              var auxPosition = new THREE3.Vector3(), auxScale = new THREE3.Vector3(), auxQuaternion = new THREE3.Quaternion(), identityQuaternion = new THREE3.Quaternion(), auxMatrix = new THREE3.Matrix4();
              return function() {
                var auxEuler = this.auxEuler, boundingBox = this.boundingBox, size = this.data.size, trackedObject3D = this.trackedObject3D || this.el.object3D, boundingBoxSize = this.boundingBoxSize, minimumColliderDimension = this.data.minimumColliderDimension;
                if (size) {
                  this.boundingBoxSize.x = size, this.boundingBoxSize.y = size, this.boundingBoxSize.z = size;
                  return;
                }
                auxEuler.copy(trackedObject3D.rotation), trackedObject3D.rotation.set(0, 0, 0), trackedObject3D.parent.matrixWorld.decompose(auxPosition, auxQuaternion, auxScale), auxMatrix.compose(auxPosition, identityQuaternion, auxScale), trackedObject3D.parent.matrixWorld.copy(auxMatrix), boundingBox.setFromObject(trackedObject3D, !0), boundingBox.getSize(boundingBoxSize), boundingBoxSize.x = boundingBoxSize.x < minimumColliderDimension ? minimumColliderDimension : boundingBoxSize.x, boundingBoxSize.y = boundingBoxSize.y < minimumColliderDimension ? minimumColliderDimension : boundingBoxSize.y, boundingBoxSize.z = boundingBoxSize.z < minimumColliderDimension ? minimumColliderDimension : boundingBoxSize.z, trackedObject3D.parent.matrixWorld.compose(auxPosition, auxQuaternion, auxScale), this.el.object3D.rotation.copy(auxEuler);
              };
            }(),
            checkTrackedObject: function() {
              var trackedObject3DPath = this.trackedObject3DPath, trackedObject3D;
              if (trackedObject3DPath && trackedObject3DPath.length && !this.trackedObject3D) {
                trackedObject3D = this.el;
                for (var i = 0; i < trackedObject3DPath.length && (trackedObject3D = trackedObject3D[trackedObject3DPath[i]], !!trackedObject3D); i++)
                  ;
                trackedObject3D && (this.trackedObject3D = trackedObject3D, this.updateCollider());
              }
              return this.trackedObject3D;
            },
            tick: function() {
              var auxPosition = new THREE3.Vector3(), auxScale = new THREE3.Vector3(), auxQuaternion = new THREE3.Quaternion(), auxMatrix = new THREE3.Matrix4();
              return function() {
                var obb = this.obb, renderColliderMesh = this.renderColliderMesh, trackedObject3D = this.checkTrackedObject() || this.el.object3D;
                !trackedObject3D || (trackedObject3D.updateMatrix(), trackedObject3D.updateMatrixWorld(!0), trackedObject3D.matrixWorld.decompose(auxPosition, auxQuaternion, auxScale), (Math.abs(auxScale.x - this.previousScale.x) > 1e-4 || Math.abs(auxScale.y - this.previousScale.y) > 1e-4 || Math.abs(auxScale.z - this.previousScale.z) > 1e-4) && this.updateCollider(), this.previousScale.copy(auxScale), auxScale.set(1, 1, 1), auxMatrix.compose(auxPosition, auxQuaternion, auxScale), renderColliderMesh && renderColliderMesh.matrixWorld.copy(auxMatrix), obb.copy(this.aabb), obb.applyMatrix4(auxMatrix));
              };
            }()
          });
        },
        "./src/components/obj-model.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var debug = __webpack_require__2("./src/utils/debug.js"), registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), warn = debug("components:obj-model:warn");
          module3.exports.Component = registerComponent("obj-model", {
            schema: {
              mtl: {
                type: "model"
              },
              obj: {
                type: "model"
              }
            },
            init: function() {
              var self2 = this;
              this.model = null, this.objLoader = new THREE3.OBJLoader(), this.mtlLoader = new THREE3.MTLLoader(this.objLoader.manager), this.mtlLoader.crossOrigin = "", this.el.addEventListener("componentinitialized", function(evt) {
                !self2.model || evt.detail.name === "material" && self2.applyMaterial();
              });
            },
            update: function() {
              var data = this.data;
              !data.obj || (this.resetMesh(), this.loadObj(data.obj, data.mtl));
            },
            remove: function() {
              this.resetMesh();
            },
            resetMesh: function() {
              !this.model || this.el.removeObject3D("mesh");
            },
            loadObj: function(objUrl, mtlUrl) {
              var self2 = this, el = this.el, mtlLoader = this.mtlLoader, objLoader = this.objLoader, rendererSystem = this.el.sceneEl.systems.renderer, BASE_PATH = mtlUrl.substr(0, mtlUrl.lastIndexOf("/") + 1);
              if (mtlUrl) {
                el.hasAttribute("material") && warn("Material component properties are ignored when a .MTL is provided"), mtlLoader.setResourcePath(BASE_PATH), mtlLoader.load(mtlUrl, function(materials) {
                  materials.preload(), objLoader.setMaterials(materials), objLoader.load(objUrl, function(objModel) {
                    self2.model = objModel, self2.model.traverse(function(object) {
                      if (object.isMesh) {
                        var material = object.material;
                        material.map && rendererSystem.applyColorCorrection(material.map), material.emissiveMap && rendererSystem.applyColorCorrection(material.emissiveMap);
                      }
                    }), el.setObject3D("mesh", objModel), el.emit("model-loaded", {
                      format: "obj",
                      model: objModel
                    });
                  });
                });
                return;
              }
              objLoader.load(objUrl, function(objModel) {
                self2.model = objModel, self2.applyMaterial(), el.setObject3D("mesh", objModel), el.emit("model-loaded", {
                  format: "obj",
                  model: objModel
                });
              });
            },
            applyMaterial: function() {
              var material = this.el.components.material;
              !material || this.model.traverse(function(child) {
                child instanceof THREE3.Mesh && (child.material = material.material);
              });
            }
          });
        },
        "./src/components/oculus-go-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged, onButtonEvent = trackedControlsUtils.onButtonEvent, isWebXRAvailable = __webpack_require__2("./src/utils/index.js").device.isWebXRAvailable, GAMEPAD_ID_WEBXR = "oculus-go", GAMEPAD_ID_WEBVR = "Oculus Go", AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, OCULUS_GO_CONTROLLER_MODEL_URL = AFRAME_CDN_ROOT + "controllers/oculus/go/oculus-go-controller.gltf", GAMEPAD_ID_PREFIX = isWebXRAvailable ? GAMEPAD_ID_WEBXR : GAMEPAD_ID_WEBVR, INPUT_MAPPING_WEBVR = {
            axes: {
              trackpad: [0, 1]
            },
            buttons: ["trackpad", "trigger"]
          }, INPUT_MAPPING_WEBXR = {
            axes: {
              touchpad: [0, 1]
            },
            buttons: ["trigger", "none", "touchpad"]
          }, INPUT_MAPPING = isWebXRAvailable ? INPUT_MAPPING_WEBXR : INPUT_MAPPING_WEBVR;
          module3.exports.Component = registerComponent("oculus-go-controls", {
            schema: {
              hand: {
                default: ""
              },
              buttonColor: {
                type: "color",
                default: "#FFFFFF"
              },
              buttonTouchedColor: {
                type: "color",
                default: "#BBBBBB"
              },
              buttonHighlightColor: {
                type: "color",
                default: "#7A7A7A"
              },
              model: {
                default: !0
              },
              orientationOffset: {
                type: "vec3"
              },
              armModel: {
                default: !0
              }
            },
            mapping: INPUT_MAPPING,
            bindMethods: function() {
              this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
            },
            init: function() {
              var self2 = this;
              this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(evt) {
                onButtonEvent(evt.detail.id, "down", self2);
              }, this.onButtonUp = function(evt) {
                onButtonEvent(evt.detail.id, "up", self2);
              }, this.onButtonTouchStart = function(evt) {
                onButtonEvent(evt.detail.id, "touchstart", self2);
              }, this.onButtonTouchEnd = function(evt) {
                onButtonEvent(evt.detail.id, "touchend", self2);
              }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.bindMethods();
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("buttonchanged", this.onButtonChanged), el.addEventListener("buttondown", this.onButtonDown), el.addEventListener("buttonup", this.onButtonUp), el.addEventListener("touchstart", this.onButtonTouchStart), el.addEventListener("touchend", this.onButtonTouchEnd), el.addEventListener("model-loaded", this.onModelLoaded), el.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0;
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("buttonchanged", this.onButtonChanged), el.removeEventListener("buttondown", this.onButtonDown), el.removeEventListener("buttonup", this.onButtonUp), el.removeEventListener("touchstart", this.onButtonTouchStart), el.removeEventListener("touchend", this.onButtonTouchEnd), el.removeEventListener("model-loaded", this.onModelLoaded), el.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1;
            },
            checkIfControllerPresent: function() {
              checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, this.data.hand ? {
                hand: this.data.hand
              } : {});
            },
            play: function() {
              this.checkIfControllerPresent(), this.addControllersUpdateListener();
            },
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            injectTrackedControls: function() {
              var el = this.el, data = this.data;
              el.setAttribute("tracked-controls", {
                armModel: data.armModel,
                hand: data.hand,
                idPrefix: GAMEPAD_ID_PREFIX,
                orientationOffset: data.orientationOffset
              }), !!this.data.model && this.el.setAttribute("gltf-model", OCULUS_GO_CONTROLLER_MODEL_URL);
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              this.checkIfControllerPresent();
            },
            onModelLoaded: function(evt) {
              var controllerObject3D = evt.detail.model, buttonMeshes;
              evt.target !== this.el || !this.data.model || (buttonMeshes = this.buttonMeshes = {}, buttonMeshes.trigger = controllerObject3D.getObjectByName("oculus_go_button_trigger"), buttonMeshes.trackpad = controllerObject3D.getObjectByName("oculus_go_touchpad"), buttonMeshes.touchpad = controllerObject3D.getObjectByName("oculus_go_touchpad"));
            },
            onButtonChanged: function(evt) {
              var button = this.mapping.buttons[evt.detail.id];
              !button || this.el.emit(button + "changed", evt.detail.state);
            },
            onAxisMoved: function(evt) {
              emitIfAxesChanged(this, this.mapping.axes, evt);
            },
            updateModel: function(buttonName, evtName) {
              !this.data.model || this.updateButtonModel(buttonName, evtName);
            },
            updateButtonModel: function(buttonName, state) {
              var buttonMeshes = this.buttonMeshes;
              if (!(!buttonMeshes || !buttonMeshes[buttonName])) {
                var color, button;
                switch (state) {
                  case "down":
                    color = this.data.buttonHighlightColor;
                    break;
                  case "touchstart":
                    color = this.data.buttonTouchedColor;
                    break;
                  default:
                    color = this.data.buttonColor;
                }
                button = buttonMeshes[buttonName], button.material.color.set(color);
              }
            }
          });
        },
        "./src/components/oculus-touch-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged, onButtonEvent = trackedControlsUtils.onButtonEvent, isWebXRAvailable = __webpack_require__2("./src/utils/index.js").device.isWebXRAvailable, GAMEPAD_ID_WEBXR = "oculus-touch", GAMEPAD_ID_WEBVR = "Oculus Touch", GAMEPAD_ID_PREFIX = isWebXRAvailable ? GAMEPAD_ID_WEBXR : GAMEPAD_ID_WEBVR, AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, TOUCH_CONTROLLER_MODEL_BASE_URL = AFRAME_CDN_ROOT + "controllers/oculus/oculus-touch-controller-", META_CONTROLLER_MODEL_BASE_URL = AFRAME_CDN_ROOT + "controllers/meta/", OCULUS_TOUCH_WEBVR = {
            left: {
              modelUrl: TOUCH_CONTROLLER_MODEL_BASE_URL + "left.gltf",
              rayOrigin: {
                origin: {
                  x: 8e-3,
                  y: -0.01,
                  z: 0
                },
                direction: {
                  x: 0,
                  y: -0.8,
                  z: -1
                }
              },
              modelPivotOffset: new THREE3.Vector3(-5e-3, 3e-3, -0.055),
              modelPivotRotation: new THREE3.Euler(0, 0, 0)
            },
            right: {
              modelUrl: TOUCH_CONTROLLER_MODEL_BASE_URL + "right.gltf",
              rayOrigin: {
                origin: {
                  x: -8e-3,
                  y: -0.01,
                  z: 0
                },
                direction: {
                  x: 0,
                  y: -0.8,
                  z: -1
                }
              },
              modelPivotOffset: new THREE3.Vector3(5e-3, 3e-3, -0.055),
              modelPivotRotation: new THREE3.Euler(0, 0, 0)
            }
          }, OCULUS_TOUCH_WEBXR = {
            left: {
              modelUrl: TOUCH_CONTROLLER_MODEL_BASE_URL + "left.gltf",
              rayOrigin: {
                origin: {
                  x: 2e-3,
                  y: -5e-3,
                  z: -0.03
                },
                direction: {
                  x: 0,
                  y: -0.8,
                  z: -1
                }
              },
              modelPivotOffset: new THREE3.Vector3(-5e-3, 0.036, -0.037),
              modelPivotRotation: new THREE3.Euler(Math.PI / 4.5, 0, 0)
            },
            right: {
              modelUrl: TOUCH_CONTROLLER_MODEL_BASE_URL + "right.gltf",
              rayOrigin: {
                origin: {
                  x: -2e-3,
                  y: -5e-3,
                  z: -0.03
                },
                direction: {
                  x: 0,
                  y: -0.8,
                  z: -1
                }
              },
              modelPivotOffset: new THREE3.Vector3(5e-3, 0.036, -0.037),
              modelPivotRotation: new THREE3.Euler(Math.PI / 4.5, 0, 0)
            }
          }, OCULUS_TOUCH_CONFIG = isWebXRAvailable ? OCULUS_TOUCH_WEBXR : OCULUS_TOUCH_WEBVR, CONTROLLER_DEFAULT = "oculus-touch", CONTROLLER_PROPERTIES = {
            "oculus-touch": OCULUS_TOUCH_CONFIG,
            "oculus-touch-v2": {
              left: {
                modelUrl: TOUCH_CONTROLLER_MODEL_BASE_URL + "gen2-left.gltf",
                rayOrigin: {
                  origin: {
                    x: -6e-3,
                    y: -0.03,
                    z: -0.04
                  },
                  direction: {
                    x: 0,
                    y: -0.9,
                    z: -1
                  }
                },
                modelPivotOffset: new THREE3.Vector3(0, -7e-3, -0.021),
                modelPivotRotation: new THREE3.Euler(-Math.PI / 4, 0, 0)
              },
              right: {
                modelUrl: TOUCH_CONTROLLER_MODEL_BASE_URL + "gen2-right.gltf",
                rayOrigin: {
                  origin: {
                    x: 6e-3,
                    y: -0.03,
                    z: -0.04
                  },
                  direction: {
                    x: 0,
                    y: -0.9,
                    z: -1
                  }
                },
                modelPivotOffset: new THREE3.Vector3(0, -7e-3, -0.021),
                modelPivotRotation: new THREE3.Euler(-Math.PI / 4, 0, 0)
              }
            },
            "oculus-touch-v3": {
              left: {
                modelUrl: TOUCH_CONTROLLER_MODEL_BASE_URL + "v3-left.glb",
                rayOrigin: {
                  origin: {
                    x: 65e-4,
                    y: -0.0186,
                    z: -0.05
                  },
                  direction: {
                    x: 0.12394785839500175,
                    y: -0.5944043672340157,
                    z: -0.7945567170519814
                  }
                },
                modelPivotOffset: new THREE3.Vector3(0, 0, 0),
                modelPivotRotation: new THREE3.Euler(0, 0, 0)
              },
              right: {
                modelUrl: TOUCH_CONTROLLER_MODEL_BASE_URL + "v3-right.glb",
                rayOrigin: {
                  origin: {
                    x: -65e-4,
                    y: -0.0186,
                    z: -0.05
                  },
                  direction: {
                    x: -0.12394785839500175,
                    y: -0.5944043672340157,
                    z: -0.7945567170519814
                  }
                },
                modelPivotOffset: new THREE3.Vector3(0, 0, 0),
                modelPivotRotation: new THREE3.Euler(0, 0, 0)
              }
            },
            "meta-quest-touch-pro": {
              left: {
                modelUrl: META_CONTROLLER_MODEL_BASE_URL + "quest-touch-pro-left.glb",
                rayOrigin: {
                  origin: {
                    x: 65e-4,
                    y: -0.0186,
                    z: -0.05
                  },
                  direction: {
                    x: 0.12394785839500175,
                    y: -0.5944043672340157,
                    z: -0.7945567170519814
                  }
                },
                modelPivotOffset: new THREE3.Vector3(0, 0, 0),
                modelPivotRotation: new THREE3.Euler(0, 0, 0)
              },
              right: {
                modelUrl: META_CONTROLLER_MODEL_BASE_URL + "quest-touch-pro-right.glb",
                rayOrigin: {
                  origin: {
                    x: -65e-4,
                    y: -0.0186,
                    z: -0.05
                  },
                  direction: {
                    x: -0.12394785839500175,
                    y: -0.5944043672340157,
                    z: -0.7945567170519814
                  }
                },
                modelPivotOffset: new THREE3.Vector3(0, 0, 0),
                modelPivotRotation: new THREE3.Euler(0, 0, 0)
              }
            },
            "meta-quest-touch-plus": {
              left: {
                modelUrl: META_CONTROLLER_MODEL_BASE_URL + "quest-touch-plus-left.glb",
                rayOrigin: {
                  origin: {
                    x: 65e-4,
                    y: -0.0186,
                    z: -0.05
                  },
                  direction: {
                    x: 0.12394785839500175,
                    y: -0.5944043672340157,
                    z: -0.7945567170519814
                  }
                },
                modelPivotOffset: new THREE3.Vector3(0, 0, 0),
                modelPivotRotation: new THREE3.Euler(0, 0, 0)
              },
              right: {
                modelUrl: META_CONTROLLER_MODEL_BASE_URL + "quest-touch-plus-right.glb",
                rayOrigin: {
                  origin: {
                    x: -65e-4,
                    y: -0.0186,
                    z: -0.05
                  },
                  direction: {
                    x: -0.12394785839500175,
                    y: -0.5944043672340157,
                    z: -0.7945567170519814
                  }
                },
                modelPivotOffset: new THREE3.Vector3(0, 0, 0),
                modelPivotRotation: new THREE3.Euler(0, 0, 0)
              }
            }
          }, INPUT_MAPPING_WEBVR = {
            left: {
              axes: {
                thumbstick: [0, 1]
              },
              buttons: ["thumbstick", "trigger", "grip", "xbutton", "ybutton", "surface"]
            },
            right: {
              axes: {
                thumbstick: [0, 1]
              },
              buttons: ["thumbstick", "trigger", "grip", "abutton", "bbutton", "surface"]
            }
          }, INPUT_MAPPING_WEBXR = {
            left: {
              axes: {
                thumbstick: [2, 3]
              },
              buttons: ["trigger", "grip", "none", "thumbstick", "xbutton", "ybutton", "surface"]
            },
            right: {
              axes: {
                thumbstick: [2, 3]
              },
              buttons: ["trigger", "grip", "none", "thumbstick", "abutton", "bbutton", "surface"]
            }
          }, INPUT_MAPPING = isWebXRAvailable ? INPUT_MAPPING_WEBXR : INPUT_MAPPING_WEBVR;
          module3.exports.Component = registerComponent("oculus-touch-controls", {
            schema: {
              hand: {
                default: "left"
              },
              buttonColor: {
                type: "color",
                default: "#999"
              },
              buttonTouchColor: {
                type: "color",
                default: "#8AB"
              },
              buttonHighlightColor: {
                type: "color",
                default: "#2DF"
              },
              model: {
                default: !0
              },
              controllerType: {
                default: "auto",
                oneOf: ["auto", "oculus-touch", "oculus-touch-v2", "oculus-touch-v3"]
              },
              orientationOffset: {
                type: "vec3",
                default: {
                  x: 43,
                  y: 0,
                  z: 0
                }
              }
            },
            after: ["tracked-controls"],
            mapping: INPUT_MAPPING,
            bindMethods: function() {
              this.onButtonChanged = this.onButtonChanged.bind(this), this.onThumbstickMoved = this.onThumbstickMoved.bind(this), this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
            },
            init: function() {
              var self2 = this;
              this.onButtonDown = function(evt) {
                onButtonEvent(evt.detail.id, "down", self2, self2.data.hand);
              }, this.onButtonUp = function(evt) {
                onButtonEvent(evt.detail.id, "up", self2, self2.data.hand);
              }, this.onButtonTouchStart = function(evt) {
                onButtonEvent(evt.detail.id, "touchstart", self2, self2.data.hand);
              }, this.onButtonTouchEnd = function(evt) {
                onButtonEvent(evt.detail.id, "touchend", self2, self2.data.hand);
              }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.previousButtonValues = {}, this.bindMethods(), this.triggerEuler = new THREE3.Euler();
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("buttonchanged", this.onButtonChanged), el.addEventListener("buttondown", this.onButtonDown), el.addEventListener("buttonup", this.onButtonUp), el.addEventListener("touchstart", this.onButtonTouchStart), el.addEventListener("touchend", this.onButtonTouchEnd), el.addEventListener("axismove", this.onAxisMoved), el.addEventListener("model-loaded", this.onModelLoaded), el.addEventListener("thumbstickmoved", this.onThumbstickMoved), this.controllerEventsActive = !0;
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("buttonchanged", this.onButtonChanged), el.removeEventListener("buttondown", this.onButtonDown), el.removeEventListener("buttonup", this.onButtonUp), el.removeEventListener("touchstart", this.onButtonTouchStart), el.removeEventListener("touchend", this.onButtonTouchEnd), el.removeEventListener("axismove", this.onAxisMoved), el.removeEventListener("model-loaded", this.onModelLoaded), el.removeEventListener("thumbstickmoved", this.onThumbstickMoved), this.controllerEventsActive = !1;
            },
            checkIfControllerPresent: function() {
              checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {
                hand: this.data.hand,
                iterateControllerProfiles: !0
              });
            },
            play: function() {
              this.checkIfControllerPresent(), this.addControllersUpdateListener();
            },
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            loadModel: function(controller) {
              var data = this.data, controllerId;
              if (!!data.model) {
                if (this.controllerObject3D) {
                  this.el.setObject3D("mesh", this.controllerObject3D);
                  return;
                }
                if (this.displayModel = CONTROLLER_PROPERTIES[data.controllerType] || CONTROLLER_PROPERTIES[CONTROLLER_DEFAULT], data.controllerType === "auto") {
                  var trackedControlsSystem = this.el.sceneEl.systems["tracked-controls-webvr"];
                  if (trackedControlsSystem && trackedControlsSystem.vrDisplay) {
                    var displayName = trackedControlsSystem.vrDisplay.displayName;
                    /^Oculus Quest$/.test(displayName) && (this.displayModel = CONTROLLER_PROPERTIES["oculus-touch-v2"]);
                  } else {
                    controllerId = CONTROLLER_DEFAULT;
                    for (var controllersPropertiesIds = Object.keys(CONTROLLER_PROPERTIES), i = 0; i < controller.profiles.length; i++)
                      if (controllersPropertiesIds.indexOf(controller.profiles[i]) !== -1) {
                        controllerId = controller.profiles[i];
                        break;
                      }
                    this.displayModel = CONTROLLER_PROPERTIES[controllerId];
                  }
                }
                var modelUrl = this.displayModel[data.hand].modelUrl;
                this.isTouchV3orPROorPlus = this.displayModel === CONTROLLER_PROPERTIES["oculus-touch-v3"] || this.displayModel === CONTROLLER_PROPERTIES["meta-quest-touch-pro"] || this.displayModel === CONTROLLER_PROPERTIES["meta-quest-touch-plus"], this.el.setAttribute("gltf-model", modelUrl);
              }
            },
            injectTrackedControls: function(controller) {
              var data = this.data, webXRId = GAMEPAD_ID_WEBXR, webVRId = data.hand === "right" ? "Oculus Touch (Right)" : "Oculus Touch (Left)", id = isWebXRAvailable ? webXRId : webVRId;
              this.el.setAttribute("tracked-controls", {
                id,
                hand: data.hand,
                orientationOffset: data.orientationOffset,
                handTrackingEnabled: !1,
                iterateControllerProfiles: !0,
                space: "gripSpace"
              }), this.loadModel(controller);
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              this.checkIfControllerPresent();
            },
            onButtonChanged: function(evt) {
              var button = this.mapping[this.data.hand].buttons[evt.detail.id];
              if (!!button) {
                if (this.isTouchV3orPROorPlus)
                  this.onButtonChangedV3orPROorPlus(evt);
                else {
                  var buttonMeshes = this.buttonMeshes, analogValue;
                  (button === "trigger" || button === "grip") && (analogValue = evt.detail.state.value), buttonMeshes && (button === "trigger" && buttonMeshes.trigger && (buttonMeshes.trigger.rotation.x = this.originalXRotationTrigger - analogValue * (Math.PI / 26)), button === "grip" && buttonMeshes.grip && (analogValue *= this.data.hand === "left" ? -1 : 1, buttonMeshes.grip.position.x = this.originalXPositionGrip + analogValue * 4e-3));
                }
                this.el.emit(button + "changed", evt.detail.state);
              }
            },
            onButtonChangedV3orPROorPlus: function(evt) {
              var button = this.mapping[this.data.hand].buttons[evt.detail.id], buttonObjects = this.buttonObjects, analogValue;
              !buttonObjects || !buttonObjects[button] || (analogValue = evt.detail.state.value, buttonObjects[button].quaternion.slerpQuaternions(this.buttonRanges[button].min.quaternion, this.buttonRanges[button].max.quaternion, analogValue), buttonObjects[button].position.lerpVectors(this.buttonRanges[button].min.position, this.buttonRanges[button].max.position, analogValue));
            },
            onModelLoaded: function(evt) {
              if (!(evt.target !== this.el || !this.data.model)) {
                if (this.isTouchV3orPROorPlus)
                  this.onTouchV3orPROorPlusModelLoaded(evt);
                else {
                  var controllerObject3D = this.controllerObject3D = evt.detail.model, buttonMeshes;
                  buttonMeshes = this.buttonMeshes = {}, buttonMeshes.grip = controllerObject3D.getObjectByName("buttonHand"), this.originalXPositionGrip = buttonMeshes.grip && buttonMeshes.grip.position.x, buttonMeshes.trigger = controllerObject3D.getObjectByName("buttonTrigger"), this.originalXRotationTrigger = buttonMeshes.trigger && buttonMeshes.trigger.rotation.x, buttonMeshes.thumbstick = controllerObject3D.getObjectByName("stick"), buttonMeshes.xbutton = controllerObject3D.getObjectByName("buttonX"), buttonMeshes.abutton = controllerObject3D.getObjectByName("buttonA"), buttonMeshes.ybutton = controllerObject3D.getObjectByName("buttonY"), buttonMeshes.bbutton = controllerObject3D.getObjectByName("buttonB");
                }
                for (var button in this.buttonMeshes)
                  this.buttonMeshes[button] && cloneMeshMaterial(this.buttonMeshes[button]);
                this.applyOffset(evt.detail.model), this.el.emit("controllermodelready", {
                  name: "oculus-touch-controls",
                  model: this.data.model,
                  rayOrigin: this.displayModel[this.data.hand].rayOrigin
                });
              }
            },
            applyOffset: function(model) {
              model.position.copy(this.displayModel[this.data.hand].modelPivotOffset), model.rotation.copy(this.displayModel[this.data.hand].modelPivotRotation);
            },
            onTouchV3orPROorPlusModelLoaded: function(evt) {
              var controllerObject3D = this.controllerObject3D = evt.detail.model, buttonObjects = this.buttonObjects = {}, buttonMeshes = this.buttonMeshes = {}, buttonRanges = this.buttonRanges = {};
              buttonMeshes.grip = controllerObject3D.getObjectByName("squeeze"), buttonObjects.grip = controllerObject3D.getObjectByName("xr_standard_squeeze_pressed_value"), buttonRanges.grip = {
                min: controllerObject3D.getObjectByName("xr_standard_squeeze_pressed_min"),
                max: controllerObject3D.getObjectByName("xr_standard_squeeze_pressed_max")
              }, buttonObjects.grip.minX = buttonObjects.grip.position.x, buttonMeshes.thumbstick = controllerObject3D.getObjectByName("thumbstick"), buttonObjects.thumbstick = controllerObject3D.getObjectByName("xr_standard_thumbstick_pressed_value"), buttonRanges.thumbstick = {
                min: controllerObject3D.getObjectByName("xr_standard_thumbstick_pressed_min"),
                max: controllerObject3D.getObjectByName("xr_standard_thumbstick_pressed_max")
              }, buttonObjects.thumbstickXAxis = controllerObject3D.getObjectByName("xr_standard_thumbstick_xaxis_pressed_value"), buttonRanges.thumbstickXAxis = {
                min: controllerObject3D.getObjectByName("xr_standard_thumbstick_xaxis_pressed_min"),
                max: controllerObject3D.getObjectByName("xr_standard_thumbstick_xaxis_pressed_max")
              }, buttonObjects.thumbstickYAxis = controllerObject3D.getObjectByName("xr_standard_thumbstick_yaxis_pressed_value"), buttonRanges.thumbstickYAxis = {
                min: controllerObject3D.getObjectByName("xr_standard_thumbstick_yaxis_pressed_min"),
                max: controllerObject3D.getObjectByName("xr_standard_thumbstick_yaxis_pressed_max")
              }, buttonMeshes.trigger = controllerObject3D.getObjectByName("trigger"), buttonObjects.trigger = controllerObject3D.getObjectByName("xr_standard_trigger_pressed_value"), buttonRanges.trigger = {
                min: controllerObject3D.getObjectByName("xr_standard_trigger_pressed_min"),
                max: controllerObject3D.getObjectByName("xr_standard_trigger_pressed_max")
              }, buttonRanges.trigger.diff = {
                x: Math.abs(buttonRanges.trigger.max.rotation.x) - Math.abs(buttonRanges.trigger.min.rotation.x),
                y: Math.abs(buttonRanges.trigger.max.rotation.y) - Math.abs(buttonRanges.trigger.min.rotation.y),
                z: Math.abs(buttonRanges.trigger.max.rotation.z) - Math.abs(buttonRanges.trigger.min.rotation.z)
              };
              var button1 = this.data.hand === "left" ? "x" : "a", button2 = this.data.hand === "left" ? "y" : "b", button1id = button1 + "button", button2id = button2 + "button";
              buttonMeshes[button1id] = controllerObject3D.getObjectByName(button1 + "_button"), buttonObjects[button1id] = controllerObject3D.getObjectByName(button1 + "_button_pressed_value"), buttonRanges[button1id] = {
                min: controllerObject3D.getObjectByName(button1 + "_button_pressed_min"),
                max: controllerObject3D.getObjectByName(button1 + "_button_pressed_max")
              }, buttonMeshes[button2id] = controllerObject3D.getObjectByName(button2 + "_button"), buttonObjects[button2id] = controllerObject3D.getObjectByName(button2 + "_button_pressed_value"), buttonRanges[button2id] = {
                min: controllerObject3D.getObjectByName(button2 + "_button_pressed_min"),
                max: controllerObject3D.getObjectByName(button2 + "_button_pressed_max")
              };
            },
            onAxisMoved: function(evt) {
              emitIfAxesChanged(this, this.mapping[this.data.hand].axes, evt);
            },
            onThumbstickMoved: function(evt) {
              if (!(!this.buttonMeshes || !this.buttonMeshes.thumbstick)) {
                if (this.isTouchV3orPROorPlus) {
                  this.updateThumbstickTouchV3orPROorPlus(evt);
                  return;
                }
                for (var axis in evt.detail)
                  this.buttonObjects.thumbstick.rotation[this.axisMap[axis]] = this.buttonRanges.thumbstick.originalRotation[this.axisMap[axis]] - Math.PI / 8 * evt.detail[axis] * (axis === "y" || this.data.hand === "right" ? -1 : 1);
              }
            },
            axisMap: {
              y: "x",
              x: "z"
            },
            updateThumbstickTouchV3orPROorPlus: function(evt) {
              var normalizedXAxis = (evt.detail.x + 1) / 2;
              this.buttonObjects.thumbstickXAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickXAxis.min.quaternion, this.buttonRanges.thumbstickXAxis.max.quaternion, normalizedXAxis);
              var normalizedYAxis = (evt.detail.y + 1) / 2;
              this.buttonObjects.thumbstickYAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickYAxis.min.quaternion, this.buttonRanges.thumbstickYAxis.max.quaternion, normalizedYAxis);
            },
            updateModel: function(buttonName, evtName) {
              !this.data.model || this.updateButtonModel(buttonName, evtName);
            },
            updateButtonModel: function(buttonName, state) {
              var buttonMeshes = this.buttonMeshes, button, color;
              !buttonMeshes || buttonMeshes[buttonName] && (color = state === "up" || state === "touchend" ? buttonMeshes[buttonName].originalColor || this.data.buttonColor : state === "touchstart" ? this.data.buttonTouchColor : this.data.buttonHighlightColor, button = buttonMeshes[buttonName], button.material.color.set(color));
            }
          });
          function cloneMeshMaterial(object3d) {
            object3d.traverse(function(node) {
              var newMaterial;
              node.type === "Mesh" && (newMaterial = node.material.clone(), object3d.originalColor = node.material.color, node.material.dispose(), node.material = newMaterial);
            });
          }
        },
        "./src/components/pico-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged, onButtonEvent = trackedControlsUtils.onButtonEvent, GAMEPAD_ID = "pico-4", AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, PICO_MODEL_GLB_BASE_URL = AFRAME_CDN_ROOT + "controllers/pico/pico4/", INPUT_MAPPING_WEBXR = {
            left: {
              axes: {
                touchpad: [2, 3]
              },
              buttons: ["trigger", "squeeze", "none", "thumbstick", "xbutton", "ybutton"]
            },
            right: {
              axes: {
                touchpad: [2, 3]
              },
              buttons: ["trigger", "squeeze", "none", "thumbstick", "abutton", "bbutton"]
            }
          };
          module3.exports.Component = registerComponent("pico-controls", {
            schema: {
              hand: {
                default: "none"
              },
              model: {
                default: !0
              },
              orientationOffset: {
                type: "vec3"
              }
            },
            mapping: INPUT_MAPPING_WEBXR,
            init: function() {
              var self2 = this;
              this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(evt) {
                onButtonEvent(evt.detail.id, "down", self2, self2.data.hand);
              }, this.onButtonUp = function(evt) {
                onButtonEvent(evt.detail.id, "up", self2, self2.data.hand);
              }, this.onButtonTouchEnd = function(evt) {
                onButtonEvent(evt.detail.id, "touchend", self2, self2.data.hand);
              }, this.onButtonTouchStart = function(evt) {
                onButtonEvent(evt.detail.id, "touchstart", self2, self2.data.hand);
              }, this.bindMethods();
            },
            update: function() {
              var data = this.data;
              this.controllerIndex = data.hand === "right" ? 0 : data.hand === "left" ? 1 : 2;
            },
            play: function() {
              this.checkIfControllerPresent(), this.addControllersUpdateListener();
            },
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            bindMethods: function() {
              this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("buttonchanged", this.onButtonChanged), el.addEventListener("buttondown", this.onButtonDown), el.addEventListener("buttonup", this.onButtonUp), el.addEventListener("touchstart", this.onButtonTouchStart), el.addEventListener("touchend", this.onButtonTouchEnd), el.addEventListener("axismove", this.onAxisMoved), el.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0;
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("buttonchanged", this.onButtonChanged), el.removeEventListener("buttondown", this.onButtonDown), el.removeEventListener("buttonup", this.onButtonUp), el.removeEventListener("touchstart", this.onButtonTouchStart), el.removeEventListener("touchend", this.onButtonTouchEnd), el.removeEventListener("axismove", this.onAxisMoved), el.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1;
            },
            checkIfControllerPresent: function() {
              var data = this.data;
              checkControllerPresentAndSetup(this, GAMEPAD_ID, {
                index: this.controllerIndex,
                hand: data.hand
              });
            },
            injectTrackedControls: function() {
              var el = this.el, data = this.data;
              el.setAttribute("tracked-controls", {
                idPrefix: GAMEPAD_ID,
                hand: data.hand,
                controller: this.controllerIndex,
                orientationOffset: data.orientationOffset
              }), !!this.data.model && this.el.setAttribute("gltf-model", PICO_MODEL_GLB_BASE_URL + this.data.hand + ".glb");
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              this.checkIfControllerPresent();
            },
            onButtonChanged: function(evt) {
              var button = this.mapping[this.data.hand].buttons[evt.detail.id], analogValue;
              !button || (button === "trigger" && (analogValue = evt.detail.state.value, console.log("analog value of trigger press: " + analogValue)), this.el.emit(button + "changed", evt.detail.state));
            },
            onModelLoaded: function(evt) {
              evt.target !== this.el || !this.data.model || this.el.emit("controllermodelready", {
                name: "pico-controls",
                model: this.data.model,
                rayOrigin: new THREE3.Vector3(0, 0, 0)
              });
            },
            onAxisMoved: function(evt) {
              emitIfAxesChanged(this, this.mapping.axes, evt);
            }
          });
        },
        "./src/components/position.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = registerComponent("position", {
            schema: {
              type: "vec3"
            },
            update: function() {
              var object3D = this.el.object3D, data = this.data;
              object3D.position.set(data.x, data.y, data.z);
            },
            remove: function() {
              this.el.object3D.position.set(0, 0, 0);
            }
          });
        },
        "./src/components/raycaster.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js"), warn = utils.debug("components:raycaster:warn"), OBSERVER_SELECTOR_RE = /^[\w\s-.,[\]#]*$/, OBSERVER_CONFIG = {
            childList: !0,
            attributes: !0,
            subtree: !0
          }, EVENTS = {
            INTERSECT: "raycaster-intersected",
            INTERSECTION: "raycaster-intersection",
            INTERSECT_CLEAR: "raycaster-intersected-cleared",
            INTERSECTION_CLEAR: "raycaster-intersection-cleared",
            INTERSECTION_CLOSEST_ENTITY_CHANGED: "raycaster-closest-entity-changed"
          };
          module3.exports.Component = registerComponent("raycaster", {
            schema: {
              autoRefresh: {
                default: !0
              },
              direction: {
                type: "vec3",
                default: {
                  x: 0,
                  y: 0,
                  z: -1
                }
              },
              enabled: {
                default: !0
              },
              far: {
                default: 1e3
              },
              interval: {
                default: 0
              },
              near: {
                default: 0
              },
              objects: {
                default: ""
              },
              origin: {
                type: "vec3"
              },
              showLine: {
                default: !1
              },
              lineColor: {
                default: "white"
              },
              lineOpacity: {
                default: 1
              },
              useWorldCoordinates: {
                default: !1
              }
            },
            multiple: !0,
            init: function() {
              this.clearedIntersectedEls = [], this.unitLineEndVec3 = new THREE3.Vector3(), this.intersectedEls = [], this.intersections = [], this.newIntersectedEls = [], this.newIntersections = [], this.objects = [], this.prevCheckTime = void 0, this.prevIntersectedEls = [], this.rawIntersections = [], this.raycaster = new THREE3.Raycaster(), this.updateOriginDirection(), this.setDirty = this.setDirty.bind(this), this.updateLine = this.updateLine.bind(this), this.observer = new MutationObserver(this.setDirty), this.dirty = !0, this.lineEndVec3 = new THREE3.Vector3(), this.otherLineEndVec3 = new THREE3.Vector3(), this.lineData = {
                end: this.lineEndVec3
              }, this.getIntersection = this.getIntersection.bind(this), this.intersectedDetail = {
                el: this.el,
                getIntersection: this.getIntersection
              }, this.intersectedClearedDetail = {
                el: this.el
              }, this.intersectionClearedDetail = {
                clearedEls: this.clearedIntersectedEls
              }, this.intersectionDetail = {};
            },
            update: function(oldData) {
              var data = this.data, el = this.el, raycaster = this.raycaster;
              raycaster.far = data.far, raycaster.near = data.near, data.showLine && (data.far !== oldData.far || data.origin !== oldData.origin || data.direction !== oldData.direction || !oldData.showLine) && (this.unitLineEndVec3.copy(data.direction).normalize(), this.drawLine()), !data.showLine && oldData.showLine && el.removeAttribute("line"), data.objects !== oldData.objects && !OBSERVER_SELECTOR_RE.test(data.objects) && warn('[raycaster] Selector "' + data.objects + '" may not update automatically with DOM changes.'), data.objects || warn('[raycaster] For performance, please define raycaster.objects when using raycaster or cursor components to whitelist which entities to intersect with. e.g., raycaster="objects: [data-raycastable]".'), data.autoRefresh !== oldData.autoRefresh && el.isPlaying && (data.autoRefresh ? this.addEventListeners() : this.removeEventListeners()), oldData.enabled && !data.enabled && this.clearAllIntersections(), this.setDirty();
            },
            play: function() {
              this.addEventListeners();
            },
            pause: function() {
              this.removeEventListeners();
            },
            remove: function() {
              this.data.showLine && this.el.removeAttribute("line"), this.clearAllIntersections();
            },
            addEventListeners: function() {
              !this.data.autoRefresh || (this.observer.observe(this.el.sceneEl, OBSERVER_CONFIG), this.el.sceneEl.addEventListener("object3dset", this.setDirty), this.el.sceneEl.addEventListener("object3dremove", this.setDirty));
            },
            removeEventListeners: function() {
              this.observer.disconnect(), this.el.sceneEl.removeEventListener("object3dset", this.setDirty), this.el.sceneEl.removeEventListener("object3dremove", this.setDirty);
            },
            setDirty: function() {
              this.dirty = !0;
            },
            refreshObjects: function() {
              var data = this.data, els;
              els = data.objects ? this.el.sceneEl.querySelectorAll(data.objects) : this.el.sceneEl.querySelectorAll("*"), this.objects = this.flattenObject3DMaps(els), this.dirty = !1;
            },
            tock: function(time) {
              var data = this.data, prevCheckTime = this.prevCheckTime;
              !data.enabled || prevCheckTime && time - prevCheckTime < data.interval || (this.prevCheckTime = time, this.checkIntersections());
            },
            checkIntersections: function() {
              var clearedIntersectedEls = this.clearedIntersectedEls, el = this.el, data = this.data, i, intersectedEls = this.intersectedEls, intersection, intersections = this.intersections, newIntersectedEls = this.newIntersectedEls, newIntersections = this.newIntersections, prevIntersectedEls = this.prevIntersectedEls, rawIntersections = this.rawIntersections;
              for (this.dirty && this.refreshObjects(), copyArray(this.prevIntersectedEls, this.intersectedEls), this.updateOriginDirection(), rawIntersections.length = 0, this.raycaster.intersectObjects(this.objects, !0, rawIntersections), intersections.length = 0, intersectedEls.length = 0, i = 0; i < rawIntersections.length; i++)
                intersection = rawIntersections[i], !(data.showLine && intersection.object === el.getObject3D("line")) && intersection.object.el && (intersections.push(intersection), intersectedEls.push(intersection.object.el));
              for (newIntersections.length = 0, newIntersectedEls.length = 0, i = 0; i < intersections.length; i++)
                prevIntersectedEls.indexOf(intersections[i].object.el) === -1 && (newIntersections.push(intersections[i]), newIntersectedEls.push(intersections[i].object.el));
              for (clearedIntersectedEls.length = 0, i = 0; i < prevIntersectedEls.length; i++)
                intersectedEls.indexOf(prevIntersectedEls[i]) === -1 && (prevIntersectedEls[i].emit(EVENTS.INTERSECT_CLEAR, this.intersectedClearedDetail), clearedIntersectedEls.push(prevIntersectedEls[i]));
              for (clearedIntersectedEls.length && el.emit(EVENTS.INTERSECTION_CLEAR, this.intersectionClearedDetail), i = 0; i < newIntersectedEls.length; i++)
                newIntersectedEls[i].emit(EVENTS.INTERSECT, this.intersectedDetail);
              newIntersections.length && (this.intersectionDetail.els = newIntersectedEls, this.intersectionDetail.intersections = newIntersections, el.emit(EVENTS.INTERSECTION, this.intersectionDetail)), (prevIntersectedEls.length === 0 && intersections.length > 0 || prevIntersectedEls.length > 0 && intersections.length === 0 || prevIntersectedEls.length && intersections.length && prevIntersectedEls[0] !== intersections[0].object.el) && (this.intersectionDetail.els = this.intersectedEls, this.intersectionDetail.intersections = intersections, el.emit(EVENTS.INTERSECTION_CLOSEST_ENTITY_CHANGED, this.intersectionDetail)), data.showLine && setTimeout(this.updateLine);
            },
            updateLine: function() {
              var el = this.el, intersections = this.intersections, lineLength;
              intersections.length && (intersections[0].object.el === el && intersections[1] ? lineLength = intersections[1].distance : lineLength = intersections[0].distance), this.drawLine(lineLength);
            },
            getIntersection: function(el) {
              var i, intersection;
              for (i = 0; i < this.intersections.length; i++)
                if (intersection = this.intersections[i], intersection.object.el === el)
                  return intersection;
              return null;
            },
            updateOriginDirection: function() {
              var direction = new THREE3.Vector3(), originVec3 = new THREE3.Vector3();
              return function() {
                var el = this.el, data = this.data;
                if (data.useWorldCoordinates) {
                  this.raycaster.set(data.origin, data.direction);
                  return;
                }
                el.object3D.updateMatrixWorld(), originVec3.setFromMatrixPosition(el.object3D.matrixWorld), (data.origin.x !== 0 || data.origin.y !== 0 || data.origin.z !== 0) && (originVec3 = el.object3D.localToWorld(originVec3.copy(data.origin))), direction.copy(data.direction).transformDirection(el.object3D.matrixWorld).normalize(), this.raycaster.set(originVec3, direction);
              };
            }(),
            drawLine: function(length) {
              var data = this.data, el = this.el, endVec3;
              endVec3 = this.lineData.end === this.lineEndVec3 ? this.otherLineEndVec3 : this.lineEndVec3, length === void 0 && (length = data.far === 1 / 0 ? 1e3 : data.far), this.lineData.start = data.origin, this.lineData.end = endVec3.copy(this.unitLineEndVec3).multiplyScalar(length).add(data.origin), this.lineData.color = data.lineColor, this.lineData.opacity = data.lineOpacity, el.setAttribute("line", this.lineData);
            },
            flattenObject3DMaps: function(els) {
              var key, i, objects = this.objects, scene = this.el.sceneEl.object3D;
              function isAttachedToScene(object) {
                return object.parent ? isAttachedToScene(object.parent) : object === scene;
              }
              for (objects.length = 0, i = 0; i < els.length; i++) {
                var el = els[i];
                if (el.isEntity && el.object3D && isAttachedToScene(el.object3D))
                  for (key in el.object3DMap)
                    objects.push(el.getObject3D(key));
              }
              return objects;
            },
            clearAllIntersections: function() {
              var i;
              for (i = 0; i < this.intersectedEls.length; i++)
                this.intersectedEls[i].emit(EVENTS.INTERSECT_CLEAR, this.intersectedClearedDetail);
              copyArray(this.clearedIntersectedEls, this.intersectedEls), this.intersectedEls.length = 0, this.intersections.length = 0, this.el.emit(EVENTS.INTERSECTION_CLEAR, this.intersectionClearedDetail);
            }
          });
          function copyArray(a, b) {
            var i;
            for (a.length = b.length, i = 0; i < b.length; i++)
              a[i] = b[i];
          }
        },
        "./src/components/rotation.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var degToRad = __webpack_require__2("./src/lib/three.js").MathUtils.degToRad, registerComponent = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = registerComponent("rotation", {
            schema: {
              type: "vec3"
            },
            update: function() {
              var data = this.data, object3D = this.el.object3D;
              object3D.rotation.set(degToRad(data.x), degToRad(data.y), degToRad(data.z), "YXZ");
            },
            remove: function() {
              this.el.object3D.rotation.set(0, 0, 0);
            }
          });
        },
        "./src/components/scale.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = registerComponent("scale", {
            schema: {
              type: "vec3",
              default: {
                x: 1,
                y: 1,
                z: 1
              }
            },
            update: function() {
              var data = this.data, object3D = this.el.object3D;
              object3D.scale.set(data.x, data.y, data.z);
            },
            remove: function() {
              this.el.object3D.scale.set(1, 1, 1);
            }
          });
        },
        "./src/components/scene/ar-hit-test.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var arrowURL = "data:image/webp;base64,UklGRkQHAABXRUJQVlA4WAoAAAAQAAAA/wEA/wEAQUxQSL0DAAARDzD/ERGCjrY9sYYFfgo6aa1kJ7K0w9Lo3AadLSVeFxevQwj5kuM8RfR/Atw/C0+ozB/oUBrloFZs6ElSW88j1KA4yExNWQaqRZquIDF0JYmlq0hAuUDTFu66tng3teW7pa3cQf1V1edvur54M/Slm6Wv3Gx9zw0MXlQLntcsBN6wkHjTQuYtC4W3LTw8mGRVG57TbAROtxHfZNhInGkjc5aNwtk2Hg6Mvki14k+NkZzCwQgCxalcAv3kddRTPI1DcUrXId1FLf1uHpzaQz4tquhZVLlKesbVpqKeTj0n0F5PpXDlFN9UqmhalL/ImuZFo6KmToWLoKlddMprqlS8cKovBvHo2kTiFV2LN4msaxKZl3QNiair8xYRdDWivIvXVXmbcMqJ51UebZuFXxZt6xd4laxtciqRtA3Cv0nU1t+kEUFbI8JvCa+tvkm3FDlO/W+OR99+kWEp/YYo+tYfTVnf/K8cE/F///3vv//993eeL+a+uvjawLcX3xjYvJotBFY3kVjTRGFtE+BU2AiMbiQyhpHMWEYeBozAH5qNBYRDB5KBCaTDBKKBAZTDBoKBDjwHAN5ABeCJBsAZcAAC0YHHxAYSMYBiYgGZWEA2MYFCbCCZGAAIANFEB+AnYgMQTDQAYSJ2AN5EBZAm4gDgTDgAeSIu4DGygTIRN1CMLOCZiACykQlg4jsAycgA8AO+BxCNdJyDkcbwRirDGXGnx8w+FDPrkM3MQ9JQZMYhiiwV/RDMtIM3U1/DmXHUo+IR2kSR2ToWkQ1NIn2qf2J8LCqJKiDUiSADHY3whirhdHgZ94HKaR97PhE+twEUJUFoAcgyTct8hfSxSkShASDKdMJ/ritKHwgyQ0sD4D/miCxU5SbhOOUDTnZpccCjYP/i0bZ/8bAgtVGEoGapWIQXyzKVKLwgNJFk2rtMIgoNRJlOZF7SNSSyUEeQmbxBFKEmtYjEe8S8zOZ1AkJVCmS88FJOtF40Ksg4oUaFiygk3C8qlTVNyl8UTevCUdAE2t14PfVqU1FPp57TopKeQZWromddTQp6QOfTOEQt/ZDuipZ11w/wOiqO8dRORcc6BQEkDQMClaHcn5wV9yLbxsNZNgpn2sicYSNxuo34Js1G4FQbnuNsOPa28PCWhcKbFjJvWEi8ZiHwqgXPcxbc5db33Cx95WboSzddX7yp+vyN0+eul7ZyN7Xlu64t3jVt4c5pc4JLV5EYupJE0xUknC4nOjVlmaYpyLit53HCQ0+ScnqceNcS5dzUkd0/CwMAVlA4IGADAAAQXwCdASoAAgACP8ne6Wy/tjCpqJ/IA/A5CWlu4XYBG/Pz8AfwD8APz//f3v8E1fuHZnxKYACtfuHZnxKYACrYTb5mOslhxu843ecbvON3nG7zjd3a0VCn7G1MABVxwH/Xd25gAK1+4dmfEpe2+PHhQaj75++riG6FuYACtfuHZnxKYACRrK3q9xO8Ss3uWKnMhs/rDF1hi6wxdYYusMXWGI5QRcCFDZog5OgqNlse1NDuz/UoFa/cOzPiUwAEsAOK4/nu5eZHK2tlXxJfNYlMABWv3Dsz4bvNJ5YA/LtxJ38SmAArX7h2Z8Sk5vdZUYv7mZPiUwAFa/cOzPh21s5OgZxf1mfEpemRyFr/rM+JS9noA/LtxJ38SmAAlUJIotzAASn6TjdhK+D3Dsz4dyvB7h2Z8O2tnJ0DOL+sz4lL2nKLT4lL/+iSLOocxq639w7M34MNZdm55uJ8v8ra2cpVZnxKTq2F3PN/cNksAfl24k7+JTAASqrD37h2Z7b1W+VtbOUqsz4lJ1bC7nm/uGyWAPy7cSd/EpgAJVVh79w7M9t6rfK2tnKVWZ8Sk6thdzzf3DZLAH5duJO/iUwAEqqw9+4dme29VvlbWzlKrM+JSdWwu55v7hslgD8u3EnfxKYACVVYe/cOzPbeq3ytrZylVme0kYJ8557FLerqFrzIbPrrf3DZLAH5duJO/iUvaVMS9BoaF4p7pSDFTP1XMyfElelrM0DOL+sz4eBJ13nV1OppBGPuKb4YzXQgq9uH19uS/0+JS9t9fr6ZUlQBelDG6GMgq97otb5QMPJwtKyBTbFp8Sl7b6/X0ykkawEOsgdiE6Fi0vb/Eve6xkwsmug0Z4nGNHQO8839bpTsjpz7SWIJxKagvd1QWMa6FYT1KEw3j4XDT6vJ9Xk+nyfT5Pq8n1eEmk5dinMM/9Fcfz4Z3Dsz3KD2dw7LxBRxKrqUUGQPH/7zxr1KIfNpLEJ0MZB2ITM/0Z2EFoh12NlXnEcpYcbvON3nG7zjd5xu84vfcNIAAP7+y8ceyzbVxkakPYY4lcr72fqOnDwipv+yxC71wAADBrjKnAAAAAAAAAAAAAAw7oNGHttqWONcoFN/2WIDc2pa6WVFtFYROlsaMaTXdcOjXHz93+YxAglKa4AAAAA=", register = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), CAM_LAYER = 21, applyPose = function() {
            var tempQuaternion = new THREE3.Quaternion(), tempVec3 = new THREE3.Vector3();
            function applyPose2(pose, object3D, offset) {
              object3D.position.copy(pose.transform.position), object3D.quaternion.copy(pose.transform.orientation), tempVec3.copy(offset), tempQuaternion.copy(pose.transform.orientation), tempVec3.applyQuaternion(tempQuaternion), object3D.position.sub(tempVec3);
            }
            return applyPose2;
          }();
          applyPose.tempFakePose = {
            transform: {
              orientation: new THREE3.Quaternion(),
              position: new THREE3.Vector3()
            }
          };
          function HitTest(renderer, hitTestSourceDetails) {
            this.renderer = renderer, this.xrHitTestSource = null, renderer.xr.addEventListener("sessionend", function() {
              this.xrHitTestSource = null;
            }.bind(this)), renderer.xr.addEventListener("sessionstart", function() {
              this.sessionStart(hitTestSourceDetails);
            }.bind(this)), this.renderer.xr.isPresenting && this.sessionStart(hitTestSourceDetails);
          }
          HitTest.prototype.previousFrameAnchors = new Set(), HitTest.prototype.anchorToObject3D = new Map();
          function warnAboutHitTest(e) {
            console.warn(e.message), console.warn('Cannot requestHitTestSource Are you missing: webxr="optionalFeatures: hit-test;" from <a-scene>?');
          }
          HitTest.prototype.sessionStart = function(hitTestSourceDetails) {
            if (this.session = this.renderer.xr.getSession(), !("requestHitTestSource" in this.session)) {
              warnAboutHitTest({
                message: "No requestHitTestSource on the session."
              });
              return;
            }
            hitTestSourceDetails.space ? this.session.requestHitTestSource(hitTestSourceDetails).then(function(xrHitTestSource) {
              this.xrHitTestSource = xrHitTestSource;
            }.bind(this)).catch(warnAboutHitTest) : hitTestSourceDetails.profile && this.session.requestHitTestSourceForTransientInput(hitTestSourceDetails).then(function(xrHitTestSource) {
              this.xrHitTestSource = xrHitTestSource, this.transient = !0;
            }.bind(this)).catch(warnAboutHitTest);
          }, HitTest.prototype.anchorFromLastHitTestResult = function(object3D, offset) {
            var hitTest = this.lastHitTest;
            if (!!hitTest) {
              var object3DOptions = {
                object3D,
                offset
              };
              Array.from(this.anchorToObject3D.entries()).forEach(function(entry) {
                var entryObject = entry[1].object3D, anchor = entry[0];
                entryObject === object3D && (this.anchorToObject3D.delete(anchor), anchor.delete());
              }.bind(this)), hitTest.createAnchor && hitTest.createAnchor().then(function(anchor) {
                this.anchorToObject3D.set(anchor, object3DOptions);
              }.bind(this)).catch(function(e) {
                console.warn(e.message), console.warn('Cannot create anchor, are you missing: webxr="optionalFeatures: anchors;" from <a-scene>?');
              });
            }
          }, HitTest.prototype.doHit = function(frame) {
            if (!!this.renderer.xr.isPresenting) {
              var refSpace = this.renderer.xr.getReferenceSpace(), xrViewerPose = frame.getViewerPose(refSpace), hitTestResults, results;
              if (this.xrHitTestSource && xrViewerPose)
                return this.transient ? (hitTestResults = frame.getHitTestResultsForTransientInput(this.xrHitTestSource), hitTestResults.length > 0 ? (results = hitTestResults[0].results, results.length > 0 ? (this.lastHitTest = results[0], results[0].getPose(refSpace)) : !1) : !1) : (hitTestResults = frame.getHitTestResults(this.xrHitTestSource), hitTestResults.length > 0 ? (this.lastHitTest = hitTestResults[0], hitTestResults[0].getPose(refSpace)) : !1);
            }
          }, HitTest.updateAnchorPoses = function(frame, refSpace) {
            var trackedAnchors = frame.trackedAnchors || HitTest.prototype.previousFrameAnchors;
            HitTest.prototype.previousFrameAnchors.forEach(function(anchor) {
              trackedAnchors.has(anchor) || HitTest.prototype.anchorToObject3D.delete(anchor);
            }), trackedAnchors.forEach(function(anchor) {
              var anchorPose, object3DOptions, offset, object3D;
              try {
                anchorPose = frame.getPose(anchor.anchorSpace, refSpace);
              } catch (e) {
              }
              if (anchorPose) {
                if (object3DOptions = HitTest.prototype.anchorToObject3D.get(anchor), !object3DOptions)
                  return;
                offset = object3DOptions.offset, object3D = object3DOptions.object3D, applyPose(anchorPose, object3D, offset);
              }
            });
          };
          var hitTestCache;
          module3.exports.Component = register("ar-hit-test", {
            schema: {
              target: {
                type: "selector"
              },
              enabled: {
                default: !0
              },
              src: {
                default: arrowURL,
                type: "map"
              },
              type: {
                default: "footprint",
                oneOf: ["footprint", "map"]
              },
              footprintDepth: {
                default: 0.1
              },
              mapSize: {
                type: "vec2",
                default: {
                  x: 0.5,
                  y: 0.5
                }
              }
            },
            sceneOnly: !0,
            init: function() {
              this.hitTest = null, this.imageDataArray = new Uint8ClampedArray(512 * 512 * 4), this.imageData = new ImageData(this.imageDataArray, 512, 512), this.textureCache = new Map(), this.orthoCam = new THREE3.OrthographicCamera(), this.orthoCam.layers.set(CAM_LAYER), this.textureTarget = new THREE3.WebGLRenderTarget(512, 512, {}), this.basicMaterial = new THREE3.MeshBasicMaterial({
                color: 0,
                side: THREE3.DoubleSide
              }), this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.context.imageSmoothingEnabled = !1, this.canvas.width = 512, this.canvas.height = 512, this.canvasTexture = new THREE3.CanvasTexture(this.canvas, {
                alpha: !0
              }), this.canvasTexture.flipY = !1;
              var webxrData = this.el.getAttribute("webxr"), optionalFeaturesArray = webxrData.optionalFeatures;
              (!optionalFeaturesArray.includes("hit-test") || !optionalFeaturesArray.includes("anchors")) && (optionalFeaturesArray.push("hit-test"), optionalFeaturesArray.push("anchors"), this.el.setAttribute("webxr", webxrData)), this.el.sceneEl.renderer.xr.addEventListener("sessionend", function() {
                this.hitTest = null;
              }.bind(this)), this.el.sceneEl.renderer.xr.addEventListener("sessionstart", function() {
                if (!!this.el.is("ar-mode")) {
                  var renderer = this.el.sceneEl.renderer, session = this.session = renderer.xr.getSession();
                  this.hasPosedOnce = !1, this.bboxMesh.visible = !1, hitTestCache || (hitTestCache = new Map()), session.requestReferenceSpace("viewer").then(function(viewerSpace) {
                    this.hitTest = new HitTest(renderer, {
                      space: viewerSpace
                    }), hitTestCache.set(viewerSpace, this.hitTest), this.el.emit("ar-hit-test-start");
                  }.bind(this));
                  var profileToSupport = "generic-touchscreen", transientHitTest = new HitTest(renderer, {
                    profile: profileToSupport
                  });
                  session.addEventListener("selectstart", function(e) {
                    if (this.data.enabled === !0) {
                      var inputSource = e.inputSource;
                      this.bboxMesh.visible = !0, this.hasPosedOnce === !0 && (this.el.emit("ar-hit-test-select-start", {
                        inputSource,
                        position: this.bboxMesh.position,
                        orientation: this.bboxMesh.quaternion
                      }), inputSource.profiles[0] === profileToSupport ? this.hitTest = transientHitTest : (this.hitTest = hitTestCache.get(inputSource) || new HitTest(renderer, {
                        space: inputSource.targetRaySpace
                      }), hitTestCache.set(inputSource, this.hitTest)));
                    }
                  }.bind(this)), session.addEventListener("selectend", function(e) {
                    if (!this.hitTest || this.data.enabled !== !0) {
                      this.hitTest = null;
                      return;
                    }
                    var inputSource = e.inputSource, object;
                    this.hasPosedOnce === !0 && (this.bboxMesh.visible = !1, this.data.target && (object = this.data.target.object3D, object && (applyPose.tempFakePose.transform.position.copy(this.bboxMesh.position), applyPose.tempFakePose.transform.orientation.copy(this.bboxMesh.quaternion), applyPose(applyPose.tempFakePose, object, this.bboxOffset), object.visible = !0, this.hitTest.anchorFromLastHitTestResult(object, this.bboxOffset))), this.el.emit("ar-hit-test-select", {
                      inputSource,
                      position: this.bboxMesh.position,
                      orientation: this.bboxMesh.quaternion
                    })), this.hitTest = null;
                  }.bind(this));
                }
              }.bind(this)), this.bboxOffset = new THREE3.Vector3(), this.update = this.update.bind(this), this.makeBBox();
            },
            update: function() {
              this.data.enabled === !1 && (this.hitTest = null, this.bboxMesh.visible = !1), this.data.target && (this.data.target.object3D ? (this.data.target.addEventListener("model-loaded", this.update), this.data.target.object3D.layers.enable(CAM_LAYER), this.data.target.object3D.traverse(function(child) {
                child.layers.enable(CAM_LAYER);
              })) : this.data.target.addEventListener("loaded", this.update, {
                once: !0
              })), this.bboxNeedsUpdate = !0;
            },
            makeBBox: function() {
              var geometry = new THREE3.PlaneGeometry(1, 1), material = new THREE3.MeshBasicMaterial({
                transparent: !0,
                color: 16777215
              });
              geometry.rotateX(-Math.PI / 2), geometry.rotateY(-Math.PI / 2), this.bbox = new THREE3.Box3(), this.bboxMesh = new THREE3.Mesh(geometry, material), this.el.setObject3D("ar-hit-test", this.bboxMesh), this.bboxMesh.visible = !1;
            },
            updateFootprint: function() {
              var tempImageData, renderer = this.el.sceneEl.renderer, oldRenderTarget, oldBackground, isXREnabled = renderer.xr.enabled;
              this.bboxMesh.material.map = this.canvasTexture, this.bboxMesh.material.needsUpdate = !0, this.orthoCam.rotation.set(-Math.PI / 2, 0, -Math.PI / 2), this.orthoCam.position.copy(this.bboxMesh.position), this.orthoCam.position.y -= this.bboxMesh.scale.y / 2, this.orthoCam.near = 0.1, this.orthoCam.far = this.orthoCam.near + this.data.footprintDepth * this.bboxMesh.scale.y, this.orthoCam.position.y += this.orthoCam.far, this.orthoCam.right = this.bboxMesh.scale.z / 2, this.orthoCam.left = -this.bboxMesh.scale.z / 2, this.orthoCam.top = this.bboxMesh.scale.x / 2, this.orthoCam.bottom = -this.bboxMesh.scale.x / 2, this.orthoCam.updateProjectionMatrix(), oldRenderTarget = renderer.getRenderTarget(), renderer.setRenderTarget(this.textureTarget), renderer.xr.enabled = !1, oldBackground = this.el.object3D.background, this.el.object3D.overrideMaterial = this.basicMaterial, this.el.object3D.background = null, renderer.render(this.el.object3D, this.orthoCam), this.el.object3D.background = oldBackground, this.el.object3D.overrideMaterial = null, renderer.xr.enabled = isXREnabled, renderer.setRenderTarget(oldRenderTarget), renderer.readRenderTargetPixels(this.textureTarget, 0, 0, 512, 512, this.imageDataArray), this.context.putImageData(this.imageData, 0, 0), this.context.shadowColor = "white", this.context.shadowBlur = 10, this.context.drawImage(this.canvas, 0, 0), tempImageData = this.context.getImageData(0, 0, 512, 512);
              for (var i = 0; i < 512 * 512; i++)
                tempImageData.data[i * 4 + 3] !== 0 && tempImageData.data[i * 4 + 3] !== 255 && (tempImageData.data[i * 4 + 3] = 128);
              this.context.putImageData(tempImageData, 0, 0), this.canvasTexture.needsUpdate = !0;
            },
            tick: function() {
              var pose, frame = this.el.sceneEl.frame, renderer = this.el.sceneEl.renderer;
              if (frame && HitTest.updateAnchorPoses(frame, renderer.xr.getReferenceSpace()), this.bboxNeedsUpdate) {
                if (this.bboxNeedsUpdate = !1, !this.data.target || this.data.type === "map") {
                  var texture;
                  this.textureCache.has(this.data.src) ? texture = this.textureCache.get(this.data.src) : (texture = new THREE3.TextureLoader().load(this.data.src), this.textureCache.set(this.data.src, texture)), this.bboxMesh.material.map = texture, this.bboxMesh.material.needsUpdate = !0;
                }
                this.data.target && this.data.target.object3D ? (this.bbox.setFromObject(this.data.target.object3D), this.bbox.getCenter(this.bboxMesh.position), this.bbox.getSize(this.bboxMesh.scale), this.data.type === "footprint" && (this.bboxMesh.scale.x *= 1.04, this.bboxMesh.scale.z *= 1.04, this.updateFootprint()), this.bboxMesh.position.y -= this.bboxMesh.scale.y / 2, this.bboxOffset.copy(this.bboxMesh.position), this.bboxOffset.sub(this.data.target.object3D.position)) : this.bboxMesh.scale.set(this.data.mapSize.x, 1, this.data.mapSize.y);
              }
              this.hitTest && (pose = this.hitTest.doHit(frame), pose && (this.hasPosedOnce !== !0 && (this.hasPosedOnce = !0, this.el.emit("ar-hit-test-achieved")), this.bboxMesh.visible = !0, this.bboxMesh.position.copy(pose.transform.position), this.bboxMesh.quaternion.copy(pose.transform.orientation)));
            }
          });
        },
        "./src/components/scene/background.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var register = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = register("background", {
            schema: {
              color: {
                type: "color",
                default: "black"
              },
              transparent: {
                default: !1
              }
            },
            sceneOnly: !0,
            update: function() {
              var data = this.data, object3D = this.el.object3D;
              data.transparent ? object3D.background = null : object3D.background = new THREE.Color(data.color);
            },
            remove: function() {
              var object3D = this.el.object3D;
              object3D.background = null;
            }
          });
        },
        "./src/components/scene/debug.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var register = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = register("debug", {
            schema: {
              default: !0
            },
            sceneOnly: !0
          });
        },
        "./src/components/scene/device-orientation-permission-ui.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, constants = __webpack_require__2("./src/constants/index.js"), MODAL_CLASS = "a-modal", DIALOG_CLASS = "a-dialog", DIALOG_TEXT_CLASS = "a-dialog-text", DIALOG_TEXT_CONTAINER_CLASS = "a-dialog-text-container", DIALOG_BUTTONS_CONTAINER_CLASS = "a-dialog-buttons-container", DIALOG_BUTTON_CLASS = "a-dialog-button", DIALOG_ALLOW_BUTTON_CLASS = "a-dialog-allow-button", DIALOG_DENY_BUTTON_CLASS = "a-dialog-deny-button", DIALOG_OK_BUTTON_CLASS = "a-dialog-ok-button";
          module3.exports.Component = registerComponent("device-orientation-permission-ui", {
            schema: {
              enabled: {
                default: !0
              },
              deviceMotionMessage: {
                default: "This immersive website requires access to your device motion sensors."
              },
              httpsMessage: {
                default: "Access this site over HTTPS to enter VR mode and grant access to the device sensors."
              },
              denyButtonText: {
                default: "Deny"
              },
              allowButtonText: {
                default: "Allow"
              },
              cancelButtonText: {
                default: "Cancel"
              }
            },
            sceneOnly: !0,
            init: function() {
              var self2 = this;
              if (!!this.data.enabled) {
                if (window.isSecureContext || this.showHTTPAlert(), typeof DeviceOrientationEvent == "undefined" || !DeviceOrientationEvent.requestPermission) {
                  this.permissionGranted = !0;
                  return;
                }
                this.onDeviceMotionDialogAllowClicked = this.onDeviceMotionDialogAllowClicked.bind(this), this.onDeviceMotionDialogDenyClicked = this.onDeviceMotionDialogDenyClicked.bind(this), DeviceOrientationEvent.requestPermission().then(function() {
                  self2.el.emit("deviceorientationpermissiongranted"), self2.permissionGranted = !0;
                }).catch(function() {
                  self2.devicePermissionDialogEl = createPermissionDialog(self2.data.denyButtonText, self2.data.allowButtonText, self2.data.deviceMotionMessage, self2.onDeviceMotionDialogAllowClicked, self2.onDeviceMotionDialogDenyClicked), self2.el.appendChild(self2.devicePermissionDialogEl);
                });
              }
            },
            remove: function() {
              this.devicePermissionDialogEl && this.el.removeChild(this.devicePermissionDialogEl);
            },
            onDeviceMotionDialogDenyClicked: function() {
              this.remove();
            },
            showHTTPAlert: function() {
              var self2 = this, httpAlertEl = createAlertDialog(self2.data.cancelButtonText, self2.data.httpsMessage, function() {
                self2.el.removeChild(httpAlertEl);
              });
              this.el.appendChild(httpAlertEl);
            },
            onDeviceMotionDialogAllowClicked: function() {
              var self2 = this;
              this.el.emit("deviceorientationpermissionrequested"), DeviceOrientationEvent.requestPermission().then(function(response) {
                response === "granted" ? (self2.el.emit("deviceorientationpermissiongranted"), self2.permissionGranted = !0) : self2.el.emit("deviceorientationpermissionrejected"), self2.remove();
              }).catch(console.error);
            }
          });
          function createPermissionDialog(denyText, allowText, dialogText, onAllowClicked, onDenyClicked) {
            var buttonsContainer, denyButton, acceptButton;
            return buttonsContainer = document.createElement("div"), buttonsContainer.classList.add(DIALOG_BUTTONS_CONTAINER_CLASS), denyButton = document.createElement("button"), denyButton.classList.add(DIALOG_BUTTON_CLASS, DIALOG_DENY_BUTTON_CLASS), denyButton.setAttribute(constants.AFRAME_INJECTED, ""), denyButton.innerHTML = denyText, buttonsContainer.appendChild(denyButton), acceptButton = document.createElement("button"), acceptButton.classList.add(DIALOG_BUTTON_CLASS, DIALOG_ALLOW_BUTTON_CLASS), acceptButton.setAttribute(constants.AFRAME_INJECTED, ""), acceptButton.innerHTML = allowText, buttonsContainer.appendChild(acceptButton), acceptButton.addEventListener("click", function(evt) {
              evt.stopPropagation(), onAllowClicked();
            }), denyButton.addEventListener("click", function(evt) {
              evt.stopPropagation(), onDenyClicked();
            }), createDialog(dialogText, buttonsContainer);
          }
          function createAlertDialog(closeText, dialogText, onOkClicked) {
            var buttonsContainer, okButton;
            return buttonsContainer = document.createElement("div"), buttonsContainer.classList.add(DIALOG_BUTTONS_CONTAINER_CLASS), okButton = document.createElement("button"), okButton.classList.add(DIALOG_BUTTON_CLASS, DIALOG_OK_BUTTON_CLASS), okButton.setAttribute(constants.AFRAME_INJECTED, ""), okButton.innerHTML = closeText, buttonsContainer.appendChild(okButton), okButton.addEventListener("click", function(evt) {
              evt.stopPropagation(), onOkClicked();
            }), createDialog(dialogText, buttonsContainer);
          }
          function createDialog(text, buttonsContainerEl) {
            var modalContainer, dialog, dialogTextContainer, dialogText;
            return modalContainer = document.createElement("div"), modalContainer.classList.add(MODAL_CLASS), modalContainer.setAttribute(constants.AFRAME_INJECTED, ""), dialog = document.createElement("div"), dialog.className = DIALOG_CLASS, dialog.setAttribute(constants.AFRAME_INJECTED, ""), modalContainer.appendChild(dialog), dialogTextContainer = document.createElement("div"), dialogTextContainer.classList.add(DIALOG_TEXT_CONTAINER_CLASS), dialog.appendChild(dialogTextContainer), dialogText = document.createElement("div"), dialogText.classList.add(DIALOG_TEXT_CLASS), dialogText.innerHTML = text, dialogTextContainer.appendChild(dialogText), dialog.appendChild(buttonsContainerEl), modalContainer;
          }
        },
        "./src/components/scene/embedded.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = registerComponent("embedded", {
            dependencies: ["xr-mode-ui"],
            schema: {
              default: !0
            },
            sceneOnly: !0,
            update: function() {
              var sceneEl = this.el, enterVREl = sceneEl.querySelector(".a-enter-vr");
              this.data === !0 ? (enterVREl && enterVREl.classList.add("embedded"), sceneEl.removeFullScreenStyles()) : (enterVREl && enterVREl.classList.remove("embedded"), sceneEl.addFullScreenStyles());
            }
          });
        },
        "./src/components/scene/fog.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var register = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), debug = __webpack_require__2("./src/utils/debug.js"), warn = debug("components:fog:warn");
          module3.exports.Component = register("fog", {
            schema: {
              color: {
                type: "color",
                default: "#000"
              },
              density: {
                default: 25e-5
              },
              far: {
                default: 1e3,
                min: 0
              },
              near: {
                default: 1,
                min: 0
              },
              type: {
                default: "linear",
                oneOf: ["linear", "exponential"]
              }
            },
            sceneOnly: !0,
            update: function() {
              var data = this.data, el = this.el, fog = this.el.object3D.fog;
              if (!fog || data.type !== fog.name) {
                el.object3D.fog = getFog(data);
                return;
              }
              Object.keys(this.schema).forEach(function(key) {
                var value = data[key];
                key === "color" && (value = new THREE3.Color(value)), fog[key] = value;
              });
            },
            remove: function() {
              var el = this.el, fog = this.el.object3D.fog;
              !fog || (el.object3D.fog = null);
            }
          });
          function getFog(data) {
            var fog;
            return data.type === "exponential" ? fog = new THREE3.FogExp2(data.color, data.density) : fog = new THREE3.Fog(data.color, data.near, data.far), fog.name = data.type, fog;
          }
        },
        "./src/components/scene/inspector.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var AFRAME_INJECTED = __webpack_require__2("./src/constants/index.js").AFRAME_INJECTED, pkg = __webpack_require__2("./package.json"), registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, utils = __webpack_require__2("./src/utils/index.js");
          function getFuzzyPatchVersion(version) {
            var split = version.split(".");
            return split[2] = "x", split.join(".");
          }
          var INSPECTOR_DEV_URL = "https://aframe.io/aframe-inspector/dist/aframe-inspector.js", INSPECTOR_RELEASE_URL = "https://unpkg.com/aframe-inspector@" + getFuzzyPatchVersion(pkg.version) + "/dist/aframe-inspector.min.js", INSPECTOR_URL = INSPECTOR_RELEASE_URL, LOADING_MESSAGE = "Loading Inspector", LOADING_ERROR_MESSAGE = "Error loading Inspector";
          module3.exports.Component = registerComponent("inspector", {
            schema: {
              url: {
                default: INSPECTOR_URL
              }
            },
            sceneOnly: !0,
            init: function() {
              this.firstPlay = !0, this.onKeydown = this.onKeydown.bind(this), this.onMessage = this.onMessage.bind(this), this.initOverlay(), window.addEventListener("keydown", this.onKeydown), window.addEventListener("message", this.onMessage);
            },
            play: function() {
              var urlParam;
              !this.firstPlay || (urlParam = utils.getUrlParameter("inspector"), urlParam !== "false" && !!urlParam && (this.openInspector(), this.firstPlay = !1));
            },
            initOverlay: function() {
              var dotsHTML = '<span class="dots"><span>.</span><span>.</span><span>.</span></span>';
              this.loadingMessageEl = document.createElement("div"), this.loadingMessageEl.classList.add("a-inspector-loader"), this.loadingMessageEl.innerHTML = LOADING_MESSAGE + dotsHTML;
            },
            remove: function() {
              this.removeEventListeners();
            },
            onKeydown: function(evt) {
              var shortcutPressed = evt.keyCode === 73 && (evt.ctrlKey && evt.altKey || evt.getModifierState("AltGraph"));
              !shortcutPressed || this.openInspector();
            },
            showLoader: function() {
              document.body.appendChild(this.loadingMessageEl);
            },
            hideLoader: function() {
              document.body.removeChild(this.loadingMessageEl);
            },
            onMessage: function(evt) {
              evt.data === "INJECT_AFRAME_INSPECTOR" && this.openInspector();
            },
            openInspector: function(focusEl) {
              var self2 = this, script;
              if (AFRAME.INSPECTOR || AFRAME.inspectorInjected) {
                AFRAME.INSPECTOR.open(focusEl);
                return;
              }
              this.showLoader(), script = document.createElement("script"), script.src = this.data.url, script.setAttribute("data-name", "aframe-inspector"), script.setAttribute(AFRAME_INJECTED, ""), script.onload = function() {
                AFRAME.INSPECTOR.open(focusEl), self2.hideLoader(), self2.removeEventListeners();
              }, script.onerror = function() {
                self2.loadingMessageEl.innerHTML = LOADING_ERROR_MESSAGE;
              }, document.head.appendChild(script), AFRAME.inspectorInjected = !0;
            },
            removeEventListeners: function() {
              window.removeEventListener("keydown", this.onKeydown), window.removeEventListener("message", this.onMessage);
            }
          });
        },
        "./src/components/scene/keyboard-shortcuts.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, shouldCaptureKeyEvent = __webpack_require__2("./src/utils/index.js").shouldCaptureKeyEvent;
          module3.exports.Component = registerComponent("keyboard-shortcuts", {
            schema: {
              enterVR: {
                default: !0
              },
              exitVR: {
                default: !0
              }
            },
            sceneOnly: !0,
            init: function() {
              this.onKeyup = this.onKeyup.bind(this);
            },
            update: function(oldData) {
              var data = this.data;
              this.enterVREnabled = data.enterVR;
            },
            play: function() {
              window.addEventListener("keyup", this.onKeyup, !1);
            },
            pause: function() {
              window.removeEventListener("keyup", this.onKeyup);
            },
            onKeyup: function(evt) {
              var scene = this.el;
              !shouldCaptureKeyEvent(evt) || (this.enterVREnabled && evt.keyCode === 70 && scene.enterVR(), this.enterVREnabled && evt.keyCode === 27 && scene.exitVR());
            }
          });
        },
        "./src/components/scene/pool.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var debug = __webpack_require__2("./src/utils/debug.js"), registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, warn = debug("components:pool:warn");
          module3.exports.Component = registerComponent("pool", {
            schema: {
              container: {
                default: ""
              },
              mixin: {
                default: ""
              },
              size: {
                default: 0
              },
              dynamic: {
                default: !1
              }
            },
            sceneOnly: !0,
            multiple: !0,
            initPool: function() {
              var i;
              for (this.availableEls = [], this.usedEls = [], this.data.mixin || warn("No mixin provided for pool component."), this.data.container && (this.container = document.querySelector(this.data.container), this.container || warn("Container " + this.data.container + " not found.")), this.container = this.container || this.el, i = 0; i < this.data.size; ++i)
                this.createEntity();
            },
            update: function(oldData) {
              var data = this.data;
              (oldData.mixin !== data.mixin || oldData.size !== data.size) && this.initPool();
            },
            createEntity: function() {
              var el;
              el = document.createElement("a-entity"), el.play = this.wrapPlay(el.play), el.setAttribute("mixin", this.data.mixin), el.object3D.visible = !1, el.pause(), this.container.appendChild(el), this.availableEls.push(el);
              var usedEls = this.usedEls;
              el.addEventListener("loaded", function() {
                usedEls.indexOf(el) === -1 && (el.object3DParent = el.object3D.parent, el.object3D.parent.remove(el.object3D));
              });
            },
            wrapPlay: function(playMethod) {
              var usedEls = this.usedEls;
              return function() {
                usedEls.indexOf(this) !== -1 && playMethod.call(this);
              };
            },
            requestEntity: function() {
              var el;
              if (this.availableEls.length === 0) {
                if (this.data.dynamic === !1) {
                  warn("Requested entity from empty pool: " + this.attrName);
                  return;
                } else
                  warn("Requested entity from empty pool. This pool is dynamic and will resize automatically. You might want to increase its initial size: " + this.attrName);
                this.createEntity();
              }
              return el = this.availableEls.shift(), this.usedEls.push(el), el.object3DParent && (el.object3DParent.add(el.object3D), this.updateRaycasters()), el.object3D.visible = !0, el;
            },
            returnEntity: function(el) {
              var index = this.usedEls.indexOf(el);
              if (index === -1) {
                warn("The returned entity was not previously pooled from " + this.attrName);
                return;
              }
              return this.usedEls.splice(index, 1), this.availableEls.push(el), el.object3DParent = el.object3D.parent, el.object3D.parent.remove(el.object3D), this.updateRaycasters(), el.object3D.visible = !1, el.pause(), el;
            },
            updateRaycasters: function() {
              var raycasterEls = document.querySelectorAll("[raycaster]");
              raycasterEls.forEach(function(el) {
                el.components.raycaster.setDirty();
              });
            }
          });
        },
        "./src/components/scene/real-world-meshing.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var register = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js");
          module3.exports.Component = register("real-world-meshing", {
            schema: {
              filterLabels: {
                type: "array"
              },
              meshesEnabled: {
                default: !0
              },
              meshMixin: {
                default: !0
              },
              planesEnabled: {
                default: !0
              },
              planeMixin: {
                default: ""
              }
            },
            sceneOnly: !0,
            init: function() {
              var webxrData = this.el.getAttribute("webxr"), requiredFeaturesArray = webxrData.requiredFeatures;
              requiredFeaturesArray.indexOf("mesh-detection") === -1 && (requiredFeaturesArray.push("mesh-detection"), this.el.setAttribute("webxr", webxrData)), requiredFeaturesArray.indexOf("plane-detection") === -1 && (requiredFeaturesArray.push("plane-detection"), this.el.setAttribute("webxr", webxrData)), this.meshEntities = [], this.initWorldMeshEntity = this.initWorldMeshEntity.bind(this);
            },
            tick: function() {
              !this.el.is("ar-mode") || (this.detectMeshes(), this.updateMeshes());
            },
            detectMeshes: function() {
              var data = this.data, detectedMeshes, detectedPlanes, sceneEl = this.el, xrManager = sceneEl.renderer.xr, frame, meshEntities = this.meshEntities, present = !1, newMeshes = [], filterLabels = this.data.filterLabels;
              frame = sceneEl.frame, detectedMeshes = frame.detectedMeshes, detectedPlanes = frame.detectedPlanes;
              for (var i = 0; i < meshEntities.length; i++)
                meshEntities[i].present = !1;
              if (data.meshesEnabled) {
                for (var mesh of detectedMeshes.values())
                  if (!(filterLabels.length && filterLabels.indexOf(mesh.semanticLabel) === -1)) {
                    for (i = 0; i < meshEntities.length; i++)
                      if (mesh === meshEntities[i].mesh) {
                        present = !0, meshEntities[i].present = !0, meshEntities[i].lastChangedTime < mesh.lastChangedTime && this.updateMeshGeometry(meshEntities[i].el, mesh), meshEntities[i].lastChangedTime = mesh.lastChangedTime;
                        break;
                      }
                    present || newMeshes.push(mesh), present = !1;
                  }
              }
              if (data.planesEnabled) {
                for (mesh of detectedPlanes.values())
                  if (!(filterLabels.length && filterLabels.indexOf(mesh.semanticLabel) === -1)) {
                    for (i = 0; i < meshEntities.length; i++)
                      if (mesh === meshEntities[i].mesh) {
                        present = !0, meshEntities[i].present = !0, meshEntities[i].lastChangedTime < mesh.lastChangedTime && this.updateMeshGeometry(meshEntities[i].el, mesh), meshEntities[i].lastChangedTime = mesh.lastChangedTime;
                        break;
                      }
                    present || newMeshes.push(mesh), present = !1;
                  }
              }
              this.deleteMeshes(), this.createNewMeshes(newMeshes);
            },
            updateMeshes: function() {
              var auxMatrix = new THREE3.Matrix4();
              return function() {
                for (var meshPose, sceneEl = this.el, meshEl, frame = sceneEl.frame, meshEntities = this.meshEntities, referenceSpace = sceneEl.renderer.xr.getReferenceSpace(), meshSpace, i = 0; i < meshEntities.length; i++)
                  meshSpace = meshEntities[i].mesh.meshSpace || meshEntities[i].mesh.planeSpace, meshPose = frame.getPose(meshSpace, referenceSpace), meshEl = meshEntities[i].el, !!meshEl.hasLoaded && (auxMatrix.fromArray(meshPose.transform.matrix), auxMatrix.decompose(meshEl.object3D.position, meshEl.object3D.quaternion, meshEl.object3D.scale));
              };
            }(),
            deleteMeshes: function() {
              for (var meshEntities = this.meshEntities, newMeshEntities = [], i = 0; i < meshEntities.length; i++)
                meshEntities[i].present ? newMeshEntities.push(meshEntities[i]) : this.el.removeChild(meshEntities[i]);
              this.meshEntities = newMeshEntities;
            },
            createNewMeshes: function(newMeshes) {
              for (var meshEl, i = 0; i < newMeshes.length; i++)
                meshEl = document.createElement("a-entity"), this.meshEntities.push({
                  mesh: newMeshes[i],
                  el: meshEl
                }), meshEl.addEventListener("loaded", this.initWorldMeshEntity), this.el.appendChild(meshEl);
            },
            initMeshGeometry: function(mesh) {
              var geometry, shape, polygon;
              if (mesh instanceof XRPlane) {
                shape = new THREE3.Shape(), polygon = mesh.polygon;
                for (var i = 0; i < polygon.length; ++i)
                  i === 0 ? shape.moveTo(polygon[i].x, polygon[i].z) : shape.lineTo(polygon[i].x, polygon[i].z);
                return geometry = new THREE3.ShapeGeometry(shape), geometry.rotateX(Math.PI / 2), geometry;
              }
              return geometry = new THREE3.BufferGeometry(), geometry.setAttribute("position", new THREE3.BufferAttribute(mesh.vertices, 3)), geometry.setIndex(new THREE3.BufferAttribute(mesh.indices, 1)), geometry;
            },
            initWorldMeshEntity: function(evt) {
              for (var el = evt.target, geometry, mesh, meshEntity, meshEntities = this.meshEntities, i = 0; i < meshEntities.length; i++)
                if (meshEntities[i].el === el) {
                  meshEntity = meshEntities[i];
                  break;
                }
              geometry = this.initMeshGeometry(meshEntity.mesh), mesh = new THREE3.Mesh(geometry, new THREE3.MeshBasicMaterial({
                color: Math.random() * 16777215,
                side: THREE3.DoubleSide
              })), el.setObject3D("mesh", mesh), meshEntity.mesh instanceof XRPlane && this.data.planeMixin ? el.setAttribute("mixin", this.data.planeMixin) : this.data.meshMixin && el.setAttribute("mixin", this.data.meshMixin), el.setAttribute("data-world-mesh", meshEntity.mesh.semanticLabel);
            },
            updateMeshGeometry: function(entityEl, mesh) {
              var entityMesh = entityEl.getObject3D("mesh");
              entityMesh.geometry.dispose(), entityMesh.geometry = this.initMeshGeometry(mesh);
            }
          });
        },
        "./src/components/scene/reflection.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var register = __webpack_require__2("./src/core/component.js").registerComponent;
          function updateLights(estimate, probeLight, directionalLight, directionalLightPosition) {
            var intensityScalar = Math.max(estimate.primaryLightIntensity.x, Math.max(estimate.primaryLightIntensity.y, estimate.primaryLightIntensity.z));
            probeLight.sh.fromArray(estimate.sphericalHarmonicsCoefficients), probeLight.intensity = 1, directionalLight && (directionalLight.color.setRGB(estimate.primaryLightIntensity.x / intensityScalar, estimate.primaryLightIntensity.y / intensityScalar, estimate.primaryLightIntensity.z / intensityScalar), directionalLight.intensity = intensityScalar, directionalLightPosition.copy(estimate.primaryLightDirection));
          }
          module3.exports.Component = register("reflection", {
            schema: {
              directionalLight: {
                type: "selector"
              }
            },
            sceneOnly: !0,
            init: function() {
              var self2 = this;
              this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(16), this.cubeCamera = new THREE.CubeCamera(0.1, 1e3, this.cubeRenderTarget), this.lightingEstimationTexture = new THREE.WebGLCubeRenderTarget(16).texture, this.needsVREnvironmentUpdate = !0;
              var webxrData = this.el.getAttribute("webxr"), optionalFeaturesArray = webxrData.optionalFeatures;
              optionalFeaturesArray.includes("light-estimation") || (optionalFeaturesArray.push("light-estimation"), this.el.setAttribute("webxr", webxrData)), this.el.addEventListener("enter-vr", function() {
                if (!!self2.el.is("ar-mode")) {
                  var renderer = self2.el.renderer, session = renderer.xr.getSession();
                  session.requestLightProbe && self2.startLightProbe();
                }
              }), this.el.addEventListener("exit-vr", function() {
                self2.xrLightProbe && self2.stopLightProbe();
              }), this.el.object3D.environment = this.cubeRenderTarget.texture;
            },
            stopLightProbe: function() {
              this.xrLightProbe = null, this.probeLight && (this.probeLight.components.light.light.intensity = 0), this.needsVREnvironmentUpdate = !0, this.el.object3D.environment = this.cubeRenderTarget.texture;
            },
            startLightProbe: function() {
              this.needsLightProbeUpdate = !0;
            },
            setupLightProbe: function() {
              var renderer = this.el.renderer, xrSession = renderer.xr.getSession(), self2 = this, gl = renderer.getContext();
              if (!this.probeLight) {
                var probeLight = document.createElement("a-light");
                probeLight.setAttribute("type", "probe"), probeLight.setAttribute("intensity", 0), this.el.appendChild(probeLight), this.probeLight = probeLight;
              }
              switch (xrSession.preferredReflectionFormat) {
                case "srgba8":
                  gl.getExtension("EXT_sRGB");
                  break;
                case "rgba16f":
                  gl.getExtension("OES_texture_half_float");
                  break;
              }
              this.glBinding = new XRWebGLBinding(xrSession, gl), gl.getExtension("EXT_sRGB"), gl.getExtension("OES_texture_half_float"), xrSession.requestLightProbe().then(function(lightProbe) {
                self2.xrLightProbe = lightProbe, lightProbe.addEventListener("reflectionchange", self2.updateXRCubeMap.bind(self2));
              }).catch(function(err) {
                console.warn("Lighting estimation not supported: " + err.message), console.warn('Are you missing: webxr="optionalFeatures: light-estimation;" from <a-scene>?');
              });
            },
            updateXRCubeMap: function() {
              var renderer = this.el.renderer, cubeMap = this.glBinding.getReflectionCubeMap(this.xrLightProbe);
              if (cubeMap) {
                var rendererProps = renderer.properties.get(this.lightingEstimationTexture);
                rendererProps.__webglTexture = cubeMap, this.lightingEstimationTexture.needsPMREMUpdate = !0, this.el.object3D.environment = this.lightingEstimationTexture;
              }
            },
            tick: function() {
              var scene = this.el.object3D, renderer = this.el.renderer, frame = this.el.frame;
              if (frame && this.xrLightProbe) {
                var estimate = frame.getLightEstimate(this.xrLightProbe);
                estimate && updateLights(estimate, this.probeLight.components.light.light, this.data.directionalLight && this.data.directionalLight.components.light.light, this.data.directionalLight && this.data.directionalLight.object3D.position);
              }
              this.needsVREnvironmentUpdate && (scene.environment = null, this.needsVREnvironmentUpdate = !1, this.cubeCamera.position.set(0, 1.6, 0), this.cubeCamera.update(renderer, scene), scene.environment = this.cubeRenderTarget.texture), this.needsLightProbeUpdate && frame && (this.setupLightProbe(), this.needsLightProbeUpdate = !1);
            },
            remove: function() {
              this.el.object3D.environment = null, this.probeLight && this.el.removeChild(this.probeLight);
            }
          });
        },
        "./src/components/scene/screenshot.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), VERTEX_SHADER = ["attribute vec3 position;", "attribute vec2 uv;", "uniform mat4 projectionMatrix;", "uniform mat4 modelViewMatrix;", "varying vec2 vUv;", "void main()  {", "  vUv = vec2( 1.- uv.x, uv.y );", "  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), FRAGMENT_SHADER = ["precision mediump float;", "uniform samplerCube map;", "varying vec2 vUv;", "#define M_PI 3.141592653589793238462643383279", "void main() {", "  vec2 uv = vUv;", "  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;", "  float latitude = uv.y * M_PI;", "  vec3 dir = vec3(", "    - sin( longitude ) * sin( latitude ),", "    cos( latitude ),", "    - cos( longitude ) * sin( latitude )", "  );", "  normalize( dir );", "  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );", "}"].join(`
`);
          module3.exports.Component = registerComponent("screenshot", {
            schema: {
              width: {
                default: 4096
              },
              height: {
                default: 2048
              },
              camera: {
                type: "selector"
              }
            },
            sceneOnly: !0,
            setup: function() {
              var el = this.el;
              if (!this.canvas) {
                var gl = el.renderer.getContext();
                !gl || (this.cubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE), this.material = new THREE3.RawShaderMaterial({
                  uniforms: {
                    map: {
                      type: "t",
                      value: null
                    }
                  },
                  vertexShader: VERTEX_SHADER,
                  fragmentShader: FRAGMENT_SHADER,
                  side: THREE3.DoubleSide
                }), this.quad = new THREE3.Mesh(new THREE3.PlaneGeometry(1, 1), this.material), this.quad.visible = !1, this.camera = new THREE3.OrthographicCamera(-1 / 2, 1 / 2, 1 / 2, -1 / 2, -1e4, 1e4), this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), el.object3D.add(this.quad), this.onKeyDown = this.onKeyDown.bind(this));
              }
            },
            getRenderTarget: function(width, height) {
              return new THREE3.WebGLRenderTarget(width, height, {
                colorSpace: this.el.sceneEl.renderer.outputColorSpace,
                minFilter: THREE3.LinearFilter,
                magFilter: THREE3.LinearFilter,
                wrapS: THREE3.ClampToEdgeWrapping,
                wrapT: THREE3.ClampToEdgeWrapping,
                format: THREE3.RGBAFormat,
                type: THREE3.UnsignedByteType
              });
            },
            resize: function(width, height) {
              this.quad.scale.set(width, height, 1), this.camera.left = -1 * width / 2, this.camera.right = width / 2, this.camera.top = height / 2, this.camera.bottom = -1 * height / 2, this.camera.updateProjectionMatrix(), this.canvas.width = width, this.canvas.height = height;
            },
            play: function() {
              window.addEventListener("keydown", this.onKeyDown);
            },
            onKeyDown: function(evt) {
              var shortcutPressed = evt.keyCode === 83 && evt.ctrlKey && evt.altKey;
              if (!(!this.data || !shortcutPressed)) {
                var projection = evt.shiftKey ? "equirectangular" : "perspective";
                this.capture(projection);
              }
            },
            setCapture: function(projection) {
              var el = this.el, size, camera, cubeCamera, cubeRenderTarget;
              return projection === "perspective" ? (this.quad.visible = !1, camera = this.data.camera && this.data.camera.components.camera.camera || el.camera, size = {
                width: this.data.width,
                height: this.data.height
              }) : (camera = this.camera, cubeRenderTarget = new THREE3.WebGLCubeRenderTarget(Math.min(this.cubeMapSize, 2048), {
                format: THREE3.RGBFormat,
                generateMipmaps: !0,
                minFilter: THREE3.LinearMipmapLinearFilter,
                colorSpace: THREE3.SRGBColorSpace
              }), cubeCamera = new THREE3.CubeCamera(el.camera.near, el.camera.far, cubeRenderTarget), el.camera.getWorldPosition(cubeCamera.position), el.camera.getWorldQuaternion(cubeCamera.quaternion), cubeCamera.update(el.renderer, el.object3D), this.quad.material.uniforms.map.value = cubeCamera.renderTarget.texture, size = {
                width: this.data.width,
                height: this.data.height
              }, this.quad.visible = !0), {
                camera,
                size,
                projection
              };
            },
            capture: function(projection) {
              var isVREnabled = this.el.renderer.xr.enabled, renderer = this.el.renderer, params;
              this.setup(), renderer.xr.enabled = !1, params = this.setCapture(projection), this.renderCapture(params.camera, params.size, params.projection), this.saveCapture(), renderer.xr.enabled = isVREnabled;
            },
            getCanvas: function(projection) {
              var isVREnabled = this.el.renderer.xr.enabled, renderer = this.el.renderer;
              this.setup();
              var params = this.setCapture(projection);
              return renderer.xr.enabled = !1, this.renderCapture(params.camera, params.size, params.projection), renderer.xr.enabled = isVREnabled, this.canvas;
            },
            renderCapture: function(camera, size, projection) {
              var autoClear = this.el.renderer.autoClear, el = this.el, imageData, output, pixels, renderer = el.renderer;
              output = this.getRenderTarget(size.width, size.height), pixels = new Uint8Array(4 * size.width * size.height), this.resize(size.width, size.height), renderer.autoClear = !0, renderer.clear(), renderer.setRenderTarget(output), renderer.render(el.object3D, camera), renderer.autoClear = autoClear, renderer.readRenderTargetPixels(output, 0, 0, size.width, size.height, pixels), renderer.setRenderTarget(null), projection === "perspective" && (pixels = this.flipPixelsVertically(pixels, size.width, size.height)), imageData = new ImageData(new Uint8ClampedArray(pixels), size.width, size.height), this.quad.visible = !1, this.ctx.putImageData(imageData, 0, 0);
            },
            flipPixelsVertically: function(pixels, width, height) {
              for (var flippedPixels = pixels.slice(0), x = 0; x < width; ++x)
                for (var y = 0; y < height; ++y)
                  flippedPixels[x * 4 + y * width * 4] = pixels[x * 4 + (height - y) * width * 4], flippedPixels[x * 4 + 1 + y * width * 4] = pixels[x * 4 + 1 + (height - y) * width * 4], flippedPixels[x * 4 + 2 + y * width * 4] = pixels[x * 4 + 2 + (height - y) * width * 4], flippedPixels[x * 4 + 3 + y * width * 4] = pixels[x * 4 + 3 + (height - y) * width * 4];
              return flippedPixels;
            },
            saveCapture: function() {
              this.canvas.toBlob(function(blob) {
                var fileName = "screenshot-" + document.title.toLowerCase() + "-" + Date.now() + ".png", linkEl = document.createElement("a"), url = URL.createObjectURL(blob);
                linkEl.href = url, linkEl.setAttribute("download", fileName), linkEl.innerHTML = "downloading...", linkEl.style.display = "none", document.body.appendChild(linkEl), setTimeout(function() {
                  linkEl.click(), document.body.removeChild(linkEl);
                }, 1);
              }, "image/png");
            }
          });
        },
        "./src/components/scene/stats.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, RStats = __webpack_require__2("./vendor/rStats.js"), utils = __webpack_require__2("./src/utils/index.js");
          __webpack_require__2("./vendor/rStats.extras.js"), __webpack_require__2("./src/lib/rStatsAframe.js");
          var AFrameStats = window.aframeStats, HIDDEN_CLASS = "a-hidden", ThreeStats = window.threeStats;
          module3.exports.Component = registerComponent("stats", {
            schema: {
              default: !0
            },
            sceneOnly: !0,
            init: function() {
              var scene = this.el;
              utils.getUrlParameter("stats") !== "false" && (this.stats = createStats(scene), this.statsEl = document.querySelector(".rs-base"), this.hideBound = this.hide.bind(this), this.showBound = this.show.bind(this), scene.addEventListener("enter-vr", this.hideBound), scene.addEventListener("exit-vr", this.showBound));
            },
            update: function() {
              if (!!this.stats)
                return this.data ? this.show() : this.hide();
            },
            remove: function() {
              this.el.removeEventListener("enter-vr", this.hideBound), this.el.removeEventListener("exit-vr", this.showBound), !!this.statsEl && this.statsEl.parentNode.removeChild(this.statsEl);
            },
            tick: function() {
              var stats = this.stats;
              !stats || (stats("rAF").tick(), stats("FPS").frame(), stats().update());
            },
            hide: function() {
              this.statsEl.classList.add(HIDDEN_CLASS);
            },
            show: function() {
              this.statsEl.classList.remove(HIDDEN_CLASS);
            }
          });
          function createStats(scene) {
            var threeStats = new ThreeStats(scene.renderer), aframeStats = new AFrameStats(scene), plugins = scene.isMobile ? [] : [threeStats, aframeStats];
            return new RStats({
              css: [],
              values: {
                fps: {
                  caption: "fps",
                  below: 30
                }
              },
              groups: [{
                caption: "Framerate",
                values: ["fps", "raf"]
              }],
              plugins
            });
          }
        },
        "./src/components/scene/xr-mode-ui.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, constants = __webpack_require__2("./src/constants/index.js"), utils = __webpack_require__2("./src/utils/index.js"), ENTER_VR_CLASS = "a-enter-vr", ENTER_AR_CLASS = "a-enter-ar", ENTER_VR_BTN_CLASS = "a-enter-vr-button", ENTER_AR_BTN_CLASS = "a-enter-ar-button", HIDDEN_CLASS = "a-hidden", ORIENTATION_MODAL_CLASS = "a-orientation-modal";
          module3.exports.Component = registerComponent("xr-mode-ui", {
            dependencies: ["canvas"],
            schema: {
              enabled: {
                default: !0
              },
              cardboardModeEnabled: {
                default: !1
              },
              enterVRButton: {
                default: ""
              },
              enterVREnabled: {
                default: !0
              },
              enterARButton: {
                default: ""
              },
              enterAREnabled: {
                default: !0
              },
              XRMode: {
                default: "vr",
                oneOf: ["vr", "ar", "xr"]
              }
            },
            sceneOnly: !0,
            init: function() {
              var self2 = this, sceneEl = this.el;
              utils.getUrlParameter("ui") !== "false" && (this.insideLoader = !1, this.enterVREl = null, this.enterAREl = null, this.orientationModalEl = null, this.bindMethods(), sceneEl.addEventListener("enter-vr", this.updateEnterInterfaces), sceneEl.addEventListener("exit-vr", this.updateEnterInterfaces), sceneEl.addEventListener("update-vr-devices", this.updateEnterInterfaces), window.addEventListener("message", function(event) {
                event.data.type === "loaderReady" && (self2.insideLoader = !0, self2.remove());
              }), window.addEventListener("orientationchange", this.toggleOrientationModalIfNeeded));
            },
            bindMethods: function() {
              this.onEnterVRButtonClick = this.onEnterVRButtonClick.bind(this), this.onEnterARButtonClick = this.onEnterARButtonClick.bind(this), this.onModalClick = this.onModalClick.bind(this), this.toggleOrientationModalIfNeeded = this.toggleOrientationModalIfNeeded.bind(this), this.updateEnterInterfaces = this.updateEnterInterfaces.bind(this);
            },
            onModalClick: function() {
              this.el.exitVR();
            },
            onEnterVRButtonClick: function() {
              this.el.enterVR();
            },
            onEnterARButtonClick: function() {
              this.el.enterAR();
            },
            update: function() {
              var data = this.data, sceneEl = this.el;
              if (!data.enabled || this.insideLoader || utils.getUrlParameter("ui") === "false")
                return this.remove();
              this.enterVREl || this.enterAREl || this.orientationModalEl || (!this.enterVREl && data.enterVREnabled && (data.XRMode === "xr" || data.XRMode === "vr") && (data.enterVRButton ? (this.enterVREl = document.querySelector(data.enterVRButton), this.enterVREl.addEventListener("click", this.onEnterVRButtonClick)) : (this.enterVREl = createEnterVRButton(this.onEnterVRButtonClick), sceneEl.appendChild(this.enterVREl))), !this.enterAREl && data.enterAREnabled && (data.XRMode === "xr" || data.XRMode === "ar") && (data.enterARButton ? (this.enterAREl = document.querySelector(data.enterARButton), this.enterAREl.addEventListener("click", this.onEnterARButtonClick)) : (this.enterAREl = createEnterARButton(this.onEnterARButtonClick, data.XRMode === "xr"), sceneEl.appendChild(this.enterAREl))), this.orientationModalEl = createOrientationModal(this.onModalClick), sceneEl.appendChild(this.orientationModalEl), this.updateEnterInterfaces());
            },
            remove: function() {
              [this.enterVREl, this.enterAREl, this.orientationModalEl].forEach(function(uiElement) {
                uiElement && uiElement.parentNode && uiElement.parentNode.removeChild(uiElement);
              }), this.enterVREl = void 0, this.enterAREl = void 0, this.orientationModalEl = void 0;
            },
            updateEnterInterfaces: function() {
              this.toggleEnterVRButtonIfNeeded(), this.toggleEnterARButtonIfNeeded(), this.toggleOrientationModalIfNeeded();
            },
            toggleEnterVRButtonIfNeeded: function() {
              var sceneEl = this.el;
              !this.enterVREl || (sceneEl.is("vr-mode") || (sceneEl.isMobile || utils.device.isMobileDeviceRequestingDesktopSite()) && !this.data.cardboardModeEnabled && !utils.device.checkVRSupport() ? this.enterVREl.classList.add(HIDDEN_CLASS) : (utils.device.checkVRSupport() || this.enterVREl.classList.add("fullscreen"), this.enterVREl.classList.remove(HIDDEN_CLASS), sceneEl.enterVR(!1, !0)));
            },
            toggleEnterARButtonIfNeeded: function() {
              var sceneEl = this.el;
              !this.enterAREl || (sceneEl.is("vr-mode") || !utils.device.checkARSupport() ? this.enterAREl.classList.add(HIDDEN_CLASS) : (this.enterAREl.classList.remove(HIDDEN_CLASS), sceneEl.enterVR(!0, !0)));
            },
            toggleOrientationModalIfNeeded: function() {
              var sceneEl = this.el, orientationModalEl = this.orientationModalEl;
              !orientationModalEl || !sceneEl.isMobile || (!utils.device.isLandscape() && sceneEl.is("vr-mode") ? orientationModalEl.classList.remove(HIDDEN_CLASS) : orientationModalEl.classList.add(HIDDEN_CLASS));
            }
          });
          function createEnterVRButton(onClick) {
            var vrButton, wrapper;
            return wrapper = document.createElement("div"), wrapper.classList.add(ENTER_VR_CLASS), wrapper.setAttribute(constants.AFRAME_INJECTED, ""), vrButton = document.createElement("button"), vrButton.className = ENTER_VR_BTN_CLASS, vrButton.setAttribute("title", "Enter VR mode with a headset or fullscreen without"), vrButton.setAttribute(constants.AFRAME_INJECTED, ""), utils.device.isMobile() && applyStickyHoverFix(vrButton), wrapper.appendChild(vrButton), vrButton.addEventListener("click", function(evt) {
              onClick(), evt.stopPropagation();
            }), wrapper;
          }
          function createEnterARButton(onClick, xrMode) {
            var arButton, wrapper;
            return wrapper = document.createElement("div"), wrapper.classList.add(ENTER_AR_CLASS), xrMode && wrapper.classList.add("xr"), wrapper.setAttribute(constants.AFRAME_INJECTED, ""), arButton = document.createElement("button"), arButton.className = ENTER_AR_BTN_CLASS, arButton.setAttribute("title", "Enter AR mode with a headset or handheld device."), arButton.setAttribute(constants.AFRAME_INJECTED, ""), utils.device.isMobile() && applyStickyHoverFix(arButton), wrapper.appendChild(arButton), arButton.addEventListener("click", function(evt) {
              onClick(), evt.stopPropagation();
            }), wrapper;
          }
          function createOrientationModal(onClick) {
            var modal = document.createElement("div");
            modal.className = ORIENTATION_MODAL_CLASS, modal.classList.add(HIDDEN_CLASS), modal.setAttribute(constants.AFRAME_INJECTED, "");
            var exit = document.createElement("button");
            return exit.setAttribute(constants.AFRAME_INJECTED, ""), exit.innerHTML = "Exit VR", exit.addEventListener("click", onClick), modal.appendChild(exit), modal;
          }
          function applyStickyHoverFix(buttonEl) {
            buttonEl.addEventListener("touchstart", function() {
              buttonEl.classList.remove("resethover");
            }, {
              passive: !0
            }), buttonEl.addEventListener("touchend", function() {
              buttonEl.classList.add("resethover");
            }, {
              passive: !0
            });
          }
        },
        "./src/components/shadow.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var component = __webpack_require__2("./src/core/component.js"), THREE3 = __webpack_require__2("./src/lib/three.js"), registerComponent = component.registerComponent;
          module3.exports.Component = registerComponent("shadow", {
            schema: {
              cast: {
                default: !0
              },
              receive: {
                default: !0
              }
            },
            init: function() {
              this.onMeshChanged = this.update.bind(this), this.el.addEventListener("object3dset", this.onMeshChanged), this.system.setShadowMapEnabled(!0);
            },
            update: function() {
              var data = this.data;
              this.updateDescendants(data.cast, data.receive);
            },
            remove: function() {
              var el = this.el;
              el.removeEventListener("object3dset", this.onMeshChanged), this.updateDescendants(!1, !1);
            },
            updateDescendants: function(cast, receive) {
              var sceneEl = this.el.sceneEl;
              this.el.object3D.traverse(function(node) {
                if (node instanceof THREE3.Mesh && (node.castShadow = cast, node.receiveShadow = receive, sceneEl.hasLoaded && node.material))
                  for (var materials = Array.isArray(node.material) ? node.material : [node.material], i = 0; i < materials.length; i++)
                    materials[i].needsUpdate = !0;
              });
            }
          });
        },
        "./src/components/sound.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, debug = __webpack_require__2("./src/utils/debug.js"), THREE3 = __webpack_require__2("./src/lib/three.js"), warn = debug("components:sound:warn");
          module3.exports.Component = registerComponent("sound", {
            schema: {
              autoplay: {
                default: !1
              },
              distanceModel: {
                default: "inverse",
                oneOf: ["linear", "inverse", "exponential"]
              },
              loop: {
                default: !1
              },
              loopStart: {
                default: 0
              },
              loopEnd: {
                default: 0
              },
              maxDistance: {
                default: 1e4
              },
              on: {
                default: ""
              },
              poolSize: {
                default: 1
              },
              positional: {
                default: !0
              },
              refDistance: {
                default: 1
              },
              rolloffFactor: {
                default: 1
              },
              src: {
                type: "audio"
              },
              volume: {
                default: 1
              }
            },
            multiple: !0,
            init: function() {
              var self2 = this;
              this.listener = null, this.audioLoader = new THREE3.AudioLoader(), this.pool = new THREE3.Group(), this.loaded = !1, this.mustPlay = !1, this.playSoundBound = function() {
                self2.playSound();
              };
            },
            update: function(oldData) {
              var data = this.data, i, sound, srcChanged = data.src !== oldData.src;
              if (srcChanged) {
                if (!data.src)
                  return;
                this.setupSound();
              }
              for (i = 0; i < this.pool.children.length; i++)
                sound = this.pool.children[i], data.positional && (sound.setDistanceModel(data.distanceModel), sound.setMaxDistance(data.maxDistance), sound.setRefDistance(data.refDistance), sound.setRolloffFactor(data.rolloffFactor)), sound.setLoop(data.loop), sound.setLoopStart(data.loopStart), data.loopStart !== 0 && data.loopEnd === 0 ? sound.setLoopEnd(sound.buffer.duration) : sound.setLoopEnd(data.loopEnd), sound.setVolume(data.volume), sound.isPaused = !1;
              if (data.on !== oldData.on && this.updateEventListener(oldData.on), srcChanged) {
                var self2 = this;
                this.loaded = !1, this.audioLoader.load(data.src, function(buffer) {
                  for (i = 0; i < self2.pool.children.length; i++)
                    sound = self2.pool.children[i], sound.setBuffer(buffer);
                  self2.loaded = !0, THREE3.Cache.remove(data.src), (self2.data.autoplay || self2.mustPlay) && self2.playSound(self2.processSound), self2.el.emit("sound-loaded", self2.evtDetail, !1);
                });
              }
            },
            pause: function() {
              this.stopSound(), this.removeEventListener();
            },
            play: function() {
              this.data.autoplay && this.playSound(), this.updateEventListener();
            },
            remove: function() {
              var i, sound;
              this.removeEventListener(), this.el.getObject3D(this.attrName) && this.el.removeObject3D(this.attrName);
              try {
                for (i = 0; i < this.pool.children.length; i++)
                  sound = this.pool.children[i], sound.disconnect();
              } catch (e) {
                warn("Audio source not properly disconnected");
              }
            },
            updateEventListener: function(oldEvt) {
              var el = this.el;
              oldEvt && el.removeEventListener(oldEvt, this.playSoundBound), el.addEventListener(this.data.on, this.playSoundBound);
            },
            removeEventListener: function() {
              this.el.removeEventListener(this.data.on, this.playSoundBound);
            },
            setupSound: function() {
              var el = this.el, i, sceneEl = el.sceneEl, self2 = this, sound;
              this.pool.children.length > 0 && (this.stopSound(), el.removeObject3D("sound"));
              var listener = this.listener = sceneEl.audioListener || new THREE3.AudioListener();
              for (sceneEl.audioListener = listener, sceneEl.camera && sceneEl.camera.add(listener), sceneEl.addEventListener("camera-set-active", function(evt) {
                evt.detail.cameraEl.getObject3D("camera").add(listener);
              }), this.pool = new THREE3.Group(), i = 0; i < this.data.poolSize; i++)
                sound = this.data.positional ? new THREE3.PositionalAudio(listener) : new THREE3.Audio(listener), this.pool.add(sound);
              for (el.setObject3D(this.attrName, this.pool), i = 0; i < this.pool.children.length; i++)
                sound = this.pool.children[i], sound.onEnded = function() {
                  this.isPlaying = !1, self2.el.emit("sound-ended", self2.evtDetail, !1);
                };
            },
            pauseSound: function() {
              var i, sound;
              for (this.isPlaying = !1, i = 0; i < this.pool.children.length; i++)
                sound = this.pool.children[i], !(!sound.source || !sound.source.buffer || !sound.isPlaying || sound.isPaused) && (sound.isPaused = !0, sound.pause());
            },
            playSound: function(processSound) {
              var found, i, sound;
              if (!this.loaded) {
                warn("Sound not loaded yet. It will be played once it finished loading"), this.mustPlay = !0, this.processSound = processSound;
                return;
              }
              for (found = !1, this.isPlaying = !0, i = 0; i < this.pool.children.length; i++)
                if (sound = this.pool.children[i], !sound.isPlaying && sound.buffer && !found) {
                  processSound && processSound(sound), sound.play(), sound.isPaused = !1, found = !0;
                  continue;
                }
              if (!found) {
                warn("All the sounds are playing. If you need to play more sounds simultaneously consider increasing the size of pool with the `poolSize` attribute.", this.el);
                return;
              }
              this.mustPlay = !1, this.processSound = void 0;
            },
            stopSound: function() {
              var i, sound;
              for (this.isPlaying = !1, i = 0; i < this.pool.children.length; i++) {
                if (sound = this.pool.children[i], !sound.source || !sound.source.buffer)
                  return;
                sound.stop();
              }
            }
          });
        },
        "./src/components/text.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var createTextGeometry = __webpack_require__2("./node_modules/three-bmfont-text/index.js"), loadBMFont = __webpack_require__2("./node_modules/load-bmfont/browser.js"), registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, coreShader = __webpack_require__2("./src/core/shader.js"), THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js"), error = utils.debug("components:text:error"), shaders = coreShader.shaders, warn = utils.debug("components:text:warn"), DEFAULT_WIDTH = 1, MAX_ANISOTROPY = 16, AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, FONT_BASE_URL = AFRAME_CDN_ROOT + "fonts/", FONTS = {
            aileronsemibold: FONT_BASE_URL + "Aileron-Semibold.fnt",
            dejavu: FONT_BASE_URL + "DejaVu-sdf.fnt",
            exo2bold: FONT_BASE_URL + "Exo2Bold.fnt",
            exo2semibold: FONT_BASE_URL + "Exo2SemiBold.fnt",
            kelsonsans: FONT_BASE_URL + "KelsonSans.fnt",
            monoid: FONT_BASE_URL + "Monoid.fnt",
            mozillavr: FONT_BASE_URL + "mozillavr.fnt",
            roboto: FONT_BASE_URL + "Roboto-msdf.json",
            sourcecodepro: FONT_BASE_URL + "SourceCodePro.fnt"
          }, MSDF_FONTS = ["roboto"], DEFAULT_FONT = "roboto";
          module3.exports.FONTS = FONTS;
          var cache = new PromiseCache(), fontWidthFactors = {}, textures = {}, protocolRe = /^\w+:/;
          module3.exports.Component = registerComponent("text", {
            multiple: !0,
            schema: {
              align: {
                type: "string",
                default: "left",
                oneOf: ["left", "right", "center"]
              },
              alphaTest: {
                default: 0.5
              },
              anchor: {
                default: "center",
                oneOf: ["left", "right", "center", "align"]
              },
              baseline: {
                default: "center",
                oneOf: ["top", "center", "bottom"]
              },
              color: {
                type: "color",
                default: "#FFF"
              },
              font: {
                type: "string",
                default: DEFAULT_FONT
              },
              fontImage: {
                type: "string"
              },
              height: {
                type: "number"
              },
              letterSpacing: {
                type: "number",
                default: 0
              },
              lineHeight: {
                type: "number"
              },
              negate: {
                type: "boolean",
                default: !0
              },
              opacity: {
                type: "number",
                default: 1
              },
              shader: {
                default: "sdf",
                oneOf: shaders
              },
              side: {
                default: "front",
                oneOf: ["front", "back", "double"]
              },
              tabSize: {
                default: 4
              },
              transparent: {
                default: !0
              },
              value: {
                type: "string"
              },
              whiteSpace: {
                default: "normal",
                oneOf: ["normal", "pre", "nowrap"]
              },
              width: {
                type: "number"
              },
              wrapCount: {
                type: "number",
                default: 40
              },
              wrapPixels: {
                type: "number"
              },
              xOffset: {
                type: "number",
                default: 0
              },
              yOffset: {
                type: "number",
                default: 0
              },
              zOffset: {
                type: "number",
                default: 1e-3
              }
            },
            init: function() {
              this.shaderData = {}, this.geometry = createTextGeometry(), this.createOrUpdateMaterial(), this.explicitGeoDimensionsChecked = !1;
            },
            update: function(oldData) {
              var data = this.data, font = this.currentFont;
              if (textures[data.font] ? this.texture = textures[data.font] : (this.texture = textures[data.font] = new THREE3.Texture(), this.texture.anisotropy = MAX_ANISOTROPY), this.createOrUpdateMaterial(), oldData.font !== data.font) {
                this.updateFont();
                return;
              }
              font && (this.updateGeometry(this.geometry, font), this.updateLayout());
            },
            remove: function() {
              this.geometry.dispose(), this.geometry = null, this.el.removeObject3D(this.attrName), this.material.dispose(), this.material = null, this.texture.dispose(), this.texture = null, this.shaderObject && delete this.shaderObject;
            },
            createOrUpdateMaterial: function() {
              var data = this.data, hasChangedShader, material = this.material, NewShader, shaderData = this.shaderData, shaderName;
              if (shaderName = data.shader, MSDF_FONTS.indexOf(data.font) !== -1 || data.font.indexOf("-msdf.") >= 0 ? shaderName = "msdf" : data.font in FONTS && MSDF_FONTS.indexOf(data.font) === -1 && (shaderName = "sdf"), hasChangedShader = (this.shaderObject && this.shaderObject.name) !== shaderName, shaderData.alphaTest = data.alphaTest, shaderData.color = data.color, shaderData.map = this.texture, shaderData.opacity = data.opacity, shaderData.side = parseSide(data.side), shaderData.transparent = data.transparent, shaderData.negate = data.negate, !hasChangedShader) {
                this.shaderObject.update(shaderData), material.transparent = shaderData.transparent, material.side = shaderData.side;
                return;
              }
              NewShader = createShader(this.el, shaderName, shaderData), this.material = NewShader.material, this.shaderObject = NewShader.shader, this.material.side = shaderData.side, this.mesh && (this.mesh.material = this.material);
            },
            updateFont: function() {
              var data = this.data, el = this.el, fontSrc, geometry = this.geometry, self2 = this;
              data.font || warn("No font specified. Using the default font."), this.mesh && (this.mesh.visible = !1), fontSrc = this.lookupFont(data.font || DEFAULT_FONT) || data.font, cache.get(fontSrc, function() {
                return loadFont(fontSrc, data.yOffset);
              }).then(function(font) {
                var fontImgSrc;
                if (font.pages.length !== 1)
                  throw new Error("Currently only single-page bitmap fonts are supported.");
                fontWidthFactors[fontSrc] || (font.widthFactor = fontWidthFactors[font] = computeFontWidthFactor(font)), self2.currentFont = font, fontImgSrc = self2.getFontImageSrc(), cache.get(fontImgSrc, function() {
                  return loadTexture(fontImgSrc);
                }).then(function(image) {
                  var texture = self2.texture;
                  !texture || (texture.image = image, texture.needsUpdate = !0, textures[data.font] = texture, self2.texture = texture, self2.initMesh(), self2.currentFont = font, self2.updateGeometry(geometry, font), self2.updateLayout(), self2.mesh.visible = !0, el.emit("textfontset", {
                    font: data.font,
                    fontObj: font
                  }));
                }).catch(function(err) {
                  error(err.message), error(err.stack);
                });
              }).catch(function(err) {
                error(err.message), error(err.stack);
              });
            },
            initMesh: function() {
              this.mesh || (this.mesh = new THREE3.Mesh(this.geometry, this.material), this.el.setObject3D(this.attrName, this.mesh));
            },
            getFontImageSrc: function() {
              if (this.data.fontImage)
                return this.data.fontImage;
              var fontSrc = this.lookupFont(this.data.font || DEFAULT_FONT) || this.data.font, imageSrc = this.currentFont.pages[0];
              return imageSrc.match(protocolRe) && imageSrc.indexOf("http") !== 0 ? fontSrc.replace(/(\.fnt)|(\.json)/, ".png") : THREE3.LoaderUtils.extractUrlBase(fontSrc) + imageSrc;
            },
            updateLayout: function() {
              var anchor, baseline, el = this.el, data = this.data, geometry = this.geometry, geometryComponent, height, layout, mesh = this.mesh, textRenderWidth, textScale, width, x, y;
              if (!(!mesh || !geometry.layout)) {
                if (geometryComponent = el.getAttribute("geometry"), width = data.width || geometryComponent && geometryComponent.width || DEFAULT_WIDTH, textRenderWidth = computeWidth(data.wrapPixels, data.wrapCount, this.currentFont.widthFactor), textScale = width / textRenderWidth, layout = geometry.layout, height = textScale * (layout.height + layout.descender), geometryComponent && geometryComponent.primitive === "plane" && (this.explicitGeoDimensionsChecked || (this.explicitGeoDimensionsChecked = !0, this.hasExplicitGeoWidth = !!geometryComponent.width, this.hasExplicitGeoHeight = !!geometryComponent.height), this.hasExplicitGeoWidth || el.setAttribute("geometry", "width", width), this.hasExplicitGeoHeight || el.setAttribute("geometry", "height", height)), anchor = data.anchor === "align" ? data.align : data.anchor, anchor === "left")
                  x = 0;
                else if (anchor === "right")
                  x = -1 * layout.width;
                else if (anchor === "center")
                  x = -1 * layout.width / 2;
                else
                  throw new TypeError("Invalid text.anchor property value", anchor);
                if (baseline = data.baseline, baseline === "bottom")
                  y = 0;
                else if (baseline === "top")
                  y = -1 * layout.height + layout.ascender;
                else if (baseline === "center")
                  y = -1 * layout.height / 2;
                else
                  throw new TypeError("Invalid text.baseline property value", baseline);
                mesh.position.x = x * textScale + data.xOffset, mesh.position.y = y * textScale, mesh.position.z = data.zOffset, mesh.scale.set(textScale, -1 * textScale, textScale);
              }
            },
            lookupFont: function(key) {
              return FONTS[key];
            },
            updateGeometry: function() {
              var geometryUpdateBase = {}, geometryUpdateData = {}, newLineRegex = /\\n/g, tabRegex = /\\t/g;
              return function(geometry, font) {
                var data = this.data;
                geometryUpdateData.font = font, geometryUpdateData.lineHeight = data.lineHeight && isFinite(data.lineHeight) ? data.lineHeight : font.common.lineHeight, geometryUpdateData.text = data.value.toString().replace(newLineRegex, `
`).replace(tabRegex, "	"), geometryUpdateData.width = computeWidth(data.wrapPixels, data.wrapCount, font.widthFactor), geometry.update(utils.extend(geometryUpdateBase, data, geometryUpdateData));
              };
            }()
          });
          function parseSide(side) {
            switch (side) {
              case "back":
                return THREE3.FrontSide;
              case "double":
                return THREE3.DoubleSide;
              default:
                return THREE3.BackSide;
            }
          }
          function loadFont(src, yOffset) {
            return new Promise(function(resolve, reject) {
              loadBMFont(src, function(err, font) {
                if (err) {
                  error("Error loading font", src), reject(err);
                  return;
                }
                src.indexOf("/Roboto-msdf.json") >= 0 && (yOffset = 30), yOffset && font.chars.map(function(ch) {
                  ch.yoffset += yOffset;
                }), resolve(font);
              });
            });
          }
          function loadTexture(src) {
            return new Promise(function(resolve, reject) {
              new THREE3.ImageLoader().load(src, function(image) {
                resolve(image);
              }, void 0, function() {
                error("Error loading font image", src), reject(null);
              });
            });
          }
          function createShader(el, shaderName, data) {
            var shader, shaderObject;
            return shaderObject = new shaders[shaderName].Shader(), shaderObject.el = el, shaderObject.init(data), shaderObject.update(data), shader = shaderObject.material, shader.transparent = data.transparent, {
              material: shader,
              shader: shaderObject
            };
          }
          function computeWidth(wrapPixels, wrapCount, widthFactor) {
            return wrapPixels || (0.5 + wrapCount) * widthFactor;
          }
          function computeFontWidthFactor(font) {
            var sum = 0, digitsum = 0, digits = 0;
            return font.chars.map(function(ch) {
              sum += ch.xadvance, ch.id >= 48 && ch.id <= 57 && (digits++, digitsum += ch.xadvance);
            }), digits ? digitsum / digits : sum / font.chars.length;
          }
          function PromiseCache() {
            var cache2 = this.cache = {};
            this.get = function(key, promiseGenerator) {
              return key in cache2 || (cache2[key] = promiseGenerator()), cache2[key];
            };
          }
        },
        "./src/components/tracked-controls-webvr.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, controllerUtils = __webpack_require__2("./src/utils/tracked-controls.js"), DEFAULT_CAMERA_HEIGHT = __webpack_require__2("./src/constants/index.js").DEFAULT_CAMERA_HEIGHT, THREE3 = __webpack_require__2("./src/lib/three.js"), DEFAULT_HANDEDNESS = __webpack_require__2("./src/constants/index.js").DEFAULT_HANDEDNESS, EYES_TO_ELBOW = {
            x: 0.175,
            y: -0.3,
            z: -0.03
          }, FOREARM = {
            x: 0,
            y: 0,
            z: -0.175
          }, EMPTY_DAYDREAM_TOUCHES = {
            touches: []
          }, EVENTS = {
            AXISMOVE: "axismove",
            BUTTONCHANGED: "buttonchanged",
            BUTTONDOWN: "buttondown",
            BUTTONUP: "buttonup",
            TOUCHSTART: "touchstart",
            TOUCHEND: "touchend"
          };
          module3.exports.Component = registerComponent("tracked-controls-webvr", {
            schema: {
              autoHide: {
                default: !0
              },
              controller: {
                default: 0
              },
              id: {
                type: "string",
                default: ""
              },
              hand: {
                type: "string",
                default: ""
              },
              idPrefix: {
                type: "string",
                default: ""
              },
              orientationOffset: {
                type: "vec3"
              },
              armModel: {
                default: !1
              },
              headElement: {
                type: "selector"
              }
            },
            init: function() {
              this.axis = this.el.components["tracked-controls"].axis = [0, 0, 0], this.buttonStates = this.el.components["tracked-controls"].buttonStates = {}, this.changedAxes = [], this.targetControllerNumber = this.data.controller, this.axisMoveEventDetail = {
                axis: this.axis,
                changed: this.changedAxes
              }, this.deltaControllerPosition = new THREE3.Vector3(), this.controllerQuaternion = new THREE3.Quaternion(), this.controllerEuler = new THREE3.Euler(), this.updateGamepad(), this.buttonEventDetails = {};
            },
            tick: function(time, delta) {
              var mesh = this.el.getObject3D("mesh");
              mesh && mesh.update && mesh.update(delta / 1e3), this.updateGamepad(), this.updatePose(), this.updateButtons();
            },
            defaultUserHeight: function() {
              return DEFAULT_CAMERA_HEIGHT;
            },
            getHeadElement: function() {
              return this.data.headElement || this.el.sceneEl.camera.el;
            },
            updateGamepad: function() {
              var data = this.data, controller = controllerUtils.findMatchingControllerWebVR(this.system.controllers, data.id, data.idPrefix, data.hand, data.controller);
              this.controller = controller, this.el.components["tracked-controls"].controller = controller, this.data.autoHide && (this.el.object3D.visible = !!this.controller);
            },
            applyArmModel: function(controllerPosition) {
              var controller = this.controller, controllerEuler = this.controllerEuler, controllerQuaternion = this.controllerQuaternion, deltaControllerPosition = this.deltaControllerPosition, hand, headEl, headObject3D, pose, userHeight;
              headEl = this.getHeadElement(), headObject3D = headEl.object3D, userHeight = this.defaultUserHeight(), pose = controller.pose, hand = (controller ? controller.hand : void 0) || DEFAULT_HANDEDNESS, controllerPosition.copy(headObject3D.position), deltaControllerPosition.set(EYES_TO_ELBOW.x * (hand === "left" ? -1 : hand === "right" ? 1 : 0), EYES_TO_ELBOW.y, EYES_TO_ELBOW.z), deltaControllerPosition.multiplyScalar(userHeight), deltaControllerPosition.applyAxisAngle(headObject3D.up, headObject3D.rotation.y), controllerPosition.add(deltaControllerPosition), deltaControllerPosition.set(FOREARM.x, FOREARM.y, FOREARM.z), deltaControllerPosition.multiplyScalar(userHeight), pose.orientation ? controllerQuaternion.fromArray(pose.orientation) : controllerQuaternion.copy(headObject3D.quaternion), controllerEuler.setFromQuaternion(controllerQuaternion), controllerEuler.set(controllerEuler.x, controllerEuler.y, 0), deltaControllerPosition.applyEuler(controllerEuler), controllerPosition.add(deltaControllerPosition);
            },
            updatePose: function() {
              var controller = this.controller, data = this.data, object3D = this.el.object3D, pose, vrDisplay = this.system.vrDisplay, standingMatrix;
              !controller || (pose = controller.pose, pose.position ? object3D.position.fromArray(pose.position) : data.armModel && this.applyArmModel(object3D.position), pose.orientation && object3D.quaternion.fromArray(pose.orientation), vrDisplay && pose.position && (standingMatrix = this.el.sceneEl.renderer.xr.getStandingMatrix(), object3D.matrix.compose(object3D.position, object3D.quaternion, object3D.scale), object3D.matrix.multiplyMatrices(standingMatrix, object3D.matrix), object3D.matrix.decompose(object3D.position, object3D.quaternion, object3D.scale)), object3D.rotateX(this.data.orientationOffset.x * THREE3.MathUtils.DEG2RAD), object3D.rotateY(this.data.orientationOffset.y * THREE3.MathUtils.DEG2RAD), object3D.rotateZ(this.data.orientationOffset.z * THREE3.MathUtils.DEG2RAD));
            },
            updateButtons: function() {
              var buttonState, controller = this.controller, id;
              if (!!controller) {
                for (id = 0; id < controller.buttons.length; ++id)
                  this.buttonStates[id] || (this.buttonStates[id] = {
                    pressed: !1,
                    touched: !1,
                    value: 0
                  }), this.buttonEventDetails[id] || (this.buttonEventDetails[id] = {
                    id,
                    state: this.buttonStates[id]
                  }), buttonState = controller.buttons[id], this.handleButton(id, buttonState);
                this.handleAxes();
              }
            },
            handleButton: function(id, buttonState) {
              var changed;
              return changed = this.handlePress(id, buttonState) | this.handleTouch(id, buttonState) | this.handleValue(id, buttonState), changed ? (this.el.emit(EVENTS.BUTTONCHANGED, this.buttonEventDetails[id], !1), !0) : !1;
            },
            handleAxes: function() {
              var changed = !1, controllerAxes = this.controller.axes, i, previousAxis = this.axis, changedAxes = this.changedAxes;
              for (this.changedAxes.splice(0, this.changedAxes.length), i = 0; i < controllerAxes.length; ++i)
                changedAxes.push(previousAxis[i] !== controllerAxes[i]), changedAxes[i] && (changed = !0);
              if (!changed)
                return !1;
              for (this.axis.splice(0, this.axis.length), i = 0; i < controllerAxes.length; i++)
                this.axis.push(controllerAxes[i]);
              return this.el.emit(EVENTS.AXISMOVE, this.axisMoveEventDetail, !1), !0;
            },
            handlePress: function(id, buttonState) {
              var evtName, previousButtonState = this.buttonStates[id];
              return buttonState.pressed === previousButtonState.pressed ? !1 : (evtName = buttonState.pressed ? EVENTS.BUTTONDOWN : EVENTS.BUTTONUP, this.el.emit(evtName, this.buttonEventDetails[id], !1), previousButtonState.pressed = buttonState.pressed, !0);
            },
            handleTouch: function(id, buttonState) {
              var evtName, previousButtonState = this.buttonStates[id];
              return buttonState.touched === previousButtonState.touched ? !1 : (evtName = buttonState.touched ? EVENTS.TOUCHSTART : EVENTS.TOUCHEND, this.el.emit(evtName, this.buttonEventDetails[id], !1, EMPTY_DAYDREAM_TOUCHES), previousButtonState.touched = buttonState.touched, !0);
            },
            handleValue: function(id, buttonState) {
              var previousButtonState = this.buttonStates[id];
              return buttonState.value === previousButtonState.value ? !1 : (previousButtonState.value = buttonState.value, !0);
            }
          });
        },
        "./src/components/tracked-controls-webxr.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var controllerUtils = __webpack_require__2("./src/utils/tracked-controls.js"), registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, EVENTS = {
            AXISMOVE: "axismove",
            BUTTONCHANGED: "buttonchanged",
            BUTTONDOWN: "buttondown",
            BUTTONUP: "buttonup",
            TOUCHSTART: "touchstart",
            TOUCHEND: "touchend"
          };
          module3.exports.Component = registerComponent("tracked-controls-webxr", {
            schema: {
              id: {
                type: "string",
                default: ""
              },
              hand: {
                type: "string",
                default: ""
              },
              handTrackingEnabled: {
                default: !1
              },
              index: {
                type: "int",
                default: -1
              },
              iterateControllerProfiles: {
                default: !1
              },
              space: {
                type: "string",
                oneOf: ["targetRaySpace", "gripSpace"],
                default: "gripSpace"
              }
            },
            init: function() {
              this.updateController = this.updateController.bind(this), this.buttonEventDetails = {}, this.buttonStates = this.el.components["tracked-controls"].buttonStates = {}, this.axis = this.el.components["tracked-controls"].axis = [0, 0, 0], this.changedAxes = [], this.axisMoveEventDetail = {
                axis: this.axis,
                changed: this.changedAxes
              };
            },
            update: function() {
              this.updateController();
            },
            play: function() {
              var sceneEl = this.el.sceneEl;
              this.updateController(), sceneEl.addEventListener("controllersupdated", this.updateController);
            },
            pause: function() {
              var sceneEl = this.el.sceneEl;
              sceneEl.removeEventListener("controllersupdated", this.updateController);
            },
            isControllerPresent: function(evt) {
              return !(!this.controller || this.controller.gamepad || evt.inputSource.handedness !== "none" && evt.inputSource.handedness !== this.data.hand);
            },
            updateController: function() {
              this.controller = controllerUtils.findMatchingControllerWebXR(this.system.controllers, this.data.id, this.data.hand, this.data.index, this.data.iterateControllerProfiles, this.data.handTrackingEnabled), this.el.components["tracked-controls"].controller = this.controller, this.data.autoHide && (this.el.object3D.visible = !!this.controller);
            },
            tick: function() {
              var sceneEl = this.el.sceneEl, controller = this.controller, frame = sceneEl.frame;
              !controller || !sceneEl.frame || !this.system.referenceSpace || controller.hand || (this.pose = frame.getPose(controller[this.data.space], this.system.referenceSpace), this.updatePose(), this.updateButtons());
            },
            updatePose: function() {
              var object3D = this.el.object3D, pose = this.pose;
              !pose || (object3D.matrix.elements = pose.transform.matrix, object3D.matrix.decompose(object3D.position, object3D.rotation, object3D.scale));
            },
            updateButtons: function() {
              var buttonState, id, controller = this.controller, gamepad;
              if (!(!controller || !controller.gamepad)) {
                for (gamepad = controller.gamepad, id = 0; id < gamepad.buttons.length; ++id)
                  this.buttonStates[id] || (this.buttonStates[id] = {
                    pressed: !1,
                    touched: !1,
                    value: 0
                  }), this.buttonEventDetails[id] || (this.buttonEventDetails[id] = {
                    id,
                    state: this.buttonStates[id]
                  }), buttonState = gamepad.buttons[id], this.handleButton(id, buttonState);
                this.handleAxes();
              }
            },
            handleButton: function(id, buttonState) {
              var changed;
              return changed = this.handlePress(id, buttonState) | this.handleTouch(id, buttonState) | this.handleValue(id, buttonState), changed ? (this.el.emit(EVENTS.BUTTONCHANGED, this.buttonEventDetails[id], !1), !0) : !1;
            },
            handleAxes: function() {
              var changed = !1, controllerAxes = this.controller.gamepad.axes, i, previousAxis = this.axis, changedAxes = this.changedAxes;
              for (this.changedAxes.splice(0, this.changedAxes.length), i = 0; i < controllerAxes.length; ++i)
                changedAxes.push(previousAxis[i] !== controllerAxes[i]), changedAxes[i] && (changed = !0);
              if (!changed)
                return !1;
              for (this.axis.splice(0, this.axis.length), i = 0; i < controllerAxes.length; i++)
                this.axis.push(controllerAxes[i]);
              return this.el.emit(EVENTS.AXISMOVE, this.axisMoveEventDetail, !1), !0;
            },
            handlePress: function(id, buttonState) {
              var evtName, previousButtonState = this.buttonStates[id];
              return buttonState.pressed === previousButtonState.pressed ? !1 : (evtName = buttonState.pressed ? EVENTS.BUTTONDOWN : EVENTS.BUTTONUP, this.el.emit(evtName, this.buttonEventDetails[id], !1), previousButtonState.pressed = buttonState.pressed, !0);
            },
            handleTouch: function(id, buttonState) {
              var evtName, previousButtonState = this.buttonStates[id];
              return buttonState.touched === previousButtonState.touched ? !1 : (evtName = buttonState.touched ? EVENTS.TOUCHSTART : EVENTS.TOUCHEND, this.el.emit(evtName, this.buttonEventDetails[id], !1), previousButtonState.touched = buttonState.touched, !0);
            },
            handleValue: function(id, buttonState) {
              var previousButtonState = this.buttonStates[id];
              return buttonState.value === previousButtonState.value ? !1 : (previousButtonState.value = buttonState.value, !0);
            }
          });
        },
        "./src/components/tracked-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = registerComponent("tracked-controls", {
            schema: {
              autoHide: {
                default: !0
              },
              controller: {
                default: -1
              },
              id: {
                type: "string",
                default: ""
              },
              hand: {
                type: "string",
                default: ""
              },
              idPrefix: {
                type: "string",
                default: ""
              },
              handTrackingEnabled: {
                default: !1
              },
              orientationOffset: {
                type: "vec3"
              },
              armModel: {
                default: !1
              },
              headElement: {
                type: "selector"
              },
              iterateControllerProfiles: {
                default: !1
              },
              space: {
                type: "string",
                oneOf: ["targetRaySpace", "gripSpace"],
                default: "targetRaySpace"
              }
            },
            after: ["tracked-controls-webvr", "tracked-controls-webxr"],
            update: function() {
              var data = this.data, el = this.el;
              el.sceneEl.hasWebXR ? el.setAttribute("tracked-controls-webxr", {
                id: data.id,
                hand: data.hand,
                index: data.controller,
                iterateControllerProfiles: data.iterateControllerProfiles,
                handTrackingEnabled: data.handTrackingEnabled,
                space: data.space
              }) : el.setAttribute("tracked-controls-webvr", data);
            }
          });
        },
        "./src/components/valve-index-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged, onButtonEvent = trackedControlsUtils.onButtonEvent, AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, INDEX_CONTROLLER_MODEL_BASE_URL = AFRAME_CDN_ROOT + "controllers/valve/index/valve-index-", INDEX_CONTROLLER_MODEL_URL = {
            left: INDEX_CONTROLLER_MODEL_BASE_URL + "left.glb",
            right: INDEX_CONTROLLER_MODEL_BASE_URL + "right.glb"
          }, GAMEPAD_ID_PREFIX = "valve", isWebXRAvailable = __webpack_require__2("./src/utils/index.js").device.isWebXRAvailable, INDEX_CONTROLLER_POSITION_OFFSET_WEBVR = {
            left: {
              x: -23692678902063457e-20,
              y: 0.04724540367838371,
              z: -0.061959880395271096
            },
            right: {
              x: 0.002471558599671131,
              y: 0.055765208987076195,
              z: -0.061068168708348844
            }
          }, INDEX_CONTROLLER_POSITION_OFFSET_WEBXR = {
            left: {
              x: 0,
              y: -0.05,
              z: 0.06
            },
            right: {
              x: 0,
              y: -0.05,
              z: 0.06
            }
          }, INDEX_CONTROLLER_ROTATION_OFFSET_WEBVR = {
            left: {
              _x: 0.692295102620542,
              _y: -0.0627618864318427,
              _z: -0.06265893149611756,
              _order: "XYZ"
            },
            right: {
              _x: 0.6484021229942998,
              _y: -0.032563619881892894,
              _z: -0.1327973171917482,
              _order: "XYZ"
            }
          }, INDEX_CONTROLLER_ROTATION_OFFSET_WEBXR = {
            left: {
              _x: Math.PI / 3,
              _y: 0,
              _z: 0,
              _order: "XYZ"
            },
            right: {
              _x: Math.PI / 3,
              _y: 0,
              _z: 0,
              _order: "XYZ"
            }
          }, INDEX_CONTROLLER_ROTATION_OFFSET = isWebXRAvailable ? INDEX_CONTROLLER_ROTATION_OFFSET_WEBXR : INDEX_CONTROLLER_ROTATION_OFFSET_WEBVR, INDEX_CONTROLLER_POSITION_OFFSET = isWebXRAvailable ? INDEX_CONTROLLER_POSITION_OFFSET_WEBXR : INDEX_CONTROLLER_POSITION_OFFSET_WEBVR;
          module3.exports.Component = registerComponent("valve-index-controls", {
            schema: {
              hand: {
                default: "left"
              },
              buttonColor: {
                type: "color",
                default: "#FAFAFA"
              },
              buttonHighlightColor: {
                type: "color",
                default: "#22D1EE"
              },
              model: {
                default: !0
              },
              orientationOffset: {
                type: "vec3"
              }
            },
            after: ["tracked-controls"],
            mapping: {
              axes: {
                trackpad: [0, 1],
                thumbstick: [2, 3]
              },
              buttons: ["trigger", "grip", "trackpad", "thumbstick", "abutton"]
            },
            init: function() {
              var self2 = this;
              this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(evt) {
                onButtonEvent(evt.detail.id, "down", self2);
              }, this.onButtonUp = function(evt) {
                onButtonEvent(evt.detail.id, "up", self2);
              }, this.onButtonTouchEnd = function(evt) {
                onButtonEvent(evt.detail.id, "touchend", self2);
              }, this.onButtonTouchStart = function(evt) {
                onButtonEvent(evt.detail.id, "touchstart", self2);
              }, this.previousButtonValues = {}, this.bindMethods();
            },
            play: function() {
              this.checkIfControllerPresent(), this.addControllersUpdateListener();
            },
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            bindMethods: function() {
              this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("buttonchanged", this.onButtonChanged), el.addEventListener("buttondown", this.onButtonDown), el.addEventListener("buttonup", this.onButtonUp), el.addEventListener("touchend", this.onButtonTouchEnd), el.addEventListener("touchstart", this.onButtonTouchStart), el.addEventListener("model-loaded", this.onModelLoaded), el.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0;
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("buttonchanged", this.onButtonChanged), el.removeEventListener("buttondown", this.onButtonDown), el.removeEventListener("buttonup", this.onButtonUp), el.removeEventListener("touchend", this.onButtonTouchEnd), el.removeEventListener("touchstart", this.onButtonTouchStart), el.removeEventListener("model-loaded", this.onModelLoaded), el.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1;
            },
            checkIfControllerPresent: function() {
              var data = this.data, controllerIndex = data.hand === "right" ? 0 : data.hand === "left" ? 1 : 2;
              checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {
                index: controllerIndex,
                iterateControllerProfiles: !0,
                hand: data.hand
              });
            },
            injectTrackedControls: function() {
              var el = this.el, data = this.data;
              el.setAttribute("tracked-controls", {
                idPrefix: GAMEPAD_ID_PREFIX,
                controller: data.hand === "right" ? 1 : data.hand === "left" ? 0 : 2,
                hand: data.hand,
                orientationOffset: data.orientationOffset
              }), this.loadModel();
            },
            loadModel: function() {
              var data = this.data;
              !data.model || this.el.setAttribute("gltf-model", "" + INDEX_CONTROLLER_MODEL_URL[data.hand] + "");
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              this.checkIfControllerPresent();
            },
            onButtonChanged: function(evt) {
              var button = this.mapping.buttons[evt.detail.id], buttonMeshes = this.buttonMeshes, analogValue;
              !button || (button === "trigger" && (analogValue = evt.detail.state.value, buttonMeshes && buttonMeshes.trigger && (buttonMeshes.trigger.rotation.x = this.triggerOriginalRotationX - analogValue * (Math.PI / 40))), this.el.emit(button + "changed", evt.detail.state));
            },
            onModelLoaded: function(evt) {
              var buttonMeshes, controllerObject3D = evt.detail.model, self2 = this;
              evt.target !== this.el || !this.data.model || (buttonMeshes = this.buttonMeshes = {}, buttonMeshes.grip = {
                left: controllerObject3D.getObjectByName("leftgrip"),
                right: controllerObject3D.getObjectByName("rightgrip")
              }, buttonMeshes.menu = controllerObject3D.getObjectByName("menubutton"), buttonMeshes.system = controllerObject3D.getObjectByName("systembutton"), buttonMeshes.trackpad = controllerObject3D.getObjectByName("touchpad"), buttonMeshes.trigger = controllerObject3D.getObjectByName("trigger"), this.triggerOriginalRotationX = buttonMeshes.trigger.rotation.x, Object.keys(buttonMeshes).forEach(function(buttonName) {
                self2.setButtonColor(buttonName, self2.data.buttonColor);
              }), controllerObject3D.position.copy(INDEX_CONTROLLER_POSITION_OFFSET[this.data.hand]), controllerObject3D.rotation.copy(INDEX_CONTROLLER_ROTATION_OFFSET[this.data.hand]), this.el.emit("controllermodelready", {
                name: "valve-index-controls",
                model: this.data.model,
                rayOrigin: new THREE3.Vector3(0, 0, 0)
              }));
            },
            onAxisMoved: function(evt) {
              emitIfAxesChanged(this, this.mapping.axes, evt);
            },
            updateModel: function(buttonName, evtName) {
              var color, isTouch;
              !this.data.model || (isTouch = evtName.indexOf("touch") !== -1, !isTouch && (color = evtName === "up" ? this.data.buttonColor : this.data.buttonHighlightColor, this.setButtonColor(buttonName, color)));
            },
            setButtonColor: function(buttonName, color) {
            }
          });
        },
        "./src/components/visible.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent;
          module3.exports.Component = registerComponent("visible", {
            schema: {
              default: !0
            },
            update: function() {
              this.el.object3D.visible = this.data;
            }
          });
        },
        "./src/components/vive-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged, onButtonEvent = trackedControlsUtils.onButtonEvent, AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, VIVE_CONTROLLER_MODEL_OBJ_URL = AFRAME_CDN_ROOT + "controllers/vive/vr_controller_vive.obj", VIVE_CONTROLLER_MODEL_OBJ_MTL = AFRAME_CDN_ROOT + "controllers/vive/vr_controller_vive.mtl", isWebXRAvailable = __webpack_require__2("./src/utils/index.js").device.isWebXRAvailable, GAMEPAD_ID_WEBXR = "htc-vive", GAMEPAD_ID_WEBVR = "OpenVR ", GAMEPAD_ID_PREFIX = isWebXRAvailable ? GAMEPAD_ID_WEBXR : GAMEPAD_ID_WEBVR, INPUT_MAPPING_WEBVR = {
            axes: {
              trackpad: [0, 1]
            },
            buttons: ["trackpad", "trigger", "grip", "menu", "system"]
          }, INPUT_MAPPING_WEBXR = {
            axes: {
              touchpad: [0, 1]
            },
            buttons: ["trigger", "grip", "touchpad", "none"]
          }, INPUT_MAPPING = isWebXRAvailable ? INPUT_MAPPING_WEBXR : INPUT_MAPPING_WEBVR;
          module3.exports.Component = registerComponent("vive-controls", {
            schema: {
              hand: {
                default: "left"
              },
              buttonColor: {
                type: "color",
                default: "#FAFAFA"
              },
              buttonHighlightColor: {
                type: "color",
                default: "#22D1EE"
              },
              model: {
                default: !0
              },
              orientationOffset: {
                type: "vec3"
              }
            },
            after: ["tracked-controls"],
            mapping: INPUT_MAPPING,
            init: function() {
              var self2 = this;
              this.controllerPresent = !1, this.lastControllerCheck = 0, this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(evt) {
                onButtonEvent(evt.detail.id, "down", self2);
              }, this.onButtonUp = function(evt) {
                onButtonEvent(evt.detail.id, "up", self2);
              }, this.onButtonTouchEnd = function(evt) {
                onButtonEvent(evt.detail.id, "touchend", self2);
              }, this.onButtonTouchStart = function(evt) {
                onButtonEvent(evt.detail.id, "touchstart", self2);
              }, this.previousButtonValues = {}, this.bindMethods();
            },
            update: function() {
              var data = this.data;
              this.controllerIndex = data.hand === "right" ? 0 : data.hand === "left" ? 1 : 2;
            },
            play: function() {
              this.checkIfControllerPresent(), this.addControllersUpdateListener();
            },
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            bindMethods: function() {
              this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("buttonchanged", this.onButtonChanged), el.addEventListener("buttondown", this.onButtonDown), el.addEventListener("buttonup", this.onButtonUp), el.addEventListener("touchend", this.onButtonTouchEnd), el.addEventListener("touchstart", this.onButtonTouchStart), el.addEventListener("model-loaded", this.onModelLoaded), el.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0;
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("buttonchanged", this.onButtonChanged), el.removeEventListener("buttondown", this.onButtonDown), el.removeEventListener("buttonup", this.onButtonUp), el.removeEventListener("touchend", this.onButtonTouchEnd), el.removeEventListener("touchstart", this.onButtonTouchStart), el.removeEventListener("model-loaded", this.onModelLoaded), el.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1;
            },
            checkIfControllerPresent: function() {
              var data = this.data;
              checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {
                index: this.controllerIndex,
                hand: data.hand
              });
            },
            injectTrackedControls: function() {
              var el = this.el, data = this.data;
              el.setAttribute("tracked-controls", {
                idPrefix: GAMEPAD_ID_PREFIX,
                hand: data.hand,
                controller: this.controllerIndex,
                orientationOffset: data.orientationOffset
              }), !!this.data.model && this.el.setAttribute("obj-model", {
                obj: VIVE_CONTROLLER_MODEL_OBJ_URL,
                mtl: VIVE_CONTROLLER_MODEL_OBJ_MTL
              });
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              this.checkIfControllerPresent();
            },
            onButtonChanged: function(evt) {
              var button = this.mapping.buttons[evt.detail.id], buttonMeshes = this.buttonMeshes, analogValue;
              !button || (button === "trigger" && (analogValue = evt.detail.state.value, buttonMeshes && buttonMeshes.trigger && (buttonMeshes.trigger.rotation.x = -analogValue * (Math.PI / 12))), this.el.emit(button + "changed", evt.detail.state));
            },
            onModelLoaded: function(evt) {
              var buttonMeshes, controllerObject3D = evt.detail.model, self2 = this;
              evt.target !== this.el || !this.data.model || (buttonMeshes = this.buttonMeshes = {}, buttonMeshes.grip = {
                left: controllerObject3D.getObjectByName("leftgrip"),
                right: controllerObject3D.getObjectByName("rightgrip")
              }, buttonMeshes.menu = controllerObject3D.getObjectByName("menubutton"), buttonMeshes.system = controllerObject3D.getObjectByName("systembutton"), buttonMeshes.trackpad = controllerObject3D.getObjectByName("touchpad"), buttonMeshes.touchpad = controllerObject3D.getObjectByName("touchpad"), buttonMeshes.trigger = controllerObject3D.getObjectByName("trigger"), Object.keys(buttonMeshes).forEach(function(buttonName) {
                self2.setButtonColor(buttonName, self2.data.buttonColor);
              }), controllerObject3D.position.set(0, -0.015, 0.04));
            },
            onAxisMoved: function(evt) {
              emitIfAxesChanged(this, this.mapping.axes, evt);
            },
            updateModel: function(buttonName, evtName) {
              var color, isTouch;
              !this.data.model || (isTouch = evtName.indexOf("touch") !== -1, !isTouch && (color = evtName === "up" ? this.data.buttonColor : this.data.buttonHighlightColor, this.setButtonColor(buttonName, color)));
            },
            setButtonColor: function(buttonName, color) {
              var buttonMeshes = this.buttonMeshes;
              if (!!buttonMeshes) {
                if (buttonName === "grip") {
                  buttonMeshes.grip.left.material.color.set(color), buttonMeshes.grip.right.material.color.set(color);
                  return;
                }
                buttonMeshes[buttonName].material.color.set(color);
              }
            }
          });
        },
        "./src/components/vive-focus-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged, onButtonEvent = trackedControlsUtils.onButtonEvent, AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, VIVE_FOCUS_CONTROLLER_MODEL_URL = AFRAME_CDN_ROOT + "controllers/vive/focus-controller/focus-controller.gltf", isWebXRAvailable = __webpack_require__2("./src/utils/index.js").device.isWebXRAvailable, GAMEPAD_ID_WEBXR = "htc-vive-focus", GAMEPAD_ID_WEBVR = "HTC Vive Focus ", GAMEPAD_ID_PREFIX = isWebXRAvailable ? GAMEPAD_ID_WEBXR : GAMEPAD_ID_WEBVR, INPUT_MAPPING_WEBVR = {
            axes: {
              trackpad: [0, 1]
            },
            buttons: ["trackpad", "trigger"]
          }, INPUT_MAPPING_WEBXR = {
            axes: {
              touchpad: [0, 1]
            },
            buttons: ["trigger", "none", "touchpad", "none", "menu"]
          }, INPUT_MAPPING = isWebXRAvailable ? INPUT_MAPPING_WEBXR : INPUT_MAPPING_WEBVR;
          module3.exports.Component = registerComponent("vive-focus-controls", {
            schema: {
              hand: {
                default: ""
              },
              buttonTouchedColor: {
                type: "color",
                default: "#BBBBBB"
              },
              buttonHighlightColor: {
                type: "color",
                default: "#7A7A7A"
              },
              model: {
                default: !0
              },
              orientationOffset: {
                type: "vec3"
              },
              armModel: {
                default: !0
              }
            },
            after: ["tracked-controls"],
            mapping: INPUT_MAPPING,
            bindMethods: function() {
              this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.removeControllersUpdateListener = this.removeControllersUpdateListener.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
            },
            init: function() {
              var self2 = this;
              this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(evt) {
                onButtonEvent(evt.detail.id, "down", self2);
              }, this.onButtonUp = function(evt) {
                onButtonEvent(evt.detail.id, "up", self2);
              }, this.onButtonTouchStart = function(evt) {
                onButtonEvent(evt.detail.id, "touchstart", self2);
              }, this.onButtonTouchEnd = function(evt) {
                onButtonEvent(evt.detail.id, "touchend", self2);
              }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.bindMethods();
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("buttonchanged", this.onButtonChanged), el.addEventListener("buttondown", this.onButtonDown), el.addEventListener("buttonup", this.onButtonUp), el.addEventListener("touchstart", this.onButtonTouchStart), el.addEventListener("touchend", this.onButtonTouchEnd), el.addEventListener("model-loaded", this.onModelLoaded), el.addEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !0, this.addControllersUpdateListener();
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("buttonchanged", this.onButtonChanged), el.removeEventListener("buttondown", this.onButtonDown), el.removeEventListener("buttonup", this.onButtonUp), el.removeEventListener("touchstart", this.onButtonTouchStart), el.removeEventListener("touchend", this.onButtonTouchEnd), el.removeEventListener("model-loaded", this.onModelLoaded), el.removeEventListener("axismove", this.onAxisMoved), this.controllerEventsActive = !1, this.removeControllersUpdateListener();
            },
            checkIfControllerPresent: function() {
              checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, this.data.hand ? {
                hand: this.data.hand
              } : {});
            },
            play: function() {
              this.checkIfControllerPresent(), this.addControllersUpdateListener();
            },
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            injectTrackedControls: function() {
              var el = this.el, data = this.data;
              el.setAttribute("tracked-controls", {
                armModel: data.armModel,
                idPrefix: GAMEPAD_ID_PREFIX,
                orientationOffset: data.orientationOffset
              }), !!this.data.model && this.el.setAttribute("gltf-model", VIVE_FOCUS_CONTROLLER_MODEL_URL);
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              this.checkIfControllerPresent();
            },
            onModelLoaded: function(evt) {
              var controllerObject3D = evt.detail.model, buttonMeshes;
              evt.target !== this.el || !this.data.model || (buttonMeshes = this.buttonMeshes = {}, buttonMeshes.trigger = controllerObject3D.getObjectByName("BumperKey"), buttonMeshes.triggerPressed = controllerObject3D.getObjectByName("BumperKey_Press"), buttonMeshes.triggerPressed && (buttonMeshes.triggerPressed.visible = !1), buttonMeshes.trackpad = controllerObject3D.getObjectByName("TouchPad"), buttonMeshes.trackpadPressed = controllerObject3D.getObjectByName("TouchPad_Press"), buttonMeshes.trackpadPressed && (buttonMeshes.trackpadPressed.visible = !1));
            },
            onButtonChanged: function(evt) {
              var button = this.mapping.buttons[evt.detail.id];
              !button || this.el.emit(button + "changed", evt.detail.state);
            },
            onAxisMoved: function(evt) {
              emitIfAxesChanged(this, this.mapping.axes, evt);
            },
            updateModel: function(buttonName, evtName) {
              !this.data.model || this.updateButtonModel(buttonName, evtName);
            },
            updateButtonModel: function(buttonName, state) {
              var buttonMeshes = this.buttonMeshes, pressedName = buttonName + "Pressed";
              if (!(!buttonMeshes || !buttonMeshes[buttonName] || !buttonMeshes[pressedName])) {
                var color;
                switch (state) {
                  case "down":
                    color = this.data.buttonHighlightColor;
                    break;
                  case "touchstart":
                    color = this.data.buttonTouchedColor;
                    break;
                }
                color && buttonMeshes[pressedName].material.color.set(color), buttonMeshes[pressedName].visible = !!color, buttonMeshes[buttonName].visible = !color;
              }
            }
          });
        },
        "./src/components/wasd-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var KEYCODE_TO_CODE = __webpack_require__2("./src/constants/index.js").keyboardevent.KEYCODE_TO_CODE, registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js"), shouldCaptureKeyEvent = utils.shouldCaptureKeyEvent, CLAMP_VELOCITY = 1e-5, MAX_DELTA = 0.2, KEYS = ["KeyW", "KeyA", "KeyS", "KeyD", "ArrowUp", "ArrowLeft", "ArrowRight", "ArrowDown"];
          module3.exports.Component = registerComponent("wasd-controls", {
            schema: {
              acceleration: {
                default: 65
              },
              adAxis: {
                default: "x",
                oneOf: ["x", "y", "z"]
              },
              adEnabled: {
                default: !0
              },
              adInverted: {
                default: !1
              },
              enabled: {
                default: !0
              },
              fly: {
                default: !1
              },
              wsAxis: {
                default: "z",
                oneOf: ["x", "y", "z"]
              },
              wsEnabled: {
                default: !0
              },
              wsInverted: {
                default: !1
              }
            },
            after: ["look-controls"],
            init: function() {
              this.keys = {}, this.easing = 1.1, this.velocity = new THREE3.Vector3(), this.onBlur = this.onBlur.bind(this), this.onContextMenu = this.onContextMenu.bind(this), this.onFocus = this.onFocus.bind(this), this.onKeyDown = this.onKeyDown.bind(this), this.onKeyUp = this.onKeyUp.bind(this), this.onVisibilityChange = this.onVisibilityChange.bind(this), this.attachVisibilityEventListeners();
            },
            tick: function(time, delta) {
              var data = this.data, el = this.el, velocity = this.velocity;
              !velocity[data.adAxis] && !velocity[data.wsAxis] && isEmptyObject(this.keys) || (delta = delta / 1e3, this.updateVelocity(delta), !(!velocity[data.adAxis] && !velocity[data.wsAxis]) && el.object3D.position.add(this.getMovementVector(delta)));
            },
            update: function(oldData) {
              oldData.adAxis !== this.data.adAxis && (this.velocity[oldData.adAxis] = 0), oldData.wsAxis !== this.data.wsAxis && (this.velocity[oldData.wsAxis] = 0);
            },
            remove: function() {
              this.removeKeyEventListeners(), this.removeVisibilityEventListeners();
            },
            play: function() {
              this.attachKeyEventListeners();
            },
            pause: function() {
              this.keys = {}, this.removeKeyEventListeners();
            },
            updateVelocity: function(delta) {
              var acceleration, adAxis, adSign, data = this.data, keys = this.keys, velocity = this.velocity, wsAxis, wsSign;
              if (adAxis = data.adAxis, wsAxis = data.wsAxis, delta > MAX_DELTA) {
                velocity[adAxis] = 0, velocity[wsAxis] = 0;
                return;
              }
              var scaledEasing = Math.pow(1 / this.easing, delta * 60);
              velocity[adAxis] !== 0 && (velocity[adAxis] = velocity[adAxis] * scaledEasing), velocity[wsAxis] !== 0 && (velocity[wsAxis] = velocity[wsAxis] * scaledEasing), Math.abs(velocity[adAxis]) < CLAMP_VELOCITY && (velocity[adAxis] = 0), Math.abs(velocity[wsAxis]) < CLAMP_VELOCITY && (velocity[wsAxis] = 0), !!data.enabled && (acceleration = data.acceleration, data.adEnabled && (adSign = data.adInverted ? -1 : 1, (keys.KeyA || keys.ArrowLeft) && (velocity[adAxis] -= adSign * acceleration * delta), (keys.KeyD || keys.ArrowRight) && (velocity[adAxis] += adSign * acceleration * delta)), data.wsEnabled && (wsSign = data.wsInverted ? -1 : 1, (keys.KeyW || keys.ArrowUp) && (velocity[wsAxis] -= wsSign * acceleration * delta), (keys.KeyS || keys.ArrowDown) && (velocity[wsAxis] += wsSign * acceleration * delta)));
            },
            getMovementVector: function() {
              var directionVector = new THREE3.Vector3(0, 0, 0), rotationEuler = new THREE3.Euler(0, 0, 0, "YXZ");
              return function(delta) {
                var rotation = this.el.getAttribute("rotation"), velocity = this.velocity, xRotation;
                return directionVector.copy(velocity), directionVector.multiplyScalar(delta), rotation && (xRotation = this.data.fly ? rotation.x : 0, rotationEuler.set(THREE3.MathUtils.degToRad(xRotation), THREE3.MathUtils.degToRad(rotation.y), 0), directionVector.applyEuler(rotationEuler)), directionVector;
              };
            }(),
            attachVisibilityEventListeners: function() {
              window.oncontextmenu = this.onContextMenu, window.addEventListener("blur", this.onBlur), window.addEventListener("focus", this.onFocus), document.addEventListener("visibilitychange", this.onVisibilityChange);
            },
            removeVisibilityEventListeners: function() {
              window.removeEventListener("blur", this.onBlur), window.removeEventListener("focus", this.onFocus), document.removeEventListener("visibilitychange", this.onVisibilityChange);
            },
            attachKeyEventListeners: function() {
              window.addEventListener("keydown", this.onKeyDown), window.addEventListener("keyup", this.onKeyUp);
            },
            removeKeyEventListeners: function() {
              window.removeEventListener("keydown", this.onKeyDown), window.removeEventListener("keyup", this.onKeyUp);
            },
            onContextMenu: function() {
              for (var keys = Object.keys(this.keys), i = 0; i < keys.length; i++)
                delete this.keys[keys[i]];
            },
            onBlur: function() {
              this.pause();
            },
            onFocus: function() {
              this.play();
            },
            onVisibilityChange: function() {
              document.hidden ? this.onBlur() : this.onFocus();
            },
            onKeyDown: function(event) {
              var code;
              !shouldCaptureKeyEvent(event) || (code = event.code || KEYCODE_TO_CODE[event.keyCode], KEYS.indexOf(code) !== -1 && (this.keys[code] = !0));
            },
            onKeyUp: function(event) {
              var code;
              code = event.code || KEYCODE_TO_CODE[event.keyCode], delete this.keys[code];
            }
          });
          function isEmptyObject(keys) {
            var key;
            for (key in keys)
              return !1;
            return !0;
          }
        },
        "./src/components/windows-motion-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, trackedControlsUtils = __webpack_require__2("./src/utils/tracked-controls.js"), checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup, emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged, onButtonEvent = trackedControlsUtils.onButtonEvent, utils = __webpack_require__2("./src/utils/index.js"), debug = utils.debug("components:windows-motion-controls:debug"), warn = utils.debug("components:windows-motion-controls:warn"), DEFAULT_HANDEDNESS = __webpack_require__2("./src/constants/index.js").DEFAULT_HANDEDNESS, AFRAME_CDN_ROOT = __webpack_require__2("./src/constants/index.js").AFRAME_CDN_ROOT, MODEL_BASE_URL = AFRAME_CDN_ROOT + "controllers/microsoft/", MODEL_FILENAMES = {
            left: "left.glb",
            right: "right.glb",
            default: "universal.glb"
          }, isWebXRAvailable = __webpack_require__2("./src/utils/index.js").device.isWebXRAvailable, GAMEPAD_ID_WEBXR = "windows-mixed-reality", GAMEPAD_ID_WEBVR = "Spatial Controller (Spatial Interaction Source) ", GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/, GAMEPAD_ID_PREFIX = isWebXRAvailable ? GAMEPAD_ID_WEBXR : GAMEPAD_ID_WEBVR, INPUT_MAPPING_WEBVR = {
            axes: {
              thumbstick: [0, 1],
              trackpad: [2, 3]
            },
            buttons: ["thumbstick", "trigger", "grip", "menu", "trackpad"],
            axisMeshNames: ["THUMBSTICK_X", "THUMBSTICK_Y", "TOUCHPAD_TOUCH_X", "TOUCHPAD_TOUCH_Y"],
            buttonMeshNames: {
              trigger: "SELECT",
              menu: "MENU",
              grip: "GRASP",
              thumbstick: "THUMBSTICK_PRESS",
              trackpad: "TOUCHPAD_PRESS"
            },
            pointingPoseMeshName: "POINTING_POSE"
          }, INPUT_MAPPING_WEBXR = {
            axes: {
              touchpad: [0, 1],
              thumbstick: [2, 3]
            },
            buttons: ["trigger", "squeeze", "touchpad", "thumbstick", "menu"],
            axisMeshNames: ["TOUCHPAD_TOUCH_X", "TOUCHPAD_TOUCH_X", "THUMBSTICK_X", "THUMBSTICK_Y"],
            buttonMeshNames: {
              trigger: "SELECT",
              menu: "MENU",
              squeeze: "GRASP",
              thumbstick: "THUMBSTICK_PRESS",
              touchpad: "TOUCHPAD_PRESS"
            },
            pointingPoseMeshName: "POINTING_POSE"
          }, INPUT_MAPPING = isWebXRAvailable ? INPUT_MAPPING_WEBXR : INPUT_MAPPING_WEBVR;
          module3.exports.Component = registerComponent("windows-motion-controls", {
            schema: {
              hand: {
                default: DEFAULT_HANDEDNESS
              },
              pair: {
                default: 0
              },
              model: {
                default: !0
              },
              hideDisconnected: {
                default: !0
              }
            },
            after: ["tracked-controls"],
            mapping: INPUT_MAPPING,
            bindMethods: function() {
              this.onModelError = this.onModelError.bind(this), this.onModelLoaded = this.onModelLoaded.bind(this), this.onControllersUpdate = this.onControllersUpdate.bind(this), this.checkIfControllerPresent = this.checkIfControllerPresent.bind(this), this.onAxisMoved = this.onAxisMoved.bind(this);
            },
            init: function() {
              var self2 = this, el = this.el;
              this.onButtonChanged = this.onButtonChanged.bind(this), this.onButtonDown = function(evt) {
                onButtonEvent(evt.detail.id, "down", self2);
              }, this.onButtonUp = function(evt) {
                onButtonEvent(evt.detail.id, "up", self2);
              }, this.onButtonTouchStart = function(evt) {
                onButtonEvent(evt.detail.id, "touchstart", self2);
              }, this.onButtonTouchEnd = function(evt) {
                onButtonEvent(evt.detail.id, "touchend", self2);
              }, this.onControllerConnected = function() {
                self2.setModelVisibility(!0);
              }, this.onControllerDisconnected = function() {
                self2.setModelVisibility(!1);
              }, this.controllerPresent = !1, this.lastControllerCheck = 0, this.previousButtonValues = {}, this.bindMethods(), this.loadedMeshInfo = {
                buttonMeshes: null,
                axisMeshes: null
              }, this.rayOrigin = {
                origin: new THREE.Vector3(),
                direction: new THREE.Vector3(0, 0, -1),
                createdFromMesh: !1
              }, el.addEventListener("controllerconnected", this.onControllerConnected), el.addEventListener("controllerdisconnected", this.onControllerDisconnected);
            },
            addEventListeners: function() {
              var el = this.el;
              el.addEventListener("buttonchanged", this.onButtonChanged), el.addEventListener("buttondown", this.onButtonDown), el.addEventListener("buttonup", this.onButtonUp), el.addEventListener("touchstart", this.onButtonTouchStart), el.addEventListener("touchend", this.onButtonTouchEnd), el.addEventListener("axismove", this.onAxisMoved), el.addEventListener("model-error", this.onModelError), el.addEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !0;
            },
            removeEventListeners: function() {
              var el = this.el;
              el.removeEventListener("buttonchanged", this.onButtonChanged), el.removeEventListener("buttondown", this.onButtonDown), el.removeEventListener("buttonup", this.onButtonUp), el.removeEventListener("touchstart", this.onButtonTouchStart), el.removeEventListener("touchend", this.onButtonTouchEnd), el.removeEventListener("axismove", this.onAxisMoved), el.removeEventListener("model-error", this.onModelError), el.removeEventListener("model-loaded", this.onModelLoaded), this.controllerEventsActive = !1;
            },
            checkIfControllerPresent: function() {
              checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {
                hand: this.data.hand,
                index: this.data.pair,
                iterateControllerProfiles: !0
              });
            },
            play: function() {
              this.checkIfControllerPresent(), this.addControllersUpdateListener();
            },
            pause: function() {
              this.removeEventListeners(), this.removeControllersUpdateListener();
            },
            updateControllerModel: function() {
              if (!this.data.model || this.rayOrigin.createdFromMesh) {
                this.modelReady();
                return;
              }
              var sourceUrl = this.createControllerModelUrl();
              this.loadModel(sourceUrl);
            },
            createControllerModelUrl: function(forceDefault) {
              var trackedControlsComponent = this.el.components["tracked-controls"], controller = trackedControlsComponent ? trackedControlsComponent.controller : null, device = "default", hand = this.data.hand, filename;
              if (controller && !window.hasNativeWebXRImplementation && (hand = controller.hand, !forceDefault)) {
                var match = controller.id.match(GAMEPAD_ID_PATTERN);
                device = match && match[0] || device;
              }
              return filename = MODEL_FILENAMES[hand] || MODEL_FILENAMES.default, MODEL_BASE_URL + device + "/" + filename;
            },
            injectTrackedControls: function() {
              var data = this.data;
              this.el.setAttribute("tracked-controls", {
                idPrefix: GAMEPAD_ID_PREFIX,
                controller: data.pair,
                hand: data.hand,
                armModel: !1
              }), this.updateControllerModel();
            },
            addControllersUpdateListener: function() {
              this.el.sceneEl.addEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            removeControllersUpdateListener: function() {
              this.el.sceneEl.removeEventListener("controllersupdated", this.onControllersUpdate, !1);
            },
            onControllersUpdate: function() {
              this.checkIfControllerPresent();
            },
            onModelError: function(evt) {
              var defaultUrl = this.createControllerModelUrl(!0);
              evt.detail.src !== defaultUrl ? (warn("Failed to load controller model for device, attempting to load default."), this.loadModel(defaultUrl)) : warn("Failed to load default controller model.");
            },
            loadModel: function(url) {
              this.el.setAttribute("gltf-model", "url(" + url + ")");
            },
            onModelLoaded: function(evt) {
              var rootNode = this.controllerModel = evt.detail.model, loadedMeshInfo = this.loadedMeshInfo, i, meshName, mesh, meshInfo;
              if (evt.target !== this.el)
                return;
              if (debug("Processing model"), loadedMeshInfo.buttonMeshes = {}, loadedMeshInfo.axisMeshes = {}, rootNode) {
                for (i = 0; i < this.mapping.buttons.length; i++) {
                  if (meshName = this.mapping.buttonMeshNames[this.mapping.buttons[i]], !meshName) {
                    debug("Skipping unknown button at index: " + i + " with mapped name: " + this.mapping.buttons[i]);
                    continue;
                  }
                  if (mesh = rootNode.getObjectByName(meshName), !mesh) {
                    warn("Missing button mesh with name: " + meshName);
                    continue;
                  }
                  meshInfo = {
                    index: i,
                    value: getImmediateChildByName(mesh, "VALUE"),
                    pressed: getImmediateChildByName(mesh, "PRESSED"),
                    unpressed: getImmediateChildByName(mesh, "UNPRESSED")
                  }, meshInfo.value && meshInfo.pressed && meshInfo.unpressed ? loadedMeshInfo.buttonMeshes[this.mapping.buttons[i]] = meshInfo : warn("Missing button submesh under mesh with name: " + meshName + "(VALUE: " + !!meshInfo.value + ", PRESSED: " + !!meshInfo.pressed + ", UNPRESSED:" + !!meshInfo.unpressed + ")");
                }
                for (i = 0; i < this.mapping.axisMeshNames.length; i++) {
                  if (meshName = this.mapping.axisMeshNames[i], !meshName) {
                    debug("Skipping unknown axis at index: " + i);
                    continue;
                  }
                  if (mesh = rootNode.getObjectByName(meshName), !mesh) {
                    warn("Missing axis mesh with name: " + meshName);
                    continue;
                  }
                  meshInfo = {
                    index: i,
                    value: getImmediateChildByName(mesh, "VALUE"),
                    min: getImmediateChildByName(mesh, "MIN"),
                    max: getImmediateChildByName(mesh, "MAX")
                  }, meshInfo.value && meshInfo.min && meshInfo.max ? loadedMeshInfo.axisMeshes[i] = meshInfo : warn("Missing axis submesh under mesh with name: " + meshName + "(VALUE: " + !!meshInfo.value + ", MIN: " + !!meshInfo.min + ", MAX:" + !!meshInfo.max + ")");
                }
                this.calculateRayOriginFromMesh(rootNode), this.setModelVisibility();
              }
              debug("Model load complete.");
              function getImmediateChildByName(object3d, value) {
                for (var i2 = 0, l = object3d.children.length; i2 < l; i2++) {
                  var obj = object3d.children[i2];
                  if (obj && obj.name === value)
                    return obj;
                }
              }
            },
            calculateRayOriginFromMesh: function() {
              var quaternion = new THREE.Quaternion();
              return function(rootNode) {
                var mesh;
                if (this.rayOrigin.origin.set(0, 0, 0), this.rayOrigin.direction.set(0, 0, -1), this.rayOrigin.createdFromMesh = !0, mesh = rootNode.getObjectByName(this.mapping.pointingPoseMeshName), mesh) {
                  var parent = rootNode.parent;
                  parent && (rootNode.parent = null, rootNode.updateMatrixWorld(!0), rootNode.parent = parent), mesh.getWorldPosition(this.rayOrigin.origin), mesh.getWorldQuaternion(quaternion), this.rayOrigin.direction.applyQuaternion(quaternion), parent && rootNode.updateMatrixWorld(!0);
                } else
                  debug("Mesh does not contain pointing origin data, defaulting to none.");
                this.modelReady();
              };
            }(),
            lerpAxisTransform: function() {
              var quaternion = new THREE.Quaternion();
              return function(axis, axisValue) {
                var axisMeshInfo = this.loadedMeshInfo.axisMeshes[axis];
                if (!!axisMeshInfo) {
                  var min = axisMeshInfo.min, max = axisMeshInfo.max, target = axisMeshInfo.value, lerpValue = axisValue * 0.5 + 0.5;
                  target.setRotationFromQuaternion(quaternion.copy(min.quaternion).slerp(max.quaternion, lerpValue)), target.position.lerpVectors(min.position, max.position, lerpValue);
                }
              };
            }(),
            lerpButtonTransform: function() {
              var quaternion = new THREE.Quaternion();
              return function(buttonName, buttonValue) {
                var buttonMeshInfo = this.loadedMeshInfo.buttonMeshes[buttonName];
                if (!!buttonMeshInfo) {
                  var min = buttonMeshInfo.unpressed, max = buttonMeshInfo.pressed, target = buttonMeshInfo.value;
                  target.setRotationFromQuaternion(quaternion.copy(min.quaternion).slerp(max.quaternion, buttonValue)), target.position.lerpVectors(min.position, max.position, buttonValue);
                }
              };
            }(),
            modelReady: function() {
              this.el.emit("controllermodelready", {
                name: "windows-motion-controls",
                model: this.data.model,
                rayOrigin: this.rayOrigin
              });
            },
            onButtonChanged: function(evt) {
              var buttonName = this.mapping.buttons[evt.detail.id];
              buttonName && (this.loadedMeshInfo && this.loadedMeshInfo.buttonMeshes && this.lerpButtonTransform(buttonName, evt.detail.state.value), this.el.emit(buttonName + "changed", evt.detail.state));
            },
            onAxisMoved: function(evt) {
              var numAxes = this.mapping.axisMeshNames.length;
              if (this.loadedMeshInfo && this.loadedMeshInfo.axisMeshes)
                for (var axis = 0; axis < numAxes; axis++)
                  this.lerpAxisTransform(axis, evt.detail.axis[axis] || 0);
              emitIfAxesChanged(this, this.mapping.axes, evt);
            },
            setModelVisibility: function(visible) {
              var model = this.el.getObject3D("mesh");
              !this.controllerPresent || (visible = visible !== void 0 ? visible : this.modelVisible, this.modelVisible = visible, !!model && (model.visible = visible));
            }
          });
        },
        "./src/constants/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          module3.exports = {
            AFRAME_CDN_ROOT: window.AFRAME_CDN_ROOT || "https://cdn.aframe.io/",
            AFRAME_INJECTED: "aframe-injected",
            DEFAULT_CAMERA_HEIGHT: 1.6,
            DEFAULT_HANDEDNESS: "right",
            keyboardevent: __webpack_require__2("./src/constants/keyboardevent.js")
          };
        },
        "./src/constants/keyboardevent.js": (module3) => {
          module3.exports = {
            KEYCODE_TO_CODE: {
              "38": "ArrowUp",
              "37": "ArrowLeft",
              "40": "ArrowDown",
              "39": "ArrowRight",
              "87": "KeyW",
              "65": "KeyA",
              "83": "KeyS",
              "68": "KeyD"
            }
          };
        },
        "./src/core/a-assets.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var ANode = __webpack_require__2("./src/core/a-node.js").ANode, debug = __webpack_require__2("./src/utils/debug.js"), THREE3 = __webpack_require__2("./src/lib/three.js"), fileLoader = new THREE3.FileLoader(), warn = debug("core:a-assets:warn");
          class AAssets extends ANode {
            constructor() {
              super();
              this.isAssets = !0, this.fileLoader = fileLoader, this.timeout = null;
            }
            doConnectedCallback() {
              var self2 = this, i, loaded = [], mediaEl, mediaEls, imgEl, imgEls, timeout, children;
              if (super.doConnectedCallback(), !this.parentNode.isScene)
                throw new Error("<a-assets> must be a child of a <a-scene>.");
              for (imgEls = this.querySelectorAll("img"), i = 0; i < imgEls.length; i++)
                imgEl = fixUpMediaElement(imgEls[i]), loaded.push(new Promise(function(resolve, reject) {
                  if (THREE3.Cache.add(imgEls[i].getAttribute("src"), imgEl), imgEl.complete) {
                    resolve();
                    return;
                  }
                  imgEl.onload = resolve, imgEl.onerror = reject;
                }));
              for (mediaEls = this.querySelectorAll("audio, video"), i = 0; i < mediaEls.length; i++)
                mediaEl = fixUpMediaElement(mediaEls[i]), !mediaEl.src && !mediaEl.srcObject && warn("Audio/video asset has neither `src` nor `srcObject` attributes."), loaded.push(mediaElementLoaded(mediaEl));
              children = this.getChildren(), children.forEach(function(child) {
                !child.isAssetItem || !child.hasAttribute("src") || loaded.push(new Promise(function(resolve, reject) {
                  if (child.hasLoaded)
                    return resolve();
                  child.addEventListener("loaded", resolve), child.addEventListener("error", reject);
                }));
              }), Promise.allSettled(loaded).then(function() {
                self2.timeout !== null && self2.load();
              }), timeout = parseInt(this.getAttribute("timeout"), 10) || 3e3, this.timeout = setTimeout(function() {
                self2.hasLoaded || (warn("Asset loading timed out in", timeout, "ms"), self2.timeout = null, self2.emit("timeout"), self2.load());
              }, timeout);
            }
            disconnectedCallback() {
              super.disconnectedCallback(), this.timeout && clearTimeout(this.timeout);
            }
            load() {
              super.load.call(this, null, function() {
                return !1;
              });
            }
          }
          customElements.define("a-assets", AAssets);
          class AAssetItem extends ANode {
            constructor() {
              super();
              this.data = null, this.isAssetItem = !0;
            }
            connectedCallback() {
              var self2 = this, src = this.getAttribute("src");
              fileLoader.setResponseType(this.getAttribute("response-type") || inferResponseType(src)), fileLoader.load(src, function(response) {
                self2.data = response, ANode.prototype.load.call(self2);
              }, function(xhr) {
                self2.emit("progress", {
                  loadedBytes: xhr.loaded,
                  totalBytes: xhr.total,
                  xhr
                });
              }, function(xhr) {
                self2.emit("error", {
                  xhr
                });
              });
            }
          }
          customElements.define("a-asset-item", AAssetItem);
          function mediaElementLoaded(el) {
            if (!(!el.hasAttribute("autoplay") && el.getAttribute("preload") !== "auto"))
              return new Promise(function(resolve, reject) {
                if (el.readyState === 4)
                  return resolve();
                if (el.error)
                  return reject();
                el.addEventListener("loadeddata", checkProgress, !1), el.addEventListener("progress", checkProgress, !1), el.addEventListener("error", reject, !1);
                function checkProgress() {
                  for (var secondsBuffered = 0, i = 0; i < el.buffered.length; i++)
                    secondsBuffered += el.buffered.end(i) - el.buffered.start(i);
                  secondsBuffered >= el.duration && (el.tagName === "VIDEO" && THREE3.Cache.add(el.getAttribute("src"), el), resolve());
                }
              });
          }
          function fixUpMediaElement(mediaEl) {
            var newMediaEl = setCrossOrigin(mediaEl);
            return newMediaEl.tagName && newMediaEl.tagName.toLowerCase() === "video" && (newMediaEl.setAttribute("playsinline", ""), newMediaEl.setAttribute("webkit-playsinline", "")), newMediaEl !== mediaEl && (mediaEl.parentNode.appendChild(newMediaEl), mediaEl.parentNode.removeChild(mediaEl)), newMediaEl;
          }
          function setCrossOrigin(mediaEl) {
            var newMediaEl, src;
            return mediaEl.hasAttribute("crossorigin") || (src = mediaEl.getAttribute("src"), src !== null && (src.indexOf("://") === -1 || extractDomain(src) === window.location.host)) ? mediaEl : (warn('Cross-origin element (e.g., <img>) was requested without `crossorigin` set. A-Frame will re-request the asset with `crossorigin` attribute set. Please set `crossorigin` on the element (e.g., <img crossorigin="anonymous">)', src), mediaEl.crossOrigin = "anonymous", newMediaEl = mediaEl.cloneNode(!0), newMediaEl);
          }
          function extractDomain(url) {
            var domain = url.indexOf("://") > -1 ? url.split("/")[2] : url.split("/")[0];
            return domain.substring(0, domain.indexOf(":"));
          }
          function inferResponseType(src) {
            var fileName = getFileNameFromURL(src), dotLastIndex = fileName.lastIndexOf(".");
            if (dotLastIndex >= 0) {
              var extension = fileName.slice(dotLastIndex, src.search(/\?|#|$/));
              if (extension === ".glb")
                return "arraybuffer";
            }
            return "text";
          }
          module3.exports.inferResponseType = inferResponseType;
          function getFileNameFromURL(url) {
            var parser = document.createElement("a");
            parser.href = url;
            var query = parser.search.replace(/^\?/, ""), filePath = url.replace(query, "").replace("?", "");
            return filePath.substring(filePath.lastIndexOf("/") + 1);
          }
          module3.exports.getFileNameFromURL = getFileNameFromURL;
        },
        "./src/core/a-cubemap.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var debug = __webpack_require__2("./src/utils/debug.js"), warn = debug("core:cubemap:warn");
          class ACubeMap extends HTMLElement {
            constructor(self2) {
              return self2 = super(self2), self2;
            }
            onReadyStateChange() {
              document.readyState === "complete" && this.doConnectedCallback();
            }
            connectedCallback() {
              if (document.readyState !== "complete") {
                document.addEventListener("readystatechange", this.onReadyStateChange.bind(this));
                return;
              }
              ACubeMap.prototype.doConnectedCallback.call(this);
            }
            doConnectedCallback() {
              this.srcs = this.validate();
            }
            validate() {
              var elements = this.querySelectorAll("[src]"), i, srcs = [];
              if (elements.length === 6) {
                for (i = 0; i < elements.length; i++)
                  elements[i].tagName === "IMG" ? srcs.push(elements[i]) : srcs.push(elements[i].getAttribute("src"));
                return srcs;
              }
              warn("<a-cubemap> did not contain exactly six elements each with a `src` attribute.");
            }
          }
          customElements.define("a-cubemap", ACubeMap);
        },
        "./src/core/a-entity.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var ANode = __webpack_require__2("./src/core/a-node.js").ANode, COMPONENTS = __webpack_require__2("./src/core/component.js").components, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js"), debug = utils.debug("core:a-entity:debug"), warn = utils.debug("core:a-entity:warn"), MULTIPLE_COMPONENT_DELIMITER = "__", OBJECT3D_COMPONENTS = ["position", "rotation", "scale", "visible"], ONCE = {
            once: !0
          };
          class AEntity extends ANode {
            constructor() {
              super();
              this.components = {}, this.initializingComponents = {}, this.componentsToUpdate = {}, this.isEntity = !0, this.isPlaying = !1, this.object3D = new THREE3.Group(), this.object3D.rotation.order = "YXZ", this.object3D.el = this, this.object3DMap = {}, this.parentEl = null, this.rotationObj = {}, this.states = [];
            }
            attributeChangedCallback(attr, oldVal, newVal) {
              var component = this.components[attr];
              if (super.attributeChangedCallback(), component && component.justInitialized && newVal === "") {
                delete component.justInitialized;
                return;
              }
              !component && newVal === null || this.setEntityAttribute(attr, oldVal, newVal);
            }
            doConnectedCallback() {
              var self2 = this, assetsEl, sceneEl;
              if (super.doConnectedCallback(), sceneEl = this.sceneEl, this.addToParent(), !this.isScene) {
                if (!sceneEl) {
                  this.load();
                  return;
                }
                if (assetsEl = sceneEl.querySelector("a-assets"), assetsEl && !assetsEl.hasLoaded) {
                  assetsEl.addEventListener("loaded", function() {
                    self2.load();
                  });
                  return;
                }
                this.load();
              }
            }
            disconnectedCallback() {
              var componentName;
              if (!!this.parentEl) {
                for (componentName in this.components)
                  this.removeComponent(componentName, !1);
                this.isScene || (this.removeFromParent(), super.disconnectedCallback(), this.object3D.el = null);
              }
            }
            getObject3D(type) {
              return this.object3DMap[type];
            }
            setObject3D(type, obj) {
              var oldObj, self2 = this;
              if (!(obj instanceof THREE3.Object3D))
                throw new Error("`Entity.setObject3D` was called with an object that was not an instance of THREE.Object3D.");
              oldObj = this.getObject3D(type), oldObj && this.object3D.remove(oldObj), obj.el = this, obj.children.length && obj.traverse(function(child) {
                child.el = self2;
              }), this.object3D.add(obj), this.object3DMap[type] = obj, this.emit("object3dset", {
                object: obj,
                type
              });
            }
            removeObject3D(type) {
              var obj = this.getObject3D(type);
              if (!obj) {
                warn("Tried to remove `Object3D` of type:", type, "which was not defined.");
                return;
              }
              this.object3D.remove(obj), delete this.object3DMap[type], this.emit("object3dremove", {
                type
              });
            }
            getOrCreateObject3D(type, Constructor) {
              var object3D = this.getObject3D(type);
              return !object3D && Constructor && (object3D = new Constructor(), this.setObject3D(type, object3D)), warn("`getOrCreateObject3D` has been deprecated. Use `setObject3D()` and `object3dset` event instead."), object3D;
            }
            add(el) {
              if (!el.object3D)
                throw new Error("Trying to add an element that doesn't have an `object3D`");
              this.object3D.add(el.object3D), this.emit("child-attached", {
                el
              });
            }
            addToParent() {
              var parentNode = this.parentEl = this.parentNode;
              !parentNode || !parentNode.add || this.attachedToParent || (parentNode.add(this), this.attachedToParent = !0);
            }
            removeFromParent() {
              var parentEl = this.parentEl;
              this.parentEl.remove(this), this.attachedToParent = !1, this.parentEl = null, parentEl.emit("child-detached", {
                el: this
              });
            }
            load() {
              var self2 = this;
              this.hasLoaded || !this.parentEl || super.load.call(this, function() {
                !self2.parentEl || (self2.updateComponents(), (self2.isScene || self2.parentEl.isPlaying) && self2.play());
              });
            }
            remove(el) {
              el ? this.object3D.remove(el.object3D) : this.parentNode.removeChild(this);
            }
            getChildEntities() {
              for (var children = this.children, childEntities = [], i = 0; i < children.length; i++) {
                var child = children[i];
                child instanceof AEntity && childEntities.push(child);
              }
              return childEntities;
            }
            initComponent(attrName, data, isDependency) {
              var component, componentId, componentInfo, componentName, isComponentDefined;
              componentInfo = utils.split(attrName, MULTIPLE_COMPONENT_DELIMITER), componentName = componentInfo[0], componentId = componentInfo.length > 2 ? componentInfo.slice(1).join("__") : componentInfo[1], !!COMPONENTS[componentName] && (isComponentDefined = checkComponentDefined(this, attrName) || data !== void 0, !(!isComponentDefined && !isDependency) && (attrName in this.components || (this.initComponentDependencies(componentName), component = new COMPONENTS[componentName].Component(this, data, componentId), this.isPlaying && component.play(), this.hasAttribute(attrName) || (component.justInitialized = !0, window.HTMLElement.prototype.setAttribute.call(this, attrName, "")), debug("Component initialized: %s", attrName))));
            }
            initComponentDependencies(name) {
              var self2 = this, component = COMPONENTS[name], dependencies, i;
              if (!!component && (dependencies = COMPONENTS[name].dependencies, !!dependencies))
                for (i = 0; i < dependencies.length; i++)
                  self2.initComponent(dependencies[i], window.HTMLElement.prototype.getAttribute.call(self2, dependencies[i]) || void 0, !0);
            }
            removeComponent(name, destroy) {
              var component;
              if (component = this.components[name], !!component) {
                if (!component.initialized) {
                  this.addEventListener("componentinitialized", function tryRemoveLater(evt) {
                    evt.detail.name === name && (this.removeComponent(name, destroy), this.removeEventListener("componentinitialized", tryRemoveLater));
                  });
                  return;
                }
                component.pause(), component.remove(), destroy && (component.destroy(), delete this.components[name], this.hasAttribute(name) && window.HTMLElement.prototype.removeAttribute.call(this, name)), this.emit("componentremoved", component.evtDetail, !1);
              }
            }
            updateComponents() {
              var data, extraComponents, i, name, componentsToUpdate = this.componentsToUpdate;
              if (!(!this.hasLoaded && !this.isLoading)) {
                for (i = 0; i < this.mixinEls.length; i++)
                  for (name in this.mixinEls[i].componentCache)
                    isComponent(name) && (componentsToUpdate[name] = !0);
                if (this.getExtraComponents) {
                  extraComponents = this.getExtraComponents();
                  for (name in extraComponents)
                    isComponent(name) && (componentsToUpdate[name] = !0);
                }
                for (i = 0; i < this.attributes.length; ++i)
                  name = this.attributes[i].name, OBJECT3D_COMPONENTS.indexOf(name) === -1 && isComponent(name) && (componentsToUpdate[name] = !0);
                for (i = 0; i < OBJECT3D_COMPONENTS.length; i++)
                  name = OBJECT3D_COMPONENTS[i], !!this.hasAttribute(name) && this.updateComponent(name, this.getDOMAttribute(name));
                for (name in componentsToUpdate)
                  data = mergeComponentData(this.getDOMAttribute(name), extraComponents && extraComponents[name]), this.updateComponent(name, data), delete componentsToUpdate[name];
              }
            }
            updateComponent(attr, attrValue, clobber) {
              var component = this.components[attr];
              if (component) {
                if (attrValue === null && !checkComponentDefined(this, attr)) {
                  this.removeComponent(attr, !0);
                  return;
                }
                component.updateProperties(attrValue, clobber);
                return;
              }
              this.initComponent(attr, attrValue, !1);
            }
            removeAttribute(attr, propertyName) {
              var component = this.components[attr];
              if (component && propertyName === void 0 && this.removeComponent(attr, !0), component && propertyName !== void 0) {
                component.resetProperty(propertyName);
                return;
              }
              attr === "mixin" && this.mixinUpdate(""), window.HTMLElement.prototype.removeAttribute.call(this, attr);
            }
            play() {
              var entities, i, key;
              if (!(this.isPlaying || !this.hasLoaded && !this.isLoading)) {
                this.isPlaying = !0;
                for (key in this.components)
                  this.components[key].play();
                for (entities = this.getChildEntities(), i = 0; i < entities.length; i++)
                  entities[i].play();
                this.emit("play");
              }
            }
            pause() {
              var entities, i, key;
              if (!!this.isPlaying) {
                this.isPlaying = !1;
                for (key in this.components)
                  this.components[key].pause();
                for (entities = this.getChildEntities(), i = 0; i < entities.length; i++)
                  entities[i].pause();
                this.emit("pause");
              }
            }
            setEntityAttribute(attr, oldVal, newVal) {
              if (COMPONENTS[attr] || this.components[attr]) {
                this.updateComponent(attr, newVal);
                return;
              }
              if (attr === "mixin") {
                if (newVal === this.computedMixinStr)
                  return;
                this.mixinUpdate(newVal, oldVal);
              }
            }
            mixinUpdate(newMixins, oldMixins, deferred) {
              var componentsUpdated = AEntity.componentsUpdated, component, mixinEl, mixinIds, i, self2 = this;
              if (deferred || (oldMixins = oldMixins || this.getAttribute("mixin")), !this.hasLoaded) {
                this.addEventListener("loaded-private", function() {
                  self2.mixinUpdate(newMixins, oldMixins, !0);
                }, ONCE);
                return;
              }
              for (mixinIds = this.updateMixins(newMixins, oldMixins), componentsUpdated.length = 0, i = 0; i < this.mixinEls.length; i++)
                for (component in this.mixinEls[i].componentCache)
                  componentsUpdated.indexOf(component) === -1 && (this.components[component] ? this.components[component].handleMixinUpdate() : this.initComponent(component, null), componentsUpdated.push(component));
              for (i = 0; i < mixinIds.oldMixinIds.length; i++)
                if (mixinEl = document.getElementById(mixinIds.oldMixinIds[i]), !!mixinEl)
                  for (component in mixinEl.componentCache)
                    componentsUpdated.indexOf(component) === -1 && this.components[component] && (this.getDOMAttribute(component) ? this.components[component].handleMixinUpdate() : this.removeComponent(component, !0));
            }
            setAttribute(attrName, arg1, arg2) {
              var singlePropUpdate = AEntity.singlePropUpdate, newAttrValue, clobber, componentName, delimiterIndex, isDebugMode, key;
              if (delimiterIndex = attrName.indexOf(MULTIPLE_COMPONENT_DELIMITER), componentName = delimiterIndex > 0 ? attrName.substring(0, delimiterIndex) : attrName, !COMPONENTS[componentName]) {
                attrName === "mixin" && this.mixinUpdate(arg1), super.setAttribute.call(this, attrName, arg1);
                return;
              }
              if (!this.components[attrName] && this.hasAttribute(attrName) && this.updateComponent(attrName, window.HTMLElement.prototype.getAttribute.call(this, attrName)), typeof arg2 != "undefined" && typeof arg1 == "string" && arg1.length > 0 && typeof utils.styleParser.parse(arg1) == "string") {
                for (key in singlePropUpdate)
                  delete singlePropUpdate[key];
                newAttrValue = singlePropUpdate, newAttrValue[arg1] = arg2, clobber = !1;
              } else
                newAttrValue = arg1, clobber = arg2 === !0;
              this.updateComponent(attrName, newAttrValue, clobber), isDebugMode = this.sceneEl && this.sceneEl.getAttribute("debug"), isDebugMode && this.components[attrName].flushToDOM();
            }
            flushToDOM(recursive) {
              var components = this.components, child, children = this.children, i, key;
              for (key in components)
                components[key].flushToDOM();
              if (!!recursive)
                for (i = 0; i < children.length; ++i)
                  child = children[i], !!child.flushToDOM && child.flushToDOM(recursive);
            }
            getAttribute(attr) {
              var component;
              return attr === "position" ? this.object3D.position : attr === "rotation" ? getRotation(this) : attr === "scale" ? this.object3D.scale : attr === "visible" ? this.object3D.visible : (component = this.components[attr], component ? component.data : window.HTMLElement.prototype.getAttribute.call(this, attr));
            }
            getDOMAttribute(attr) {
              var component = this.components[attr];
              return component ? component.attrValue : window.HTMLElement.prototype.getAttribute.call(this, attr);
            }
            addState(state) {
              this.is(state) || (this.states.push(state), this.emit("stateadded", state));
            }
            removeState(state) {
              var stateIndex = this.states.indexOf(state);
              stateIndex !== -1 && (this.states.splice(stateIndex, 1), this.emit("stateremoved", state));
            }
            is(state) {
              return this.states.indexOf(state) !== -1;
            }
            inspect() {
              this.sceneEl.components.inspector.openInspector(this);
            }
            destroy() {
              var key;
              if (this.parentNode) {
                warn("Entity can only be destroyed if detached from scenegraph.");
                return;
              }
              for (key in this.components)
                this.components[key].destroy();
            }
          }
          function checkComponentDefined(el, name) {
            return el.components[name] && el.components[name].attrValue ? !0 : isComponentMixedIn(name, el.mixinEls);
          }
          function isComponentMixedIn(name, mixinEls) {
            var i, inMixin = !1;
            for (i = 0; i < mixinEls.length && (inMixin = mixinEls[i].hasAttribute(name), !inMixin); ++i)
              ;
            return inMixin;
          }
          function mergeComponentData(attrValue, extraData) {
            return extraData ? extraData.constructor === Object ? utils.extend(extraData, utils.styleParser.parse(attrValue || {})) : attrValue || extraData : attrValue;
          }
          function isComponent(componentName) {
            return componentName.indexOf(MULTIPLE_COMPONENT_DELIMITER) !== -1 && (componentName = utils.split(componentName, MULTIPLE_COMPONENT_DELIMITER)[0]), !!COMPONENTS[componentName];
          }
          function getRotation(entityEl) {
            var radToDeg = THREE3.MathUtils.radToDeg, rotation = entityEl.object3D.rotation, rotationObj = entityEl.rotationObj;
            return rotationObj.x = radToDeg(rotation.x), rotationObj.y = radToDeg(rotation.y), rotationObj.z = radToDeg(rotation.z), rotationObj;
          }
          AEntity.componentsUpdated = [], AEntity.singlePropUpdate = {}, customElements.define("a-entity", AEntity), module3.exports.AEntity = AEntity;
        },
        "./src/core/a-mixin.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var ANode = __webpack_require__2("./src/core/a-node.js").ANode, components = __webpack_require__2("./src/core/component.js").components, utils = __webpack_require__2("./src/utils/index.js"), styleParser = utils.styleParser, MULTIPLE_COMPONENT_DELIMITER = "__";
          class AMixin extends ANode {
            constructor() {
              super();
              this.componentCache = {}, this.rawAttributeCache = {}, this.isMixin = !0;
            }
            doConnectedCallback() {
              super.doConnectedCallback(), this.sceneEl = this.closestScene(), this.id = this.getAttribute("id"), this.cacheAttributes(), this.updateEntities(), this.load();
            }
            attributeChangedCallback(attr, oldVal, newVal) {
              super.attributeChangedCallback(), this.cacheAttribute(attr, newVal), this.updateEntities();
            }
            setAttribute(attr, value) {
              window.HTMLElement.prototype.setAttribute.call(this, attr, value), this.cacheAttribute(attr, value);
            }
            cacheAttribute(attr, value) {
              var component, componentName;
              componentName = utils.split(attr, MULTIPLE_COMPONENT_DELIMITER)[0], component = components[componentName], value === void 0 && (value = window.HTMLElement.prototype.getAttribute.call(this, attr)), this.rawAttributeCache[attr] = value, !!component && (this.componentCache[attr] = this.parseComponentAttrValue(component, value));
            }
            parseComponentAttrValue(component, attrValue) {
              var parsedValue;
              return typeof attrValue != "string" ? attrValue : (component.isSingleProperty ? (parsedValue = component.schema.parse(attrValue), typeof parsedValue == "string" && (parsedValue = attrValue)) : parsedValue = styleParser.parse(attrValue), parsedValue);
            }
            getAttribute(attr) {
              return this.componentCache[attr] || window.HTMLElement.prototype.getAttribute.call(this, attr);
            }
            cacheAttributes() {
              var attributes = this.attributes, attrName, i;
              for (i = 0; i < attributes.length; i++)
                attrName = attributes[i].name, this.cacheAttribute(attrName);
            }
            updateEntities() {
              var entity, entities, i;
              if (!!this.sceneEl)
                for (entities = this.sceneEl.querySelectorAll("[mixin~=" + this.id + "]"), i = 0; i < entities.length; i++)
                  entity = entities[i], !(!entity.hasLoaded || entity.isMixin) && entity.mixinUpdate(this.id);
            }
          }
          customElements.define("a-mixin", AMixin);
        },
        "./src/core/a-node.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var utils = __webpack_require__2("./src/utils/index.js"), readyState = __webpack_require__2("./src/core/readyState.js"), warn = utils.debug("core:a-node:warn"), knownTags = {
            "a-scene": !0,
            "a-assets": !0,
            "a-assets-items": !0,
            "a-cubemap": !0,
            "a-mixin": !0,
            "a-node": !0,
            "a-entity": !0
          };
          function isNode(node) {
            return node.tagName.toLowerCase() in knownTags || node.isNode;
          }
          class ANode extends HTMLElement {
            constructor() {
              super();
              this.computedMixinStr = "", this.hasLoaded = !1, this.isNode = !0, this.mixinEls = [];
            }
            connectedCallback() {
              if (!readyState.canInitializeElements) {
                document.addEventListener("aframeready", this.connectedCallback.bind(this));
                return;
              }
              this.doConnectedCallback();
            }
            doConnectedCallback() {
              var mixins;
              this.sceneEl = this.closestScene(), this.sceneEl || warn("You are attempting to attach <" + this.tagName + "> outside of an A-Frame scene. Append this element to `<a-scene>` instead."), this.hasLoaded = !1, this.emit("nodeready", void 0, !1), this.isMixin || (mixins = this.getAttribute("mixin"), mixins && this.updateMixins(mixins));
            }
            attributeChangedCallback(attr, oldVal, newVal) {
              newVal !== this.computedMixinStr && attr === "mixin" && !this.isMixin && this.updateMixins(newVal, oldVal);
            }
            closestScene() {
              for (var element = this; element && !element.isScene; )
                element = element.parentElement;
              return element;
            }
            closest(selector) {
              for (var matches = this.matches || this.mozMatchesSelector || this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector, element = this; element && !matches.call(element, selector); )
                element = element.parentElement;
              return element;
            }
            disconnectedCallback() {
              this.hasLoaded = !1;
            }
            load(cb, childFilter) {
              var children, childrenLoaded, self2 = this;
              this.hasLoaded || (childFilter = childFilter || isNode, children = this.getChildren(), childrenLoaded = children.filter(childFilter).map(function(child) {
                return new Promise(function(resolve, reject) {
                  if (child.hasLoaded)
                    return resolve();
                  child.addEventListener("loaded", resolve), child.addEventListener("error", reject);
                });
              }), Promise.allSettled(childrenLoaded).then(function(results) {
                results.forEach(function(result) {
                  result.status === "rejected" && warn("Rendering scene with errors on node: ", result.reason.target);
                }), self2.isLoading = !0, self2.setupMutationObserver(), cb && cb(), self2.isLoading = !1, self2.hasLoaded = !0, self2.emit("loaded-private", void 0, !1), self2.emit("loaded", void 0, !1);
              }));
            }
            setupMutationObserver() {
              var self2 = this, observerConfig = {
                attributes: !0,
                attributeOldValue: !0
              }, observer = new MutationObserver(function(mutationList) {
                var i;
                for (i = 0; i < mutationList.length; i++)
                  if (mutationList[i].type === "attributes") {
                    var attributeName = mutationList[i].attributeName, newValue = window.HTMLElement.prototype.getAttribute.call(self2, attributeName), oldValue = mutationList[i].oldValue;
                    self2.attributeChangedCallback(attributeName, oldValue, newValue);
                  }
              });
              observer.observe(this, observerConfig);
            }
            getChildren() {
              return Array.prototype.slice.call(this.children, 0);
            }
            updateMixins(newMixins, oldMixins) {
              var newMixinIdArray = ANode.newMixinIdArray, oldMixinIdArray = ANode.oldMixinIdArray, mixinIds = ANode.mixinIds, i, newMixinIds, oldMixinIds;
              for (newMixinIdArray.length = 0, oldMixinIdArray.length = 0, newMixinIds = newMixins ? utils.split(newMixins.trim(), /\s+/) : newMixinIdArray, oldMixinIds = oldMixins ? utils.split(oldMixins.trim(), /\s+/) : oldMixinIdArray, mixinIds.newMixinIds = newMixinIds, mixinIds.oldMixinIds = oldMixinIds, i = 0; i < oldMixinIds.length; i++)
                newMixinIds.indexOf(oldMixinIds[i]) === -1 && this.unregisterMixin(oldMixinIds[i]);
              for (this.computedMixinStr = "", this.mixinEls.length = 0, i = 0; i < newMixinIds.length; i++)
                this.registerMixin(newMixinIds[i]);
              return this.computedMixinStr && (this.computedMixinStr = this.computedMixinStr.trim(), window.HTMLElement.prototype.setAttribute.call(this, "mixin", this.computedMixinStr)), newMixinIds.length === 0 && window.HTMLElement.prototype.removeAttribute.call(this, "mixin"), mixinIds;
            }
            registerMixin(mixinId) {
              var compositedMixinIds, i, mixin, mixinEl = document.getElementById(mixinId);
              if (!mixinEl) {
                warn("No mixin was found with id `%s`", mixinId);
                return;
              }
              if (mixin = mixinEl.getAttribute("mixin"), mixin)
                for (compositedMixinIds = utils.split(mixin.trim(), /\s+/), i = 0; i < compositedMixinIds.length; i++)
                  this.registerMixin(compositedMixinIds[i]);
              this.computedMixinStr = this.computedMixinStr + " " + mixinEl.id, this.mixinEls.push(mixinEl);
            }
            setAttribute(attr, newValue) {
              attr === "mixin" && this.updateMixins(newValue), window.HTMLElement.prototype.setAttribute.call(this, attr, newValue);
            }
            unregisterMixin(mixinId) {
              var i, mixinEls = this.mixinEls, mixinEl;
              for (i = 0; i < mixinEls.length; ++i)
                if (mixinEl = mixinEls[i], mixinId === mixinEl.id) {
                  mixinEls.splice(i, 1);
                  break;
                }
            }
            emit(name, detail, bubbles, extraData) {
              var data = ANode.evtData;
              bubbles === void 0 && (bubbles = !0), data.bubbles = !!bubbles, data.detail = detail, extraData && (data = utils.extend({}, extraData, data)), this.dispatchEvent(new CustomEvent(name, data));
            }
          }
          ANode.evtData = {}, ANode.newMixinIdArray = [], ANode.oldMixinIdArray = [], ANode.mixinIds = {}, customElements.define("a-node", ANode), module3.exports.ANode = ANode, module3.exports.knownTags = knownTags;
        },
        "./src/core/component.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var schema = __webpack_require__2("./src/core/schema.js"), scenes = __webpack_require__2("./src/core/scene/scenes.js"), systems = __webpack_require__2("./src/core/system.js"), utils = __webpack_require__2("./src/utils/index.js"), components = module3.exports.components = {}, parseProperty = schema.parseProperty, processSchema = schema.process, isSingleProp = schema.isSingleProperty, stringifyProperties = schema.stringifyProperties, stringifyProperty = schema.stringifyProperty, styleParser = utils.styleParser, warn = utils.debug("core:component:warn"), aframeScript = document.currentScript, upperCaseRegExp = new RegExp("[A-Z]+"), objectPools = {}, emptyInitialOldData = Object.freeze({}), encounteredUnknownProperties = [], attrValueProxyHandler = {
            get: function(target, prop) {
              return target.getComputedPropertyValue(prop);
            },
            set: function(target, prop, newValue) {
              return prop in target.schema ? target.recomputeProperty(prop, newValue) : newValue !== void 0 && target.handleUnknownProperty(prop, newValue), !0;
            }
          }, Component = module3.exports.Component = function(el, attrValue, id) {
            var self2 = this;
            if (this.sceneOnly && !el.isScene)
              throw new Error("Component `" + this.name + "` can only be applied to <a-scene>");
            if (id && !this.multiple)
              throw new Error("Trying to initialize multiple components of type `" + this.name + "`. There can only be one component of this type per entity.");
            this.el = el, this.id = id, this.attrName = this.name + (id ? "__" + id : ""), this.evtDetail = {
              id: this.id,
              name: this.name
            }, this.initialized = !1, this.el.components[this.attrName] = this, this.objectPool = objectPools[this.name];
            var events = this.events;
            this.events = {}, eventsBind(this, events), this.attrValue = void 0, this.isObjectBased ? (this.data = this.objectPool.use(), utils.objectPool.removeUnusedKeys(this.data, this.schema), this.oldData = this.objectPool.use(), utils.objectPool.removeUnusedKeys(this.oldData, this.schema), this.attrValueProxy = new Proxy(this, attrValueProxyHandler)) : (this.data = void 0, this.oldData = void 0, this.attrValueProxy = void 0), this.deferUnknownPropertyWarnings = !!this.updateSchema, this.silenceUnknownPropertyWarnings = !1, this.throttledEmitComponentChanged = utils.throttleLeadingAndTrailing(function() {
              el.emit("componentchanged", self2.evtDetail, !1);
            }, 200), this.updateProperties(attrValue, !0);
          };
          Component.prototype = {
            schema: {},
            init: function() {
            },
            events: {},
            update: function(prevData) {
            },
            updateSchema: void 0,
            tick: void 0,
            tock: void 0,
            play: function() {
            },
            pause: function() {
            },
            remove: function() {
            },
            stringify: function(data) {
              var schema2 = this.schema;
              return typeof data == "string" ? data : this.isSingleProperty ? stringifyProperty(data, schema2) : (data = stringifyProperties(data, schema2), styleParser.stringify(data));
            },
            flushToDOM: function(isDefault) {
              var attrValue = isDefault ? this.data : this.attrValue;
              attrValue != null && window.HTMLElement.prototype.setAttribute.call(this.el, this.attrName, this.stringify(attrValue));
            },
            updateProperties: function(attrValue, clobber) {
              var el = this.el;
              this.updateData(attrValue, clobber), !(!el.hasLoaded && !el.isLoading) && (this.initialized ? this.callUpdateHandler() : this.initComponent());
            },
            initComponent: function() {
              var el = this.el, initialOldData;
              el.initializingComponents[this.name] || (el.initializingComponents[this.name] = !0, this.init(), this.initialized = !0, delete el.initializingComponents[this.name], initialOldData = this.isObjectBased ? emptyInitialOldData : void 0, this.dataChanged = !1, this.storeOldData(), this.update(initialOldData), el.isPlaying && this.play(), el.emit("componentinitialized", this.evtDetail, !1));
            },
            updateData: function(attrValue, clobber) {
              if (this.isSingleProperty) {
                this.recomputeProperty(void 0, attrValue);
                return;
              }
              clobber ? (utils.objectPool.clearObject(this.attrValue), this.recomputeData(attrValue), this.schemaChangeRequired = !!this.updateSchema) : typeof attrValue == "string" ? styleParser.parse(attrValue, this.attrValueProxy) : utils.extend(this.attrValueProxy, attrValue), this.updateSchemaIfNeeded(attrValue);
            },
            updateSchemaIfNeeded: function(attrValue) {
              if (!this.schemaChangeRequired || !this.updateSchema) {
                for (var i = 0; i < encounteredUnknownProperties.length; i++)
                  warn("Unknown property `" + encounteredUnknownProperties[i] + "` for component `" + this.name + "`.");
                encounteredUnknownProperties.length = 0;
                return;
              }
              encounteredUnknownProperties.length = 0, this.updateSchema(this.data), utils.objectPool.removeUnusedKeys(this.data, this.schema), this.silenceUnknownPropertyWarnings = !0, this.recomputeData(attrValue), this.silenceUnknownPropertyWarnings = !1, this.schemaChangeRequired = !1;
            },
            callUpdateHandler: function() {
              if (!(!this.isPositionRotationScale && !this.dataChanged)) {
                this.dataChanged = !1;
                var oldData = this.oldData;
                this.oldDataInUse = !0, this.update(oldData), oldData !== this.oldData && this.objectPool.recycle(oldData), this.oldDataInUse = !1, this.storeOldData(), this.throttledEmitComponentChanged();
              }
            },
            handleMixinUpdate: function() {
              this.recomputeData(), this.updateSchemaIfNeeded(), this.callUpdateHandler();
            },
            resetProperty: function(propertyName) {
              !this.isSingleProperty && !(propertyName in this.schema) || (propertyName ? this.attrValue[propertyName] = void 0 : (this.isObjectBased && this.objectPool.recycle(this.attrValue), this.attrValue = void 0), this.recomputeProperty(propertyName, void 0), this.updateSchemaIfNeeded(), this.callUpdateHandler());
            },
            extendSchema: function(schemaAddon) {
              var extendedSchema;
              extendedSchema = utils.extend({}, components[this.name].schema), utils.extend(extendedSchema, schemaAddon), this.schema = processSchema(extendedSchema), this.el.emit("schemachanged", this.evtDetail);
            },
            getComputedPropertyValue: function(key) {
              var mixinEls = this.el.mixinEls, attrValue = this.attrValue && key ? this.attrValue[key] : this.attrValue;
              if (attrValue !== void 0)
                return attrValue;
              for (var i = mixinEls.length - 1; i >= 0; i--) {
                var mixinData = mixinEls[i].getAttribute(this.attrName);
                if (!(mixinData === null || key && !(key in mixinData)))
                  return key ? mixinData[key] : mixinData;
              }
              var schemaDefault = key ? this.schema[key].default : this.schema.default;
              return schemaDefault;
            },
            recomputeProperty: function(key, newValue) {
              var propertySchema = key ? this.schema[key] : this.schema;
              if (newValue != null) {
                this.attrValue === void 0 && this.isObjectBased && (this.attrValue = this.objectPool.use());
                var newAttrValue = key ? this.attrValue[key] : this.attrValue;
                newAttrValue = propertySchema.isCacheable ? parseProperty(newValue, propertySchema, newAttrValue) : newValue, typeof newAttrValue == "string" && (newAttrValue = newValue === "" ? void 0 : newValue), key ? this.attrValue[key] = newAttrValue : this.attrValue = newAttrValue;
              }
              this.oldDataInUse && (this.oldData = this.objectPool.use(), utils.objectPool.removeUnusedKeys(this.oldData, this.schema), this.storeOldData(), this.oldDataInUse = !1);
              var oldComputedValue = key ? this.oldData[key] : this.oldData, targetValue = key ? this.data[key] : this.data, newComputedValue = parseProperty(this.getComputedPropertyValue(key), propertySchema, targetValue);
              return propertySchema.type === "array" && !key && (newComputedValue = utils.clone(newComputedValue)), propertySchema.equals(newComputedValue, oldComputedValue) || (this.dataChanged = !0, propertySchema.schemaChange && (this.schemaChangeRequired = !0)), key ? this.data[key] = newComputedValue : this.data = newComputedValue, newComputedValue;
            },
            handleUnknownProperty: function(key, newValue) {
              this.attrValue === void 0 && (this.attrValue = this.objectPool.use()), this.attrValue[key] = newValue, this.silenceUnknownPropertyWarnings || (this.deferUnknownPropertyWarnings ? encounteredUnknownProperties.push(key) : this.silenceUnknownPropertyWarnings || warn("Unknown property `" + key + "` for component `" + this.name + "`."));
            },
            storeOldData: function() {
              if (!this.isObjectBased) {
                this.oldData = this.data;
                return;
              }
              if (this.isSingleProperty) {
                this.oldData = parseProperty(this.data, this.schema, this.oldData);
                return;
              }
              var key;
              for (key in this.schema)
                this.data[key] !== void 0 && (this.data[key] && typeof this.data[key] == "object" ? this.oldData[key] = parseProperty(this.data[key], this.schema[key], this.oldData[key]) : this.oldData[key] = this.data[key]);
            },
            recomputeData: function(attrValue) {
              var key;
              if (this.isSingleProperty) {
                this.recomputeProperty(void 0, attrValue);
                return;
              }
              if (attrValue && typeof attrValue == "object")
                for (key in this.schema)
                  this.attrValueProxy[key] = attrValue[key];
              else
                for (key in this.schema)
                  this.attrValueProxy[key] = void 0;
              typeof attrValue == "string" && styleParser.parse(attrValue, this.attrValueProxy);
              for (key in this.attrValue)
                this.attrValue[key] !== void 0 && encounteredUnknownProperties.indexOf(key) !== -1 && (key in this.schema || warn("Unknown property `" + key + "` for component `" + this.name + "`."));
            },
            eventsAttach: function() {
              var eventName;
              this.eventsDetach();
              for (eventName in this.events)
                this.el.addEventListener(eventName, this.events[eventName]);
            },
            eventsDetach: function() {
              var eventName;
              for (eventName in this.events)
                this.el.removeEventListener(eventName, this.events[eventName]);
            },
            destroy: function() {
              this.objectPool.recycle(this.attrValue), this.objectPool.recycle(this.data), this.objectPool.recycle(this.oldData), this.attrValue = this.data = this.oldData = this.attrValueProxy = void 0;
            }
          };
          function eventsBind(component, events) {
            var eventName;
            for (eventName in events)
              component.events[eventName] = events[eventName].bind(component);
          }
          if (window.debug)
            var registrationOrderWarnings = module3.exports.registrationOrderWarnings = {};
          module3.exports.registerComponent = function(name, definition) {
            var NewComponent, proto = {}, schema2, schemaIsSingleProp;
            if (document.currentScript && document.currentScript !== aframeScript && scenes.forEach(function(sceneEl) {
              sceneEl.hasLoaded || document.currentScript.compareDocumentPosition(sceneEl) !== Node.DOCUMENT_POSITION_FOLLOWING && (warn("The component `" + name + "` was registered in a <script> tag after the scene. Component <script> tags in an HTML file should be declared *before* the scene such that the component is available to entities during scene initialization."), window.debug && (registrationOrderWarnings[name] = !0));
            }), upperCaseRegExp.test(name) === !0 && warn("The component name `" + name + "` contains uppercase characters, but HTML will ignore the capitalization of attribute names. Change the name to be lowercase: `" + name.toLowerCase() + "`"), name.indexOf("__") !== -1)
              throw new Error("The component name `" + name + "` is not allowed. The sequence __ (double underscore) is reserved to specify an id for multiple components of the same type");
            if (Object.keys(definition).forEach(function(key) {
              proto[key] = {
                value: definition[key],
                writable: !0
              };
            }), components[name])
              throw new Error("The component `" + name + "` has been already registered. Check that you are not loading two versions of the same component or two different components of the same name.");
            NewComponent = function(el, attr, id) {
              Component.call(this, el, attr, id);
            }, NewComponent.prototype = Object.create(Component.prototype, proto), NewComponent.prototype.name = name, NewComponent.prototype.isPositionRotationScale = name === "position" || name === "rotation" || name === "scale", NewComponent.prototype.constructor = NewComponent, NewComponent.prototype.system = systems && systems.systems[name], NewComponent.prototype.play = wrapPlay(NewComponent.prototype.play), NewComponent.prototype.pause = wrapPause(NewComponent.prototype.pause), schema2 = utils.extend(processSchema(NewComponent.prototype.schema, NewComponent.prototype.name)), NewComponent.prototype.isSingleProperty = schemaIsSingleProp = isSingleProp(NewComponent.prototype.schema), NewComponent.prototype.isObjectBased = !schemaIsSingleProp || schemaIsSingleProp && (isObject(schema2.default) || isObject(parseProperty(void 0, schema2))), objectPools[name] = utils.objectPool.createPool(), components[name] = {
              Component: NewComponent,
              dependencies: NewComponent.prototype.dependencies,
              before: NewComponent.prototype.before,
              after: NewComponent.prototype.after,
              isSingleProperty: NewComponent.prototype.isSingleProperty,
              isObjectBased: NewComponent.prototype.isObjectBased,
              multiple: NewComponent.prototype.multiple,
              sceneOnly: NewComponent.prototype.sceneOnly,
              name,
              schema: schema2,
              stringify: NewComponent.prototype.stringify
            };
            for (var i = 0; i < scenes.length; i++)
              scenes[i].emit("componentregistered", {
                name
              }, !1);
            return NewComponent;
          };
          function hasBehavior(component) {
            return component.tick || component.tock;
          }
          function wrapPause(pauseMethod) {
            return function() {
              var sceneEl = this.el.sceneEl;
              !this.isPlaying || (pauseMethod.call(this), this.isPlaying = !1, this.eventsDetach(), !!hasBehavior(this) && sceneEl.removeBehavior(this));
            };
          }
          function wrapPlay(playMethod) {
            return function() {
              var sceneEl = this.el.sceneEl, shouldPlay = this.el.isPlaying && !this.isPlaying;
              !this.initialized || !shouldPlay || (playMethod.call(this), this.isPlaying = !0, this.eventsAttach(), !!hasBehavior(this) && sceneEl.addBehavior(this));
            };
          }
          function isObject(value) {
            return value && value.constructor === Object && !(value instanceof window.HTMLElement);
          }
        },
        "./src/core/geometry.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var schema = __webpack_require__2("./src/core/schema.js"), processSchema = schema.process, geometries = module3.exports.geometries = {}, geometryNames = module3.exports.geometryNames = [], THREE3 = __webpack_require__2("./src/lib/three.js"), Geometry = module3.exports.Geometry = function() {
          };
          Geometry.prototype = {
            schema: {},
            init: function(data) {
              return this.geometry = new THREE3.BufferGeometry(), this.geometry;
            },
            update: function(data) {
            }
          }, module3.exports.registerGeometry = function(name, definition) {
            var NewGeometry, proto = {};
            if (Object.keys(definition).forEach(function(key) {
              proto[key] = {
                value: definition[key],
                writable: !0
              };
            }), geometries[name])
              throw new Error("The geometry `" + name + "` has been already registered");
            return NewGeometry = function() {
              Geometry.call(this);
            }, NewGeometry.prototype = Object.create(Geometry.prototype, proto), NewGeometry.prototype.name = name, NewGeometry.prototype.constructor = NewGeometry, geometries[name] = {
              Geometry: NewGeometry,
              schema: processSchema(NewGeometry.prototype.schema)
            }, geometryNames.push(name), NewGeometry;
          };
        },
        "./src/core/propertyTypes.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var coordinates = __webpack_require__2("./src/utils/coordinates.js"), debug = __webpack_require__2("./node_modules/debug/src/browser.js"), warn = debug("core:propertyTypes:warn"), propertyTypes = module3.exports.propertyTypes = {}, nonCharRegex = /[,> .[\]:]/, urlRegex = /url\((.+)\)/;
          registerPropertyType("audio", "", assetParse), registerPropertyType("array", [], arrayParse, arrayStringify, arrayEquals), registerPropertyType("asset", "", assetParse), registerPropertyType("boolean", !1, boolParse), registerPropertyType("color", "#FFF"), registerPropertyType("int", 0, intParse), registerPropertyType("number", 0, numberParse), registerPropertyType("map", "", assetParse), registerPropertyType("model", "", assetParse), registerPropertyType("selector", null, selectorParse, selectorStringify, defaultEquals, !1), registerPropertyType("selectorAll", null, selectorAllParse, selectorAllStringify, arrayEquals, !1), registerPropertyType("src", "", srcParse), registerPropertyType("string", ""), registerPropertyType("time", 0, intParse), registerPropertyType("vec2", {
            x: 0,
            y: 0
          }, vecParse, coordinates.stringify, coordinates.equals), registerPropertyType("vec3", {
            x: 0,
            y: 0,
            z: 0
          }, vecParse, coordinates.stringify, coordinates.equals), registerPropertyType("vec4", {
            x: 0,
            y: 0,
            z: 0,
            w: 1
          }, vecParse, coordinates.stringify, coordinates.equals);
          function registerPropertyType(type, defaultValue, parse, stringify, equals, cacheable) {
            if (type in propertyTypes)
              throw new Error("Property type " + type + " is already registered.");
            propertyTypes[type] = {
              default: defaultValue,
              parse: parse || defaultParse,
              stringify: stringify || defaultStringify,
              equals: equals || defaultEquals,
              isCacheable: cacheable !== !1
            };
          }
          module3.exports.registerPropertyType = registerPropertyType;
          function arrayParse(value) {
            if (Array.isArray(value))
              return value;
            if (!value || typeof value != "string")
              return [];
            return value.split(",").map(trim);
            function trim(str) {
              return str.trim();
            }
          }
          function arrayStringify(value) {
            return value.join(", ");
          }
          function arrayEquals(a, b) {
            if (!Array.isArray(a) || !Array.isArray(b))
              return a === b;
            if (a.length !== b.length)
              return !1;
            for (var i = 0; i < a.length; i++)
              if (a[i] !== b[i])
                return !1;
            return !0;
          }
          function assetParse(value) {
            var el, parsedUrl;
            if (typeof value != "string")
              return value;
            if (parsedUrl = value.match(urlRegex), parsedUrl)
              return parsedUrl[1];
            if (value.charAt(0) === "#") {
              if (el = document.getElementById(value.substring(1)), el)
                return el.tagName === "CANVAS" || el.tagName === "VIDEO" || el.tagName === "IMG" ? el : el.getAttribute("src");
              warn('"' + value + '" asset not found.');
              return;
            }
            return value;
          }
          function defaultParse(value) {
            return value;
          }
          function defaultStringify(value) {
            return value === null ? "null" : value.toString();
          }
          function defaultEquals(a, b) {
            return a === b;
          }
          function boolParse(value) {
            return value !== "false" && value !== !1;
          }
          function intParse(value) {
            return parseInt(value, 10);
          }
          function numberParse(value) {
            return parseFloat(value, 10);
          }
          function selectorParse(value) {
            return value ? typeof value != "string" ? value : value[0] === "#" && !nonCharRegex.test(value) ? document.getElementById(value.substring(1)) : document.querySelector(value) : null;
          }
          function selectorAllParse(value) {
            return value ? typeof value != "string" ? value : Array.prototype.slice.call(document.querySelectorAll(value), 0) : null;
          }
          function selectorStringify(value) {
            return value.getAttribute ? "#" + value.getAttribute("id") : defaultStringify(value);
          }
          function selectorAllStringify(value) {
            return value instanceof Array ? value.map(function(element) {
              return "#" + element.getAttribute("id");
            }).join(", ") : defaultStringify(value);
          }
          function srcParse(value) {
            return warn("`src` property type is deprecated. Use `asset` instead."), assetParse(value);
          }
          function vecParse(value, defaultValue, target) {
            return coordinates.parse(value, defaultValue, target);
          }
          function isValidDefaultValue(type, defaultVal) {
            return type === "audio" && typeof defaultVal != "string" || type === "array" && !Array.isArray(defaultVal) || type === "asset" && typeof defaultVal != "string" || type === "boolean" && typeof defaultVal != "boolean" || type === "color" && typeof defaultVal != "string" || type === "int" && typeof defaultVal != "number" || type === "number" && typeof defaultVal != "number" || type === "map" && typeof defaultVal != "string" || type === "model" && typeof defaultVal != "string" || type === "selector" && typeof defaultVal != "string" && defaultVal !== null || type === "selectorAll" && typeof defaultVal != "string" && defaultVal !== null || type === "src" && typeof defaultVal != "string" || type === "string" && typeof defaultVal != "string" || type === "time" && typeof defaultVal != "number" ? !1 : type === "vec2" ? isValidDefaultCoordinate(defaultVal, 2) : type === "vec3" ? isValidDefaultCoordinate(defaultVal, 3) : type === "vec4" ? isValidDefaultCoordinate(defaultVal, 4) : !0;
          }
          module3.exports.isValidDefaultValue = isValidDefaultValue;
          function isValidDefaultCoordinate(possibleCoordinates, dimensions) {
            if (possibleCoordinates === null)
              return !0;
            if (typeof possibleCoordinates != "object" || Object.keys(possibleCoordinates).length !== dimensions)
              return !1;
            var x = possibleCoordinates.x, y = possibleCoordinates.y, z = possibleCoordinates.z, w = possibleCoordinates.w;
            return !(typeof x != "number" || typeof y != "number" || dimensions > 2 && typeof z != "number" || dimensions > 3 && typeof w != "number");
          }
          module3.exports.isValidDefaultCoordinate = isValidDefaultCoordinate;
        },
        "./src/core/readyState.js": (module3) => {
          module3.exports.canInitializeElements = !1;
          function waitForDocumentReadyState() {
            if (document.readyState === "complete") {
              emitReady();
              return;
            }
            document.addEventListener("readystatechange", function onReadyStateChange() {
              document.readyState === "complete" && (document.removeEventListener("readystatechange", onReadyStateChange), emitReady());
            });
          }
          module3.exports.waitForDocumentReadyState = waitForDocumentReadyState;
          function emitReady() {
            module3.exports.canInitializeElements || (module3.exports.canInitializeElements = !0, setTimeout(function() {
              document.dispatchEvent(new CustomEvent("aframeready"));
            }));
          }
          module3.exports.emitReady = emitReady;
        },
        "./src/core/scene/a-scene.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var initMetaTags = __webpack_require__2("./src/core/scene/metaTags.js").inject, initWakelock = __webpack_require__2("./src/core/scene/wakelock.js"), loadingScreen = __webpack_require__2("./src/core/scene/loadingScreen.js"), scenes = __webpack_require__2("./src/core/scene/scenes.js"), systems = __webpack_require__2("./src/core/system.js").systems, components = __webpack_require__2("./src/core/component.js").components, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js"), warn = utils.debug("core:a-scene:warn"), AEntity = __webpack_require__2("./src/core/a-entity.js").AEntity, ANode = __webpack_require__2("./src/core/a-node.js").ANode, initPostMessageAPI = __webpack_require__2("./src/core/scene/postMessage.js"), isIOS = utils.device.isIOS(), isMobile = utils.device.isMobile(), isWebXRAvailable = utils.device.isWebXRAvailable;
          isIOS && __webpack_require__2("./src/utils/ios-orientationchange-blank-bug.js");
          class AScene extends AEntity {
            constructor() {
              var self2;
              super();
              self2 = this, self2.clock = new THREE3.Clock(), self2.isIOS = isIOS, self2.isMobile = isMobile, self2.hasWebXR = isWebXRAvailable, self2.isAR = !1, self2.isScene = !0, self2.object3D = new THREE3.Scene(), self2.object3D.onAfterRender = function(renderer, scene, camera) {
                self2.isPlaying && self2.tock(self2.time, self2.delta, camera);
              }, self2.resize = self2.resize.bind(self2), self2.render = self2.render.bind(self2), self2.systems = {}, self2.systemNames = [], self2.time = self2.delta = 0, self2.usedOfferSession = !1, self2.componentOrder = [], self2.behaviors = {}, self2.hasLoaded = !1, self2.isPlaying = !1, self2.originalHTML = self2.innerHTML;
            }
            addFullScreenStyles() {
              document.documentElement.classList.add("a-fullscreen");
            }
            removeFullScreenStyles() {
              document.documentElement.classList.remove("a-fullscreen");
            }
            doConnectedCallback() {
              var self2 = this, embedded = this.hasAttribute("embedded");
              this.setAttribute("inspector", ""), this.setAttribute("keyboard-shortcuts", ""), this.setAttribute("screenshot", ""), this.setAttribute("xr-mode-ui", ""), this.setAttribute("device-orientation-permission-ui", ""), super.doConnectedCallback(), setupCanvas(this), this.setupRenderer(), loadingScreen.setup(this, getCanvasSize), this.resize(), embedded || this.addFullScreenStyles(), initPostMessageAPI(this), initMetaTags(this), initWakelock(this), this.onVRPresentChangeBound = this.onVRPresentChange.bind(this), window.addEventListener("vrdisplaypresentchange", this.onVRPresentChangeBound), this.enterVRBound = function() {
                self2.enterVR();
              }, this.exitVRBound = function() {
                self2.exitVR();
              }, this.exitVRTrueBound = function() {
                self2.exitVR(!0);
              }, this.pointerRestrictedBound = function() {
                self2.pointerRestricted();
              }, this.pointerUnrestrictedBound = function() {
                self2.pointerUnrestricted();
              }, self2.hasWebXR || (window.addEventListener("vrdisplaydeactivate", this.exitVRBound), window.addEventListener("vrdisplaydisconnect", this.exitVRTrueBound), window.addEventListener("vrdisplaypointerrestricted", this.pointerRestrictedBound), window.addEventListener("vrdisplaypointerunrestricted", this.pointerUnrestrictedBound)), window.addEventListener("sessionend", this.resize), this.addEventListener("cameraready", function() {
                self2.attachedCallbackPostCamera();
              }), this.initSystems(), this.componentOrder = determineComponentBehaviorOrder(components, this.componentOrder), this.addEventListener("componentregistered", function() {
                self2.componentOrder = determineComponentBehaviorOrder(components, self2.componentOrder);
              }), this.hasWebXR && navigator.xr && navigator.xr.addEventListener && navigator.xr.addEventListener("sessiongranted", function() {
                self2.enterVR();
              });
            }
            attachedCallbackPostCamera() {
              var resize, self2 = this;
              window.addEventListener("load", resize), window.addEventListener("resize", function() {
                self2.isIOS ? setTimeout(self2.resize, 100) : self2.resize();
              }), this.play(), scenes.push(this);
            }
            initSystems() {
              var name;
              this.initSystem("camera");
              for (name in systems)
                name !== "camera" && this.initSystem(name);
            }
            initSystem(name) {
              this.systems[name] || (this.systems[name] = new systems[name](this), this.systemNames.push(name));
            }
            disconnectedCallback() {
              var sceneIndex = scenes.indexOf(this);
              super.disconnectedCallback(), scenes.splice(sceneIndex, 1), window.removeEventListener("vrdisplaypresentchange", this.onVRPresentChangeBound), window.removeEventListener("vrdisplayactivate", this.enterVRBound), window.removeEventListener("vrdisplaydeactivate", this.exitVRBound), window.removeEventListener("vrdisplayconnect", this.enterVRBound), window.removeEventListener("vrdisplaydisconnect", this.exitVRTrueBound), window.removeEventListener("vrdisplaypointerrestricted", this.pointerRestrictedBound), window.removeEventListener("vrdisplaypointerunrestricted", this.pointerUnrestrictedBound), window.removeEventListener("sessionend", this.resize), this.renderer.dispose();
            }
            addBehavior(behavior) {
              var behaviorSet, behaviors = this.behaviors[behavior.name], behaviorType;
              behaviors || (behaviors = this.behaviors[behavior.name] = {
                tick: {
                  inUse: !1,
                  array: [],
                  markedForRemoval: []
                },
                tock: {
                  inUse: !1,
                  array: [],
                  markedForRemoval: []
                }
              });
              for (behaviorType in behaviors)
                if (!!behavior[behaviorType]) {
                  if (behaviorSet = behaviors[behaviorType], behaviorSet.inUse) {
                    var index = behaviorSet.markedForRemoval.indexOf(behavior);
                    index !== -1 && behaviorSet.markedForRemoval.splice(index, 1);
                  }
                  behaviorSet.array.indexOf(behavior) === -1 && behaviorSet.array.push(behavior);
                }
            }
            getPointerLockElement() {
              return document.pointerLockElement;
            }
            checkHeadsetConnected() {
              return utils.device.checkHeadsetConnected();
            }
            enterAR() {
              var errorMessage;
              if (!this.hasWebXR)
                throw errorMessage = "Failed to enter AR mode, WebXR not supported.", new Error(errorMessage);
              if (!utils.device.checkARSupport())
                throw errorMessage = "Failed to enter AR, WebXR immersive-ar mode not supported in your browser or device.", new Error(errorMessage);
              return this.enterVR(!0);
            }
            enterVR(useAR, useOfferSession) {
              var self2 = this, vrDisplay, vrManager = self2.renderer.xr, xrInit;
              if (useOfferSession && (!navigator.xr || !navigator.xr.offerSession))
                return Promise.resolve("OfferSession is not supported.");
              if (self2.usedOfferSession && useOfferSession)
                return Promise.resolve("OfferSession was already called.");
              if (this.is("vr-mode"))
                return Promise.resolve("Already in VR.");
              if (this.checkHeadsetConnected() || this.isMobile) {
                var rendererSystem = self2.getAttribute("renderer");
                if (vrManager.enabled = !0, this.hasWebXR) {
                  this.xrSession && this.xrSession.removeEventListener("end", this.exitVRBound);
                  var refspace = this.sceneEl.systems.webxr.sessionReferenceSpaceType;
                  vrManager.setReferenceSpaceType(refspace);
                  var xrMode = useAR ? "immersive-ar" : "immersive-vr";
                  return xrInit = this.sceneEl.systems.webxr.sessionConfiguration, new Promise(function(resolve, reject) {
                    var requestSession = useOfferSession ? navigator.xr.offerSession.bind(navigator.xr) : navigator.xr.requestSession.bind(navigator.xr);
                    self2.usedOfferSession |= useOfferSession, requestSession(xrMode, xrInit).then(function(xrSession) {
                      useOfferSession && (self2.usedOfferSession = !1), vrManager.layersEnabled = xrInit.requiredFeatures.indexOf("layers") !== -1, vrManager.setSession(xrSession).then(function() {
                        vrManager.setFoveation(rendererSystem.foveationLevel), self2.xrSession = xrSession, self2.systems.renderer.setWebXRFrameRate(xrSession), xrSession.addEventListener("end", self2.exitVRBound), enterVRSuccess(resolve);
                      });
                    }, function(error) {
                      var useAR2 = xrMode === "immersive-ar", mode = useAR2 ? "AR" : "VR";
                      reject(new Error("Failed to enter " + mode + " mode (`requestSession`)", {
                        cause: error
                      }));
                    });
                  });
                } else {
                  if (vrDisplay = utils.device.getVRDisplay(), vrManager.setDevice(vrDisplay), vrDisplay.isPresenting && !window.hasNativeWebVRImplementation)
                    return enterVRSuccess(), Promise.resolve();
                  var presentationAttributes = {
                    highRefreshRate: rendererSystem.highRefreshRate
                  };
                  return vrDisplay.requestPresent([{
                    source: this.canvas,
                    attributes: presentationAttributes
                  }]).then(enterVRSuccess, enterVRFailure);
                }
              }
              return enterVRSuccess(), Promise.resolve();
              function enterVRSuccess(resolve) {
                var event;
                window.hasNativeWebVRImplementation && !window.hasNativeWebXRImplementation && (event = new CustomEvent("vrdisplaypresentchange", {
                  detail: {
                    display: utils.device.getVRDisplay()
                  }
                }), window.dispatchEvent(event)), useAR ? self2.addState("ar-mode") : self2.addState("vr-mode"), self2.emit("enter-vr", {
                  target: self2
                }), !self2.hasWebXR && self2.isMobile && screen.orientation && screen.orientation.lock && screen.orientation.lock("landscape"), self2.addFullScreenStyles(), !self2.isMobile && !self2.checkHeadsetConnected() && requestFullscreen(self2.canvas), self2.resize(), resolve && resolve();
              }
              function enterVRFailure(err) {
                throw self2.removeState("vr-mode"), err && err.message ? new Error("Failed to enter VR mode (`requestPresent`): " + err.message) : new Error("Failed to enter VR mode (`requestPresent`).");
              }
            }
            exitVR() {
              var self2 = this, vrDisplay, vrManager = this.renderer.xr;
              if (!this.is("vr-mode") && !this.is("ar-mode"))
                return Promise.resolve("Not in immersive mode.");
              if (this.checkHeadsetConnected() || this.isMobile) {
                if (vrManager.enabled = !1, vrDisplay = utils.device.getVRDisplay(), this.hasWebXR)
                  this.xrSession.removeEventListener("end", this.exitVRBound), this.xrSession.end().then(function() {
                  }, function() {
                  }), this.xrSession = void 0;
                else if (vrDisplay.isPresenting)
                  return vrDisplay.exitPresent().then(exitVRSuccess, exitVRFailure);
              } else
                exitFullscreen();
              return exitVRSuccess(), Promise.resolve();
              function exitVRSuccess() {
                self2.removeState("vr-mode"), self2.removeState("ar-mode"), self2.isMobile && screen.orientation && screen.orientation.unlock && screen.orientation.unlock(), self2.hasAttribute("embedded") && self2.removeFullScreenStyles(), self2.resize(), self2.isIOS && utils.forceCanvasResizeSafariMobile(self2.canvas), self2.renderer.setPixelRatio(window.devicePixelRatio), self2.emit("exit-vr", {
                  target: self2
                });
              }
              function exitVRFailure(err) {
                throw err && err.message ? new Error("Failed to exit VR mode (`exitPresent`): " + err.message) : new Error("Failed to exit VR mode (`exitPresent`).");
              }
            }
            pointerRestricted() {
              if (this.canvas) {
                var pointerLockElement = this.getPointerLockElement();
                pointerLockElement && pointerLockElement !== this.canvas && document.exitPointerLock && document.exitPointerLock(), this.canvas.requestPointerLock && this.canvas.requestPointerLock();
              }
            }
            pointerUnrestricted() {
              var pointerLockElement = this.getPointerLockElement();
              pointerLockElement && pointerLockElement === this.canvas && document.exitPointerLock && document.exitPointerLock();
            }
            onVRPresentChange(evt) {
              var display = evt.display || evt.detail.display;
              if (display && display.isPresenting) {
                this.enterVR();
                return;
              }
              this.exitVR();
            }
            getAttribute(attr) {
              var system = this.systems[attr];
              return system ? system.data : AEntity.prototype.getAttribute.call(this, attr);
            }
            getDOMAttribute(attr) {
              var system = this.systems[attr];
              return system ? system.data : AEntity.prototype.getDOMAttribute.call(this, attr);
            }
            setAttribute(attr, value, componentPropValue) {
              if (systems[attr]) {
                ANode.prototype.setAttribute.call(this, attr, value);
                var system = this.systems[attr];
                system && system.updateProperties(value);
                return;
              }
              AEntity.prototype.setAttribute.call(this, attr, value, componentPropValue);
            }
            removeBehavior(behavior) {
              var behaviorSet, behaviorType, behaviors = this.behaviors[behavior.name], index;
              for (behaviorType in behaviors)
                !behavior[behaviorType] || (behaviorSet = behaviors[behaviorType], index = behaviorSet.array.indexOf(behavior), index !== -1 && (behaviorSet.inUse ? behaviorSet.markedForRemoval.indexOf(behavior) === -1 && behaviorSet.markedForRemoval.push(behavior) : (behaviorSet.array[index] = behaviorSet.array[behaviorSet.array.length - 1], behaviorSet.array.pop())));
            }
            resize() {
              var camera = this.camera, canvas = this.canvas, embedded, isVRPresenting, size, isPresenting = this.renderer.xr.isPresenting;
              isVRPresenting = this.renderer.xr.enabled && isPresenting, !(!camera || !canvas || this.is("vr-mode") && (this.isMobile || isVRPresenting)) && (embedded = this.getAttribute("embedded") && !this.is("vr-mode"), size = getCanvasSize(canvas, embedded, this.maxCanvasSize, this.is("vr-mode")), camera.aspect = size.width / size.height, camera.updateProjectionMatrix(), this.renderer.setSize(size.width, size.height, !1), this.emit("rendererresize", null, !1));
            }
            setupRenderer() {
              var self2 = this, renderer, rendererAttr, rendererAttrString, rendererConfig;
              rendererConfig = {
                alpha: !0,
                antialias: !isMobile,
                canvas: this.canvas,
                logarithmicDepthBuffer: !1,
                powerPreference: "high-performance"
              }, this.maxCanvasSize = {
                height: -1,
                width: -1
              }, this.hasAttribute("renderer") && (rendererAttrString = this.getAttribute("renderer"), rendererAttr = utils.styleParser.parse(rendererAttrString), rendererAttr.precision && (rendererConfig.precision = rendererAttr.precision + "p"), rendererAttr.antialias && rendererAttr.antialias !== "auto" && (rendererConfig.antialias = rendererAttr.antialias === "true"), rendererAttr.logarithmicDepthBuffer && rendererAttr.logarithmicDepthBuffer !== "auto" && (rendererConfig.logarithmicDepthBuffer = rendererAttr.logarithmicDepthBuffer === "true"), rendererAttr.alpha && (rendererConfig.alpha = rendererAttr.alpha === "true"), rendererAttr.stencil && (rendererConfig.stencil = rendererAttr.stencil === "true"), rendererAttr.multiviewStereo && (rendererConfig.multiviewStereo = rendererAttr.multiviewStereo === "true"), this.maxCanvasSize = {
                width: rendererAttr.maxCanvasWidth ? parseInt(rendererAttr.maxCanvasWidth) : this.maxCanvasSize.width,
                height: rendererAttr.maxCanvasHeight ? parseInt(rendererAttr.maxCanvasHeight) : this.maxCanvasSize.height
              }), renderer = this.renderer = new THREE3.WebGLRenderer(rendererConfig), renderer.setPixelRatio(window.devicePixelRatio), this.camera && renderer.xr.setPoseTarget(this.camera.el.object3D), this.addEventListener("camera-set-active", function() {
                renderer.xr.setPoseTarget(self2.camera.el.object3D);
              });
            }
            play() {
              var self2 = this, sceneEl = this;
              if (this.renderStarted) {
                AEntity.prototype.play.call(this);
                return;
              }
              this.addEventListener("loaded", function() {
                var renderer = this.renderer, vrDisplay, vrManager = this.renderer.xr;
                AEntity.prototype.play.call(this), !sceneEl.renderStarted && (sceneEl.resize(), sceneEl.renderer && (window.performance && window.performance.mark("render-started"), loadingScreen.remove(), vrDisplay = utils.device.getVRDisplay(), vrDisplay && vrDisplay.isPresenting && (vrManager.setDevice(vrDisplay), vrManager.enabled = !0, sceneEl.enterVR()), renderer.setAnimationLoop(this.render), sceneEl.renderStarted = !0, sceneEl.emit("renderstart")));
              }), setTimeout(function() {
                AEntity.prototype.load.call(self2);
              });
            }
            updateComponent(componentName) {
              componentName in systems || AEntity.prototype.updateComponent.apply(this, arguments);
            }
            tick(time, timeDelta) {
              var i, systems2 = this.systems;
              for (this.callComponentBehaviors("tick", time, timeDelta), i = 0; i < this.systemNames.length; i++)
                !systems2[this.systemNames[i]].tick || systems2[this.systemNames[i]].tick(time, timeDelta);
            }
            tock(time, timeDelta, camera) {
              var i, systems2 = this.systems;
              for (this.callComponentBehaviors("tock", time, timeDelta), i = 0; i < this.systemNames.length; i++)
                !systems2[this.systemNames[i]].tock || systems2[this.systemNames[i]].tock(time, timeDelta, camera);
            }
            render(time, frame) {
              var renderer = this.renderer;
              this.frame = frame, this.delta = this.clock.getDelta() * 1e3, this.time = this.clock.elapsedTime * 1e3, this.isPlaying && this.tick(this.time, this.delta);
              var savedBackground = null;
              this.is("ar-mode") && (savedBackground = this.object3D.background, this.object3D.background = null), renderer.render(this.object3D, this.camera), savedBackground && (this.object3D.background = savedBackground);
            }
            callComponentBehaviors(behavior, time, timeDelta) {
              for (var i, c = 0; c < this.componentOrder.length; c++) {
                var behaviors = this.behaviors[this.componentOrder[c]];
                if (!!behaviors) {
                  var behaviorSet = behaviors[behavior];
                  for (behaviorSet.inUse = !0, i = 0; i < behaviorSet.array.length; i++)
                    !behaviorSet.array[i].isPlaying || behaviorSet.array[i][behavior](time, timeDelta);
                  for (behaviorSet.inUse = !1, i = 0; i < behaviorSet.markedForRemoval.length; i++)
                    this.removeBehavior(behaviorSet.markedForRemoval[i]);
                  behaviorSet.markedForRemoval.length = 0;
                }
              }
            }
          }
          function determineComponentBehaviorOrder(components2, array) {
            var graph = {}, i, key, result = array || [];
            result.length = 0;
            for (key in components2) {
              var element = components2[key];
              if (element !== void 0) {
                var before = element.before ? element.before.slice(0) : [], after = element.after ? element.after.slice(0) : [];
                graph[key] = {
                  before,
                  after,
                  visited: !1,
                  done: !1
                };
              }
            }
            for (key in graph)
              for (i = 0; i < graph[key].before.length; i++) {
                var beforeName = graph[key].before[i];
                if (!(beforeName in graph)) {
                  warn("Invalid ordering constraint, no component named `" + beforeName + "` referenced by `" + key + "`");
                  continue;
                }
                graph[beforeName].after.push(key);
              }
            function visit(name) {
              if (!(!(name in graph) || graph[name].done)) {
                if (graph[name].visited) {
                  warn("Cycle detected, ignoring one or more before/after constraints. The resulting order might be incorrect");
                  return;
                }
                graph[name].visited = !0;
                for (var i2 = 0; i2 < graph[name].after.length; i2++) {
                  var afterName = graph[name].after[i2];
                  afterName in graph || warn("Invalid before/after constraint, no component named `" + afterName + "` referenced in `" + name + "`"), visit(afterName);
                }
                graph[name].done = !0, result.push(name);
              }
            }
            for (key in graph)
              graph[key].done || visit(key);
            return result;
          }
          module3.exports.determineComponentBehaviorOrder = determineComponentBehaviorOrder;
          function constrainSizeTo(size, maxSize) {
            var aspectRatio, pixelRatio = window.devicePixelRatio;
            return !maxSize || maxSize.width === -1 && maxSize.height === -1 || size.width * pixelRatio < maxSize.width && size.height * pixelRatio < maxSize.height || (aspectRatio = size.width / size.height, size.width * pixelRatio > maxSize.width && maxSize.width !== -1 && (size.width = Math.round(maxSize.width / pixelRatio), size.height = Math.round(maxSize.width / aspectRatio / pixelRatio)), size.height * pixelRatio > maxSize.height && maxSize.height !== -1 && (size.height = Math.round(maxSize.height / pixelRatio), size.width = Math.round(maxSize.height * aspectRatio / pixelRatio))), size;
          }
          customElements.define("a-scene", AScene);
          function getCanvasSize(canvasEl, embedded, maxSize, isVR) {
            if (!canvasEl.parentElement)
              return {
                height: 0,
                width: 0
              };
            if (embedded) {
              var size;
              return size = {
                height: canvasEl.parentElement.offsetHeight,
                width: canvasEl.parentElement.offsetWidth
              }, constrainSizeTo(size, maxSize);
            }
            return getMaxSize(maxSize, isVR);
          }
          function getMaxSize(maxSize, isVR) {
            var size;
            return size = {
              height: document.body.offsetHeight,
              width: document.body.offsetWidth
            }, isVR ? size : constrainSizeTo(size, maxSize);
          }
          function requestFullscreen(canvas) {
            var requestFullscreen2 = canvas.requestFullscreen || canvas.webkitRequestFullscreen || canvas.mozRequestFullScreen || canvas.msRequestFullscreen;
            requestFullscreen2.apply(canvas, [{
              navigationUI: "hide"
            }]);
          }
          function exitFullscreen() {
            var fullscreenEl = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement;
            !fullscreenEl || (document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen());
          }
          function setupCanvas(sceneEl) {
            var canvasEl;
            canvasEl = document.createElement("canvas"), canvasEl.classList.add("a-canvas"), canvasEl.dataset.aframeCanvas = !0, sceneEl.appendChild(canvasEl), document.addEventListener("fullscreenchange", onFullScreenChange), document.addEventListener("mozfullscreenchange", onFullScreenChange), document.addEventListener("webkitfullscreenchange", onFullScreenChange), document.addEventListener("MSFullscreenChange", onFullScreenChange), canvasEl.addEventListener("touchmove", function(event) {
              event.preventDefault();
            }, {
              passive: !1
            }), sceneEl.canvas = canvasEl, sceneEl.emit("render-target-loaded", {
              target: canvasEl
            }), setTimeout(sceneEl.resize.bind(sceneEl), 0);
            function onFullScreenChange() {
              var fullscreenEl = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
              fullscreenEl || sceneEl.exitVR(), document.activeElement.blur(), document.body.focus();
            }
          }
          module3.exports.setupCanvas = setupCanvas, module3.exports.AScene = AScene;
        },
        "./src/core/scene/loadingScreen.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var utils = __webpack_require__2("./src/utils/index.js"), styleParser = utils.styleParser, sceneEl, titleEl, getSceneCanvasSize, ATTR_NAME = "loading-screen", LOADER_TITLE_CLASS = "a-loader-title";
          module3.exports.setup = function(el, getCanvasSize) {
            sceneEl = el, getSceneCanvasSize = getCanvasSize;
            var loaderAttribute = sceneEl.hasAttribute(ATTR_NAME) ? styleParser.parse(sceneEl.getAttribute(ATTR_NAME)) : void 0, dotsColor = loaderAttribute && loaderAttribute.dotsColor || "white", backgroundColor = loaderAttribute && loaderAttribute.backgroundColor || "#24CAFF", loaderEnabled = loaderAttribute === void 0 || loaderAttribute.enabled === "true" || loaderAttribute.enabled === void 0, loaderScene, sphereGeometry, sphereMaterial, sphereMesh1, sphereMesh2, sphereMesh3, camera, clock, time, render;
            !loaderEnabled || (loaderScene = new THREE.Scene(), sphereGeometry = new THREE.SphereGeometry(0.2, 36, 18, 0, 2 * Math.PI, 0, Math.PI), sphereMaterial = new THREE.MeshBasicMaterial({
              color: dotsColor
            }), sphereMesh1 = new THREE.Mesh(sphereGeometry, sphereMaterial), sphereMesh2 = sphereMesh1.clone(), sphereMesh3 = sphereMesh1.clone(), camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 5e-4, 1e4), clock = new THREE.Clock(), time = 0, render = function() {
              sceneEl.renderer.render(loaderScene, camera), time = clock.getElapsedTime() % 4, sphereMesh1.visible = time >= 1, sphereMesh2.visible = time >= 2, sphereMesh3.visible = time >= 3;
            }, loaderScene.background = new THREE.Color(backgroundColor), loaderScene.add(camera), sphereMesh1.position.set(-1, 0, -15), sphereMesh2.position.set(0, 0, -15), sphereMesh3.position.set(1, 0, -15), camera.add(sphereMesh1), camera.add(sphereMesh2), camera.add(sphereMesh3), setupTitle(), setTimeout(function() {
              sceneEl.hasLoaded || (resize(camera), titleEl.style.display = "block", window.addEventListener("resize", function() {
                resize(camera);
              }), sceneEl.renderer.setAnimationLoop(render));
            }, 200));
          }, module3.exports.remove = function() {
            window.removeEventListener("resize", resize), !!titleEl && (titleEl.style.display = "none");
          };
          function resize(camera) {
            var embedded = sceneEl.hasAttribute("embedded"), size = getSceneCanvasSize(sceneEl.canvas, embedded, sceneEl.maxCanvasSize, sceneEl.is("vr-mode"));
            camera.aspect = size.width / size.height, camera.updateProjectionMatrix(), sceneEl.renderer.setSize(size.width, size.height, !1);
          }
          function setupTitle() {
            titleEl = document.createElement("div"), titleEl.className = LOADER_TITLE_CLASS, titleEl.innerHTML = document.title, titleEl.style.display = "none", sceneEl.appendChild(titleEl);
          }
        },
        "./src/core/scene/metaTags.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var constants = __webpack_require__2("./src/constants/index.js"), extend = __webpack_require__2("./src/utils/index.js").extend, MOBILE_HEAD_TAGS = module3.exports.MOBILE_HEAD_TAGS = [
            Meta({
              name: "viewport",
              content: "width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui,viewport-fit=cover"
            }),
            Meta({
              name: "mobile-web-app-capable",
              content: "yes"
            }),
            Meta({
              name: "theme-color",
              content: "black"
            })
          ], MOBILE_IOS_HEAD_TAGS = [
            Meta({
              name: "apple-mobile-web-app-capable",
              content: "yes"
            }),
            Meta({
              name: "apple-mobile-web-app-status-bar-style",
              content: "black"
            }),
            Link({
              rel: "apple-touch-icon",
              href: "https://aframe.io/images/aframe-logo-152.png"
            })
          ];
          function Meta(attrs) {
            return {
              tagName: "meta",
              attributes: attrs,
              exists: function() {
                return document.querySelector('meta[name="' + attrs.name + '"]');
              }
            };
          }
          function Link(attrs) {
            return {
              tagName: "link",
              attributes: attrs,
              exists: function() {
                return document.querySelector('link[rel="' + attrs.rel + '"]');
              }
            };
          }
          module3.exports.inject = function(scene) {
            var headEl = document.head, headScriptEl = headEl.querySelector("script"), tag, headTags = [];
            return MOBILE_HEAD_TAGS.forEach(createAndInjectTag), scene.isIOS && MOBILE_IOS_HEAD_TAGS.forEach(createAndInjectTag), headTags;
            function createAndInjectTag(tagObj) {
              !tagObj || tagObj.exists() || (tag = createTag(tagObj), !!tag && (headScriptEl ? headScriptEl.parentNode.insertBefore(tag, headScriptEl) : headEl.appendChild(tag), headTags.push(tag)));
            }
          };
          function createTag(tagObj) {
            if (!(!tagObj || !tagObj.tagName)) {
              var meta = document.createElement(tagObj.tagName);
              return meta.setAttribute(constants.AFRAME_INJECTED, ""), extend(meta, tagObj.attributes);
            }
          }
        },
        "./src/core/scene/postMessage.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var isIframed = __webpack_require__2("./src/utils/index.js").isIframed;
          module3.exports = function(scene) {
            !isIframed() || window.addEventListener("message", postMessageAPIHandler.bind(scene));
          };
          function postMessageAPIHandler(event) {
            var scene = this;
            if (!!event.data)
              switch (event.data.type) {
                case "vr":
                  switch (event.data.data) {
                    case "enter":
                      scene.enterVR();
                      break;
                    case "exit":
                      scene.exitVR();
                      break;
                  }
              }
          }
        },
        "./src/core/scene/scenes.js": (module3) => {
          module3.exports = [];
        },
        "./src/core/scene/wakelock.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var Wakelock = __webpack_require__2("./vendor/wakelock/wakelock.js");
          module3.exports = function(scene) {
            if (!!scene.isMobile) {
              var wakelock = scene.wakelock = new Wakelock();
              scene.addEventListener("enter-vr", function() {
                wakelock.request();
              }), scene.addEventListener("exit-vr", function() {
                wakelock.release();
              });
            }
          };
        },
        "./src/core/schema.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var utils = __webpack_require__2("./src/utils/index.js"), PropertyTypes = __webpack_require__2("./src/core/propertyTypes.js"), debug = utils.debug, isValidDefaultValue = PropertyTypes.isValidDefaultValue, propertyTypes = PropertyTypes.propertyTypes, warn = debug("core:schema:warn");
          function isSingleProperty(schema) {
            return "type" in schema ? typeof schema.type == "string" : "default" in schema;
          }
          module3.exports.isSingleProperty = isSingleProperty, module3.exports.process = function(schema, componentName) {
            var propName;
            if (isSingleProperty(schema))
              return processPropertyDefinition(schema, componentName);
            for (propName in schema)
              schema[propName] = processPropertyDefinition(schema[propName], componentName);
            return schema;
          };
          function processPropertyDefinition(propDefinition, componentName) {
            var defaultVal = propDefinition.default, isCustomType, propType, typeName = propDefinition.type;
            return propDefinition.type ? propDefinition.type === "bool" ? typeName = "boolean" : propDefinition.type === "float" && (typeName = "number") : defaultVal !== void 0 && (typeof defaultVal == "boolean" || typeof defaultVal == "number") ? typeName = typeof defaultVal : Array.isArray(defaultVal) ? typeName = "array" : typeName = "string", propType = propertyTypes[typeName], propType || warn("Unknown property type for component `" + componentName + "`: " + typeName), isCustomType = !!propDefinition.parse, propDefinition.parse = propDefinition.parse || propType.parse, propDefinition.stringify = propDefinition.stringify || propType.stringify, propDefinition.equals = propDefinition.equals || propType.equals, propDefinition.isCacheable = propDefinition.isCacheable === !0 || propType.isCacheable, propDefinition.type = typeName, "default" in propDefinition ? !isCustomType && !isValidDefaultValue(typeName, defaultVal) && warn("Default value `" + defaultVal + "` does not match type `" + typeName + "` in component `" + componentName + "`") : propDefinition.default = propType.default, propDefinition;
          }
          module3.exports.processPropertyDefinition = processPropertyDefinition, module3.exports.parseProperties = function() {
            var propNames = [];
            return function(propData, schema, getPartialData, componentName, silent) {
              var i, propName, propDefinition, propValue;
              propNames.length = 0;
              for (propName in getPartialData ? propData : schema)
                getPartialData && propData[propName] === void 0 || propNames.push(propName);
              if (propData === null || typeof propData != "object")
                return propData;
              for (propName in propData)
                propData[propName] !== void 0 && !schema[propName] && !silent && warn("Unknown property `" + propName + "` for component/system `" + componentName + "`.");
              for (i = 0; i < propNames.length; i++) {
                if (propName = propNames[i], propDefinition = schema[propName], propValue = propData[propName], !schema[propName])
                  return;
                propData[propName] = parseProperty(propValue, propDefinition);
              }
              return propData;
            };
          }();
          function parseProperty(value, propDefinition, target) {
            return (value == null || value === "") && (value = propDefinition.default, Array.isArray(value) && (value = value.slice())), propDefinition.parse(value, propDefinition.default, target);
          }
          module3.exports.parseProperty = parseProperty, module3.exports.stringifyProperties = function(propData, schema) {
            var propName, propDefinition, propValue, stringifiedData = {}, value;
            for (propName in propData)
              propDefinition = schema[propName], propValue = propData[propName], value = propValue, typeof value == "object" && (value = stringifyProperty(propValue, propDefinition), propDefinition || warn("Unknown component property: " + propName)), stringifiedData[propName] = value;
            return stringifiedData;
          };
          function stringifyProperty(value, propDefinition) {
            return typeof value != "object" ? value : !propDefinition || value === null ? JSON.stringify(value) : propDefinition.stringify(value);
          }
          module3.exports.stringifyProperty = stringifyProperty;
        },
        "./src/core/shader.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var schema = __webpack_require__2("./src/core/schema.js"), processSchema = schema.process, shaders = module3.exports.shaders = {}, shaderNames = module3.exports.shaderNames = [], THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js"), propertyToThreeMapping = {
            array: "v3",
            color: "v3",
            int: "i",
            number: "f",
            map: "t",
            time: "f",
            vec2: "v2",
            vec3: "v3",
            vec4: "v4"
          }, Shader = module3.exports.Shader = function() {
          };
          Shader.prototype = {
            schema: {},
            vertexShader: "void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}",
            fragmentShader: "void main() {gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);}",
            init: function(data) {
              return this.uniforms = this.initUniforms(), this.material = new (this.raw ? THREE3.RawShaderMaterial : THREE3.ShaderMaterial)({
                uniforms: this.uniforms,
                glslVersion: this.raw || this.glsl3 ? THREE3.GLSL3 : null,
                vertexShader: this.vertexShader,
                fragmentShader: this.fragmentShader
              }), this.material;
            },
            initUniforms: function() {
              var key, schema2 = this.schema, variables = {}, varType;
              for (key in schema2)
                schema2[key].is === "uniform" && (varType = propertyToThreeMapping[schema2[key].type], variables[key] = {
                  type: varType,
                  value: void 0
                });
              return variables;
            },
            update: function(data) {
              var key, materialKey, schema2 = this.schema, uniforms = this.uniforms;
              for (key in data)
                if (!(!schema2[key] || schema2[key].is !== "uniform")) {
                  if (schema2[key].type === "map") {
                    if (!uniforms[key] || uniforms[key].value === data[key])
                      continue;
                    materialKey = "_texture_" + key, this.setMapOnTextureLoad(uniforms, key, materialKey), utils.material.updateMapMaterialFromData(materialKey, key, this, data);
                    continue;
                  }
                  uniforms[key].value = this.parseValue(schema2[key].type, data[key]), uniforms[key].needsUpdate = !0;
                }
            },
            parseValue: function(type, value) {
              var color;
              switch (type) {
                case "vec2":
                  return new THREE3.Vector2(value.x, value.y);
                case "vec3":
                  return new THREE3.Vector3(value.x, value.y, value.z);
                case "vec4":
                  return new THREE3.Vector4(value.x, value.y, value.z, value.w);
                case "color":
                  return color = new THREE3.Color(value), new THREE3.Vector3(color.r, color.g, color.b);
                default:
                  return value;
              }
            },
            setMapOnTextureLoad: function(uniforms, key, materialKey) {
              var self2 = this;
              this.el.addEventListener("materialtextureloaded", function() {
                uniforms[key].value = self2.material[materialKey], uniforms[key].needsUpdate = !0;
              });
            }
          }, module3.exports.registerShader = function(name, definition) {
            var NewShader, proto = {};
            if (Object.keys(definition).forEach(function(key) {
              proto[key] = {
                value: definition[key],
                writable: !0
              };
            }), shaders[name])
              throw new Error("The shader " + name + " has already been registered");
            return NewShader = function() {
              Shader.call(this);
            }, NewShader.prototype = Object.create(Shader.prototype, proto), NewShader.prototype.name = name, NewShader.prototype.constructor = NewShader, shaders[name] = {
              Shader: NewShader,
              schema: processSchema(NewShader.prototype.schema)
            }, shaderNames.push(name), NewShader;
          };
        },
        "./src/core/system.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var components = __webpack_require__2("./src/core/component.js"), schema = __webpack_require__2("./src/core/schema.js"), utils = __webpack_require__2("./src/utils/index.js"), ready = __webpack_require__2("./src/core/readyState.js"), parseProperties = schema.parseProperties, parseProperty = schema.parseProperty, processSchema = schema.process, isSingleProp = schema.isSingleProperty, styleParser = utils.styleParser, systems = module3.exports.systems = {}, System = module3.exports.System = function(sceneEl) {
            var component = components && components.components[this.name];
            this.el = sceneEl, this.sceneEl = sceneEl, component && (component.Component.prototype.system = this), this.buildData(), this.init(), this.update({});
          };
          System.prototype = {
            schema: {},
            init: function() {
            },
            update: function(oldData) {
            },
            updateProperties: function(rawData) {
              var oldData = this.data;
              !Object.keys(schema).length || (this.buildData(rawData), this.update(oldData));
            },
            buildData: function(rawData) {
              var schema2 = this.schema;
              !Object.keys(schema2).length || (rawData = rawData || window.HTMLElement.prototype.getAttribute.call(this.sceneEl, this.name), isSingleProp(schema2) ? this.data = parseProperty(rawData, schema2) : this.data = parseProperties(styleParser.parse(rawData) || {}, schema2, !1, this.name));
            },
            tick: void 0,
            tock: void 0,
            play: function() {
            },
            pause: function() {
            }
          }, module3.exports.registerSystem = function(name, definition) {
            var i, NewSystem, proto = {}, scenes = utils.findAllScenes(document);
            if (Object.keys(definition).forEach(function(key) {
              proto[key] = {
                value: definition[key],
                writable: !0
              };
            }), systems[name])
              throw new Error("The system `" + name + "` has been already registered. Check that you are not loading two versions of the same system or two different systems of the same name.");
            if (NewSystem = function(sceneEl) {
              System.call(this, sceneEl);
            }, NewSystem.prototype = Object.create(System.prototype, proto), NewSystem.prototype.name = name, NewSystem.prototype.constructor = NewSystem, NewSystem.prototype.schema = utils.extend(processSchema(NewSystem.prototype.schema)), systems[name] = NewSystem, ready.canInitializeElements)
              for (i = 0; i < scenes.length; i++)
                scenes[i].initSystem(name);
          };
        },
        "./src/extras/components/index.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2("./src/extras/components/pivot.js");
        },
        "./src/extras/components/pivot.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, THREE3 = __webpack_require__2("./src/lib/three.js"), originalPosition = new THREE3.Vector3(), originalRotation = new THREE3.Vector3();
          registerComponent("pivot", {
            dependencies: ["position"],
            schema: {
              type: "vec3"
            },
            init: function() {
              var data = this.data, el = this.el, originalParent = el.object3D.parent, originalGroup = el.object3D, outerGroup = new THREE3.Group();
              originalPosition.copy(originalGroup.position), originalRotation.copy(originalGroup.rotation), originalParent.remove(originalGroup), outerGroup.add(originalGroup), originalParent.add(outerGroup), el.object3D = outerGroup, originalGroup.position.set(-1 * data.x, -1 * data.y, -1 * data.z), outerGroup.position.set(data.x + originalPosition.x, data.y + originalPosition.y, data.z + originalPosition.z), outerGroup.rotation.copy(originalGroup.rotation), originalGroup.rotation.set(0, 0, 0);
            }
          });
        },
        "./src/extras/primitives/getMeshMixin.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var components = __webpack_require__2("./src/core/component.js").components, shaders = __webpack_require__2("./src/core/shader.js").shaders, utils = __webpack_require__2("./src/utils/index.js"), materialMappings = {};
          Object.keys(components.material.schema).forEach(addMapping), Object.keys(shaders.standard.schema).forEach(addMapping);
          function addMapping(prop) {
            var htmlAttrName = prop.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
            prop === "fog" && (htmlAttrName = "material-fog"), prop === "visible" && (htmlAttrName = "material-visible"), materialMappings[htmlAttrName] = "material." + prop;
          }
          module3.exports = function() {
            return {
              defaultComponents: {
                material: {}
              },
              mappings: utils.extend({}, materialMappings)
            };
          };
        },
        "./src/extras/primitives/index.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2("./src/extras/primitives/primitives/a-camera.js"), __webpack_require__2("./src/extras/primitives/primitives/a-cursor.js"), __webpack_require__2("./src/extras/primitives/primitives/a-curvedimage.js"), __webpack_require__2("./src/extras/primitives/primitives/a-gltf-model.js"), __webpack_require__2("./src/extras/primitives/primitives/a-image.js"), __webpack_require__2("./src/extras/primitives/primitives/a-light.js"), __webpack_require__2("./src/extras/primitives/primitives/a-link.js"), __webpack_require__2("./src/extras/primitives/primitives/a-obj-model.js"), __webpack_require__2("./src/extras/primitives/primitives/a-sky.js"), __webpack_require__2("./src/extras/primitives/primitives/a-sound.js"), __webpack_require__2("./src/extras/primitives/primitives/a-text.js"), __webpack_require__2("./src/extras/primitives/primitives/a-video.js"), __webpack_require__2("./src/extras/primitives/primitives/a-videosphere.js"), __webpack_require__2("./src/extras/primitives/primitives/meshPrimitives.js");
        },
        "./src/extras/primitives/primitives.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var knownTags = __webpack_require__2("./src/core/a-node.js").knownTags, AEntity = __webpack_require__2("./src/core/a-entity.js").AEntity, components = __webpack_require__2("./src/core/component.js").components, utils = __webpack_require__2("./src/utils/index.js"), debug = utils.debug, setComponentProperty = utils.entity.setComponentProperty, log = debug("extras:primitives:debug"), warn = debug("extras:primitives:warn"), error = debug("extras:primitives:error"), primitives = module3.exports.primitives = {};
          module3.exports.registerPrimitive = function(name, definition) {
            if (name = name.toLowerCase(), knownTags[name]) {
              error("Trying to register primitive " + name + " that has been already previously registered");
              return;
            }
            knownTags[name] = !0, log("Registering <%s>", name), definition.defaultAttributes && warn("The 'defaultAttributes' object is deprecated. Use 'defaultComponents' instead.");
            var mappings = definition.mappings || {}, primitiveClass = class extends AEntity {
              constructor() {
                super();
                this.defaultComponentsFromPrimitive = definition.defaultComponents || definition.defaultAttributes || {}, this.deprecated = definition.deprecated || null, this.deprecatedMappings = definition.deprecatedMappings || {}, this.mappings = mappings, definition.deprecated && console.warn(definition.deprecated), this.resolveMappingCollisions();
              }
              resolveMappingCollisions() {
                var mappings2 = this.mappings, self2 = this;
                Object.keys(mappings2).forEach(function(key) {
                  var newAttribute;
                  key !== key.toLowerCase() && warn("Mapping keys should be specified in lower case. The mapping key " + key + " may not be recognized"), components[key] && (newAttribute = mappings2[key].replace(".", "-"), mappings2[newAttribute] = mappings2[key], delete mappings2[key], console.warn("The primitive " + self2.tagName.toLowerCase() + " has a mapping collision. The attribute " + key + " has the same name as a registered component and has been renamed to " + newAttribute));
                });
              }
              getExtraComponents() {
                var attr, data, i, mapping, mixins, self2 = this;
                for (data = utils.clone(this.defaultComponentsFromPrimitive), mixins = this.getAttribute("mixin"), mixins && (mixins = utils.split(mixins.trim(), /\s+/), mixins.forEach(function(mixinId) {
                  var mixinEl = document.getElementById(mixinId);
                  if (!!mixinEl) {
                    var rawAttributeCache = mixinEl.rawAttributeCache, mixinComponents = mixinEl.componentCache;
                    for (var name2 in rawAttributeCache) {
                      if (mapping = self2.mappings[name2], mapping) {
                        applyMapping(mapping, rawAttributeCache[name2], data);
                        return;
                      }
                      name2 in mixinComponents && (data[name2] = extend(data[name2], mixinComponents[name2]));
                    }
                  }
                })), i = 0; i < this.attributes.length; i++)
                  attr = this.attributes[i], mapping = this.mappings[attr.name], mapping && applyMapping(mapping, attr.value, data);
                return data;
                function extend(base, extension) {
                  return isUndefined(base) ? copy(extension) : isUndefined(extension) ? copy(base) : isPureObject(base) && isPureObject(extension) ? utils.extendDeep(base, extension) : copy(extension);
                }
                function isUndefined(value) {
                  return typeof value == "undefined";
                }
                function copy(value) {
                  return isPureObject(value) ? utils.extendDeep({}, value) : value;
                }
                function isPureObject(value) {
                  return value !== null && value.constructor === Object;
                }
              }
              attributeChangedCallback(attr, oldVal, value) {
                var componentName = this.mappings[attr];
                if (attr in this.deprecatedMappings && console.warn(this.deprecatedMappings[attr]), !attr || !componentName) {
                  super.attributeChangedCallback(attr, oldVal, value);
                  return;
                }
                setComponentProperty(this, componentName, value);
              }
            };
            return customElements.define(name, primitiveClass), primitiveClass.mappings = mappings, primitives[name] = primitiveClass, primitiveClass;
          };
          function applyMapping(mapping, attrValue, data) {
            var path = utils.entity.getComponentPropertyPath(mapping);
            path.constructor === Array ? (data[path[0]] = data[path[0]] || {}, data[path[0]][path[1]] = attrValue.trim()) : data[path] = attrValue.trim();
          }
          function addComponentMapping(componentName, mappings) {
            var schema = components[componentName].schema;
            Object.keys(schema).map(function(prop) {
              var attrName = prop.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
              mappings[attrName] !== void 0 && (attrName = componentName + "-" + prop), mappings[attrName] = componentName + "." + prop;
            });
          }
          function definePrimitive(tagName, defaultComponents, mappings) {
            mappings = mappings || {}, Object.keys(defaultComponents).map(function(componentName) {
              addComponentMapping(componentName, mappings);
            }), module3.exports.registerPrimitive(tagName, utils.extendDeep({}, null, {
              defaultComponents,
              mappings
            }));
          }
          module3.exports.definePrimitive = definePrimitive;
        },
        "./src/extras/primitives/primitives/a-camera.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive;
          registerPrimitive("a-camera", {
            defaultComponents: {
              camera: {},
              "look-controls": {},
              "wasd-controls": {},
              position: {
                x: 0,
                y: 1.6,
                z: 0
              }
            },
            mappings: {
              active: "camera.active",
              far: "camera.far",
              fov: "camera.fov",
              "look-controls-enabled": "look-controls.enabled",
              near: "camera.near",
              "pointer-lock-enabled": "look-controls.pointerLockEnabled",
              "wasd-controls-enabled": "wasd-controls.enabled",
              "reverse-mouse-drag": "look-controls.reverseMouseDrag",
              zoom: "camera.zoom"
            }
          });
        },
        "./src/extras/primitives/primitives/a-cursor.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var getMeshMixin = __webpack_require__2("./src/extras/primitives/getMeshMixin.js"), registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive, utils = __webpack_require__2("./src/utils/index.js");
          registerPrimitive("a-cursor", utils.extendDeep({}, getMeshMixin(), {
            defaultComponents: {
              cursor: {},
              geometry: {
                primitive: "ring",
                radiusOuter: 0.016,
                radiusInner: 0.01,
                segmentsTheta: 32
              },
              material: {
                color: "#000",
                shader: "flat",
                opacity: 0.8
              },
              position: {
                x: 0,
                y: 0,
                z: -1
              }
            },
            mappings: {
              far: "raycaster.far",
              fuse: "cursor.fuse",
              "fuse-timeout": "cursor.fuseTimeout",
              interval: "raycaster.interval",
              objects: "raycaster.objects"
            }
          }));
        },
        "./src/extras/primitives/primitives/a-curvedimage.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var getMeshMixin = __webpack_require__2("./src/extras/primitives/getMeshMixin.js"), registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive, utils = __webpack_require__2("./src/utils/index.js");
          registerPrimitive("a-curvedimage", utils.extendDeep({}, getMeshMixin(), {
            defaultComponents: {
              geometry: {
                height: 1,
                primitive: "cylinder",
                radius: 2,
                segmentsRadial: 48,
                thetaLength: 270,
                openEnded: !0,
                thetaStart: 0
              },
              material: {
                color: "#FFF",
                shader: "flat",
                side: "double",
                transparent: !0,
                repeat: "-1 1"
              }
            },
            mappings: {
              height: "geometry.height",
              "open-ended": "geometry.openEnded",
              radius: "geometry.radius",
              segments: "geometry.segmentsRadial",
              start: "geometry.thetaStart",
              "theta-length": "geometry.thetaLength",
              "theta-start": "geometry.thetaStart",
              width: "geometry.thetaLength"
            }
          }));
        },
        "./src/extras/primitives/primitives/a-gltf-model.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive;
          registerPrimitive("a-gltf-model", {
            mappings: {
              src: "gltf-model"
            }
          });
        },
        "./src/extras/primitives/primitives/a-image.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var getMeshMixin = __webpack_require__2("./src/extras/primitives/getMeshMixin.js"), registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive, utils = __webpack_require__2("./src/utils/index.js");
          registerPrimitive("a-image", utils.extendDeep({}, getMeshMixin(), {
            defaultComponents: {
              geometry: {
                primitive: "plane"
              },
              material: {
                color: "#FFF",
                shader: "flat",
                side: "double",
                transparent: !0
              }
            },
            mappings: {
              height: "geometry.height",
              width: "geometry.width"
            }
          }));
        },
        "./src/extras/primitives/primitives/a-light.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive;
          registerPrimitive("a-light", {
            defaultComponents: {
              light: {}
            },
            mappings: {
              angle: "light.angle",
              color: "light.color",
              "ground-color": "light.groundColor",
              decay: "light.decay",
              distance: "light.distance",
              intensity: "light.intensity",
              penumbra: "light.penumbra",
              type: "light.type",
              target: "light.target",
              envmap: "light.envMap",
              "shadow-camera-automatic": "light.shadowCameraAutomatic"
            }
          });
        },
        "./src/extras/primitives/primitives/a-link.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive;
          registerPrimitive("a-link", {
            defaultComponents: {
              link: {
                visualAspectEnabled: !0
              }
            },
            mappings: {
              href: "link.href",
              image: "link.image",
              title: "link.title"
            }
          });
        },
        "./src/extras/primitives/primitives/a-obj-model.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var meshMixin = __webpack_require__2("./src/extras/primitives/getMeshMixin.js")(), registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive, utils = __webpack_require__2("./src/utils/index.js");
          registerPrimitive("a-obj-model", utils.extendDeep({}, meshMixin, {
            defaultComponents: {
              "obj-model": {}
            },
            mappings: {
              src: "obj-model.obj",
              mtl: "obj-model.mtl"
            }
          }));
        },
        "./src/extras/primitives/primitives/a-sky.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var getMeshMixin = __webpack_require__2("./src/extras/primitives/getMeshMixin.js"), registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive, utils = __webpack_require__2("./src/utils/index.js"), meshPrimitives = __webpack_require__2("./src/extras/primitives/primitives/meshPrimitives.js");
          registerPrimitive("a-sky", utils.extendDeep({}, getMeshMixin(), {
            defaultComponents: {
              geometry: {
                primitive: "sphere",
                radius: 500,
                segmentsWidth: 64,
                segmentsHeight: 32
              },
              material: {
                color: "#FFF",
                side: "back",
                shader: "flat",
                npot: !0
              },
              scale: "-1 1 1"
            },
            mappings: utils.extendDeep({}, meshPrimitives["a-sphere"].mappings)
          }));
        },
        "./src/extras/primitives/primitives/a-sound.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive;
          registerPrimitive("a-sound", {
            defaultComponents: {
              sound: {}
            },
            mappings: {
              src: "sound.src",
              on: "sound.on",
              autoplay: "sound.autoplay",
              loop: "sound.loop",
              volume: "sound.volume"
            }
          });
        },
        "./src/extras/primitives/primitives/a-text.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var definePrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").definePrimitive;
          definePrimitive("a-text", {
            text: {
              anchor: "align",
              width: 5
            }
          });
        },
        "./src/extras/primitives/primitives/a-video.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var getMeshMixin = __webpack_require__2("./src/extras/primitives/getMeshMixin.js"), registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive, utils = __webpack_require__2("./src/utils/index.js");
          registerPrimitive("a-video", utils.extendDeep({}, getMeshMixin(), {
            defaultComponents: {
              geometry: {
                primitive: "plane"
              },
              material: {
                color: "#FFF",
                shader: "flat",
                side: "double",
                transparent: !0
              }
            },
            mappings: {
              height: "geometry.height",
              width: "geometry.width"
            }
          }));
        },
        "./src/extras/primitives/primitives/a-videosphere.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var getMeshMixin = __webpack_require__2("./src/extras/primitives/getMeshMixin.js"), registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive, utils = __webpack_require__2("./src/utils/index.js");
          registerPrimitive("a-videosphere", utils.extendDeep({}, getMeshMixin(), {
            defaultComponents: {
              geometry: {
                primitive: "sphere",
                radius: 500,
                segmentsWidth: 64,
                segmentsHeight: 32
              },
              material: {
                color: "#FFF",
                shader: "flat",
                side: "back",
                npot: !0
              },
              scale: "-1 1 1"
            },
            mappings: {
              radius: "geometry.radius",
              "segments-height": "geometry.segmentsHeight",
              "segments-width": "geometry.segmentsWidth"
            }
          }));
        },
        "./src/extras/primitives/primitives/meshPrimitives.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var getMeshMixin = __webpack_require__2("./src/extras/primitives/getMeshMixin.js"), geometries = __webpack_require__2("./src/core/geometry.js").geometries, geometryNames = __webpack_require__2("./src/core/geometry.js").geometryNames, registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive, utils = __webpack_require__2("./src/utils/index.js"), meshPrimitives = module3.exports = {};
          geometryNames.forEach(function(geometryName) {
            var geometry = geometries[geometryName], geometryHyphened = unCamelCase(geometryName), mappings = {};
            Object.keys(geometry.schema).forEach(function(property) {
              mappings[unCamelCase(property)] = "geometry." + property;
            });
            var tagName = "a-" + geometryHyphened, primitive = registerPrimitive(tagName, utils.extendDeep({}, getMeshMixin(), {
              defaultComponents: {
                geometry: {
                  primitive: geometryName
                }
              },
              mappings
            }));
            meshPrimitives[tagName] = primitive;
          });
          function unCamelCase(str) {
            return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
          }
        },
        "./src/geometries/box.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js");
          registerGeometry("box", {
            schema: {
              depth: {
                default: 1,
                min: 0
              },
              height: {
                default: 1,
                min: 0
              },
              width: {
                default: 1,
                min: 0
              },
              segmentsHeight: {
                default: 1,
                min: 1,
                max: 20,
                type: "int"
              },
              segmentsWidth: {
                default: 1,
                min: 1,
                max: 20,
                type: "int"
              },
              segmentsDepth: {
                default: 1,
                min: 1,
                max: 20,
                type: "int"
              }
            },
            init: function(data) {
              this.geometry = new THREE3.BoxGeometry(data.width, data.height, data.depth, data.segmentsWidth, data.segmentsHeight, data.segmentsDepth);
            }
          });
        },
        "./src/geometries/circle.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js"), degToRad = THREE3.MathUtils.degToRad;
          registerGeometry("circle", {
            schema: {
              radius: {
                default: 1,
                min: 0
              },
              segments: {
                default: 32,
                min: 3,
                type: "int"
              },
              thetaLength: {
                default: 360,
                min: 0
              },
              thetaStart: {
                default: 0
              }
            },
            init: function(data) {
              this.geometry = new THREE3.CircleGeometry(data.radius, data.segments, degToRad(data.thetaStart), degToRad(data.thetaLength));
            }
          });
        },
        "./src/geometries/cone.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js"), degToRad = THREE3.MathUtils.degToRad;
          registerGeometry("cone", {
            schema: {
              height: {
                default: 1,
                min: 0
              },
              openEnded: {
                default: !1
              },
              radiusBottom: {
                default: 1,
                min: 0
              },
              radiusTop: {
                default: 0.01,
                min: 0
              },
              segmentsHeight: {
                default: 18,
                min: 1,
                type: "int"
              },
              segmentsRadial: {
                default: 36,
                min: 3,
                type: "int"
              },
              thetaLength: {
                default: 360,
                min: 0
              },
              thetaStart: {
                default: 0
              }
            },
            init: function(data) {
              this.geometry = new THREE3.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.segmentsRadial, data.segmentsHeight, data.openEnded, degToRad(data.thetaStart), degToRad(data.thetaLength));
            }
          });
        },
        "./src/geometries/cylinder.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js"), degToRad = THREE3.MathUtils.degToRad;
          registerGeometry("cylinder", {
            schema: {
              height: {
                default: 1,
                min: 0
              },
              openEnded: {
                default: !1
              },
              radius: {
                default: 1,
                min: 0
              },
              segmentsHeight: {
                default: 18,
                min: 1,
                type: "int"
              },
              segmentsRadial: {
                default: 36,
                min: 3,
                type: "int"
              },
              thetaLength: {
                default: 360,
                min: 0
              },
              thetaStart: {
                default: 0
              }
            },
            init: function(data) {
              this.geometry = new THREE3.CylinderGeometry(data.radius, data.radius, data.height, data.segmentsRadial, data.segmentsHeight, data.openEnded, degToRad(data.thetaStart), degToRad(data.thetaLength));
            }
          });
        },
        "./src/geometries/dodecahedron.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js");
          registerGeometry("dodecahedron", {
            schema: {
              detail: {
                default: 0,
                min: 0,
                max: 5,
                type: "int"
              },
              radius: {
                default: 1,
                min: 0
              }
            },
            init: function(data) {
              this.geometry = new THREE3.DodecahedronGeometry(data.radius, data.detail);
            }
          });
        },
        "./src/geometries/icosahedron.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js");
          registerGeometry("icosahedron", {
            schema: {
              detail: {
                default: 0,
                min: 0,
                max: 5,
                type: "int"
              },
              radius: {
                default: 1,
                min: 0
              }
            },
            init: function(data) {
              this.geometry = new THREE3.IcosahedronGeometry(data.radius, data.detail);
            }
          });
        },
        "./src/geometries/index.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2("./src/geometries/box.js"), __webpack_require__2("./src/geometries/circle.js"), __webpack_require__2("./src/geometries/cone.js"), __webpack_require__2("./src/geometries/cylinder.js"), __webpack_require__2("./src/geometries/dodecahedron.js"), __webpack_require__2("./src/geometries/icosahedron.js"), __webpack_require__2("./src/geometries/octahedron.js"), __webpack_require__2("./src/geometries/plane.js"), __webpack_require__2("./src/geometries/ring.js"), __webpack_require__2("./src/geometries/sphere.js"), __webpack_require__2("./src/geometries/tetrahedron.js"), __webpack_require__2("./src/geometries/torus.js"), __webpack_require__2("./src/geometries/torusKnot.js"), __webpack_require__2("./src/geometries/triangle.js");
        },
        "./src/geometries/octahedron.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js");
          registerGeometry("octahedron", {
            schema: {
              detail: {
                default: 0,
                min: 0,
                max: 5,
                type: "int"
              },
              radius: {
                default: 1,
                min: 0
              }
            },
            init: function(data) {
              this.geometry = new THREE3.OctahedronGeometry(data.radius, data.detail);
            }
          });
        },
        "./src/geometries/plane.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js");
          registerGeometry("plane", {
            schema: {
              height: {
                default: 1,
                min: 0
              },
              width: {
                default: 1,
                min: 0
              },
              segmentsHeight: {
                default: 1,
                min: 1,
                max: 20,
                type: "int"
              },
              segmentsWidth: {
                default: 1,
                min: 1,
                max: 20,
                type: "int"
              }
            },
            init: function(data) {
              this.geometry = new THREE3.PlaneGeometry(data.width, data.height, data.segmentsWidth, data.segmentsHeight);
            }
          });
        },
        "./src/geometries/ring.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js"), degToRad = THREE3.MathUtils.degToRad;
          registerGeometry("ring", {
            schema: {
              radiusInner: {
                default: 0.8,
                min: 0
              },
              radiusOuter: {
                default: 1.2,
                min: 0
              },
              segmentsPhi: {
                default: 10,
                min: 1,
                type: "int"
              },
              segmentsTheta: {
                default: 32,
                min: 3,
                type: "int"
              },
              thetaLength: {
                default: 360,
                min: 0
              },
              thetaStart: {
                default: 0
              }
            },
            init: function(data) {
              this.geometry = new THREE3.RingGeometry(data.radiusInner, data.radiusOuter, data.segmentsTheta, data.segmentsPhi, degToRad(data.thetaStart), degToRad(data.thetaLength));
            }
          });
        },
        "./src/geometries/sphere.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js"), degToRad = THREE3.MathUtils.degToRad;
          registerGeometry("sphere", {
            schema: {
              radius: {
                default: 1,
                min: 0
              },
              phiLength: {
                default: 360
              },
              phiStart: {
                default: 0,
                min: 0
              },
              thetaLength: {
                default: 180,
                min: 0
              },
              thetaStart: {
                default: 0
              },
              segmentsHeight: {
                default: 18,
                min: 2,
                type: "int"
              },
              segmentsWidth: {
                default: 36,
                min: 3,
                type: "int"
              }
            },
            init: function(data) {
              this.geometry = new THREE3.SphereGeometry(data.radius, data.segmentsWidth, data.segmentsHeight, degToRad(data.phiStart), degToRad(data.phiLength), degToRad(data.thetaStart), degToRad(data.thetaLength));
            }
          });
        },
        "./src/geometries/tetrahedron.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js");
          registerGeometry("tetrahedron", {
            schema: {
              detail: {
                default: 0,
                min: 0,
                max: 5,
                type: "int"
              },
              radius: {
                default: 1,
                min: 0
              }
            },
            init: function(data) {
              this.geometry = new THREE3.TetrahedronGeometry(data.radius, data.detail);
            }
          });
        },
        "./src/geometries/torus.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js"), degToRad = THREE3.MathUtils.degToRad;
          registerGeometry("torus", {
            schema: {
              arc: {
                default: 360
              },
              radius: {
                default: 1,
                min: 0
              },
              radiusTubular: {
                default: 0.2,
                min: 0
              },
              segmentsRadial: {
                default: 36,
                min: 2,
                type: "int"
              },
              segmentsTubular: {
                default: 32,
                min: 3,
                type: "int"
              }
            },
            init: function(data) {
              this.geometry = new THREE3.TorusGeometry(data.radius, data.radiusTubular * 2, data.segmentsRadial, data.segmentsTubular, degToRad(data.arc));
            }
          });
        },
        "./src/geometries/torusKnot.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js");
          registerGeometry("torusKnot", {
            schema: {
              p: {
                default: 2,
                min: 1
              },
              q: {
                default: 3,
                min: 1
              },
              radius: {
                default: 1,
                min: 0
              },
              radiusTubular: {
                default: 0.2,
                min: 0
              },
              segmentsRadial: {
                default: 8,
                min: 3,
                type: "int"
              },
              segmentsTubular: {
                default: 100,
                min: 3,
                type: "int"
              }
            },
            init: function(data) {
              this.geometry = new THREE3.TorusKnotGeometry(data.radius, data.radiusTubular * 2, data.segmentsTubular, data.segmentsRadial, data.p, data.q);
            }
          });
        },
        "./src/geometries/triangle.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, THREE3 = __webpack_require__2("./src/lib/three.js"), quaternion = new THREE3.Quaternion(), rotateVector = new THREE3.Vector3(0, 0, 1), uvMinVector = new THREE3.Vector2(), uvMaxVector = new THREE3.Vector2(), uvScaleVector = new THREE3.Vector2();
          registerGeometry("triangle", {
            schema: {
              vertexA: {
                type: "vec3",
                default: {
                  x: 0,
                  y: 0.5,
                  z: 0
                }
              },
              vertexB: {
                type: "vec3",
                default: {
                  x: -0.5,
                  y: -0.5,
                  z: 0
                }
              },
              vertexC: {
                type: "vec3",
                default: {
                  x: 0.5,
                  y: -0.5,
                  z: 0
                }
              }
            },
            init: function(data) {
              var geometry, normal, triangle, uvA, uvB, uvC, vertices, normals, uvs;
              triangle = new THREE3.Triangle(), triangle.a.set(data.vertexA.x, data.vertexA.y, data.vertexA.z), triangle.b.set(data.vertexB.x, data.vertexB.y, data.vertexB.z), triangle.c.set(data.vertexC.x, data.vertexC.y, data.vertexC.z), normal = triangle.getNormal(new THREE3.Vector3()), quaternion.setFromUnitVectors(normal, rotateVector), uvA = triangle.a.clone().applyQuaternion(quaternion), uvB = triangle.b.clone().applyQuaternion(quaternion), uvC = triangle.c.clone().applyQuaternion(quaternion), uvMinVector.set(Math.min(uvA.x, uvB.x, uvC.x), Math.min(uvA.y, uvB.y, uvC.y)), uvMaxVector.set(Math.max(uvA.x, uvB.x, uvC.x), Math.max(uvA.y, uvB.y, uvC.y)), uvScaleVector.set(0, 0).subVectors(uvMaxVector, uvMinVector), uvA = new THREE3.Vector2().subVectors(uvA, uvMinVector).divide(uvScaleVector), uvB = new THREE3.Vector2().subVectors(uvB, uvMinVector).divide(uvScaleVector), uvC = new THREE3.Vector2().subVectors(uvC, uvMinVector).divide(uvScaleVector), geometry = this.geometry = new THREE3.BufferGeometry(), vertices = [triangle.a.x, triangle.a.y, triangle.a.z, triangle.b.x, triangle.b.y, triangle.b.z, triangle.c.x, triangle.c.y, triangle.c.z], normals = [normal.x, normal.y, normal.z, normal.x, normal.y, normal.z, normal.x, normal.y, normal.z], uvs = [uvA.x, uvA.y, uvB.x, uvB.y, uvC.x, uvC.y], geometry.setAttribute("position", new THREE3.Float32BufferAttribute(vertices, 3)), geometry.setAttribute("normal", new THREE3.Float32BufferAttribute(normals, 3)), geometry.setAttribute("uv", new THREE3.Float32BufferAttribute(uvs, 2));
            }
          });
        },
        "./src/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          if (window.hasNativeWebVRImplementation = !!window.navigator.getVRDisplays || !!window.navigator.getVRDevices, window.hasNativeWebXRImplementation = navigator.xr !== void 0, !window.hasNativeWebXRImplementation && !window.hasNativeWebVRImplementation) {
            var isIOSOlderThan10 = __webpack_require__2("./src/utils/isIOSOlderThan10.js"), bufferScale = isIOSOlderThan10(window.navigator.userAgent) ? 1 / window.devicePixelRatio : 1, WebVRPolyfill = __webpack_require__2("./node_modules/webvr-polyfill/build/webvr-polyfill.js"), polyfillConfig = {
              BUFFER_SCALE: bufferScale,
              CARDBOARD_UI_DISABLED: !0,
              ROTATE_INSTRUCTIONS_DISABLED: !0,
              MOBILE_WAKE_LOCK: !!window.cordova
            };
            window.webvrpolyfill = new WebVRPolyfill(polyfillConfig);
          }
          var utils = __webpack_require__2("./src/utils/index.js"), debug = utils.debug, error = debug("A-Frame:error"), warn = debug("A-Frame:warn");
          window.document.currentScript && window.document.currentScript.parentNode !== window.document.head && !window.debug && warn("Put the A-Frame <script> tag in the <head> of the HTML *before* the scene to ensure everything for A-Frame is properly registered before they are used from HTML."), !window.cordova && window.location.protocol === "file:" && error("This HTML file is currently being served via the file:// protocol. Assets, textures, and models WILL NOT WORK due to cross-origin policy! Please use a local or hosted server: https://aframe.io/docs/1.4.0/introduction/installation.html#use-a-local-server."), utils.device.isBrowserEnvironment && (__webpack_require__2("./src/style/aframe.css"), __webpack_require__2("./src/style/rStats.css"));
          var AScene = __webpack_require__2("./src/core/scene/a-scene.js").AScene, components = __webpack_require__2("./src/core/component.js").components, registerComponent = __webpack_require__2("./src/core/component.js").registerComponent, registerGeometry = __webpack_require__2("./src/core/geometry.js").registerGeometry, registerPrimitive = __webpack_require__2("./src/extras/primitives/primitives.js").registerPrimitive, registerShader = __webpack_require__2("./src/core/shader.js").registerShader, registerSystem = __webpack_require__2("./src/core/system.js").registerSystem, shaders = __webpack_require__2("./src/core/shader.js").shaders, systems = __webpack_require__2("./src/core/system.js").systems, THREE3 = window.THREE = __webpack_require__2("./src/lib/three.js"), readyState = __webpack_require__2("./src/core/readyState.js"), pkg = __webpack_require__2("./package.json");
          __webpack_require__2("./src/components/index.js"), __webpack_require__2("./src/geometries/index.js"), __webpack_require__2("./src/shaders/index.js"), __webpack_require__2("./src/systems/index.js");
          var ANode = __webpack_require__2("./src/core/a-node.js").ANode, AEntity = __webpack_require__2("./src/core/a-entity.js").AEntity;
          __webpack_require__2("./src/core/a-assets.js"), __webpack_require__2("./src/core/a-cubemap.js"), __webpack_require__2("./src/core/a-mixin.js"), __webpack_require__2("./src/extras/components/index.js"), __webpack_require__2("./src/extras/primitives/index.js"), console.log("A-Frame Version: 1.6.0 (Date 2024-05-23, Commit #e6c47761)"), console.log("THREE Version (https://github.com/supermedium/three.js):", THREE3.REVISION), console.log("WebVR Polyfill Version:", pkg.dependencies["webvr-polyfill"]), window.AFRAME_ASYNC || readyState.waitForDocumentReadyState(), module3.exports = window.AFRAME = {
            AComponent: __webpack_require__2("./src/core/component.js").Component,
            AEntity,
            ANode,
            ANIME: __webpack_require__2("./node_modules/super-animejs/lib/anime.es.js").default,
            AScene,
            components,
            coreComponents: Object.keys(components),
            geometries: __webpack_require__2("./src/core/geometry.js").geometries,
            registerComponent,
            registerGeometry,
            registerPrimitive,
            registerShader,
            registerSystem,
            primitives: {
              getMeshMixin: __webpack_require__2("./src/extras/primitives/getMeshMixin.js"),
              primitives: __webpack_require__2("./src/extras/primitives/primitives.js").primitives
            },
            scenes: __webpack_require__2("./src/core/scene/scenes.js"),
            schema: __webpack_require__2("./src/core/schema.js"),
            shaders,
            systems,
            emitReady: readyState.emitReady,
            THREE: THREE3,
            utils,
            version: pkg.version
          };
        },
        "./src/lib/rStatsAframe.js": (module3) => {
          window.aframeStats = function(scene) {
            var _rS = null, _scene = scene, _values = {
              te: {
                caption: "Entities"
              },
              lt: {
                caption: "Load Time"
              }
            }, _groups = [{
              caption: "A-Frame",
              values: ["te", "lt"]
            }];
            function _update() {
              _rS("te").set(getEntityCount()), window.performance.getEntriesByName && _rS("lt").set(window.performance.getEntriesByName("render-started")[0].startTime.toFixed(0));
            }
            function getEntityCount() {
              var elements = _scene.querySelectorAll("*");
              return Array.prototype.slice.call(elements).filter(function(el) {
                return el.isEntity;
              }), elements.length;
            }
            function _start() {
            }
            function _end() {
            }
            function _attach(r) {
              _rS = r;
            }
            return {
              update: _update,
              start: _start,
              end: _end,
              attach: _attach,
              values: _values,
              groups: _groups,
              fractions: []
            };
          }, module3.exports = {
            aframeStats: window.aframeStats
          };
        },
        "./src/lib/three.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var THREE3 = __webpack_require__2("./src/lib/three.mjs").default;
          __webpack_require__2.g.THREE = THREE3, __webpack_require__2("./vendor/DeviceOrientationControls.js"), THREE3.Cache && (THREE3.Cache.enabled = !0), module3.exports = THREE3;
        },
        "./src/shaders/flat.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerShader = __webpack_require__2("./src/core/shader.js").registerShader, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js");
          module3.exports.Shader = registerShader("flat", {
            schema: {
              color: {
                type: "color"
              },
              fog: {
                default: !0
              },
              height: {
                default: 256
              },
              offset: {
                type: "vec2",
                default: {
                  x: 0,
                  y: 0
                }
              },
              repeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              src: {
                type: "map"
              },
              width: {
                default: 512
              },
              wireframe: {
                default: !1
              },
              wireframeLinewidth: {
                default: 2
              },
              toneMapped: {
                default: !0
              }
            },
            init: function(data) {
              this.materialData = {
                color: new THREE3.Color()
              }, getMaterialData(data, this.materialData), this.material = new THREE3.MeshBasicMaterial(this.materialData);
            },
            update: function(data) {
              this.updateMaterial(data), utils.material.updateMap(this, data);
            },
            updateMaterial: function(data) {
              var key;
              getMaterialData(data, this.materialData);
              for (key in this.materialData)
                this.material[key] = this.materialData[key];
            }
          });
          function getMaterialData(data, materialData) {
            return materialData.color.set(data.color), materialData.fog = data.fog, materialData.wireframe = data.wireframe, materialData.toneMapped = data.toneMapped, materialData.wireframeLinewidth = data.wireframeLinewidth, materialData;
          }
        },
        "./src/shaders/index.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2("./src/shaders/flat.js"), __webpack_require__2("./src/shaders/standard.js"), __webpack_require__2("./src/shaders/phong.js"), __webpack_require__2("./src/shaders/sdf.js"), __webpack_require__2("./src/shaders/msdf.js"), __webpack_require__2("./src/shaders/shadow.js");
        },
        "./src/shaders/msdf.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerShader = __webpack_require__2("./src/core/shader.js").registerShader, THREE3 = __webpack_require__2("./src/lib/three.js"), VERTEX_SHADER = ["#include <common>", "#include <fog_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "out vec2 vUV;", "void main(void) {", "  vUV = uv;", "  #include <begin_vertex>", "  #include <project_vertex>", "  #include <logdepthbuf_vertex>", "  #include <fog_vertex>", "}"].join(`
`), FRAGMENT_SHADER = [
            "#include <common>",
            "#include <fog_pars_fragment>",
            "#include <logdepthbuf_pars_fragment>",
            "uniform bool negate;",
            "uniform float alphaTest;",
            "uniform float opacity;",
            "uniform sampler2D map;",
            "uniform vec3 color;",
            "in vec2 vUV;",
            "float median(float r, float g, float b) {",
            "  return max(min(r, g), min(max(r, g), b));",
            "}",
            "#define BIG_ENOUGH 0.001",
            "#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)",
            "void main() {",
            "  vec3 sampleColor = texture(map, vUV).rgb;",
            "  if (negate) { sampleColor = 1.0 - sampleColor; }",
            "  float sigDist = median(sampleColor.r, sampleColor.g, sampleColor.b) - 0.5;",
            "  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);",
            "  float dscale = 0.353505;",
            "  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));",
            "  float isBigEnough = max(abs(duv.x), abs(duv.y));",
            "  // Do modified alpha test.",
            "  if (isBigEnough > BIG_ENOUGH) {",
            "    float ratio = BIG_ENOUGH / isBigEnough;",
            "    alpha = ratio * alpha + (1.0 - ratio) * (sigDist + 0.5);",
            "  }",
            "  // Do modified alpha test.",
            "  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }",
            "  gl_FragColor = vec4(color.xyz, alpha * opacity);",
            "  #include <logdepthbuf_fragment>",
            "  #include <tonemapping_fragment>",
            "  #include <colorspace_fragment>",
            "  #include <fog_fragment>",
            "}"
          ].join(`
`);
          module3.exports.Shader = registerShader("msdf", {
            schema: {
              alphaTest: {
                type: "number",
                is: "uniform",
                default: 0.5
              },
              color: {
                type: "color",
                is: "uniform",
                default: "white"
              },
              map: {
                type: "map",
                is: "uniform"
              },
              negate: {
                type: "boolean",
                is: "uniform",
                default: !0
              },
              opacity: {
                type: "number",
                is: "uniform",
                default: 1
              }
            },
            vertexShader: VERTEX_SHADER,
            fragmentShader: FRAGMENT_SHADER,
            init: function() {
              return this.uniforms = THREE3.UniformsUtils.merge([THREE3.UniformsLib.fog, this.initUniforms()]), this.material = new THREE3.ShaderMaterial({
                uniforms: this.uniforms,
                vertexShader: this.vertexShader,
                fragmentShader: this.fragmentShader,
                fog: !0
              }), this.material;
            }
          });
        },
        "./src/shaders/phong.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerShader = __webpack_require__2("./src/core/shader.js").registerShader, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js");
          module3.exports.Shader = registerShader("phong", {
            schema: {
              color: {
                type: "color"
              },
              emissive: {
                type: "color",
                default: "black"
              },
              emissiveIntensity: {
                default: 1
              },
              specular: {
                type: "color",
                default: "#111111"
              },
              transparent: {
                default: !1
              },
              fog: {
                default: !0
              },
              offset: {
                type: "vec2",
                default: {
                  x: 0,
                  y: 0
                }
              },
              repeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              src: {
                type: "map"
              },
              envMap: {
                default: ""
              },
              sphericalEnvMap: {
                type: "map"
              },
              shininess: {
                default: 30
              },
              flatShading: {
                default: !1
              },
              wireframe: {
                default: !1
              },
              wireframeLinewidth: {
                default: 2
              },
              combine: {
                oneOF: ["multiply", "mix", "add"],
                default: "mix"
              },
              reflectivity: {
                default: 0.9
              },
              refractionRatio: {
                default: 0.98
              },
              refract: {
                default: !1
              },
              normalMap: {
                type: "map"
              },
              normalScale: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              normalTextureOffset: {
                type: "vec2"
              },
              normalTextureRepeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              ambientOcclusionMap: {
                type: "map"
              },
              ambientOcclusionMapIntensity: {
                default: 1
              },
              displacementMap: {
                type: "map"
              },
              displacementScale: {
                default: 1
              },
              displacementBias: {
                default: 0.5
              },
              displacementTextureOffset: {
                type: "vec2"
              },
              displacementTextureRepeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              bumpMap: {
                type: "map"
              },
              bumpMapScale: {
                default: 1
              },
              bumpTextureOffset: {
                type: "vec2"
              },
              bumpTextureRepeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              }
            },
            init: function(data) {
              this.materialData = {
                color: new THREE3.Color(),
                specular: new THREE3.Color(),
                emissive: new THREE3.Color()
              }, getMaterialData(data, this.materialData), this.material = new THREE3.MeshPhongMaterial(this.materialData);
              var sceneEl = this.el.sceneEl;
              Object.defineProperty(this.material, "envMap", {
                get: function() {
                  return this._envMap || sceneEl.object3D.environment;
                },
                set: function(value) {
                  this._envMap = value;
                }
              });
            },
            update: function(data) {
              this.updateMaterial(data), utils.material.updateMap(this, data), utils.material.updateDistortionMap("normal", this, data), utils.material.updateDistortionMap("displacement", this, data), utils.material.updateDistortionMap("ambientOcclusion", this, data), utils.material.updateDistortionMap("bump", this, data), utils.material.updateEnvMap(this, data);
            },
            updateMaterial: function(data) {
              var key;
              getMaterialData(data, this.materialData);
              for (key in this.materialData)
                this.material[key] = this.materialData[key];
            }
          });
          function getMaterialData(data, materialData) {
            switch (materialData.color.set(data.color), materialData.specular.set(data.specular), materialData.emissive.set(data.emissive), materialData.emissiveIntensity = data.emissiveIntensity, materialData.fog = data.fog, materialData.transparent = data.transparent, materialData.wireframe = data.wireframe, materialData.wireframeLinewidth = data.wireframeLinewidth, materialData.shininess = data.shininess, materialData.flatShading = data.flatShading, materialData.wireframe = data.wireframe, materialData.wireframeLinewidth = data.wireframeLinewidth, materialData.reflectivity = data.reflectivity, materialData.refractionRatio = data.refractionRatio, data.combine) {
              case "mix":
                materialData.combine = THREE3.MixOperation;
                break;
              case "multiply":
                materialData.combine = THREE3.MultiplyOperation;
                break;
              case "add":
                materialData.combine = THREE3.AddOperation;
                break;
            }
            return data.normalMap && (materialData.normalScale = data.normalScale), data.ambientOcclusionMap && (materialData.aoMapIntensity = data.ambientOcclusionMapIntensity), data.bumpMap && (materialData.bumpScale = data.bumpMapScale), data.displacementMap && (materialData.displacementScale = data.displacementScale, materialData.displacementBias = data.displacementBias), materialData;
          }
        },
        "./src/shaders/sdf.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerShader = __webpack_require__2("./src/core/shader.js").registerShader, THREE3 = __webpack_require__2("./src/lib/three.js"), VERTEX_SHADER = ["#include <common>", "#include <fog_pars_vertex>", "#include <logdepthbuf_pars_vertex>", "out vec2 vUV;", "void main(void) {", "  vUV = uv;", "  #include <begin_vertex>", "  #include <project_vertex>", "  #include <logdepthbuf_vertex>", "  #include <fog_vertex>", "}"].join(`
`), FRAGMENT_SHADER = [
            "#include <common>",
            "#include <fog_pars_fragment>",
            "#include <logdepthbuf_pars_fragment>",
            "uniform float alphaTest;",
            "uniform float opacity;",
            "uniform sampler2D map;",
            "uniform vec3 color;",
            "in vec2 vUV;",
            "float contour(float width, float value) {",
            "  return smoothstep(0.5 - value, 0.5 + value, width);",
            "}",
            "#define BIG_ENOUGH 0.001",
            "#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)",
            "void main() {",
            "  vec2 uv = vUV;",
            "  vec4 texColor = texture(map, uv);",
            "  float dist = texColor.a;",
            "  float width = fwidth(dist);",
            "  float alpha = contour(dist, width);",
            "  float dscale = 0.353505;",
            "  vec2 duv = dscale * (dFdx(uv) + dFdy(uv));",
            "  float isBigEnough = max(abs(duv.x), abs(duv.y));",
            "  if (isBigEnough > BIG_ENOUGH) {",
            "    float ratio = BIG_ENOUGH / isBigEnough;",
            "    alpha = ratio * alpha + (1.0 - ratio) * dist;",
            "  }",
            "  if (isBigEnough <= BIG_ENOUGH) {",
            "    vec4 box = vec4 (uv - duv, uv + duv);",
            "    alpha = (alpha + 0.5 * (",
            "      contour(texture(map, box.xy).a, width)",
            "      + contour(texture(map, box.zw).a, width)",
            "      + contour(texture(map, box.xw).a, width)",
            "      + contour(texture(map, box.zy).a, width)",
            "    )) / 3.0;",
            "  }",
            "  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }",
            "  gl_FragColor = vec4(color, opacity * alpha);",
            "  #include <logdepthbuf_fragment>",
            "  #include <tonemapping_fragment>",
            "  #include <colorspace_fragment>",
            "  #include <fog_fragment>",
            "}"
          ].join(`
`);
          module3.exports.Shader = registerShader("sdf", {
            schema: {
              alphaTest: {
                type: "number",
                is: "uniform",
                default: 0.5
              },
              color: {
                type: "color",
                is: "uniform",
                default: "white"
              },
              map: {
                type: "map",
                is: "uniform"
              },
              opacity: {
                type: "number",
                is: "uniform",
                default: 1
              }
            },
            vertexShader: VERTEX_SHADER,
            fragmentShader: FRAGMENT_SHADER,
            init: function() {
              return this.uniforms = THREE3.UniformsUtils.merge([THREE3.UniformsLib.fog, this.initUniforms()]), this.material = new THREE3.ShaderMaterial({
                uniforms: this.uniforms,
                vertexShader: this.vertexShader,
                fragmentShader: this.fragmentShader,
                fog: !0
              }), this.material;
            }
          });
        },
        "./src/shaders/shadow.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerShader = __webpack_require__2("./src/core/shader.js").registerShader, THREE3 = __webpack_require__2("./src/lib/three.js");
          module3.exports.Shader = registerShader("shadow", {
            schema: {
              opacity: {
                default: 0.5
              },
              transparent: {
                default: !0
              },
              alphaToCoverage: {
                default: !0
              }
            },
            init: function(data) {
              this.material = new THREE3.ShadowMaterial();
            },
            update: function(data) {
              this.material.opacity = data.opacity, this.material.alphaToCoverage = data.alphaToCoverage, this.material.transparent = data.transparent;
            }
          });
        },
        "./src/shaders/standard.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerShader = __webpack_require__2("./src/core/shader.js").registerShader, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js");
          module3.exports.Shader = registerShader("standard", {
            schema: {
              ambientOcclusionMap: {
                type: "map"
              },
              ambientOcclusionMapIntensity: {
                default: 1
              },
              ambientOcclusionTextureOffset: {
                type: "vec2"
              },
              ambientOcclusionTextureRepeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              color: {
                type: "color"
              },
              displacementMap: {
                type: "map"
              },
              displacementScale: {
                default: 1
              },
              displacementBias: {
                default: 0.5
              },
              displacementTextureOffset: {
                type: "vec2"
              },
              displacementTextureRepeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              emissive: {
                type: "color",
                default: "#000"
              },
              emissiveIntensity: {
                default: 1
              },
              envMap: {
                default: ""
              },
              fog: {
                default: !0
              },
              height: {
                default: 256
              },
              metalness: {
                default: 0,
                min: 0,
                max: 1
              },
              metalnessMap: {
                type: "map"
              },
              metalnessTextureOffset: {
                type: "vec2"
              },
              metalnessTextureRepeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              normalMap: {
                type: "map"
              },
              normalScale: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              normalTextureOffset: {
                type: "vec2"
              },
              normalTextureRepeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              offset: {
                type: "vec2",
                default: {
                  x: 0,
                  y: 0
                }
              },
              repeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              roughness: {
                default: 0.5,
                min: 0,
                max: 1
              },
              roughnessMap: {
                type: "map"
              },
              roughnessTextureOffset: {
                type: "vec2"
              },
              roughnessTextureRepeat: {
                type: "vec2",
                default: {
                  x: 1,
                  y: 1
                }
              },
              sphericalEnvMap: {
                type: "map"
              },
              src: {
                type: "map"
              },
              width: {
                default: 512
              },
              wireframe: {
                default: !1
              },
              wireframeLinewidth: {
                default: 2
              }
            },
            init: function(data) {
              this.materialData = {
                color: new THREE3.Color(),
                emissive: new THREE3.Color()
              }, getMaterialData(data, this.materialData), this.material = new THREE3.MeshStandardMaterial(this.materialData);
            },
            update: function(data) {
              this.updateMaterial(data), utils.material.updateMap(this, data), utils.material.updateDistortionMap("normal", this, data), utils.material.updateDistortionMap("displacement", this, data), utils.material.updateDistortionMap("ambientOcclusion", this, data), utils.material.updateDistortionMap("metalness", this, data), utils.material.updateDistortionMap("roughness", this, data), utils.material.updateEnvMap(this, data);
            },
            updateMaterial: function(data) {
              var key, material = this.material;
              getMaterialData(data, this.materialData);
              for (key in this.materialData)
                material[key] = this.materialData[key];
            }
          });
          function getMaterialData(data, materialData) {
            return materialData.color.set(data.color), materialData.emissive.set(data.emissive), materialData.emissiveIntensity = data.emissiveIntensity, materialData.fog = data.fog, materialData.metalness = data.metalness, materialData.roughness = data.roughness, materialData.wireframe = data.wireframe, materialData.wireframeLinewidth = data.wireframeLinewidth, data.normalMap && (materialData.normalScale = data.normalScale), data.ambientOcclusionMap && (materialData.aoMapIntensity = data.ambientOcclusionMapIntensity), data.displacementMap && (materialData.displacementScale = data.displacementScale, materialData.displacementBias = data.displacementBias), materialData;
          }
        },
        "./src/systems/camera.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var constants = __webpack_require__2("./src/constants/index.js"), registerSystem = __webpack_require__2("./src/core/system.js").registerSystem, DEFAULT_CAMERA_ATTR = "data-aframe-default-camera";
          module3.exports.System = registerSystem("camera", {
            init: function() {
              this.activeCameraEl = null, this.render = this.render.bind(this), this.unwrapRender = this.unwrapRender.bind(this), this.wrapRender = this.wrapRender.bind(this), this.initialCameraFound = !1, this.numUserCameras = 0, this.numUserCamerasChecked = 0, this.setupInitialCamera();
            },
            setupInitialCamera: function() {
              var cameraEls, i, sceneEl = this.sceneEl, self2 = this;
              if (sceneEl.camera && !sceneEl.camera.el.getAttribute("camera").spectator) {
                sceneEl.emit("cameraready", {
                  cameraEl: sceneEl.camera.el
                });
                return;
              }
              if (cameraEls = sceneEl.querySelectorAll("a-camera, :not(a-mixin)[camera]"), !cameraEls.length) {
                this.createDefaultCamera();
                return;
              }
              for (this.numUserCameras = cameraEls.length, i = 0; i < cameraEls.length; i++)
                cameraEls[i].addEventListener("object3dset", function(evt) {
                  evt.detail.type === "camera" && self2.checkUserCamera(this);
                }), cameraEls[i].isNode ? cameraEls[i].load() : cameraEls[i].addEventListener("nodeready", function() {
                  this.load();
                });
            },
            checkUserCamera: function(cameraEl) {
              var cameraData, sceneEl = this.el.sceneEl;
              if (this.numUserCamerasChecked++, !this.initialCameraFound) {
                if (cameraData = cameraEl.getAttribute("camera"), !cameraData.active || cameraData.spectator) {
                  this.numUserCamerasChecked === this.numUserCameras && this.createDefaultCamera();
                  return;
                }
                this.initialCameraFound = !0, sceneEl.camera = cameraEl.getObject3D("camera"), sceneEl.emit("cameraready", {
                  cameraEl
                });
              }
            },
            createDefaultCamera: function() {
              var defaultCameraEl, sceneEl = this.sceneEl;
              defaultCameraEl = document.createElement("a-entity"), defaultCameraEl.setAttribute("camera", {
                active: !0
              }), defaultCameraEl.setAttribute("position", {
                x: 0,
                y: constants.DEFAULT_CAMERA_HEIGHT,
                z: 0
              }), defaultCameraEl.setAttribute("wasd-controls", ""), defaultCameraEl.setAttribute("look-controls", ""), defaultCameraEl.setAttribute(constants.AFRAME_INJECTED, ""), defaultCameraEl.addEventListener("object3dset", function(evt) {
                evt.detail.type === "camera" && (sceneEl.camera = evt.detail.object, sceneEl.emit("cameraready", {
                  cameraEl: defaultCameraEl
                }));
              }), sceneEl.appendChild(defaultCameraEl);
            },
            disableActiveCamera: function() {
              var cameraEls, newActiveCameraEl;
              cameraEls = this.sceneEl.querySelectorAll(":not(a-mixin)[camera]"), newActiveCameraEl = cameraEls[cameraEls.length - 1], newActiveCameraEl.setAttribute("camera", "active", !0);
            },
            setActiveCamera: function(newCameraEl) {
              var cameraEl, cameraEls, i, newCamera, previousCamera = this.activeCameraEl, sceneEl = this.sceneEl;
              if (newCamera = newCameraEl.getObject3D("camera"), !(!newCamera || newCameraEl === this.activeCameraEl)) {
                var defaultCameraWrapper = sceneEl.querySelector("[" + DEFAULT_CAMERA_ATTR + "]"), defaultCameraEl = defaultCameraWrapper && defaultCameraWrapper.querySelector(":not(a-mixin)[camera]");
                for (newCameraEl !== defaultCameraEl && removeDefaultCamera(sceneEl), this.activeCameraEl = newCameraEl, this.activeCameraEl.play(), sceneEl.camera = newCamera, previousCamera && previousCamera.setAttribute("camera", "active", !1), cameraEls = sceneEl.querySelectorAll(":not(a-mixin)[camera]"), i = 0; i < cameraEls.length; i++)
                  cameraEl = cameraEls[i], !(!cameraEl.isEntity || newCameraEl === cameraEl) && (cameraEl.setAttribute("camera", "active", !1), cameraEl.pause());
                sceneEl.emit("camera-set-active", {
                  cameraEl: newCameraEl
                });
              }
            },
            setSpectatorCamera: function(newCameraEl) {
              var newCamera, previousCamera = this.spectatorCameraEl, sceneEl = this.sceneEl, spectatorCameraEl;
              newCamera = newCameraEl.getObject3D("camera"), !(!newCamera || newCameraEl === this.spectatorCameraEl) && (previousCamera && previousCamera.setAttribute("camera", "spectator", !1), spectatorCameraEl = this.spectatorCameraEl = newCameraEl, sceneEl.addEventListener("enter-vr", this.wrapRender), sceneEl.addEventListener("exit-vr", this.unwrapRender), spectatorCameraEl.setAttribute("camera", "active", !1), spectatorCameraEl.play(), sceneEl.emit("camera-set-spectator", {
                cameraEl: newCameraEl
              }));
            },
            disableSpectatorCamera: function() {
              this.spectatorCameraEl = void 0;
            },
            wrapRender: function() {
              !this.spectatorCameraEl || this.originalRender || (this.originalRender = this.sceneEl.renderer.render, this.sceneEl.renderer.render = this.render);
            },
            unwrapRender: function() {
              !this.originalRender || (this.sceneEl.renderer.render = this.originalRender, this.originalRender = void 0);
            },
            render: function(scene, camera) {
              var isVREnabled, sceneEl = this.sceneEl, spectatorCamera;
              isVREnabled = sceneEl.renderer.xr.enabled, this.originalRender.call(sceneEl.renderer, scene, camera), !(!this.spectatorCameraEl || sceneEl.isMobile || !isVREnabled) && (spectatorCamera = this.spectatorCameraEl.components.camera.camera, sceneEl.renderer.xr.enabled = !1, this.originalRender.call(sceneEl.renderer, scene, spectatorCamera), sceneEl.renderer.xr.enabled = isVREnabled);
            }
          });
          function removeDefaultCamera(sceneEl) {
            var defaultCamera, camera = sceneEl.camera;
            !camera || (defaultCamera = sceneEl.querySelector("[" + DEFAULT_CAMERA_ATTR + "]"), !!defaultCamera && sceneEl.removeChild(defaultCamera));
          }
        },
        "./src/systems/geometry.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var geometries = __webpack_require__2("./src/core/geometry.js").geometries, registerSystem = __webpack_require__2("./src/core/system.js").registerSystem;
          module3.exports.System = registerSystem("geometry", {
            init: function() {
              this.cache = {}, this.cacheCount = {};
            },
            clearCache: function() {
              this.cache = {}, this.cacheCount = {};
            },
            getOrCreateGeometry: function(data) {
              var cache = this.cache, cachedGeometry, hash;
              return data.skipCache ? createGeometry(data) : (hash = this.hash(data), cachedGeometry = cache[hash], incrementCacheCount(this.cacheCount, hash), cachedGeometry || (cachedGeometry = createGeometry(data), cache[hash] = cachedGeometry, cachedGeometry));
            },
            unuseGeometry: function(data) {
              var cache = this.cache, cacheCount = this.cacheCount, geometry, hash;
              data.skipCache || (hash = this.hash(data), !!cache[hash] && (decrementCacheCount(cacheCount, hash), !(cacheCount[hash] > 0) && (geometry = cache[hash], geometry.dispose(), delete cache[hash], delete cacheCount[hash])));
            },
            hash: function(data) {
              return JSON.stringify(data);
            }
          });
          function createGeometry(data) {
            var geometryType = data.primitive, GeometryClass = geometries[geometryType] && geometries[geometryType].Geometry, geometryInstance = new GeometryClass();
            if (!GeometryClass)
              throw new Error("Unknown geometry `" + geometryType + "`");
            return geometryInstance.init(data), geometryInstance.geometry;
          }
          function decrementCacheCount(cacheCount, hash) {
            cacheCount[hash]--;
          }
          function incrementCacheCount(cacheCount, hash) {
            cacheCount[hash] = cacheCount[hash] === void 0 ? 1 : cacheCount[hash] + 1;
          }
        },
        "./src/systems/gltf-model.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerSystem = __webpack_require__2("./src/core/system.js").registerSystem, THREE3 = __webpack_require__2("./src/lib/three.js");
          function fetchScript(src) {
            return new Promise(function(resolve, reject) {
              var script = document.createElement("script");
              document.body.appendChild(script), script.onload = resolve, script.onerror = reject, script.async = !0, script.src = src;
            });
          }
          module3.exports.System = registerSystem("gltf-model", {
            schema: {
              dracoDecoderPath: {
                default: "https://www.gstatic.com/draco/versioned/decoders/1.5.6/"
              },
              basisTranscoderPath: {
                default: ""
              },
              meshoptDecoderPath: {
                default: ""
              }
            },
            init: function() {
              this.update();
            },
            update: function() {
              var dracoDecoderPath = this.data.dracoDecoderPath, basisTranscoderPath = this.data.basisTranscoderPath, meshoptDecoderPath = this.data.meshoptDecoderPath;
              !this.dracoLoader && dracoDecoderPath && (this.dracoLoader = new THREE3.DRACOLoader(), this.dracoLoader.setDecoderPath(dracoDecoderPath)), !this.ktx2Loader && basisTranscoderPath && (this.ktx2Loader = new THREE3.KTX2Loader(), this.ktx2Loader.setTranscoderPath(basisTranscoderPath).detectSupport(this.el.renderer)), !this.meshoptDecoder && meshoptDecoderPath && (this.meshoptDecoder = fetchScript(meshoptDecoderPath).then(function() {
                return window.MeshoptDecoder.ready;
              }).then(function() {
                return window.MeshoptDecoder;
              }));
            },
            getDRACOLoader: function() {
              return this.dracoLoader;
            },
            getKTX2Loader: function() {
              return this.ktx2Loader;
            },
            getMeshoptDecoder: function() {
              return this.meshoptDecoder;
            }
          });
        },
        "./src/systems/index.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2("./src/systems/camera.js"), __webpack_require__2("./src/systems/geometry.js"), __webpack_require__2("./src/systems/gltf-model.js"), __webpack_require__2("./src/systems/light.js"), __webpack_require__2("./src/systems/material.js"), __webpack_require__2("./src/systems/obb-collider.js"), __webpack_require__2("./src/systems/renderer.js"), __webpack_require__2("./src/systems/shadow.js"), __webpack_require__2("./src/systems/tracked-controls-webvr.js"), __webpack_require__2("./src/systems/tracked-controls-webxr.js"), __webpack_require__2("./src/systems/webxr.js");
        },
        "./src/systems/light.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerSystem = __webpack_require__2("./src/core/system.js").registerSystem, constants = __webpack_require__2("./src/constants/index.js"), DEFAULT_LIGHT_ATTR = "data-aframe-default-light";
          module3.exports.System = registerSystem("light", {
            schema: {
              defaultLightsEnabled: {
                default: !0
              }
            },
            init: function() {
              this.defaultLights = !1, this.userDefinedLights = !1, this.sceneEl.addEventListener("loaded", this.setupDefaultLights.bind(this));
            },
            registerLight: function(el) {
              el.hasAttribute(DEFAULT_LIGHT_ATTR) || (this.removeDefaultLights(), this.userDefinedLights = !0);
            },
            removeDefaultLights: function() {
              var defaultLights, sceneEl = this.sceneEl;
              if (!!this.defaultLights) {
                defaultLights = document.querySelectorAll("[" + DEFAULT_LIGHT_ATTR + "]");
                for (var i = 0; i < defaultLights.length; i++)
                  sceneEl.removeChild(defaultLights[i]);
                this.defaultLights = !1;
              }
            },
            setupDefaultLights: function() {
              var sceneEl = this.sceneEl, ambientLight, directionalLight;
              this.userDefinedLights || this.defaultLights || !this.data.defaultLightsEnabled || (ambientLight = document.createElement("a-entity"), ambientLight.setAttribute("light", {
                color: "#BBB",
                type: "ambient"
              }), ambientLight.setAttribute(DEFAULT_LIGHT_ATTR, ""), ambientLight.setAttribute(constants.AFRAME_INJECTED, ""), sceneEl.appendChild(ambientLight), directionalLight = document.createElement("a-entity"), directionalLight.setAttribute("light", {
                color: "#FFF",
                intensity: 0.6,
                castShadow: !0
              }), directionalLight.setAttribute("position", {
                x: -0.5,
                y: 1,
                z: 1
              }), directionalLight.setAttribute(DEFAULT_LIGHT_ATTR, ""), directionalLight.setAttribute(constants.AFRAME_INJECTED, ""), sceneEl.appendChild(directionalLight), this.defaultLights = !0);
            }
          });
        },
        "./src/systems/material.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerSystem = __webpack_require__2("./src/core/system.js").registerSystem, THREE3 = __webpack_require__2("./src/lib/three.js"), utils = __webpack_require__2("./src/utils/index.js"), setTextureProperties = __webpack_require__2("./src/utils/material.js").setTextureProperties, createCompatibleTexture = __webpack_require__2("./src/utils/material.js").createCompatibleTexture, debug = utils.debug, error = debug("components:texture:error"), warn = debug("components:texture:warn"), ImageLoader = new THREE3.ImageLoader();
          module3.exports.System = registerSystem("material", {
            init: function() {
              this.materials = {}, this.sourceCache = {};
            },
            clearTextureSourceCache: function() {
              this.sourceCache = {};
            },
            loadTexture: function(src, data, cb) {
              this.loadTextureSource(src, function(source) {
                var texture = createCompatibleTexture(source);
                setTextureProperties(texture, data), cb(texture);
              });
            },
            loadTextureSource: function(src, cb) {
              var self2 = this, sourceCache = this.sourceCache, hash = this.hash(src);
              if (sourceCache[hash]) {
                sourceCache[hash].then(cb);
                return;
              }
              if (src.tagName === "CANVAS") {
                sourceLoaded(new THREE3.Source(src));
                return;
              }
              sourceLoaded(new Promise(doSourceLoad));
              function doSourceLoad(resolve, reject) {
                utils.srcLoader.validateSrc(src, loadImageCb, loadVideoCb);
                function loadImageCb(src2) {
                  self2.loadImage(src2, resolve);
                }
                function loadVideoCb(src2) {
                  self2.loadVideo(src2, resolve);
                }
              }
              function sourceLoaded(sourcePromise) {
                sourceCache[hash] = Promise.resolve(sourcePromise), sourceCache[hash].then(cb);
              }
            },
            loadCubeMapTexture: function(srcs, cb) {
              var self2 = this, loaded = 0, cube = new THREE3.CubeTexture();
              cube.colorSpace = THREE3.SRGBColorSpace;
              function loadSide(index) {
                self2.loadTextureSource(srcs[index], function(source) {
                  cube.images[index] = source, loaded++, loaded === 6 && (cube.needsUpdate = !0, cb(cube));
                });
              }
              if (srcs.length !== 6) {
                warn("Cube map texture requires exactly 6 sources, got only %s sources", srcs.length);
                return;
              }
              for (var i = 0; i < srcs.length; i++)
                loadSide(i);
            },
            loadImage: function(src, cb) {
              if (typeof src != "string") {
                cb(new THREE3.Source(src));
                return;
              }
              cb(loadImageUrl(src));
            },
            loadVideo: function(src, cb) {
              var videoEl;
              typeof src != "string" && (videoEl = src, fixVideoAttributes(videoEl)), videoEl = videoEl || createVideoEl(src), cb(new THREE3.Source(videoEl));
            },
            hash: function(src) {
              return src.tagName && (src.id || src.src) || src;
            },
            registerMaterial: function(material) {
              this.materials[material.uuid] = material;
            },
            unregisterMaterial: function(material) {
              delete this.materials[material.uuid];
            }
          });
          function loadImageUrl(src) {
            return new Promise(doLoadImageUrl);
            function doLoadImageUrl(resolve, reject) {
              ImageLoader.load(src, resolveSource, function() {
              }, function(xhr) {
                error("`$s` could not be fetched (Error code: %s; Response: %s)", xhr.status, xhr.statusText);
              });
              function resolveSource(data) {
                resolve(new THREE3.Source(data));
              }
            }
          }
          function createVideoEl(src) {
            var videoEl = document.createElement("video");
            return videoEl.setAttribute("playsinline", ""), videoEl.setAttribute("webkit-playsinline", ""), videoEl.autoplay = !0, videoEl.loop = !0, videoEl.crossOrigin = "anonymous", videoEl.addEventListener("error", function() {
              warn("`%s` is not a valid video", src);
            }, !0), videoEl.src = src, videoEl;
          }
          function fixVideoAttributes(videoEl) {
            return videoEl.autoplay = videoEl.hasAttribute("autoplay") && videoEl.getAttribute("autoplay") !== "false", videoEl.controls = videoEl.hasAttribute("controls") && videoEl.getAttribute("controls") !== "false", videoEl.getAttribute("loop") === "false" && videoEl.removeAttribute("loop"), videoEl.getAttribute("preload") === "false" && (videoEl.preload = "none"), videoEl.crossOrigin = videoEl.crossOrigin || "anonymous", videoEl.setAttribute("playsinline", ""), videoEl.setAttribute("webkit-playsinline", ""), videoEl;
          }
        },
        "./src/systems/obb-collider.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var registerSystem = __webpack_require__2("./src/core/system.js").registerSystem;
          registerSystem("obb-collider", {
            schema: {
              showColliders: {
                default: !1
              }
            },
            init: function() {
              this.collisions = [], this.colliderEls = [];
            },
            addCollider: function(colliderEl) {
              this.colliderEls.push(colliderEl), this.data.showColliders ? colliderEl.components["obb-collider"].showCollider() : colliderEl.components["obb-collider"].hideCollider(), this.tick = this.detectCollisions;
            },
            removeCollider: function(colliderEl) {
              var colliderEls = this.colliderEls, elIndex = colliderEls.indexOf(colliderEl);
              colliderEl.components["obb-collider"].hideCollider(), elIndex > -1 && colliderEls.splice(elIndex, 1), colliderEls.length === 0 && (this.tick = void 0);
            },
            registerCollision: function(componentA, componentB) {
              var collisions = this.collisions, existingCollision = !1, boundingBoxA = componentA.obb, boundingBoxB = componentB.obb, collisionMeshA = componentA.renderColliderMesh, collisionMeshB = componentB.renderColliderMesh;
              collisionMeshA && collisionMeshA.material.color.set(16711680), collisionMeshB && collisionMeshB.material.color.set(16711680);
              for (var i = 0; i < collisions.length; i++)
                if (collisions[i].componentA.obb === boundingBoxA && collisions[i].componentB.obb === boundingBoxB || collisions[i].componentA.obb === boundingBoxB && collisions[i].componentB.obb === boundingBoxA) {
                  existingCollision = !0, collisions[i].detected = !0;
                  break;
                }
              existingCollision || (collisions.push({
                componentA,
                componentB,
                detected: !0
              }), componentA.el.emit("obbcollisionstarted", {
                trackedObject3D: componentA.trackedObject3D,
                withEl: componentB.el
              }), componentB.el.emit("obbcollisionstarted", {
                trackedObject3D: componentB.trackedObject3D,
                withEl: componentA.el
              }));
            },
            resetCollisions: function() {
              for (var collisions = this.collisions, i = 0; i < collisions.length; i++)
                collisions[i].detected = !1;
            },
            clearCollisions: function() {
              for (var collisions = this.collisions, detectedCollisions = [], componentA, componentB, collisionMeshA, collisionMeshB, i = 0; i < collisions.length; i++)
                collisions[i].detected ? detectedCollisions.push(collisions[i]) : (componentA = collisions[i].componentA, componentB = collisions[i].componentB, collisionMeshA = componentA.renderColliderMesh, collisionMeshB = componentB.renderColliderMesh, collisionMeshA && collisionMeshA.material.color.set(65280), componentA.el.emit("obbcollisionended", {
                  trackedObject3D: this.trackedObject3D,
                  withEl: componentB.el
                }), collisionMeshB && collisionMeshB.material.color.set(65280), componentB.el.emit("obbcollisionended", {
                  trackedObject3D: this.trackedObject3D,
                  withEl: componentA.el
                }));
              this.collisions = detectedCollisions;
            },
            detectCollisions: function() {
              var boxA, boxB, componentA, componentB, colliderEls = this.colliderEls;
              if (!(colliderEls.length < 2)) {
                this.resetCollisions();
                for (var i = 0; i < colliderEls.length; i++)
                  if (componentA = colliderEls[i].components["obb-collider"], boxA = colliderEls[i].components["obb-collider"].obb, !(boxA.halfSize.x === 0 || boxA.halfSize.y === 0 || boxA.halfSize.z === 0))
                    for (var j = i + 1; j < colliderEls.length; j++)
                      componentB = colliderEls[j].components["obb-collider"], boxB = componentB.obb, !(boxB.halfSize.x === 0 || boxB.halfSize.y === 0 || boxB.halfSize.z === 0) && boxA.intersectsOBB(boxB) && this.registerCollision(componentA, componentB);
                this.clearCollisions();
              }
            }
          });
        },
        "./src/systems/renderer.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerSystem = __webpack_require__2("./src/core/system.js").registerSystem, utils = __webpack_require__2("./src/utils/index.js"), THREE3 = __webpack_require__2("./src/lib/three.js"), debug = utils.debug, warn = debug("components:renderer:warn");
          module3.exports.System = registerSystem("renderer", {
            schema: {
              antialias: {
                default: "auto",
                oneOf: ["true", "false", "auto"]
              },
              highRefreshRate: {
                default: utils.device.isOculusBrowser()
              },
              logarithmicDepthBuffer: {
                default: "auto",
                oneOf: ["true", "false", "auto"]
              },
              maxCanvasWidth: {
                default: -1
              },
              maxCanvasHeight: {
                default: -1
              },
              multiviewStereo: {
                default: !1
              },
              physicallyCorrectLights: {
                default: !1
              },
              exposure: {
                default: 1,
                if: {
                  toneMapping: ["ACESFilmic", "linear", "reinhard", "cineon"]
                }
              },
              toneMapping: {
                default: "no",
                oneOf: ["no", "ACESFilmic", "linear", "reinhard", "cineon"]
              },
              precision: {
                default: "high",
                oneOf: ["high", "medium", "low"]
              },
              anisotropy: {
                default: 1
              },
              sortTransparentObjects: {
                default: !1
              },
              colorManagement: {
                default: !0
              },
              alpha: {
                default: !0
              },
              stencil: {
                default: !1
              },
              foveationLevel: {
                default: 1
              }
            },
            init: function() {
              var data = this.data, sceneEl = this.el, toneMappingName = this.data.toneMapping.charAt(0).toUpperCase() + this.data.toneMapping.slice(1), renderer = sceneEl.renderer;
              data.physicallyCorrectLights || (renderer.useLegacyLights = !data.physicallyCorrectLights), renderer.toneMapping = THREE3[toneMappingName + "ToneMapping"], THREE3.Texture.DEFAULT_ANISOTROPY = data.anisotropy, THREE3.ColorManagement.enabled = data.colorManagement, renderer.outputColorSpace = data.colorManagement ? THREE3.SRGBColorSpace : THREE3.LinearSRGBColorSpace, sceneEl.hasAttribute("antialias") && warn('Component `antialias` is deprecated. Use `renderer="antialias: true"` instead.'), sceneEl.hasAttribute("logarithmicDepthBuffer") && warn('Component `logarithmicDepthBuffer` is deprecated. Use `renderer="logarithmicDepthBuffer: true"` instead.'), renderer.sortObjects = !0, renderer.setOpaqueSort(sortFrontToBack);
            },
            update: function() {
              var data = this.data, sceneEl = this.el, renderer = sceneEl.renderer, toneMappingName = this.data.toneMapping.charAt(0).toUpperCase() + this.data.toneMapping.slice(1);
              renderer.toneMapping = THREE3[toneMappingName + "ToneMapping"], renderer.toneMappingExposure = data.exposure, renderer.xr.setFoveation(data.foveationLevel), data.sortObjects && warn('`sortObjects` property is deprecated. Use `renderer="sortTransparentObjects: true"` instead.'), data.sortTransparentObjects ? renderer.setTransparentSort(sortBackToFront) : renderer.setTransparentSort(sortRenderOrderOnly);
            },
            applyColorCorrection: function(texture) {
              !this.data.colorManagement || !texture || texture.isTexture && texture.colorSpace !== THREE3.SRGBColorSpace && (texture.colorSpace = THREE3.SRGBColorSpace, texture.needsUpdate = !0);
            },
            setWebXRFrameRate: function(xrSession) {
              var data = this.data, rates = xrSession.supportedFrameRates;
              if (rates && xrSession.updateTargetFrameRate) {
                var targetRate;
                rates.includes(90) ? targetRate = data.highRefreshRate ? 90 : 72 : targetRate = data.highRefreshRate ? 72 : 60, xrSession.updateTargetFrameRate(targetRate).catch(function(error) {
                  console.warn("failed to set target frame rate of " + targetRate + ". Error info: " + error);
                });
              }
            }
          });
          function sortFrontToBack(a, b) {
            return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z - b.z;
          }
          function sortRenderOrderOnly(a, b) {
            return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder - b.renderOrder;
          }
          function sortBackToFront(a, b) {
            return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : b.z - a.z;
          }
          module3.exports.sortFrontToBack = sortFrontToBack, module3.exports.sortRenderOrderOnly = sortRenderOrderOnly, module3.exports.sortBackToFront = sortBackToFront;
        },
        "./src/systems/shadow.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerSystem = __webpack_require__2("./src/core/system.js").registerSystem, THREE3 = __webpack_require__2("./src/lib/three.js"), SHADOW_MAP_TYPE_MAP = {
            basic: THREE3.BasicShadowMap,
            pcf: THREE3.PCFShadowMap,
            pcfsoft: THREE3.PCFSoftShadowMap
          };
          module3.exports.System = registerSystem("shadow", {
            schema: {
              enabled: {
                default: !0
              },
              autoUpdate: {
                default: !0
              },
              type: {
                default: "pcf",
                oneOf: ["basic", "pcf", "pcfsoft"]
              }
            },
            init: function() {
              var sceneEl = this.sceneEl, data = this.data;
              this.shadowMapEnabled = !1, sceneEl.renderer.shadowMap.type = SHADOW_MAP_TYPE_MAP[data.type], sceneEl.renderer.shadowMap.autoUpdate = data.autoUpdate;
            },
            update: function(prevData) {
              prevData.enabled !== this.data.enabled && this.setShadowMapEnabled(this.shadowMapEnabled);
            },
            setShadowMapEnabled: function(enabled) {
              var sceneEl = this.sceneEl, renderer = this.sceneEl.renderer;
              this.shadowMapEnabled = enabled;
              var newEnabledState = this.data.enabled && this.shadowMapEnabled;
              renderer && newEnabledState !== renderer.shadowMap.enabled && (renderer.shadowMap.enabled = newEnabledState, updateAllMaterials(sceneEl));
            }
          });
          function updateAllMaterials(sceneEl) {
            !sceneEl.hasLoaded || sceneEl.object3D.traverse(function(node) {
              if (node.material)
                for (var materials = Array.isArray(node.material) ? node.material : [node.material], i = 0; i < materials.length; i++)
                  materials[i].needsUpdate = !0;
            });
          }
        },
        "./src/systems/tracked-controls-webvr.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerSystem = __webpack_require__2("./src/core/system.js").registerSystem, utils = __webpack_require__2("./src/utils/index.js"), isWebXRAvailable = utils.device.isWebXRAvailable;
          module3.exports.System = registerSystem("tracked-controls-webvr", {
            init: function() {
              var self2 = this;
              this.controllers = [], this.isChrome = navigator.userAgent.indexOf("Chrome") !== -1, this.updateControllerList(), this.throttledUpdateControllerList = utils.throttle(this.updateControllerList, 500, this), !isWebXRAvailable && (!navigator.getVRDisplays || this.sceneEl.addEventListener("enter-vr", function() {
                navigator.getVRDisplays().then(function(displays) {
                  displays.length && (self2.vrDisplay = displays[0]);
                });
              }));
            },
            tick: function() {
              this.isChrome ? this.updateControllerList() : this.throttledUpdateControllerList();
            },
            updateControllerList: function() {
              var controllers = this.controllers, gamepad, gamepads, i, prevCount;
              if (gamepads = navigator.getGamepads && navigator.getGamepads(), !!gamepads) {
                for (prevCount = controllers.length, controllers.length = 0, i = 0; i < gamepads.length; ++i)
                  gamepad = gamepads[i], gamepad && gamepad.pose && controllers.push(gamepad);
                controllers.length !== prevCount && this.el.emit("controllersupdated", void 0, !1);
              }
            }
          });
        },
        "./src/systems/tracked-controls-webxr.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerSystem = __webpack_require__2("./src/core/system.js").registerSystem, utils = __webpack_require__2("./src/utils/index.js");
          module3.exports.System = registerSystem("tracked-controls-webxr", {
            init: function() {
              this.controllers = [], this.oldControllers = [], this.oldControllersLength = 0, this.throttledUpdateControllerList = utils.throttle(this.updateControllerList, 500, this), this.updateReferenceSpace = this.updateReferenceSpace.bind(this), this.el.addEventListener("enter-vr", this.updateReferenceSpace), this.el.addEventListener("exit-vr", this.updateReferenceSpace);
            },
            tick: function() {
              this.throttledUpdateControllerList();
            },
            updateReferenceSpace: function() {
              var self2 = this, xrSession = this.el.xrSession;
              if (!xrSession) {
                this.referenceSpace = void 0, this.controllers = [], this.oldControllersLength > 0 && (this.oldControllersLength = 0, this.el.emit("controllersupdated", void 0, !1));
                return;
              }
              var refspace = self2.el.sceneEl.systems.webxr.sessionReferenceSpaceType;
              xrSession.requestReferenceSpace(refspace).then(function(referenceSpace) {
                self2.referenceSpace = referenceSpace;
              }).catch(function(err) {
                throw self2.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(refspace, 'tracked-controls-webxr uses reference space "' + refspace + '".'), err;
              });
            },
            updateControllerList: function() {
              var xrSession = this.el.xrSession, oldControllers = this.oldControllers, i;
              if (!xrSession) {
                if (this.oldControllersLength === 0)
                  return;
                this.oldControllersLength = 0, this.controllers = [], this.el.emit("controllersupdated", void 0, !1);
                return;
              }
              if (!!xrSession.inputSources) {
                if (this.controllers = xrSession.inputSources, this.oldControllersLength === this.controllers.length) {
                  var equal = !0;
                  for (i = 0; i < this.controllers.length; ++i)
                    if (!(this.controllers[i] === oldControllers[i] && this.controllers[i].gamepad === oldControllers[i].gamepad)) {
                      equal = !1;
                      break;
                    }
                  if (equal)
                    return;
                }
                for (oldControllers.length = 0, i = 0; i < this.controllers.length; i++)
                  oldControllers.push(this.controllers[i]);
                this.oldControllersLength = this.controllers.length, this.el.emit("controllersupdated", void 0, !1);
              }
            }
          });
        },
        "./src/systems/webxr.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var registerSystem = __webpack_require__2("./src/core/system.js").registerSystem, utils = __webpack_require__2("./src/utils/index.js"), warn = utils.debug("systems:webxr:warn");
          module3.exports.System = registerSystem("webxr", {
            schema: {
              referenceSpaceType: {
                type: "string",
                default: "local-floor"
              },
              requiredFeatures: {
                type: "array",
                default: ["local-floor"]
              },
              optionalFeatures: {
                type: "array",
                default: ["bounded-floor"]
              },
              overlayElement: {
                type: "selector"
              }
            },
            update: function() {
              var data = this.data;
              this.sessionConfiguration = {
                requiredFeatures: data.requiredFeatures,
                optionalFeatures: data.optionalFeatures
              }, this.sessionReferenceSpaceType = data.referenceSpaceType, data.overlayElement && (data.overlayElement.classList.remove("a-dom-overlay"), data.optionalFeatures.includes("dom-overlay") || (data.optionalFeatures.push("dom-overlay"), this.el.setAttribute("webxr", data)), this.warnIfFeatureNotRequested("dom-overlay"), this.sessionConfiguration.domOverlay = {
                root: data.overlayElement
              }, data.overlayElement.classList.add("a-dom-overlay"));
            },
            wasFeatureRequested: function(feature) {
              return !!(feature === "viewer" || feature === "local" || this.sessionConfiguration.requiredFeatures.includes(feature) || this.sessionConfiguration.optionalFeatures.includes(feature));
            },
            warnIfFeatureNotRequested: function(feature, optIntro) {
              if (!this.wasFeatureRequested(feature)) {
                var msg = 'Please add the feature "' + feature + `" to a-scene's webxr system options in requiredFeatures/optionalFeatures.`;
                warn((optIntro ? optIntro + " " : "") + msg);
              }
            }
          });
        },
        "./src/utils/coordinates.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var debug = __webpack_require__2("./src/utils/debug.js"), warn = debug("utils:coordinates:warn"), COORDINATE_KEYS = ["x", "y", "z", "w"], regex = /^\s*((-?\d*\.{0,1}\d+(e-?\d+)?)\s+){2,3}(-?\d*\.{0,1}\d+(e-?\d+)?)\s*$/;
          module3.exports.regex = regex;
          var whitespaceRegex = /\s+/g;
          function parse(value, defaultVec, target) {
            var coordinate, defaultVal, key, i, vec = target && typeof target == "object" ? target : {}, x, y, z, w;
            if (value && value instanceof Object)
              return x = value.x === void 0 ? defaultVec && defaultVec.x : value.x, y = value.y === void 0 ? defaultVec && defaultVec.y : value.y, z = value.z === void 0 ? defaultVec && defaultVec.z : value.z, w = value.w === void 0 ? defaultVec && defaultVec.w : value.w, x != null && (vec.x = parseIfString(x)), y != null && (vec.y = parseIfString(y)), z != null && (vec.z = parseIfString(z)), w != null && (vec.w = parseIfString(w)), vec;
            if (value == null)
              return typeof defaultVec == "object" ? Object.assign(vec, defaultVec) : defaultVec;
            for (coordinate = value.trim().split(whitespaceRegex), i = 0; i < COORDINATE_KEYS.length; i++)
              if (key = COORDINATE_KEYS[i], coordinate[i])
                vec[key] = parseFloat(coordinate[i], 10);
              else {
                if (defaultVal = defaultVec && defaultVec[key], defaultVal === void 0)
                  continue;
                vec[key] = parseIfString(defaultVal);
              }
            return vec;
          }
          module3.exports.parse = parse;
          function stringify(data) {
            var str;
            return typeof data != "object" ? data : (str = data.x + " " + data.y, data.z != null && (str += " " + data.z), data.w != null && (str += " " + data.w), str);
          }
          module3.exports.stringify = stringify;
          function equals(a, b) {
            return typeof a != "object" || typeof b != "object" ? a === b : a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
          }
          module3.exports.equals = equals;
          function isCoordinates(value) {
            return regex.test(value);
          }
          module3.exports.isCoordinates = isCoordinates, module3.exports.isCoordinate = function(value) {
            return warn("`AFRAME.utils.isCoordinate` has been renamed to `AFRAME.utils.isCoordinates`"), isCoordinates(value);
          };
          function parseIfString(val) {
            return val != null && val.constructor === String ? parseFloat(val, 10) : val;
          }
          module3.exports.toVector3 = function(vec3) {
            return new THREE.Vector3(vec3.x, vec3.y, vec3.z);
          };
        },
        "./src/utils/debug.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var debug = __webpack_require__2("./node_modules/debug/src/browser.js"), isBrowserEnvironment = __webpack_require__2("./src/utils/device.js").isBrowserEnvironment, settings = {
            colors: {
              debug: "gray",
              error: "red",
              info: "gray",
              warn: "orange"
            }
          };
          debug.formatArgs = formatArgs;
          function formatArgs(args) {
            if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " "), !!this.useColors) {
              this.color = getDebugNamespaceColor(this.namespace);
              var c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");
              var index = 0, lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, function(match) {
                match !== "%%" && (index++, match === "%c" && (lastC = index));
              }), args.splice(lastC, 0, c);
            }
          }
          function getDebugNamespaceType(namespace) {
            var chunks = namespace.split(":");
            return chunks[chunks.length - 1];
          }
          function getDebugNamespaceColor(namespace) {
            var type = getDebugNamespaceType(namespace), color = settings.colors && settings.colors[type];
            return color || null;
          }
          function storage() {
            try {
              return window.localStorage;
            } catch (e) {
            }
          }
          var ls = storage();
          ls && (parseInt(ls.logs, 10) || ls.logs === "true") ? debug.enable("*") : debug.enable("*:error,*:info,*:warn"), isBrowserEnvironment && (window.logs = debug), module3.exports = debug;
        },
        "./src/utils/device.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var error = __webpack_require__2("./node_modules/debug/src/browser.js")("device:error"), vrDisplay, supportsVRSession = !1, supportsARSession = !1, isWebXRAvailable = module3.exports.isWebXRAvailable = navigator.xr !== void 0;
          if (window.addEventListener("vrdisplayactivate", function(evt) {
            var canvasEl;
            isWebXRAvailable || (canvasEl = document.createElement("canvas"), vrDisplay = evt.display, canvasEl.getContext("webgl", {}), vrDisplay.requestPresent([{
              source: canvasEl
            }]).then(function() {
            }, function() {
            }));
          }), isWebXRAvailable) {
            var updateEnterInterfaces = function() {
              var sceneEl = document.querySelector("a-scene");
              if (!sceneEl) {
                window.addEventListener("DOMContentLoaded", updateEnterInterfaces);
                return;
              }
              sceneEl.hasLoaded ? sceneEl.components["xr-mode-ui"].updateEnterInterfaces() : sceneEl.addEventListener("loaded", updateEnterInterfaces);
            }, errorHandler = function(err) {
              error("WebXR session support error: " + err.message);
            };
            navigator.xr.isSessionSupported ? (navigator.xr.isSessionSupported("immersive-vr").then(function(supported) {
              supportsVRSession = supported, updateEnterInterfaces();
            }).catch(errorHandler), navigator.xr.isSessionSupported("immersive-ar").then(function(supported) {
              supportsARSession = supported, updateEnterInterfaces();
            }).catch(function() {
            })) : navigator.xr.supportsSession ? (navigator.xr.supportsSession("immersive-vr").then(function() {
              supportsVRSession = !0, updateEnterInterfaces();
            }).catch(errorHandler), navigator.xr.supportsSession("immersive-ar").then(function() {
              supportsARSession = !0, updateEnterInterfaces();
            }).catch(function() {
            })) : error("WebXR has neither isSessionSupported or supportsSession?!");
          } else
            navigator.getVRDisplays && navigator.getVRDisplays().then(function(displays) {
              var sceneEl = document.querySelector("a-scene");
              vrDisplay = displays.length && displays[0], sceneEl && sceneEl.emit("displayconnected", {
                vrDisplay
              });
            });
          function getVRDisplay() {
            return vrDisplay;
          }
          module3.exports.getVRDisplay = getVRDisplay;
          function checkHeadsetConnected() {
            return supportsVRSession || supportsARSession || !!getVRDisplay();
          }
          module3.exports.checkHeadsetConnected = checkHeadsetConnected;
          function checkARSupport() {
            return supportsARSession;
          }
          module3.exports.checkARSupport = checkARSupport;
          function checkVRSupport() {
            return supportsVRSession;
          }
          module3.exports.checkVRSupport = checkVRSupport;
          var isMobile = function() {
            var _isMobile = !1;
            return function(a) {
              (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) && (_isMobile = !0), (isIOS() || isTablet() || isR7()) && (_isMobile = !0), isMobileVR() && (_isMobile = !1);
            }(window.navigator.userAgent || window.navigator.vendor || window.opera), function() {
              return _isMobile;
            };
          }();
          module3.exports.isMobile = isMobile;
          function isTablet(mockUserAgent) {
            var userAgent = mockUserAgent || window.navigator.userAgent, isTablet2 = /Nexus (7|9)|xoom|sch-i800|playbook|tablet|kindle/i.test(userAgent);
            return isTablet2 || isIpad();
          }
          module3.exports.isTablet = isTablet;
          function isIpad(mockUserAgent, mockDevicePlatform, mockDeviceTouchPoints) {
            var userAgent = mockUserAgent || window.navigator.userAgent, platform = mockDevicePlatform || window.navigator.platform, maxTouchPoints = mockDeviceTouchPoints || window.navigator.maxTouchPoints || 0;
            return (platform === "iPad" || platform === "MacIntel") && maxTouchPoints > 0 && /Macintosh|Intel|iPad|ipad/i.test(userAgent) && !window.MSStream;
          }
          module3.exports.isIpad = isIpad;
          function isIOS() {
            return /iPad|iPhone|iPod/.test(window.navigator.platform);
          }
          module3.exports.isIOS = isIOS;
          function isMobileDeviceRequestingDesktopSite() {
            return !isMobile() && !isMobileVR() && window.orientation !== void 0;
          }
          module3.exports.isMobileDeviceRequestingDesktopSite = isMobileDeviceRequestingDesktopSite;
          function isOculusBrowser() {
            return /(OculusBrowser)/i.test(window.navigator.userAgent);
          }
          module3.exports.isOculusBrowser = isOculusBrowser;
          function isFirefoxReality() {
            return /(Mobile VR)/i.test(window.navigator.userAgent);
          }
          module3.exports.isFirefoxReality = isFirefoxReality;
          function isMobileVR() {
            return isOculusBrowser() || isFirefoxReality();
          }
          module3.exports.isMobileVR = isMobileVR;
          function isR7() {
            return /R7 Build/.test(window.navigator.userAgent);
          }
          module3.exports.isR7 = isR7, module3.exports.isLandscape = function() {
            var orientation = window.orientation;
            return isR7() && (orientation += 90), orientation === 90 || orientation === -90;
          }, module3.exports.isBrowserEnvironment = typeof process == "undefined" || process.browser === !0, module3.exports.isNodeEnvironment = !module3.exports.isBrowserEnvironment;
        },
        "./src/utils/entity.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var split = __webpack_require__2("./src/utils/split.js").split;
          function getComponentPropertyPath(str, delimiter) {
            delimiter = delimiter || ".";
            var parts = split(str, delimiter);
            return parts.length === 1 ? parts[0] : parts;
          }
          module3.exports.getComponentPropertyPath = getComponentPropertyPath, module3.exports.getComponentProperty = function(el, name, delimiter) {
            var splitName;
            return delimiter = delimiter || ".", name.indexOf(delimiter) !== -1 ? (splitName = getComponentPropertyPath(name, delimiter), splitName.constructor === String ? el.getAttribute(splitName) : el.getAttribute(splitName[0])[splitName[1]]) : el.getAttribute(name);
          }, module3.exports.setComponentProperty = function(el, name, value, delimiter) {
            var splitName;
            if (delimiter = delimiter || ".", name.indexOf(delimiter) !== -1) {
              splitName = getComponentPropertyPath(name, delimiter), splitName.constructor === String ? el.setAttribute(splitName, value) : el.setAttribute(splitName[0], splitName[1], value);
              return;
            }
            el.setAttribute(name, value);
          };
        },
        "./src/utils/forceCanvasResizeSafariMobile.js": (module3) => {
          module3.exports = function(canvasEl) {
            var width = canvasEl.style.width, height = canvasEl.style.height;
            canvasEl.style.width = parseInt(width, 10) + 1 + "px", canvasEl.style.height = parseInt(height, 10) + 1 + "px", setTimeout(function() {
              canvasEl.style.width = width, canvasEl.style.height = height;
            }, 200);
          };
        },
        "./src/utils/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var debug = __webpack_require__2("./src/utils/debug.js"), deepAssign = __webpack_require__2("./node_modules/deep-assign/index.js"), device = __webpack_require__2("./src/utils/device.js"), objectPool = __webpack_require__2("./src/utils/object-pool.js"), warn = debug("utils:warn");
          module3.exports.bind = function(fn) {
            return fn.bind.apply(fn, Array.prototype.slice.call(arguments, 1));
          }, module3.exports.coordinates = __webpack_require__2("./src/utils/coordinates.js"), module3.exports.debug = debug, module3.exports.device = device, module3.exports.entity = __webpack_require__2("./src/utils/entity.js"), module3.exports.forceCanvasResizeSafariMobile = __webpack_require__2("./src/utils/forceCanvasResizeSafariMobile.js"), module3.exports.material = __webpack_require__2("./src/utils/material.js"), module3.exports.objectPool = objectPool, module3.exports.split = __webpack_require__2("./src/utils/split.js").split, module3.exports.styleParser = __webpack_require__2("./src/utils/styleParser.js"), module3.exports.trackedControls = __webpack_require__2("./src/utils/tracked-controls.js"), module3.exports.checkHeadsetConnected = function() {
            return warn("`utils.checkHeadsetConnected` has moved to `utils.device.checkHeadsetConnected`"), device.checkHeadsetConnected(arguments);
          }, module3.exports.isGearVR = module3.exports.device.isGearVR = function() {
            warn("`utils.isGearVR` has been deprecated, use `utils.device.isMobileVR`");
          }, module3.exports.isIOS = function() {
            return warn("`utils.isIOS` has moved to `utils.device.isIOS`"), device.isIOS(arguments);
          }, module3.exports.isOculusGo = module3.exports.device.isOculusGo = function() {
            warn("`utils.isOculusGo` has been deprecated, use `utils.device.isMobileVR`");
          }, module3.exports.isMobile = function() {
            return warn("`utils.isMobile has moved to `utils.device.isMobile`"), device.isMobile(arguments);
          }, module3.exports.throttle = function(functionToThrottle, minimumInterval, optionalContext) {
            var lastTime;
            return optionalContext && (functionToThrottle = functionToThrottle.bind(optionalContext)), function() {
              var time = Date.now(), sinceLastTime = typeof lastTime == "undefined" ? minimumInterval : time - lastTime;
              (typeof lastTime == "undefined" || sinceLastTime >= minimumInterval) && (lastTime = time, functionToThrottle.apply(null, arguments));
            };
          }, module3.exports.throttleLeadingAndTrailing = function(functionToThrottle, minimumInterval, optionalContext) {
            var lastTime, deferTimer;
            optionalContext && (functionToThrottle = functionToThrottle.bind(optionalContext));
            var args, timerExpired = function() {
              lastTime = Date.now(), functionToThrottle.apply(this, args), deferTimer = void 0;
            };
            return function() {
              var time = Date.now(), sinceLastTime = typeof lastTime == "undefined" ? minimumInterval : time - lastTime;
              sinceLastTime >= minimumInterval ? (clearTimeout(deferTimer), deferTimer = void 0, lastTime = time, functionToThrottle.apply(null, arguments)) : (deferTimer = deferTimer || setTimeout(timerExpired, minimumInterval - sinceLastTime), args = arguments);
            };
          }, module3.exports.throttleTick = function(functionToThrottle, minimumInterval, optionalContext) {
            var lastTime;
            return optionalContext && (functionToThrottle = functionToThrottle.bind(optionalContext)), function(time, delta) {
              var sinceLastTime = typeof lastTime == "undefined" ? delta : time - lastTime;
              (typeof lastTime == "undefined" || sinceLastTime >= minimumInterval) && (lastTime = time, functionToThrottle(time, sinceLastTime));
            };
          }, module3.exports.debounce = function(func, wait, immediate) {
            var timeout;
            return function() {
              var context = this, args = arguments, later = function() {
                timeout = null, immediate || func.apply(context, args);
              }, callNow = immediate && !timeout;
              clearTimeout(timeout), timeout = setTimeout(later, wait), callNow && func.apply(context, args);
            };
          }, module3.exports.extend = Object.assign, module3.exports.extendDeep = deepAssign, module3.exports.clone = function(obj) {
            return JSON.parse(JSON.stringify(obj));
          };
          var deepEqual = function() {
            var arrayPool = objectPool.createPool(function() {
              return [];
            });
            return function(a, b) {
              var key, keysA, keysB, i, valA, valB;
              if (a === void 0 || b === void 0 || a === null || b === null || !(a && b && a.constructor === Object && b.constructor === Object || a.constructor === Array && b.constructor === Array))
                return a === b;
              keysA = arrayPool.use(), keysB = arrayPool.use(), keysA.length = 0, keysB.length = 0;
              for (key in a)
                keysA.push(key);
              for (key in b)
                keysB.push(key);
              if (keysA.length !== keysB.length)
                return arrayPool.recycle(keysA), arrayPool.recycle(keysB), !1;
              for (i = 0; i < keysA.length; ++i)
                if (valA = a[keysA[i]], valB = b[keysA[i]], typeof valA == "object" || typeof valB == "object" || Array.isArray(valA) && Array.isArray(valB)) {
                  if (valA === valB)
                    continue;
                  if (!deepEqual(valA, valB))
                    return arrayPool.recycle(keysA), arrayPool.recycle(keysB), !1;
                } else if (valA !== valB)
                  return arrayPool.recycle(keysA), arrayPool.recycle(keysB), !1;
              return arrayPool.recycle(keysA), arrayPool.recycle(keysB), !0;
            };
          }();
          module3.exports.deepEqual = deepEqual, module3.exports.diff = function() {
            var keys = [];
            return function(a, b, targetObject) {
              var aVal, bVal, bKey, diff, key, i, isComparingObjects;
              diff = targetObject || {}, keys.length = 0;
              for (key in a)
                keys.push(key);
              if (!b)
                return diff;
              for (bKey in b)
                keys.indexOf(bKey) === -1 && keys.push(bKey);
              for (i = 0; i < keys.length; i++)
                key = keys[i], aVal = a[key], bVal = b[key], isComparingObjects = aVal && bVal && aVal.constructor === Object && bVal.constructor === Object, (isComparingObjects && !deepEqual(aVal, bVal) || !isComparingObjects && aVal !== bVal) && (diff[key] = bVal);
              return diff;
            };
          }(), module3.exports.shouldCaptureKeyEvent = function(event) {
            return event.metaKey ? !1 : document.activeElement === document.body;
          }, module3.exports.splitString = function(str, delimiter) {
            typeof delimiter == "undefined" && (delimiter = " ");
            var regex = new RegExp(delimiter, "g");
            return str = (str || "").replace(regex, delimiter), str.split(delimiter);
          }, module3.exports.getElData = function(el, defaults) {
            defaults = defaults || {};
            var data = {};
            Object.keys(defaults).forEach(copyAttribute);
            function copyAttribute(key) {
              el.hasAttribute(key) && (data[key] = el.getAttribute(key));
            }
            return data;
          }, module3.exports.getUrlParameter = function(name) {
            name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"), results = regex.exec(location.search);
            return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
          }, module3.exports.isIframed = function() {
            return window.top !== window.self;
          }, module3.exports.findAllScenes = function(el) {
            for (var matchingElements = [], allElements = el.getElementsByTagName("*"), i = 0, n = allElements.length; i < n; i++)
              allElements[i].isScene && matchingElements.push(allElements[i]);
            return matchingElements;
          }, module3.exports.srcLoader = __webpack_require__2("./src/utils/src-loader.js");
        },
        "./src/utils/ios-orientationchange-blank-bug.js": () => {
          window.addEventListener("orientationchange", function() {
            document.documentElement.style.height = "initial", setTimeout(function() {
              document.documentElement.style.height = "100%", setTimeout(function() {
                window.scrollTo(0, 1);
              }, 500);
            }, 500);
          });
        },
        "./src/utils/isIOSOlderThan10.js": (module3) => {
          module3.exports = function(userAgent) {
            return /(iphone|ipod|ipad).*os.(7_|8_|9_)/i.test(userAgent);
          };
        },
        "./src/utils/material.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var THREE3 = __webpack_require__2("./src/lib/three.js"), srcLoader = __webpack_require__2("./src/utils/src-loader.js"), debug = __webpack_require__2("./src/utils/debug.js"), warn = debug("utils:material:warn"), COLOR_MAPS = new Set(["emissiveMap", "envMap", "map", "specularMap"]);
          function setTextureProperties(texture, data) {
            var offset = data.offset || {
              x: 0,
              y: 0
            }, repeat = data.repeat || {
              x: 1,
              y: 1
            }, npot = data.npot || !1, anisotropy = data.anisotropy || THREE3.Texture.DEFAULT_ANISOTROPY, wrapS = texture.wrapS, wrapT = texture.wrapT, magFilter = texture.magFilter, minFilter = texture.minFilter;
            npot && (wrapS = THREE3.ClampToEdgeWrapping, wrapT = THREE3.ClampToEdgeWrapping, magFilter = THREE3.LinearFilter, minFilter = THREE3.LinearFilter), (repeat.x !== 1 || repeat.y !== 1) && (wrapS = THREE3.RepeatWrapping, wrapT = THREE3.RepeatWrapping), texture.offset.set(offset.x, offset.y), texture.repeat.set(repeat.x, repeat.y), (texture.wrapS !== wrapS || texture.wrapT !== wrapT || texture.magFilter !== magFilter || texture.minFilter !== minFilter || texture.anisotropy !== anisotropy) && (texture.wrapS = wrapS, texture.wrapT = wrapT, texture.magFilter = magFilter, texture.minFilter = minFilter, texture.anisotropy = anisotropy, texture.needsUpdate = !0);
          }
          module3.exports.setTextureProperties = setTextureProperties, module3.exports.updateMapMaterialFromData = function(materialName, dataName, shader, data) {
            var el = shader.el, material = shader.material, rendererSystem = el.sceneEl.systems.renderer, src = data[dataName];
            if (shader.materialSrcs || (shader.materialSrcs = {}), !src) {
              delete shader.materialSrcs[materialName], setMap(null);
              return;
            }
            if (src === shader.materialSrcs[materialName] && material[materialName]) {
              setTextureProperties(material[materialName], data);
              return;
            }
            shader.materialSrcs[materialName] = src, src instanceof THREE3.Texture ? setMap(src) : el.sceneEl.systems.material.loadTextureSource(src, updateTexture);
            function updateTexture(source) {
              if (shader.materialSrcs[materialName] === src) {
                var texture = material[materialName];
                texture && (source === null || !isCompatibleTexture(texture, source)) && (texture = null), !texture && source && (texture = createCompatibleTexture(source)), texture && (texture.source !== source && (texture.source = source, texture.needsUpdate = !0), COLOR_MAPS.has(materialName) && rendererSystem.applyColorCorrection(texture), setTextureProperties(texture, data)), setMap(texture);
              }
            }
            function setMap(texture) {
              material[materialName] !== texture && (material[materialName] && material[materialName].dispose(), material[materialName] = texture, material.needsUpdate = !0, handleTextureEvents(el, texture));
            }
          }, module3.exports.updateMap = function(shader, data) {
            return module3.exports.updateMapMaterialFromData("map", "src", shader, data);
          }, module3.exports.updateDistortionMap = function(longType, shader, data) {
            var shortType = longType;
            longType === "ambientOcclusion" && (shortType = "ao");
            var info = {};
            return info.src = data[longType + "Map"], info.offset = data[longType + "TextureOffset"], info.repeat = data[longType + "TextureRepeat"], info.wrap = data[longType + "TextureWrap"], module3.exports.updateMapMaterialFromData(shortType + "Map", "src", shader, info);
          };
          var envMapPromises = {};
          module3.exports.updateEnvMap = function(shader, data) {
            var material = shader.material, el = shader.el, materialName = "envMap", src = data.envMap, sphericalEnvMap = data.sphericalEnvMap, refract = data.refract;
            if (sphericalEnvMap && (src = sphericalEnvMap, warn("`sphericalEnvMap` property is deprecated, using spherical map as equirectangular map instead. Use `envMap` property with a CubeMap or Equirectangular image instead.")), shader.materialSrcs || (shader.materialSrcs = {}), !src) {
              delete shader.materialSrcs[materialName], material.envMap = null, material.needsUpdate = !0;
              return;
            }
            if (shader.materialSrcs[materialName] = src, envMapPromises[src]) {
              envMapPromises[src].then(checkSetMap);
              return;
            }
            envMapPromises[src] = new Promise(function(resolve) {
              srcLoader.validateEnvMapSrc(src, function(srcs) {
                el.sceneEl.systems.material.loadCubeMapTexture(srcs, function(texture) {
                  texture.mapping = refract ? THREE3.CubeRefractionMapping : THREE3.CubeReflectionMapping, checkSetMap(texture), resolve(texture);
                });
              }, function(src2) {
                el.sceneEl.systems.material.loadTexture(src2, {
                  src: src2
                }, function(texture) {
                  texture.mapping = refract ? THREE3.EquirectangularRefractionMapping : THREE3.EquirectangularReflectionMapping, checkSetMap(texture), resolve(texture);
                });
              });
            });
            function checkSetMap(texture) {
              shader.materialSrcs[materialName] === src && (material.envMap = texture, material.needsUpdate = !0, handleTextureEvents(el, texture));
            }
          };
          function handleTextureEvents(el, texture) {
            if (!texture || (el.emit("materialtextureloaded", {
              src: texture.image,
              texture
            }), !texture.image || texture.image.tagName !== "VIDEO"))
              return;
            texture.image.addEventListener("loadeddata", emitVideoTextureLoadedDataAll), texture.image.addEventListener("ended", emitVideoTextureEndedAll);
            function emitVideoTextureLoadedDataAll() {
              el.emit("materialvideoloadeddata", {
                src: texture.image,
                texture
              });
            }
            function emitVideoTextureEndedAll() {
              el.emit("materialvideoended", {
                src: texture.image,
                texture
              });
            }
            texture.addEventListener("dispose", function() {
              texture.image.removeEventListener("loadeddata", emitVideoTextureLoadedDataAll), texture.image.removeEventListener("ended", emitVideoTextureEndedAll);
            });
          }
          module3.exports.handleTextureEvents = handleTextureEvents;
          function isCompatibleTexture(texture, source) {
            return source.data instanceof HTMLCanvasElement ? texture.isCanvasTexture : source.data instanceof HTMLVideoElement ? texture.isVideoTexture && texture.source === source : texture.isTexture && !texture.isCanvasTexture && !texture.isVideoTexture;
          }
          module3.exports.isCompatibleTexture = isCompatibleTexture;
          function createCompatibleTexture(source) {
            var texture;
            return source.data instanceof HTMLCanvasElement ? texture = new THREE3.CanvasTexture() : source.data instanceof HTMLVideoElement ? texture = new THREE3.VideoTexture(source.data) : texture = new THREE3.Texture(), texture.source = source, texture.needsUpdate = !0, texture;
          }
          module3.exports.createCompatibleTexture = createCompatibleTexture;
        },
        "./src/utils/math.js": (module3) => {
          function distanceOfPointFromPlane(positionOnPlane, planeNormal, pointToTest) {
            var d = planeNormal.dot(positionOnPlane);
            return (d - planeNormal.dot(pointToTest)) / planeNormal.length();
          }
          function nearestPointInPlane(positionOnPlane, planeNormal, pointToTest, resultPoint) {
            var t = distanceOfPointFromPlane(positionOnPlane, planeNormal, pointToTest);
            return resultPoint.copy(planeNormal), resultPoint.multiplyScalar(t), resultPoint.add(pointToTest), resultPoint;
          }
          module3.exports.distanceOfPointFromPlane = distanceOfPointFromPlane, module3.exports.nearestPointInPlane = nearestPointInPlane;
        },
        "./src/utils/object-pool.js": (module3) => {
          var EMPTY_SLOT = Object.freeze(Object.create(null));
          function defaultObjectFactory() {
            return {};
          }
          module3.exports.createPool = function(objectFactory) {
            var objPool = [], nextFreeSlot = null;
            objectFactory = objectFactory || defaultObjectFactory;
            function use() {
              var objToUse;
              return (nextFreeSlot === null || nextFreeSlot === objPool.length) && grow(objPool.length || 5), objToUse = objPool[nextFreeSlot], objPool[nextFreeSlot++] = EMPTY_SLOT, clearObject(objToUse), objToUse;
            }
            function recycle(obj) {
              if (obj instanceof Object) {
                if (nextFreeSlot === null || nextFreeSlot === -1) {
                  objPool[objPool.length] = obj;
                  return;
                }
                objPool[--nextFreeSlot] = obj;
              }
            }
            function grow(count) {
              var currentLength, i;
              if (count = count === void 0 ? objPool.length : count, count > 0 && nextFreeSlot == null && (nextFreeSlot = 0), count > 0)
                for (currentLength = objPool.length, objPool.length += Number(count), i = currentLength; i < objPool.length; i++)
                  objPool[i] = objectFactory();
              return objPool.length;
            }
            function size() {
              return objPool.length;
            }
            return {
              grow,
              pool: objPool,
              recycle,
              size,
              use
            };
          };
          function clearObject(obj) {
            var key;
            if (!(!obj || obj.constructor !== Object))
              for (key in obj)
                obj[key] = void 0;
          }
          module3.exports.clearObject = clearObject;
          function removeUnusedKeys(obj, schema) {
            var key;
            if (!(!obj || obj.constructor !== Object))
              for (key in obj)
                key in schema || delete obj[key];
          }
          module3.exports.removeUnusedKeys = removeUnusedKeys;
        },
        "./src/utils/split.js": (module3) => {
          module3.exports.split = function() {
            var splitCache = {};
            return function(str, delimiter) {
              return delimiter in splitCache || (splitCache[delimiter] = {}), str in splitCache[delimiter] || (splitCache[delimiter][str] = str.split(delimiter)), splitCache[delimiter][str];
            };
          }();
        },
        "./src/utils/src-loader.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var debug = __webpack_require__2("./src/utils/debug.js"), warn = debug("utils:src-loader:warn");
          function validateSrc(src, isImageCb, isVideoCb) {
            checkIsImage(src, function(isImage) {
              if (isImage) {
                isImageCb(src);
                return;
              }
              isVideoCb(src);
            });
          }
          function validateEnvMapSrc(src, isCubemapCb, isEquirectCb) {
            var el, cubemapSrcRegex = "", i, urls, validatedUrls = [];
            if (typeof src == "string") {
              let isImageCb2 = function(url) {
                validatedUrls.push(url), validatedUrls.length === 6 && isCubemapCb(validatedUrls);
              };
              var isImageCb = isImageCb2;
              for (i = 0; i < 5; i++)
                cubemapSrcRegex += "(url\\((?:[^\\)]+)\\),\\s*)";
              if (cubemapSrcRegex += "(url\\((?:[^\\)]+)\\)\\s*)", urls = src.match(new RegExp(cubemapSrcRegex)), urls) {
                for (i = 1; i < 7; i++)
                  validateSrc(parseUrl(urls[i]), isImageCb2);
                return;
              }
              if (!src.startsWith("#")) {
                var parsedSrc = parseUrl(src);
                validateSrc(parsedSrc || src, isEquirectCb);
                return;
              }
            }
            if (src.tagName ? el = src : el = validateAndGetQuerySelector(src), !!el) {
              if (el.tagName === "A-CUBEMAP" && el.srcs)
                return isCubemapCb(el.srcs);
              if (el.tagName === "IMG")
                return isEquirectCb(el);
              warn('Selector "%s" does not point to <a-cubemap> or <img>', src);
            }
          }
          function validateCubemapSrc(src, cb) {
            return validateEnvMapSrc(src, cb, function() {
              warn("Expected cubemap but got image");
            });
          }
          function parseUrl(src) {
            var parsedSrc = src.match(/url\((.+)\)/);
            if (!!parsedSrc)
              return parsedSrc[1];
          }
          function checkIsImage(src, onResult) {
            var request;
            if (src.tagName) {
              onResult(src.tagName === "IMG");
              return;
            }
            request = new XMLHttpRequest(), request.open("HEAD", src), request.addEventListener("load", function(event) {
              var contentType;
              request.status >= 200 && request.status < 300 ? (contentType = request.getResponseHeader("Content-Type"), contentType == null ? checkIsImageFallback(src, onResult) : contentType.startsWith("image") ? onResult(!0) : onResult(!1)) : checkIsImageFallback(src, onResult), request.abort();
            }), request.send();
          }
          function checkIsImageFallback(src, onResult) {
            var tester = new Image();
            tester.addEventListener("load", onLoad);
            function onLoad() {
              onResult(!0);
            }
            tester.addEventListener("error", onError);
            function onError() {
              onResult(!1);
            }
            tester.src = src;
          }
          function validateAndGetQuerySelector(selector) {
            try {
              var el = document.querySelector(selector);
              return el || warn('No element was found matching the selector: "%s"', selector), el;
            } catch (e) {
              warn('"%s" is not a valid selector', selector);
              return;
            }
          }
          module3.exports = {
            parseUrl,
            validateSrc,
            validateCubemapSrc,
            validateEnvMapSrc
          };
        },
        "./src/utils/styleParser.js": (module3) => {
          var DASH_REGEX = /-([a-z])/g;
          module3.exports.parse = function(value, obj) {
            var parsedData;
            return typeof value != "string" || (parsedData = styleParse(value, obj), parsedData[""]) ? value : parsedData;
          }, module3.exports.stringify = function(data) {
            return typeof data == "string" ? data : styleStringify(data);
          };
          function toCamelCase(str) {
            return str.replace(DASH_REGEX, upperCase);
          }
          module3.exports.toCamelCase = toCamelCase;
          var getKeyValueChunks = function() {
            var chunks = [], hasUnclosedUrl = /url\([^)]+$/;
            return function(raw) {
              var chunk = "", nextSplit, offset = 0, sep = ";";
              for (chunks.length = 0; offset < raw.length; ) {
                if (nextSplit = raw.indexOf(sep, offset), nextSplit === -1 && (nextSplit = raw.length), chunk += raw.substring(offset, nextSplit), hasUnclosedUrl.test(chunk)) {
                  chunk += ";", offset = nextSplit + 1;
                  continue;
                }
                chunks.push(chunk.trim()), chunk = "", offset = nextSplit + 1;
              }
              return chunks;
            };
          }();
          function styleParse(str, obj) {
            var chunks, i, item, pos, key, val;
            for (obj = obj || {}, chunks = getKeyValueChunks(str), i = 0; i < chunks.length; i++)
              item = chunks[i], !!item && (pos = item.indexOf(":"), key = item.substr(0, pos).trim(), val = item.substr(pos + 1).trim(), obj[toCamelCase(key)] = val);
            return obj;
          }
          function styleStringify(obj) {
            var key, keyCount = 0, i = 0, str = "";
            for (key in obj)
              keyCount++;
            for (key in obj)
              str += key + ": " + obj[key], i < keyCount - 1 && (str += "; "), i++;
            return str;
          }
          function upperCase(str) {
            return str[1].toUpperCase();
          }
        },
        "./src/utils/tracked-controls.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var DEFAULT_HANDEDNESS = __webpack_require__2("./src/constants/index.js").DEFAULT_HANDEDNESS, AXIS_LABELS = ["x", "y", "z", "w"], NUM_HANDS = 2;
          module3.exports.checkControllerPresentAndSetup = function(component, idPrefix, queryObject) {
            var el = component.el, controller, hasWebXR = el.sceneEl.hasWebXR, isControllerPresent = hasWebXR ? isControllerPresentWebXR : isControllerPresentWebVR, isPresent;
            if (controller = isControllerPresent(component, idPrefix, queryObject), isPresent = !!controller, component.controllerPresent && !component.controllerEventsActive && !hasWebXR && component.addEventListeners(), isPresent === component.controllerPresent)
              return isPresent;
            component.controllerPresent = isPresent, isPresent ? (component.addEventListeners(), component.injectTrackedControls(controller), el.emit("controllerconnected", {
              name: component.name,
              component
            })) : (component.removeEventListeners(), el.emit("controllerdisconnected", {
              name: component.name,
              component
            }));
          };
          function isControllerPresentWebVR(component, idPrefix, queryObject) {
            var gamepads, sceneEl = component.el.sceneEl, trackedControlsSystem, filterControllerIndex = queryObject.index || 0;
            return !idPrefix || (trackedControlsSystem = sceneEl && sceneEl.systems["tracked-controls-webvr"], !trackedControlsSystem) || (gamepads = trackedControlsSystem.controllers, !gamepads.length) ? !1 : !!findMatchingControllerWebVR(gamepads, null, idPrefix, queryObject.hand, filterControllerIndex);
          }
          function isControllerPresentWebXR(component, id, queryObject) {
            var controllers, sceneEl = component.el.sceneEl, trackedControlsSystem = sceneEl && sceneEl.systems["tracked-controls-webxr"];
            return !trackedControlsSystem || (controllers = trackedControlsSystem.controllers, !controllers || !controllers.length) ? !1 : findMatchingControllerWebXR(controllers, id, queryObject.hand, queryObject.index, queryObject.iterateControllerProfiles, queryObject.handTracking);
          }
          module3.exports.isControllerPresentWebVR = isControllerPresentWebVR, module3.exports.isControllerPresentWebXR = isControllerPresentWebXR;
          function findMatchingControllerWebVR(controllers, filterIdExact, filterIdPrefix, filterHand, filterControllerIndex) {
            var controller, i, matchingControllerOccurrence = 0, targetControllerMatch = filterControllerIndex >= 0 ? filterControllerIndex : 0;
            for (i = 0; i < controllers.length; i++)
              if (controller = controllers[i], !(filterIdPrefix && !controller.id.startsWith(filterIdPrefix)) && !(!filterIdPrefix && controller.id !== filterIdExact) && !(filterHand && controller.hand && filterHand !== controller.hand)) {
                if (filterHand && !controller.hand)
                  targetControllerMatch = NUM_HANDS * filterControllerIndex + (filterHand === DEFAULT_HANDEDNESS ? 0 : 1);
                else
                  return controller;
                if (matchingControllerOccurrence === targetControllerMatch)
                  return controller;
                ++matchingControllerOccurrence;
              }
          }
          function findMatchingControllerWebXR(controllers, idPrefix, handedness, index, iterateProfiles, handTracking) {
            var i, j, controller, controllerMatch = !1, controllerHasHandedness, profiles;
            for (i = 0; i < controllers.length; i++) {
              if (controller = controllers[i], profiles = controller.profiles, handTracking)
                controllerMatch = controller.hand;
              else if (iterateProfiles)
                for (j = 0; j < profiles.length && (controllerMatch = profiles[j].startsWith(idPrefix), !controllerMatch); j++)
                  ;
              else
                controllerMatch = profiles.length > 0 && profiles[0].startsWith(idPrefix);
              if (!!controllerMatch) {
                if (controllerHasHandedness = controller.handedness === "right" || controller.handedness === "left", controllerHasHandedness) {
                  if (controller.handedness === handedness)
                    return controllers[i];
                } else if (i === index)
                  return controllers[i];
              }
            }
          }
          module3.exports.findMatchingControllerWebVR = findMatchingControllerWebVR, module3.exports.findMatchingControllerWebXR = findMatchingControllerWebXR, module3.exports.emitIfAxesChanged = function(component, axesMapping, evt) {
            var axes, buttonType, changed, detail, j;
            for (buttonType in axesMapping) {
              for (axes = axesMapping[buttonType], changed = !1, j = 0; j < axes.length; j++)
                evt.detail.changed[axes[j]] && (changed = !0);
              if (!!changed) {
                for (detail = {}, j = 0; j < axes.length; j++)
                  detail[AXIS_LABELS[j]] = evt.detail.axis[axes[j]];
                component.el.emit(buttonType + "moved", detail);
              }
            }
          }, module3.exports.onButtonEvent = function(id, evtName, component, hand) {
            var mapping = hand ? component.mapping[hand] : component.mapping, buttonName = mapping.buttons[id];
            component.el.emit(buttonName + evtName), component.updateModel && component.updateModel(buttonName, evtName);
          };
        },
        "./vendor/DeviceOrientationControls.js": () => {
          THREE.DeviceOrientationControls = function(object) {
            var scope = this;
            this.object = object, this.object.rotation.reorder("YXZ"), this.enabled = !0, this.deviceOrientation = {}, this.screenOrientation = 0, this.alphaOffset = 0;
            var onDeviceOrientationChangeEvent = function(event) {
              scope.deviceOrientation = event;
            }, onScreenOrientationChangeEvent = function() {
              scope.screenOrientation = window.orientation || 0;
            }, setObjectQuaternion = function() {
              var zee = new THREE.Vector3(0, 0, 1), euler = new THREE.Euler(), q0 = new THREE.Quaternion(), q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
              return function(quaternion, alpha, beta, gamma, orient) {
                euler.set(beta, alpha, -gamma, "YXZ"), quaternion.setFromEuler(euler), quaternion.multiply(q1), quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
              };
            }();
            this.connect = function() {
              onScreenOrientationChangeEvent(), window.addEventListener("orientationchange", onScreenOrientationChangeEvent, !1), window.addEventListener("deviceorientation", onDeviceOrientationChangeEvent, !1), scope.enabled = !0;
            }, this.disconnect = function() {
              window.removeEventListener("orientationchange", onScreenOrientationChangeEvent, !1), window.removeEventListener("deviceorientation", onDeviceOrientationChangeEvent, !1), scope.enabled = !1;
            }, this.update = function() {
              if (scope.enabled !== !1) {
                var device = scope.deviceOrientation;
                if (device) {
                  var alpha = device.alpha ? THREE.MathUtils.degToRad(device.alpha) + scope.alphaOffset : 0, beta = device.beta ? THREE.MathUtils.degToRad(device.beta) : 0, gamma = device.gamma ? THREE.MathUtils.degToRad(device.gamma) : 0, orient = scope.screenOrientation ? THREE.MathUtils.degToRad(scope.screenOrientation) : 0;
                  setObjectQuaternion(scope.object.quaternion, alpha, beta, gamma, orient);
                }
              }
            }, this.dispose = function() {
              scope.disconnect();
            }, this.connect();
          };
        },
        "./vendor/rStats.extras.js": (module3) => {
          window.glStats = function() {
            var _rS = null, _totalDrawArraysCalls = 0, _totalDrawElementsCalls = 0, _totalUseProgramCalls = 0, _totalFaces = 0, _totalVertices = 0, _totalPoints = 0, _totalBindTexures = 0;
            function _h(f, c) {
              return function() {
                c.apply(this, arguments), f.apply(this, arguments);
              };
            }
            WebGLRenderingContext.prototype.drawArrays = _h(WebGLRenderingContext.prototype.drawArrays, function() {
              _totalDrawArraysCalls++, arguments[0] == this.POINTS ? _totalPoints += arguments[2] : _totalVertices += arguments[2];
            }), WebGLRenderingContext.prototype.drawElements = _h(WebGLRenderingContext.prototype.drawElements, function() {
              _totalDrawElementsCalls++, _totalFaces += arguments[1] / 3, _totalVertices += arguments[1];
            }), WebGLRenderingContext.prototype.useProgram = _h(WebGLRenderingContext.prototype.useProgram, function() {
              _totalUseProgramCalls++;
            }), WebGLRenderingContext.prototype.bindTexture = _h(WebGLRenderingContext.prototype.bindTexture, function() {
              _totalBindTexures++;
            });
            var _values = {
              allcalls: {
                over: 3e3,
                caption: "Calls (hook)"
              },
              drawelements: {
                caption: "drawElements (hook)"
              },
              drawarrays: {
                caption: "drawArrays (hook)"
              }
            }, _groups = [{
              caption: "WebGL",
              values: ["allcalls", "drawelements", "drawarrays", "useprogram", "bindtexture", "glfaces", "glvertices", "glpoints"]
            }], _fractions = [{
              base: "allcalls",
              steps: ["drawelements", "drawarrays"]
            }];
            function _update() {
              _rS("allcalls").set(_totalDrawArraysCalls + _totalDrawElementsCalls), _rS("drawElements").set(_totalDrawElementsCalls), _rS("drawArrays").set(_totalDrawArraysCalls), _rS("bindTexture").set(_totalBindTexures), _rS("useProgram").set(_totalUseProgramCalls), _rS("glfaces").set(_totalFaces), _rS("glvertices").set(_totalVertices), _rS("glpoints").set(_totalPoints);
            }
            function _start() {
              _totalDrawArraysCalls = 0, _totalDrawElementsCalls = 0, _totalUseProgramCalls = 0, _totalFaces = 0, _totalVertices = 0, _totalPoints = 0, _totalBindTexures = 0;
            }
            function _end() {
            }
            function _attach(r) {
              _rS = r;
            }
            return {
              update: _update,
              start: _start,
              end: _end,
              attach: _attach,
              values: _values,
              groups: _groups,
              fractions: _fractions
            };
          }, window.threeStats = function(renderer) {
            var _rS = null, _values = {
              "renderer.info.memory.geometries": {
                caption: "Geometries"
              },
              "renderer.info.memory.textures": {
                caption: "Textures"
              },
              "renderer.info.programs": {
                caption: "Programs"
              },
              "renderer.info.render.calls": {
                caption: "Calls"
              },
              "renderer.info.render.triangles": {
                caption: "Triangles",
                over: 1e3
              },
              "renderer.info.render.points": {
                caption: "Points"
              }
            }, _groups = [{
              caption: "Three.js - Memory",
              values: ["renderer.info.memory.geometries", "renderer.info.programs", "renderer.info.memory.textures"]
            }, {
              caption: "Three.js - Render",
              values: ["renderer.info.render.calls", "renderer.info.render.triangles", "renderer.info.render.points"]
            }], _fractions = [];
            function _update() {
              _rS("renderer.info.memory.geometries").set(renderer.info.memory.geometries), _rS("renderer.info.programs").set(renderer.info.programs.length), _rS("renderer.info.memory.textures").set(renderer.info.memory.textures), _rS("renderer.info.render.calls").set(renderer.info.render.calls), _rS("renderer.info.render.triangles").set(renderer.info.render.triangles), _rS("renderer.info.render.points").set(renderer.info.render.points);
            }
            function _start() {
            }
            function _end() {
            }
            function _attach(r) {
              _rS = r;
            }
            return {
              update: _update,
              start: _start,
              end: _end,
              attach: _attach,
              values: _values,
              groups: _groups,
              fractions: _fractions
            };
          }, window.BrowserStats = function() {
            var _rS = null, _usedJSHeapSize = 0, _totalJSHeapSize = 0;
            window.performance && !performance.memory && (performance.memory = {
              usedJSHeapSize: 0,
              totalJSHeapSize: 0
            }), performance.memory.totalJSHeapSize === 0 && console.warn("totalJSHeapSize === 0... performance.memory is only available in Chrome .");
            var _values = {
              memory: {
                caption: "Used Memory",
                average: !0,
                avgMs: 1e3,
                over: 22
              },
              total: {
                caption: "Total Memory"
              }
            }, _groups = [{
              caption: "Browser",
              values: ["memory", "total"]
            }], _fractions = [{
              base: "total",
              steps: ["memory"]
            }], log1024 = Math.log(1024);
            function _size(v) {
              var precision = 100, i = Math.floor(Math.log(v) / log1024);
              return Math.round(v * precision / Math.pow(1024, i)) / precision;
            }
            function _update() {
              _usedJSHeapSize = _size(performance.memory.usedJSHeapSize), _totalJSHeapSize = _size(performance.memory.totalJSHeapSize), _rS("memory").set(_usedJSHeapSize), _rS("total").set(_totalJSHeapSize);
            }
            function _start() {
              _usedJSHeapSize = 0;
            }
            function _end() {
            }
            function _attach(r) {
              _rS = r;
            }
            return {
              update: _update,
              start: _start,
              end: _end,
              attach: _attach,
              values: _values,
              groups: _groups,
              fractions: _fractions
            };
          }, module3.exports = {
            glStats: window.glStats,
            threeStats: window.threeStats,
            BrowserStats: window.BrowserStats
          };
        },
        "./vendor/rStats.js": (module3) => {
          "use strict";
          (function() {
            "performance" in window || (window.performance = {});
            var performance2 = window.performance;
            if (!("now" in performance2)) {
              var nowOffset = Date.now();
              performance2.timing && performance2.timing.navigationStart && (nowOffset = performance2.timing.navigationStart), performance2.now = function() {
                return Date.now() - nowOffset;
              };
            }
            performance2.mark || (performance2.mark = function() {
            }), performance2.measure || (performance2.measure = function() {
            });
          })(), window.rStats = function(settings) {
            function iterateKeys(array, callback) {
              for (var keys = Object.keys(array), j = 0, l = keys.length; j < l; j++)
                callback(keys[j]);
            }
            function importCSS(url) {
              var element = document.createElement("link");
              element.href = url, element.rel = "stylesheet", element.type = "text/css", document.getElementsByTagName("head")[0].appendChild(element);
            }
            var _settings = settings || {}, _colours = _settings.colours || ["#850700", "#c74900", "#fcb300", "#284280", "#4c7c0c"], _cssFont = "https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300", _cssRStats = (_settings.CSSPath ? _settings.CSSPath : "") + "rStats.css", _css = _settings.css || [_cssFont, _cssRStats];
            _css.forEach(function(uri) {
              importCSS(uri);
            }), _settings.values || (_settings.values = {});
            var _base, _div, _elHeight = 10, _elWidth = 200, _perfCounters = {};
            function Graph(_dom, _id, _defArg) {
              var _def = _defArg || {}, _canvas = document.createElement("canvas"), _ctx = _canvas.getContext("2d"), _max = 0, _current = 0, c = _def.color ? _def.color : "#666666", _dotCanvas = document.createElement("canvas"), _dotCtx = _dotCanvas.getContext("2d");
              _dotCanvas.width = 1, _dotCanvas.height = 2 * _elHeight, _dotCtx.fillStyle = "#444444", _dotCtx.fillRect(0, 0, 1, 2 * _elHeight), _dotCtx.fillStyle = c, _dotCtx.fillRect(0, _elHeight, 1, _elHeight), _dotCtx.fillStyle = "#ffffff", _dotCtx.globalAlpha = 0.5, _dotCtx.fillRect(0, _elHeight, 1, 1), _dotCtx.globalAlpha = 1;
              var _alarmCanvas = document.createElement("canvas"), _alarmCtx = _alarmCanvas.getContext("2d");
              _alarmCanvas.width = 1, _alarmCanvas.height = 2 * _elHeight, _alarmCtx.fillStyle = "#444444", _alarmCtx.fillRect(0, 0, 1, 2 * _elHeight), _alarmCtx.fillStyle = "#b70000", _alarmCtx.fillRect(0, _elHeight, 1, _elHeight), _alarmCtx.globalAlpha = 0.5, _alarmCtx.fillStyle = "#ffffff", _alarmCtx.fillRect(0, _elHeight, 1, 1), _alarmCtx.globalAlpha = 1;
              function _init2() {
                _canvas.width = _elWidth, _canvas.height = _elHeight, _canvas.style.width = _canvas.width + "px", _canvas.style.height = _canvas.height + "px", _canvas.className = "rs-canvas", _dom.appendChild(_canvas), _ctx.fillStyle = "#444444", _ctx.fillRect(0, 0, _canvas.width, _canvas.height);
              }
              function _draw(v, alarm) {
                _current += (v - _current) * 0.1, _max *= 0.99, _current > _max && (_max = _current), _ctx.drawImage(_canvas, 1, 0, _canvas.width - 1, _canvas.height, 0, 0, _canvas.width - 1, _canvas.height), alarm ? _ctx.drawImage(_alarmCanvas, _canvas.width - 1, _canvas.height - _current * _canvas.height / _max - _elHeight) : _ctx.drawImage(_dotCanvas, _canvas.width - 1, _canvas.height - _current * _canvas.height / _max - _elHeight);
              }
              return _init2(), {
                draw: _draw
              };
            }
            function StackGraph(_dom, _num) {
              var _canvas = document.createElement("canvas"), _ctx = _canvas.getContext("2d");
              function _init2() {
                _canvas.width = _elWidth, _canvas.height = _elHeight * _num, _canvas.style.width = _canvas.width + "px", _canvas.style.height = _canvas.height + "px", _canvas.className = "rs-canvas", _dom.appendChild(_canvas), _ctx.fillStyle = "#444444", _ctx.fillRect(0, 0, _canvas.width, _canvas.height);
              }
              function _draw(v) {
                _ctx.drawImage(_canvas, 1, 0, _canvas.width - 1, _canvas.height, 0, 0, _canvas.width - 1, _canvas.height);
                var th = 0;
                iterateKeys(v, function(j) {
                  var h = v[j] * _canvas.height;
                  _ctx.fillStyle = _colours[j], _ctx.fillRect(_canvas.width - 1, th, 1, h), th += h;
                });
              }
              return _init2(), {
                draw: _draw
              };
            }
            function PerfCounter(id, group) {
              var _id = id, _time, _value = 0, _total = 0, _averageValue = 0, _accumValue = 0, _accumStart = performance.now(), _accumSamples = 0, _dom = document.createElement("div"), _spanId = document.createElement("span"), _spanValue = document.createElement("div"), _spanValueText = document.createTextNode(""), _def = _settings ? _settings.values[_id.toLowerCase()] : null, _graph = new Graph(_dom, _id, _def), _started = !1;
              _spanId.className = "rs-counter-id", _spanId.textContent = _def && _def.caption ? _def.caption : _id, _spanValue.className = "rs-counter-value", _spanValue.appendChild(_spanValueText), _dom.appendChild(_spanId), _dom.appendChild(_spanValue), group ? group.div.appendChild(_dom) : _div.appendChild(_dom), _time = performance.now();
              function _average(v) {
                if (_def && _def.average) {
                  _accumValue += v, _accumSamples++;
                  var t = performance.now();
                  t - _accumStart >= (_def.avgMs || 1e3) && (_averageValue = _accumValue / _accumSamples, _accumValue = 0, _accumStart = t, _accumSamples = 0);
                }
              }
              function _start() {
                _time = performance.now(), _settings.userTimingAPI && performance.mark(_id + "-start"), _started = !0;
              }
              function _end() {
                _value = performance.now() - _time, _settings.userTimingAPI && (performance.mark(_id + "-end"), _started && performance.measure(_id, _id + "-start", _id + "-end")), _average(_value);
              }
              function _tick() {
                _end(), _start();
              }
              function _draw() {
                var v = _def && _def.average ? _averageValue : _value;
                _spanValueText.nodeValue = Math.round(v * 100) / 100;
                var a = _def && (_def.below && _value < _def.below || _def.over && _value > _def.over);
                _graph.draw(_value, a), _dom.className = a ? "rs-counter-base alarm" : "rs-counter-base";
              }
              function _frame() {
                var t = performance.now(), e = t - _time;
                _total++, e > 1e3 && (_def && _def.interpolate === !1 ? _value = _total : _value = _total * 1e3 / e, _total = 0, _time = t, _average(_value));
              }
              function _set(v) {
                _value = v, _average(_value);
              }
              return {
                set: _set,
                start: _start,
                tick: _tick,
                end: _end,
                frame: _frame,
                value: function() {
                  return _value;
                },
                draw: _draw
              };
            }
            function sample() {
              var _value = 0;
              function _set(v) {
                _value = v;
              }
              return {
                set: _set,
                value: function() {
                  return _value;
                }
              };
            }
            function _perf(idArg) {
              var id = idArg.toLowerCase();
              if (id === void 0 && (id = "default"), _perfCounters[id])
                return _perfCounters[id];
              var group = null;
              _settings && _settings.groups && iterateKeys(_settings.groups, function(j) {
                var g = _settings.groups[parseInt(j, 10)];
                !group && g.values.indexOf(id.toLowerCase()) !== -1 && (group = g);
              });
              var p = new PerfCounter(id, group);
              return _perfCounters[id] = p, p;
            }
            function _init() {
              if (_settings.plugins) {
                _settings.values || (_settings.values = {}), _settings.groups || (_settings.groups = []), _settings.fractions || (_settings.fractions = []);
                for (var j = 0; j < _settings.plugins.length; j++)
                  _settings.plugins[j].attach(_perf), iterateKeys(_settings.plugins[j].values, function(k) {
                    _settings.values[k] = _settings.plugins[j].values[k];
                  }), _settings.groups = _settings.groups.concat(_settings.plugins[j].groups), _settings.fractions = _settings.fractions.concat(_settings.plugins[j].fractions);
              } else
                _settings.plugins = {};
              _base = document.createElement("div"), _base.className = "rs-base", _div = document.createElement("div"), _div.className = "rs-container", _div.style.height = "auto", _base.appendChild(_div), document.body.appendChild(_base), !!_settings && (_settings.groups && iterateKeys(_settings.groups, function(j2) {
                var g = _settings.groups[parseInt(j2, 10)], div = document.createElement("div");
                div.className = "rs-group", g.div = div;
                var h1 = document.createElement("h1");
                h1.textContent = g.caption, h1.addEventListener("click", function(e) {
                  this.classList.toggle("hidden"), e.preventDefault();
                }.bind(div)), _div.appendChild(h1), _div.appendChild(div);
              }), _settings.fractions && iterateKeys(_settings.fractions, function(j2) {
                var f = _settings.fractions[parseInt(j2, 10)], div = document.createElement("div");
                div.className = "rs-fraction";
                var legend = document.createElement("div");
                legend.className = "rs-legend";
                var h = 0;
                iterateKeys(_settings.fractions[j2].steps, function(k) {
                  var p = document.createElement("p");
                  p.textContent = _settings.fractions[j2].steps[k], p.style.color = _colours[h], legend.appendChild(p), h++;
                }), div.appendChild(legend), div.style.height = h * _elHeight + "px", f.div = div;
                var graph = new StackGraph(div, h);
                f.graph = graph, _div.appendChild(div);
              }));
            }
            function _update() {
              iterateKeys(_settings.plugins, function(j) {
                _settings.plugins[j].update();
              }), iterateKeys(_perfCounters, function(j) {
                _perfCounters[j].draw();
              }), _settings && _settings.fractions && iterateKeys(_settings.fractions, function(j) {
                var f = _settings.fractions[parseInt(j, 10)], v = [], base = _perfCounters[f.base.toLowerCase()];
                base && (base = base.value(), iterateKeys(_settings.fractions[j].steps, function(k) {
                  var s = _settings.fractions[j].steps[parseInt(k, 10)].toLowerCase(), val = _perfCounters[s];
                  val && v.push(val.value() / base);
                })), f.graph.draw(v);
              });
            }
            return _init(), function(id) {
              return id ? _perf(id) : {
                element: _base,
                update: _update
              };
            };
          }, module3.exports = window.rStats;
        },
        "./vendor/wakelock/util.js": (module3) => {
          var Util = {};
          Util.base64 = function(mimeType, base64) {
            return "data:" + mimeType + ";base64," + base64;
          }, Util.isMobile = function() {
            var check = !1;
            return function(a) {
              (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) && (check = !0);
            }(navigator.userAgent || navigator.vendor || window.opera), check;
          }, Util.isIOS = function() {
            return /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
          }, Util.isIFrame = function() {
            try {
              return window.self !== window.top;
            } catch (e) {
              return !0;
            }
          }, Util.appendQueryParameter = function(url, key, value) {
            var delimiter = url.indexOf("?") < 0 ? "?" : "&";
            return url += delimiter + key + "=" + value, url;
          }, Util.getQueryParameter = function(name) {
            name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"), results = regex.exec(location.search);
            return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
          }, Util.isLandscapeMode = function() {
            return window.orientation == 90 || window.orientation == -90;
          }, module3.exports = Util;
        },
        "./vendor/wakelock/wakelock.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          var Util = __webpack_require__2("./vendor/wakelock/util.js");
          function AndroidWakeLock() {
            var video = document.createElement("video");
            video.addEventListener("ended", function() {
              video.play();
            }), this.request = function() {
              video.paused && (video.src = Util.base64("video/webm", "GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw=="), video.play());
            }, this.release = function() {
              video.pause(), video.src = "";
            };
          }
          function iOSWakeLock() {
            var timer = null;
            this.request = function() {
              timer || (timer = setInterval(function() {
                window.location.href = "/", setTimeout(window.stop, 0);
              }, 15e3));
            }, this.release = function() {
              timer && (clearInterval(timer), timer = null);
            };
          }
          function getWakeLock() {
            var userAgent = navigator.userAgent || navigator.vendor || window.opera;
            return userAgent.match(/iPhone/i) || userAgent.match(/iPod/i) ? iOSWakeLock : AndroidWakeLock;
          }
          module3.exports = getWakeLock();
        },
        "./node_modules/css-loader/dist/cjs.js!./src/style/aframe.css": (module3, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            default: () => __WEBPACK_DEFAULT_EXPORT__
          });
          var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/css-loader/dist/runtime/sourceMaps.js"), _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__), _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2("./node_modules/css-loader/dist/runtime/api.js"), _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__), _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2("./node_modules/css-loader/dist/runtime/getUrl.js"), _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__), ___CSS_LOADER_URL_IMPORT_0___ = new URL(__webpack_require__2("data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"), __webpack_require__2.b), ___CSS_LOADER_URL_IMPORT_1___ = new URL(__webpack_require__2("data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"), __webpack_require__2.b), ___CSS_LOADER_URL_IMPORT_2___ = new URL(__webpack_require__2("data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E"), __webpack_require__2.b), ___CSS_LOADER_URL_IMPORT_3___ = new URL(__webpack_require__2("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E"), __webpack_require__2.b), ___CSS_LOADER_URL_IMPORT_4___ = new URL(__webpack_require__2("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E"), __webpack_require__2.b), ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()), ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___), ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___), ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___), ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___), ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);
          ___CSS_LOADER_EXPORT___.push([module3.id, `/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url(` + ___CSS_LOADER_URL_REPLACEMENT_0___ + `) 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url(` + ___CSS_LOADER_URL_REPLACEMENT_1___ + `) 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url(` + ___CSS_LOADER_URL_REPLACEMENT_2___ + `);
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(` + ___CSS_LOADER_URL_REPLACEMENT_3___ + `) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(` + ___CSS_LOADER_URL_REPLACEMENT_4___ + `) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`, "", { version: 3, sources: ["webpack://./src/style/aframe.css"], names: [], mappings: "AAAA,sCAAsC;AACtC;EACE,SAAS;EACT,OAAO;EACP,eAAe;EACf,QAAQ;EACR,MAAM;AACR;;AAEA;EACE,YAAY;EACZ,SAAS;EACT,gBAAgB;EAChB,UAAU;EACV,WAAW;AACb;;AAEA,oDAAoD;AACpD;EACE,sBAAsB;EACtB,uBAAuB;EACvB,iBAAiB;EACjB,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;EACpB,0BAA0B;AAC5B;;AAEA;;EAEE,UAAU;EACV,WAAW;AACb;;AAEA;EACE,WAAW;AACb;;AAEA,gEAAgE;AAChE;EACE,6BAA6B;AAC/B;;AAEA;EACE,wBAAwB;AAC1B;;AAEA;EACE,YAAY;EACZ,OAAO;EACP,kBAAkB;EAClB,MAAM;EACN,WAAW;AACb;;AAEA;EACE,YAAY;EACZ,iBAAiB;EACjB,oBAAoB;AACtB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,yBAAyB;EACzB,eAAe;EACf,SAAS;EACT,QAAQ;EACR,iBAAiB;EACjB,WAAW;EACX,qBAAqB;EACrB,eAAe;EACf,8BAA8B;EAC9B,kBAAkB;EAClB,cAAc;EACd,YAAY;AACd;;AAEA,+BAA+B;AAC/B,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;;AAErE;EACE,sCAAsC;EACtC,8CAA8C;AAChD;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,YAAY;EACZ,WAAW;AACb;;AAEA;;;;EAIE,aAAa;AACf;;AAEA;;EAEE,0DAA0D;AAC5D;;AAEA;EACE,6BAA6B;EAC7B,cAAc;EACd,qBAAqB;EACrB,6BAA6B;AAC/B;;AAEA;EACE,sBAAsB;EACtB,WAAW;EACX,gBAAgB;EAChB,kBAAkB;EAClB,UAAU;AACZ;;AAEA;;EAEE,kCAAkC;EAClC,eAAe;EACf,WAAW;EACX,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,WAAW;AACb;;AAEA;;;EAGE,WAAW;EACX,iBAAiB;EACjB,aAAa;AACf;;AAEA;EACE,yFAA4qB;AAC9qB;;AAEA;EACE,yFAAkzB;AACpzB;;AAEA;EACE,yDAA2qK;AAC7qK;;AAEA;;EAEE,wBAAwB;EACxB,SAAS;EACT,SAAS;EACT,eAAe;EACf,eAAe;EACf,gBAAgB;EAChB,kBAAkB;EAClB;;;;GAIC;EACD,gBAAgB;EAChB,cAAc;EACd,kBAAkB;EAClB,QAAQ;EACR,sCAAsC;EACtC,8CAA8C;EAC9C,aAAa;EACb,kBAAkB;EAClB,0BAA0B,EAAE,8CAA8C;AAC5E;;AAEA;EACE,yBAAyB;EACzB,kBAAkB;AACpB;;AAEA;;;;EAIE,yBAAyB;AAC3B;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,sBAAsB;EACtB,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,SAAS;EACT,kBAAkB;AACpB;;AAEA;EACE,qCAAqC;EACrC,4BAA4B;EAC5B,kCAAkC;EAClC,qBAAqB;EACrB,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,QAAQ;EACR,QAAQ;EACR,SAAS;AACX;;AAEA;;EAEE,eAAe;AACjB;;AAEA;EACE,SAAS;AACX;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,2FAAivF;EACjvF,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,8CAA8C;EAC9C,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,QAAQ;EACR,2BAA2B;EAC3B,WAAW;AACb;;AAEA;EACE,6DAA25B;EAC35B,YAAY;EACZ,YAAY;EACZ,oBAAoB;EACpB,WAAW;AACb;;AAEA;EACE,oCAAoC;EACpC,kCAAkC;EAClC,kBAAkB;EAClB,eAAe;EACf,YAAY;EACZ,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,UAAU;EACV,SAAS;EACT,QAAQ;EACR,YAAY;AACd;;AAEA;EACE,kBAAkB;EAClB,+BAA+B;EAC/B,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,gCAAgC;EAChC,eAAe;EACf,YAAY;EACZ,aAAa;EACb,wBAAwB;EACxB,uBAAuB;EACvB,kCAAkC;EAClC,eAAe;EACf,kBAAkB;EAClB,YAAY;AACd;;AAEA;EACE,WAAW;EACX,WAAW;EACX,sBAAsB;EACtB,aAAa;EACb,uBAAuB;EACvB,qBAAqB;EACrB,sBAAsB;AACxB;;AAEA;EACE,qBAAqB;EACrB,mBAAmB;EACnB,eAAe;EACf,WAAW;AACb;;AAEA;EACE,oBAAoB;EACpB,oBAAoB;EACpB,WAAW;EACX,WAAW;AACb;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,UAAU;EACV,eAAe;EACf,WAAW;EACX,kBAAkB;EAClB,iBAAiB;EACjB,YAAY;EACZ,qBAAqB;EACrB,yCAAyC;EACzC,iCAAiC;EACjC,wEAAwE;EACxE,iBAAiB;AACnB;;AAEA;EACE,mEAAmE;AACrE;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;EACzB,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,kBAAkB;EAClB,oBAAoB;EACpB,sBAAsB;EACtB,SAAS;EACT,OAAO;EACP,QAAQ;EACR,MAAM;EACN,YAAY;AACd;;AAEA;EACE,oBAAoB;AACtB", sourcesContent: [`/* .a-fullscreen means not embedded. */
html.a-fullscreen {
  bottom: 0;
  left: 0;
  position: fixed;
  right: 0;
  top: 0;
}

html.a-fullscreen body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  padding: 0;
  width: 100%;
}

/* Class is removed when doing <a-scene embedded>. */
html.a-fullscreen .a-canvas {
  width: 100% !important;
  height: 100% !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  position: fixed !important;
}

html:not(.a-fullscreen) .a-enter-vr,
html:not(.a-fullscreen) .a-enter-ar {
  right: 5px;
  bottom: 5px;
}

html:not(.a-fullscreen) .a-enter-ar {
  right: 60px;
}

/* In chrome mobile the user agent stylesheet set it to white  */
:-webkit-full-screen {
  background-color: transparent;
}

.a-hidden {
  display: none !important;
}

.a-canvas {
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}

.a-canvas.a-grab-cursor:hover {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}

canvas.a-canvas.a-mouse-cursor-hover:hover {
  cursor: pointer;
}

.a-inspector-loader {
  background-color: #ed3160;
  position: fixed;
  left: 3px;
  top: 3px;
  padding: 6px 10px;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  font-family: Roboto,sans-serif;
  text-align: center;
  z-index: 99999;
  width: 204px;
}

/* Inspector loader animation */
@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }
@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }
@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }
@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }

.a-inspector-loader .dots span {
  animation: dots-1 2s infinite steps(1);
  -webkit-animation: dots-1 2s infinite steps(1);
}

.a-inspector-loader .dots span:first-child + span {
  animation-name: dots-2;
  -webkit-animation-name: dots-2;
}

.a-inspector-loader .dots span:first-child + span + span {
  animation-name: dots-3;
  -webkit-animation-name: dots-3;
}

a-scene {
  display: block;
  position: relative;
  height: 100%;
  width: 100%;
}

a-assets,
a-scene video,
a-scene img,
a-scene audio {
  display: none;
}

.a-enter-vr-modal,
.a-orientation-modal {
  font-family: Consolas, Andale Mono, Courier New, monospace;
}

.a-enter-vr-modal a {
  border-bottom: 1px solid #fff;
  padding: 2px 0;
  text-decoration: none;
  transition: .1s color ease-in;
}

.a-enter-vr-modal a:hover {
  background-color: #fff;
  color: #111;
  padding: 2px 4px;
  position: relative;
  left: -4px;
}

.a-enter-vr,
.a-enter-ar {
  font-family: sans-serif, monospace;
  font-size: 13px;
  width: 100%;
  font-weight: 200;
  line-height: 16px;
  position: absolute;
  right: 20px;
  bottom: 20px;
}

.a-enter-ar.xr {
  right: 90px;
}

.a-enter-vr-button,
.a-enter-vr-modal,
.a-enter-vr-modal a {
  color: #fff;
  user-select: none;
  outline: none;
}

.a-enter-vr-button {
  background: rgba(0, 0, 0, 0.35) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z' fill='%23fff'/%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-ar-button {
  background: rgba(0, 0, 0, 0.20) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z' fill='%23fff'/%3E%3Cpath d='M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z' fill='%23fff'/%3E%3Cpath d='M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z' fill='%23fff'/%3E%3C/svg%3E") 50% 50% no-repeat;
}

.a-enter-vr.fullscreen .a-enter-vr-button {
  background-image: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg width='108' height='62' viewBox='0 0 108 62' version='1.1' id='svg320' sodipodi:docname='fullscreen-aframe.svg' xml:space='preserve' inkscape:version='1.2.1 (9c6d41e  2022-07-14)' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:cc='http://creativecommons.org/ns%23' xmlns:dc='http://purl.org/dc/elements/1.1/'%3E%3Cdefs id='defs324' /%3E%3Csodipodi:namedview id='namedview322' pagecolor='%23ffffff' bordercolor='%23000000' borderopacity='0.25' inkscape:showpageshadow='2' inkscape:pageopacity='0.0' inkscape:pagecheckerboard='0' inkscape:deskcolor='%23d1d1d1' showgrid='false' inkscape:zoom='3.8064516' inkscape:cx='91.423729' inkscape:cy='-1.4449153' inkscape:window-width='1440' inkscape:window-height='847' inkscape:window-x='32' inkscape:window-y='25' inkscape:window-maximized='0' inkscape:current-layer='svg320' /%3E%3Ctitle id='title312'%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z' fill='%23fff' id='path314' style='fill:%23ffffff' /%3E%3Cg id='g356' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g358' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g360' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g362' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g364' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g366' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g368' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g370' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g372' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g374' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g376' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g378' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g380' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g382' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g384' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cmetadata id='metadata561'%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=''%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d='m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4' id='path596' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4' id='path598' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4' id='path600' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616' id='path602' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3C/svg%3E");
}

.a-enter-vr-button,
.a-enter-ar-button {
  background-size: 90% 90%;
  border: 0;
  bottom: 0;
  cursor: pointer;
  min-width: 58px;
  min-height: 34px;
  /* 1.74418604651 */
  /*
    In order to keep the aspect ratio when resizing
    padding-top percentages are relative to the containing block's width.
    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio
  */
  padding-right: 0;
  padding-top: 0;
  position: absolute;
  right: 0;
  transition: background-color .05s ease;
  -webkit-transition: background-color .05s ease;
  z-index: 9999;
  border-radius: 8px;
  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */
}

.a-enter-ar-button {
  background-size: 100% 90%;
  border-radius: 7px;
}

.a-enter-ar-button:active,
.a-enter-ar-button:hover,
.a-enter-vr-button:active,
.a-enter-vr-button:hover {
  background-color: #ef2d5e;
}

.a-enter-vr-button.resethover {
  background-color: rgba(0, 0, 0, 0.35);
}

.a-enter-vr-modal {
  background-color: #666;
  border-radius: 0;
  display: none;
  min-height: 32px;
  margin-right: 70px;
  padding: 9px;
  width: 280px;
  right: 2%;
  position: absolute;
}

.a-enter-vr-modal:after {
  border-bottom: 10px solid transparent;
  border-left: 10px solid #666;
  border-top: 10px solid transparent;
  display: inline-block;
  content: '';
  position: absolute;
  right: -5px;
  top: 5px;
  width: 0;
  height: 0;
}

.a-enter-vr-modal p,
.a-enter-vr-modal a {
  display: inline;
}

.a-enter-vr-modal p {
  margin: 0;
}

.a-enter-vr-modal p:after {
  content: ' ';
}

.a-orientation-modal {
  background: rgba(244, 244, 244, 1) url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center no-repeat;
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-orientation-modal:after {
  color: #666;
  content: "Insert phone into Cardboard holder.";
  display: block;
  position: absolute;
  text-align: center;
  top: 70%;
  transform: translateY(-70%);
  width: 100%;
}

.a-orientation-modal button {
  background: url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E) no-repeat;
  border: none;
  height: 50px;
  text-indent: -9999px;
  width: 50px;
}

.a-loader-title {
  background-color: rgba(0, 0, 0, 0.6);
  font-family: sans-serif, monospace;
  text-align: center;
  font-size: 20px;
  height: 50px;
  font-weight: 300;
  line-height: 50px;
  position: absolute;
  right: 0px;
  left: 0px;
  top: 0px;
  color: white;
}

.a-modal {
  position: absolute;
  background: rgba(0, 0, 0, 0.60);
  background-size: 50% 50%;
  bottom: 0;
  font-size: 14px;
  font-weight: 600;
  left: 0;
  line-height: 20px;
  right: 0;
  position: fixed;
  top: 0;
  z-index: 9999999;
}

.a-dialog {
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  z-index: 199995;
  width: 300px;
  height: 200px;
  background-size: contain;
  background-color: white;
  font-family: sans-serif, monospace;
  font-size: 20px;
  border-radius: 3px;
  padding: 6px;
}

.a-dialog-text-container {
  width: 100%;
  height: 70%;
  align-self: flex-start;
  display: flex;
  justify-content: center;
  align-content: center;
  flex-direction: column;
}

.a-dialog-text {
  display: inline-block;
  font-weight: normal;
  font-size: 14pt;
  margin: 8px;
}

.a-dialog-buttons-container {
  display: inline-flex;
  align-self: flex-end;
  width: 100%;
  height: 30%;
}

.a-dialog-button {
  cursor: pointer;
  align-self: center;
  opacity: 0.9;
  height: 80%;
  width: 50%;
  font-size: 12pt;
  margin: 4px;
  border-radius: 2px;
  text-align:center;
  border: none;
  display: inline-block;
  -webkit-transition: all 0.25s ease-in-out;
  transition: all 0.25s ease-in-out;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);
  user-select: none;
}

.a-dialog-permission-button:hover {
  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);
}

.a-dialog-allow-button {
  background-color: #00ceff;
}

.a-dialog-deny-button {
  background-color: #ff005b;
}

.a-dialog-ok-button {
  background-color: #00ceff;
  width: 100%;
}

.a-dom-overlay:not(.a-no-style) {
  overflow: hidden;
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  padding: 1em;
}

.a-dom-overlay:not(.a-no-style)>* {
  pointer-events: auto;
}
`], sourceRoot: "" }]);
          let __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
        },
        "./node_modules/css-loader/dist/cjs.js!./src/style/rStats.css": (module3, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            default: () => __WEBPACK_DEFAULT_EXPORT__
          });
          var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/css-loader/dist/runtime/sourceMaps.js"), _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__), _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2("./node_modules/css-loader/dist/runtime/api.js"), _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__), ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
          ___CSS_LOADER_EXPORT___.push([module3.id, `.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`, "", { version: 3, sources: ["webpack://./src/style/rStats.css"], names: [], mappings: "AAAA;EACE,sBAAsB;EACtB,cAAc;EACd,gBAAgB;EAChB,oBAAoB;EACpB,SAAS;EACT,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,aAAa;EACb,eAAe;EACf,QAAQ;EACR,YAAY;EACZ,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;EACX,eAAe;EACf,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;EACf,UAAU;AACZ;;AAEA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,sCAAsC;EACtC,8BAA8B;EAC9B,kBAAkB;AACpB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,YAAY;EACZ,sCAAsC;EACtC,8BAA8B;EAC9B,aAAa;AACf;;AAEA;EACE,cAAc;EACd;;;;;;;;2BAQyB;AAC3B;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,iBAAiB;EACjB,WAAW;AACb;;AAEA;EACE,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;AACV;;AAEA;EACE;IACE,UAAU;IACV,SAAS;EACX;AACF", sourcesContent: [`.rs-base {
  background-color: #333;
  color: #fafafa;
  border-radius: 0;
  font: 10px monospace;
  left: 5px;
  line-height: 1em;
  opacity: 0.85;
  overflow: hidden;
  padding: 10px;
  position: fixed;
  top: 5px;
  width: 300px;
  z-index: 10000;
}

.rs-base div.hidden {
  display: none;
}

.rs-base h1 {
  color: #fff;
  cursor: pointer;
  font-size: 1.4em;
  font-weight: 300;
  margin: 0 0 5px;
  padding: 0;
}

.rs-group {
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
  margin-bottom: 5px;
}

.rs-group:last-child {
  margin-bottom: 0;
}

.rs-counter-base {
  align-items: center;
  display: -webkit-box;
  display: -webkit-flex;
  display: flex;
  height: 10px;
  -webkit-justify-content: space-between;
  justify-content: space-between;
  margin: 2px 0;
}

.rs-counter-base.alarm {
  color: #b70000;
  text-shadow: 0 0 0 #b70000,
               0 0 1px #fff,
               0 0 1px #fff,
               0 0 2px #fff,
               0 0 2px #fff,
               0 0 3px #fff,
               0 0 3px #fff,
               0 0 4px #fff,
               0 0 4px #fff;
}

.rs-counter-id {
  font-weight: 300;
  -webkit-box-ordinal-group: 0;
  -webkit-order: 0;
  order: 0;
  width: 54px;
}

.rs-counter-value {
  font-weight: 300;
  -webkit-box-ordinal-group: 1;
  -webkit-order: 1;
  order: 1;
  text-align: right;
  width: 35px;
}

.rs-canvas {
  -webkit-box-ordinal-group: 2;
  -webkit-order: 2;
  order: 2;
}

@media (min-width: 480px) {
  .rs-base {
    left: 20px;
    top: 20px;
  }
}
`], sourceRoot: "" }]);
          let __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
        },
        "./src/style/aframe.css": (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            default: () => __WEBPACK_DEFAULT_EXPORT__
          });
          var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"), _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__), _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/styleDomAPI.js"), _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__), _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/insertBySelector.js"), _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__), _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"), _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__), _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/insertStyleElement.js"), _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__), _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/styleTagTransform.js"), _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__), _node_modules_css_loader_dist_cjs_js_aframe_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2("./node_modules/css-loader/dist/cjs.js!./src/style/aframe.css"), options = {};
          options.styleTagTransform = _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default(), options.setAttributes = _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default(), options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head"), options.domAPI = _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default(), options.insertStyleElement = _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default();
          var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_aframe_css__WEBPACK_IMPORTED_MODULE_6__.default, options);
          let __WEBPACK_DEFAULT_EXPORT__ = _node_modules_css_loader_dist_cjs_js_aframe_css__WEBPACK_IMPORTED_MODULE_6__.default && _node_modules_css_loader_dist_cjs_js_aframe_css__WEBPACK_IMPORTED_MODULE_6__.default.locals ? _node_modules_css_loader_dist_cjs_js_aframe_css__WEBPACK_IMPORTED_MODULE_6__.default.locals : void 0;
        },
        "./src/style/rStats.css": (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            default: () => __WEBPACK_DEFAULT_EXPORT__
          });
          var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js"), _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__), _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/styleDomAPI.js"), _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__), _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/insertBySelector.js"), _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__), _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js"), _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__), _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/insertStyleElement.js"), _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__), _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2("./node_modules/style-loader/dist/runtime/styleTagTransform.js"), _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__), _node_modules_css_loader_dist_cjs_js_rStats_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2("./node_modules/css-loader/dist/cjs.js!./src/style/rStats.css"), options = {};
          options.styleTagTransform = _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default(), options.setAttributes = _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default(), options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head"), options.domAPI = _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default(), options.insertStyleElement = _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default();
          var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_rStats_css__WEBPACK_IMPORTED_MODULE_6__.default, options);
          let __WEBPACK_DEFAULT_EXPORT__ = _node_modules_css_loader_dist_cjs_js_rStats_css__WEBPACK_IMPORTED_MODULE_6__.default && _node_modules_css_loader_dist_cjs_js_rStats_css__WEBPACK_IMPORTED_MODULE_6__.default.locals ? _node_modules_css_loader_dist_cjs_js_rStats_css__WEBPACK_IMPORTED_MODULE_6__.default.locals : void 0;
        },
        "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js": (module3) => {
          "use strict";
          var stylesInDOM = [];
          function getIndexByIdentifier(identifier) {
            for (var result = -1, i = 0; i < stylesInDOM.length; i++)
              if (stylesInDOM[i].identifier === identifier) {
                result = i;
                break;
              }
            return result;
          }
          function modulesToDom(list, options) {
            for (var idCountMap = {}, identifiers = [], i = 0; i < list.length; i++) {
              var item = list[i], id = options.base ? item[0] + options.base : item[0], count = idCountMap[id] || 0, identifier = "".concat(id, " ").concat(count);
              idCountMap[id] = count + 1;
              var indexByIdentifier = getIndexByIdentifier(identifier), obj = {
                css: item[1],
                media: item[2],
                sourceMap: item[3],
                supports: item[4],
                layer: item[5]
              };
              if (indexByIdentifier !== -1)
                stylesInDOM[indexByIdentifier].references++, stylesInDOM[indexByIdentifier].updater(obj);
              else {
                var updater = addElementStyle(obj, options);
                options.byIndex = i, stylesInDOM.splice(i, 0, {
                  identifier,
                  updater,
                  references: 1
                });
              }
              identifiers.push(identifier);
            }
            return identifiers;
          }
          function addElementStyle(obj, options) {
            var api = options.domAPI(options);
            api.update(obj);
            var updater = function(newObj) {
              if (newObj) {
                if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer)
                  return;
                api.update(obj = newObj);
              } else
                api.remove();
            };
            return updater;
          }
          module3.exports = function(list, options) {
            options = options || {}, list = list || [];
            var lastIdentifiers = modulesToDom(list, options);
            return function(newList) {
              newList = newList || [];
              for (var i = 0; i < lastIdentifiers.length; i++) {
                var identifier = lastIdentifiers[i], index = getIndexByIdentifier(identifier);
                stylesInDOM[index].references--;
              }
              for (var newLastIdentifiers = modulesToDom(newList, options), _i = 0; _i < lastIdentifiers.length; _i++) {
                var _identifier = lastIdentifiers[_i], _index = getIndexByIdentifier(_identifier);
                stylesInDOM[_index].references === 0 && (stylesInDOM[_index].updater(), stylesInDOM.splice(_index, 1));
              }
              lastIdentifiers = newLastIdentifiers;
            };
          };
        },
        "./node_modules/style-loader/dist/runtime/insertBySelector.js": (module3) => {
          "use strict";
          var memo = {};
          function getTarget(target) {
            if (typeof memo[target] == "undefined") {
              var styleTarget = document.querySelector(target);
              if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement)
                try {
                  styleTarget = styleTarget.contentDocument.head;
                } catch (e) {
                  styleTarget = null;
                }
              memo[target] = styleTarget;
            }
            return memo[target];
          }
          function insertBySelector(insert, style) {
            var target = getTarget(insert);
            if (!target)
              throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
            target.appendChild(style);
          }
          module3.exports = insertBySelector;
        },
        "./node_modules/style-loader/dist/runtime/insertStyleElement.js": (module3) => {
          "use strict";
          function insertStyleElement(options) {
            var element = document.createElement("style");
            return options.setAttributes(element, options.attributes), options.insert(element, options.options), element;
          }
          module3.exports = insertStyleElement;
        },
        "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
          "use strict";
          function setAttributesWithoutAttributes(styleElement) {
            var nonce = __webpack_require__2.nc;
            nonce && styleElement.setAttribute("nonce", nonce);
          }
          module3.exports = setAttributesWithoutAttributes;
        },
        "./node_modules/style-loader/dist/runtime/styleDomAPI.js": (module3) => {
          "use strict";
          function apply(styleElement, options, obj) {
            var css = "";
            obj.supports && (css += "@supports (".concat(obj.supports, ") {")), obj.media && (css += "@media ".concat(obj.media, " {"));
            var needLayer = typeof obj.layer != "undefined";
            needLayer && (css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {")), css += obj.css, needLayer && (css += "}"), obj.media && (css += "}"), obj.supports && (css += "}");
            var sourceMap = obj.sourceMap;
            sourceMap && typeof btoa != "undefined" && (css += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */")), options.styleTagTransform(css, styleElement, options.options);
          }
          function removeStyleElement(styleElement) {
            if (styleElement.parentNode === null)
              return !1;
            styleElement.parentNode.removeChild(styleElement);
          }
          function domAPI(options) {
            if (typeof document == "undefined")
              return {
                update: function() {
                },
                remove: function() {
                }
              };
            var styleElement = options.insertStyleElement(options);
            return {
              update: function(obj) {
                apply(styleElement, options, obj);
              },
              remove: function() {
                removeStyleElement(styleElement);
              }
            };
          }
          module3.exports = domAPI;
        },
        "./node_modules/style-loader/dist/runtime/styleTagTransform.js": (module3) => {
          "use strict";
          function styleTagTransform(css, styleElement) {
            if (styleElement.styleSheet)
              styleElement.styleSheet.cssText = css;
            else {
              for (; styleElement.firstChild; )
                styleElement.removeChild(styleElement.firstChild);
              styleElement.appendChild(document.createTextNode(css));
            }
          }
          module3.exports = styleTagTransform;
        },
        "data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E": (module3) => {
          "use strict";
          module3.exports = "data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E";
        },
        "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E": (module3) => {
          "use strict";
          module3.exports = "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E";
        },
        "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E": (module3) => {
          "use strict";
          module3.exports = "data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E";
        },
        "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E": (module3) => {
          "use strict";
          module3.exports = "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E";
        },
        "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E": (module3) => {
          "use strict";
          module3.exports = "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E";
        },
        "./node_modules/three/build/three.module.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            ACESFilmicToneMapping: () => ACESFilmicToneMapping,
            AddEquation: () => AddEquation,
            AddOperation: () => AddOperation,
            AdditiveAnimationBlendMode: () => AdditiveAnimationBlendMode,
            AdditiveBlending: () => AdditiveBlending,
            AgXToneMapping: () => AgXToneMapping,
            AlphaFormat: () => AlphaFormat,
            AlwaysCompare: () => AlwaysCompare,
            AlwaysDepth: () => AlwaysDepth,
            AlwaysStencilFunc: () => AlwaysStencilFunc,
            AmbientLight: () => AmbientLight,
            AnimationAction: () => AnimationAction,
            AnimationClip: () => AnimationClip,
            AnimationLoader: () => AnimationLoader,
            AnimationMixer: () => AnimationMixer,
            AnimationObjectGroup: () => AnimationObjectGroup,
            AnimationUtils: () => AnimationUtils,
            ArcCurve: () => ArcCurve,
            ArrayCamera: () => ArrayCamera,
            ArrowHelper: () => ArrowHelper,
            AttachedBindMode: () => AttachedBindMode,
            Audio: () => Audio,
            AudioAnalyser: () => AudioAnalyser,
            AudioContext: () => AudioContext,
            AudioListener: () => AudioListener,
            AudioLoader: () => AudioLoader,
            AxesHelper: () => AxesHelper,
            BackSide: () => BackSide,
            BasicDepthPacking: () => BasicDepthPacking,
            BasicShadowMap: () => BasicShadowMap,
            BatchedMesh: () => BatchedMesh,
            Bone: () => Bone,
            BooleanKeyframeTrack: () => BooleanKeyframeTrack,
            Box2: () => Box2,
            Box3: () => Box3,
            Box3Helper: () => Box3Helper,
            BoxGeometry: () => BoxGeometry,
            BoxHelper: () => BoxHelper,
            BufferAttribute: () => BufferAttribute,
            BufferGeometry: () => BufferGeometry,
            BufferGeometryLoader: () => BufferGeometryLoader,
            ByteType: () => ByteType,
            Cache: () => Cache,
            Camera: () => Camera,
            CameraHelper: () => CameraHelper,
            CanvasTexture: () => CanvasTexture,
            CapsuleGeometry: () => CapsuleGeometry,
            CatmullRomCurve3: () => CatmullRomCurve3,
            CineonToneMapping: () => CineonToneMapping,
            CircleGeometry: () => CircleGeometry,
            ClampToEdgeWrapping: () => ClampToEdgeWrapping,
            Clock: () => Clock,
            Color: () => Color,
            ColorKeyframeTrack: () => ColorKeyframeTrack,
            ColorManagement: () => ColorManagement,
            CompressedArrayTexture: () => CompressedArrayTexture,
            CompressedCubeTexture: () => CompressedCubeTexture,
            CompressedTexture: () => CompressedTexture,
            CompressedTextureLoader: () => CompressedTextureLoader,
            ConeGeometry: () => ConeGeometry,
            ConstantAlphaFactor: () => ConstantAlphaFactor,
            ConstantColorFactor: () => ConstantColorFactor,
            CubeCamera: () => CubeCamera,
            CubeReflectionMapping: () => CubeReflectionMapping,
            CubeRefractionMapping: () => CubeRefractionMapping,
            CubeTexture: () => CubeTexture,
            CubeTextureLoader: () => CubeTextureLoader,
            CubeUVReflectionMapping: () => CubeUVReflectionMapping,
            CubicBezierCurve: () => CubicBezierCurve,
            CubicBezierCurve3: () => CubicBezierCurve3,
            CubicInterpolant: () => CubicInterpolant,
            CullFaceBack: () => CullFaceBack,
            CullFaceFront: () => CullFaceFront,
            CullFaceFrontBack: () => CullFaceFrontBack,
            CullFaceNone: () => CullFaceNone,
            Curve: () => Curve,
            CurvePath: () => CurvePath,
            CustomBlending: () => CustomBlending,
            CustomToneMapping: () => CustomToneMapping,
            CylinderGeometry: () => CylinderGeometry,
            Cylindrical: () => Cylindrical,
            Data3DTexture: () => Data3DTexture,
            DataArrayTexture: () => DataArrayTexture,
            DataTexture: () => DataTexture,
            DataTextureLoader: () => DataTextureLoader,
            DataUtils: () => DataUtils,
            DecrementStencilOp: () => DecrementStencilOp,
            DecrementWrapStencilOp: () => DecrementWrapStencilOp,
            DefaultLoadingManager: () => DefaultLoadingManager,
            DepthFormat: () => DepthFormat,
            DepthStencilFormat: () => DepthStencilFormat,
            DepthTexture: () => DepthTexture,
            DetachedBindMode: () => DetachedBindMode,
            DirectionalLight: () => DirectionalLight,
            DirectionalLightHelper: () => DirectionalLightHelper,
            DiscreteInterpolant: () => DiscreteInterpolant,
            DisplayP3ColorSpace: () => DisplayP3ColorSpace,
            DodecahedronGeometry: () => DodecahedronGeometry,
            DoubleSide: () => DoubleSide,
            DstAlphaFactor: () => DstAlphaFactor,
            DstColorFactor: () => DstColorFactor,
            DynamicCopyUsage: () => DynamicCopyUsage,
            DynamicDrawUsage: () => DynamicDrawUsage,
            DynamicReadUsage: () => DynamicReadUsage,
            EdgesGeometry: () => EdgesGeometry,
            EllipseCurve: () => EllipseCurve,
            EqualCompare: () => EqualCompare,
            EqualDepth: () => EqualDepth,
            EqualStencilFunc: () => EqualStencilFunc,
            EquirectangularReflectionMapping: () => EquirectangularReflectionMapping,
            EquirectangularRefractionMapping: () => EquirectangularRefractionMapping,
            Euler: () => Euler,
            EventDispatcher: () => EventDispatcher,
            ExtrudeGeometry: () => ExtrudeGeometry,
            FileLoader: () => FileLoader,
            Float16BufferAttribute: () => Float16BufferAttribute,
            Float32BufferAttribute: () => Float32BufferAttribute,
            FloatType: () => FloatType,
            Fog: () => Fog,
            FogExp2: () => FogExp2,
            FramebufferTexture: () => FramebufferTexture,
            FrontSide: () => FrontSide,
            Frustum: () => Frustum,
            GLBufferAttribute: () => GLBufferAttribute,
            GLSL1: () => GLSL1,
            GLSL3: () => GLSL3,
            GreaterCompare: () => GreaterCompare,
            GreaterDepth: () => GreaterDepth,
            GreaterEqualCompare: () => GreaterEqualCompare,
            GreaterEqualDepth: () => GreaterEqualDepth,
            GreaterEqualStencilFunc: () => GreaterEqualStencilFunc,
            GreaterStencilFunc: () => GreaterStencilFunc,
            GridHelper: () => GridHelper,
            Group: () => Group,
            HalfFloatType: () => HalfFloatType,
            HemisphereLight: () => HemisphereLight,
            HemisphereLightHelper: () => HemisphereLightHelper,
            IcosahedronGeometry: () => IcosahedronGeometry,
            ImageBitmapLoader: () => ImageBitmapLoader,
            ImageLoader: () => ImageLoader,
            ImageUtils: () => ImageUtils,
            IncrementStencilOp: () => IncrementStencilOp,
            IncrementWrapStencilOp: () => IncrementWrapStencilOp,
            InstancedBufferAttribute: () => InstancedBufferAttribute,
            InstancedBufferGeometry: () => InstancedBufferGeometry,
            InstancedInterleavedBuffer: () => InstancedInterleavedBuffer,
            InstancedMesh: () => InstancedMesh,
            Int16BufferAttribute: () => Int16BufferAttribute,
            Int32BufferAttribute: () => Int32BufferAttribute,
            Int8BufferAttribute: () => Int8BufferAttribute,
            IntType: () => IntType,
            InterleavedBuffer: () => InterleavedBuffer,
            InterleavedBufferAttribute: () => InterleavedBufferAttribute,
            Interpolant: () => Interpolant,
            InterpolateDiscrete: () => InterpolateDiscrete,
            InterpolateLinear: () => InterpolateLinear,
            InterpolateSmooth: () => InterpolateSmooth,
            InvertStencilOp: () => InvertStencilOp,
            KeepStencilOp: () => KeepStencilOp,
            KeyframeTrack: () => KeyframeTrack,
            LOD: () => LOD,
            LatheGeometry: () => LatheGeometry,
            Layers: () => Layers,
            LessCompare: () => LessCompare,
            LessDepth: () => LessDepth,
            LessEqualCompare: () => LessEqualCompare,
            LessEqualDepth: () => LessEqualDepth,
            LessEqualStencilFunc: () => LessEqualStencilFunc,
            LessStencilFunc: () => LessStencilFunc,
            Light: () => Light,
            LightProbe: () => LightProbe,
            Line: () => Line,
            Line3: () => Line3,
            LineBasicMaterial: () => LineBasicMaterial,
            LineCurve: () => LineCurve,
            LineCurve3: () => LineCurve3,
            LineDashedMaterial: () => LineDashedMaterial,
            LineLoop: () => LineLoop,
            LineSegments: () => LineSegments,
            LinearDisplayP3ColorSpace: () => LinearDisplayP3ColorSpace,
            LinearFilter: () => LinearFilter,
            LinearInterpolant: () => LinearInterpolant,
            LinearMipMapLinearFilter: () => LinearMipMapLinearFilter,
            LinearMipMapNearestFilter: () => LinearMipMapNearestFilter,
            LinearMipmapLinearFilter: () => LinearMipmapLinearFilter,
            LinearMipmapNearestFilter: () => LinearMipmapNearestFilter,
            LinearSRGBColorSpace: () => LinearSRGBColorSpace,
            LinearToneMapping: () => LinearToneMapping,
            LinearTransfer: () => LinearTransfer,
            Loader: () => Loader,
            LoaderUtils: () => LoaderUtils,
            LoadingManager: () => LoadingManager,
            LoopOnce: () => LoopOnce,
            LoopPingPong: () => LoopPingPong,
            LoopRepeat: () => LoopRepeat,
            LuminanceAlphaFormat: () => LuminanceAlphaFormat,
            LuminanceFormat: () => LuminanceFormat,
            MOUSE: () => MOUSE,
            Material: () => Material,
            MaterialLoader: () => MaterialLoader,
            MathUtils: () => MathUtils,
            Matrix3: () => Matrix3,
            Matrix4: () => Matrix4,
            MaxEquation: () => MaxEquation,
            Mesh: () => Mesh,
            MeshBasicMaterial: () => MeshBasicMaterial,
            MeshDepthMaterial: () => MeshDepthMaterial,
            MeshDistanceMaterial: () => MeshDistanceMaterial,
            MeshLambertMaterial: () => MeshLambertMaterial,
            MeshMatcapMaterial: () => MeshMatcapMaterial,
            MeshNormalMaterial: () => MeshNormalMaterial,
            MeshPhongMaterial: () => MeshPhongMaterial,
            MeshPhysicalMaterial: () => MeshPhysicalMaterial,
            MeshStandardMaterial: () => MeshStandardMaterial,
            MeshToonMaterial: () => MeshToonMaterial,
            MinEquation: () => MinEquation,
            MirroredRepeatWrapping: () => MirroredRepeatWrapping,
            MixOperation: () => MixOperation,
            MultiplyBlending: () => MultiplyBlending,
            MultiplyOperation: () => MultiplyOperation,
            NearestFilter: () => NearestFilter,
            NearestMipMapLinearFilter: () => NearestMipMapLinearFilter,
            NearestMipMapNearestFilter: () => NearestMipMapNearestFilter,
            NearestMipmapLinearFilter: () => NearestMipmapLinearFilter,
            NearestMipmapNearestFilter: () => NearestMipmapNearestFilter,
            NeutralToneMapping: () => NeutralToneMapping,
            NeverCompare: () => NeverCompare,
            NeverDepth: () => NeverDepth,
            NeverStencilFunc: () => NeverStencilFunc,
            NoBlending: () => NoBlending,
            NoColorSpace: () => NoColorSpace,
            NoToneMapping: () => NoToneMapping,
            NormalAnimationBlendMode: () => NormalAnimationBlendMode,
            NormalBlending: () => NormalBlending,
            NotEqualCompare: () => NotEqualCompare,
            NotEqualDepth: () => NotEqualDepth,
            NotEqualStencilFunc: () => NotEqualStencilFunc,
            NumberKeyframeTrack: () => NumberKeyframeTrack,
            Object3D: () => Object3D,
            ObjectLoader: () => ObjectLoader,
            ObjectSpaceNormalMap: () => ObjectSpaceNormalMap,
            OctahedronGeometry: () => OctahedronGeometry,
            OneFactor: () => OneFactor,
            OneMinusConstantAlphaFactor: () => OneMinusConstantAlphaFactor,
            OneMinusConstantColorFactor: () => OneMinusConstantColorFactor,
            OneMinusDstAlphaFactor: () => OneMinusDstAlphaFactor,
            OneMinusDstColorFactor: () => OneMinusDstColorFactor,
            OneMinusSrcAlphaFactor: () => OneMinusSrcAlphaFactor,
            OneMinusSrcColorFactor: () => OneMinusSrcColorFactor,
            OrthographicCamera: () => OrthographicCamera,
            P3Primaries: () => P3Primaries,
            PCFShadowMap: () => PCFShadowMap,
            PCFSoftShadowMap: () => PCFSoftShadowMap,
            PMREMGenerator: () => PMREMGenerator,
            Path: () => Path,
            PerspectiveCamera: () => PerspectiveCamera,
            Plane: () => Plane,
            PlaneGeometry: () => PlaneGeometry,
            PlaneHelper: () => PlaneHelper,
            PointLight: () => PointLight,
            PointLightHelper: () => PointLightHelper,
            Points: () => Points,
            PointsMaterial: () => PointsMaterial,
            PolarGridHelper: () => PolarGridHelper,
            PolyhedronGeometry: () => PolyhedronGeometry,
            PositionalAudio: () => PositionalAudio,
            PropertyBinding: () => PropertyBinding,
            PropertyMixer: () => PropertyMixer,
            QuadraticBezierCurve: () => QuadraticBezierCurve,
            QuadraticBezierCurve3: () => QuadraticBezierCurve3,
            Quaternion: () => Quaternion,
            QuaternionKeyframeTrack: () => QuaternionKeyframeTrack,
            QuaternionLinearInterpolant: () => QuaternionLinearInterpolant,
            RED_GREEN_RGTC2_Format: () => RED_GREEN_RGTC2_Format,
            RED_RGTC1_Format: () => RED_RGTC1_Format,
            REVISION: () => REVISION,
            RGBADepthPacking: () => RGBADepthPacking,
            RGBAFormat: () => RGBAFormat,
            RGBAIntegerFormat: () => RGBAIntegerFormat,
            RGBA_ASTC_10x10_Format: () => RGBA_ASTC_10x10_Format,
            RGBA_ASTC_10x5_Format: () => RGBA_ASTC_10x5_Format,
            RGBA_ASTC_10x6_Format: () => RGBA_ASTC_10x6_Format,
            RGBA_ASTC_10x8_Format: () => RGBA_ASTC_10x8_Format,
            RGBA_ASTC_12x10_Format: () => RGBA_ASTC_12x10_Format,
            RGBA_ASTC_12x12_Format: () => RGBA_ASTC_12x12_Format,
            RGBA_ASTC_4x4_Format: () => RGBA_ASTC_4x4_Format,
            RGBA_ASTC_5x4_Format: () => RGBA_ASTC_5x4_Format,
            RGBA_ASTC_5x5_Format: () => RGBA_ASTC_5x5_Format,
            RGBA_ASTC_6x5_Format: () => RGBA_ASTC_6x5_Format,
            RGBA_ASTC_6x6_Format: () => RGBA_ASTC_6x6_Format,
            RGBA_ASTC_8x5_Format: () => RGBA_ASTC_8x5_Format,
            RGBA_ASTC_8x6_Format: () => RGBA_ASTC_8x6_Format,
            RGBA_ASTC_8x8_Format: () => RGBA_ASTC_8x8_Format,
            RGBA_BPTC_Format: () => RGBA_BPTC_Format,
            RGBA_ETC2_EAC_Format: () => RGBA_ETC2_EAC_Format,
            RGBA_PVRTC_2BPPV1_Format: () => RGBA_PVRTC_2BPPV1_Format,
            RGBA_PVRTC_4BPPV1_Format: () => RGBA_PVRTC_4BPPV1_Format,
            RGBA_S3TC_DXT1_Format: () => RGBA_S3TC_DXT1_Format,
            RGBA_S3TC_DXT3_Format: () => RGBA_S3TC_DXT3_Format,
            RGBA_S3TC_DXT5_Format: () => RGBA_S3TC_DXT5_Format,
            RGBFormat: () => RGBFormat,
            RGB_BPTC_SIGNED_Format: () => RGB_BPTC_SIGNED_Format,
            RGB_BPTC_UNSIGNED_Format: () => RGB_BPTC_UNSIGNED_Format,
            RGB_ETC1_Format: () => RGB_ETC1_Format,
            RGB_ETC2_Format: () => RGB_ETC2_Format,
            RGB_PVRTC_2BPPV1_Format: () => RGB_PVRTC_2BPPV1_Format,
            RGB_PVRTC_4BPPV1_Format: () => RGB_PVRTC_4BPPV1_Format,
            RGB_S3TC_DXT1_Format: () => RGB_S3TC_DXT1_Format,
            RGFormat: () => RGFormat,
            RGIntegerFormat: () => RGIntegerFormat,
            RawShaderMaterial: () => RawShaderMaterial,
            Ray: () => Ray,
            Raycaster: () => Raycaster,
            Rec709Primaries: () => Rec709Primaries,
            RectAreaLight: () => RectAreaLight,
            RedFormat: () => RedFormat,
            RedIntegerFormat: () => RedIntegerFormat,
            ReinhardToneMapping: () => ReinhardToneMapping,
            RenderTarget: () => RenderTarget,
            RepeatWrapping: () => RepeatWrapping,
            ReplaceStencilOp: () => ReplaceStencilOp,
            ReverseSubtractEquation: () => ReverseSubtractEquation,
            RingGeometry: () => RingGeometry,
            SIGNED_RED_GREEN_RGTC2_Format: () => SIGNED_RED_GREEN_RGTC2_Format,
            SIGNED_RED_RGTC1_Format: () => SIGNED_RED_RGTC1_Format,
            SRGBColorSpace: () => SRGBColorSpace,
            SRGBTransfer: () => SRGBTransfer,
            Scene: () => Scene,
            ShaderChunk: () => ShaderChunk,
            ShaderLib: () => ShaderLib,
            ShaderMaterial: () => ShaderMaterial,
            ShadowMaterial: () => ShadowMaterial,
            Shape: () => Shape,
            ShapeGeometry: () => ShapeGeometry,
            ShapePath: () => ShapePath,
            ShapeUtils: () => ShapeUtils,
            ShortType: () => ShortType,
            Skeleton: () => Skeleton,
            SkeletonHelper: () => SkeletonHelper,
            SkinnedMesh: () => SkinnedMesh,
            Source: () => Source,
            Sphere: () => Sphere,
            SphereGeometry: () => SphereGeometry,
            Spherical: () => Spherical,
            SphericalHarmonics3: () => SphericalHarmonics3,
            SplineCurve: () => SplineCurve,
            SpotLight: () => SpotLight,
            SpotLightHelper: () => SpotLightHelper,
            Sprite: () => Sprite,
            SpriteMaterial: () => SpriteMaterial,
            SrcAlphaFactor: () => SrcAlphaFactor,
            SrcAlphaSaturateFactor: () => SrcAlphaSaturateFactor,
            SrcColorFactor: () => SrcColorFactor,
            StaticCopyUsage: () => StaticCopyUsage,
            StaticDrawUsage: () => StaticDrawUsage,
            StaticReadUsage: () => StaticReadUsage,
            StereoCamera: () => StereoCamera,
            StreamCopyUsage: () => StreamCopyUsage,
            StreamDrawUsage: () => StreamDrawUsage,
            StreamReadUsage: () => StreamReadUsage,
            StringKeyframeTrack: () => StringKeyframeTrack,
            SubtractEquation: () => SubtractEquation,
            SubtractiveBlending: () => SubtractiveBlending,
            TOUCH: () => TOUCH,
            TangentSpaceNormalMap: () => TangentSpaceNormalMap,
            TetrahedronGeometry: () => TetrahedronGeometry,
            Texture: () => Texture,
            TextureLoader: () => TextureLoader,
            TorusGeometry: () => TorusGeometry,
            TorusKnotGeometry: () => TorusKnotGeometry,
            Triangle: () => Triangle,
            TriangleFanDrawMode: () => TriangleFanDrawMode,
            TriangleStripDrawMode: () => TriangleStripDrawMode,
            TrianglesDrawMode: () => TrianglesDrawMode,
            TubeGeometry: () => TubeGeometry,
            UVMapping: () => UVMapping,
            Uint16BufferAttribute: () => Uint16BufferAttribute,
            Uint32BufferAttribute: () => Uint32BufferAttribute,
            Uint8BufferAttribute: () => Uint8BufferAttribute,
            Uint8ClampedBufferAttribute: () => Uint8ClampedBufferAttribute,
            Uniform: () => Uniform,
            UniformsGroup: () => UniformsGroup,
            UniformsLib: () => UniformsLib,
            UniformsUtils: () => UniformsUtils,
            UnsignedByteType: () => UnsignedByteType,
            UnsignedInt248Type: () => UnsignedInt248Type,
            UnsignedInt5999Type: () => UnsignedInt5999Type,
            UnsignedIntType: () => UnsignedIntType,
            UnsignedShort4444Type: () => UnsignedShort4444Type,
            UnsignedShort5551Type: () => UnsignedShort5551Type,
            UnsignedShortType: () => UnsignedShortType,
            VSMShadowMap: () => VSMShadowMap,
            Vector2: () => Vector2,
            Vector3: () => Vector3,
            Vector4: () => Vector4,
            VectorKeyframeTrack: () => VectorKeyframeTrack,
            VideoTexture: () => VideoTexture,
            WebGL3DRenderTarget: () => WebGL3DRenderTarget,
            WebGLArrayRenderTarget: () => WebGLArrayRenderTarget,
            WebGLCoordinateSystem: () => WebGLCoordinateSystem,
            WebGLCubeRenderTarget: () => WebGLCubeRenderTarget,
            WebGLMultipleRenderTargets: () => WebGLMultipleRenderTargets,
            WebGLRenderTarget: () => WebGLRenderTarget,
            WebGLRenderer: () => WebGLRenderer,
            WebGLUtils: () => WebGLUtils,
            WebGPUCoordinateSystem: () => WebGPUCoordinateSystem,
            WireframeGeometry: () => WireframeGeometry,
            WrapAroundEnding: () => WrapAroundEnding,
            ZeroCurvatureEnding: () => ZeroCurvatureEnding,
            ZeroFactor: () => ZeroFactor,
            ZeroSlopeEnding: () => ZeroSlopeEnding,
            ZeroStencilOp: () => ZeroStencilOp,
            createCanvasElement: () => createCanvasElement
          });
          let REVISION = "164", MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, CullFaceFrontBack = 3, BasicShadowMap = 0, PCFShadowMap = 1, PCFSoftShadowMap = 2, VSMShadowMap = 3, FrontSide = 0, BackSide = 1, DoubleSide = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, ConstantColorFactor = 211, OneMinusConstantColorFactor = 212, ConstantAlphaFactor = 213, OneMinusConstantAlphaFactor = 214, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, CineonToneMapping = 3, ACESFilmicToneMapping = 4, CustomToneMapping = 5, AgXToneMapping = 6, NeutralToneMapping = 7, AttachedBindMode = "attached", DetachedBindMode = "detached", UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, CubeUVReflectionMapping = 306, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapNearestFilter = 1004, NearestMipMapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipMapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedInt248Type = 1020, UnsignedInt5999Type = 35902, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, RGB_BPTC_SIGNED_Format = 36494, RGB_BPTC_UNSIGNED_Format = 36495, RED_RGTC1_Format = 36283, SIGNED_RED_RGTC1_Format = 36284, RED_GREEN_RGTC2_Format = 36285, SIGNED_RED_GREEN_RGTC2_Format = 36286, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, NormalAnimationBlendMode = 2500, AdditiveAnimationBlendMode = 2501, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, BasicDepthPacking = 3200, RGBADepthPacking = 3201, TangentSpaceNormalMap = 0, ObjectSpaceNormalMap = 1, NoColorSpace = "", SRGBColorSpace = "srgb", LinearSRGBColorSpace = "srgb-linear", DisplayP3ColorSpace = "display-p3", LinearDisplayP3ColorSpace = "display-p3-linear", LinearTransfer = "linear", SRGBTransfer = "srgb", Rec709Primaries = "rec709", P3Primaries = "p3", ZeroStencilOp = 0, KeepStencilOp = 7680, ReplaceStencilOp = 7681, IncrementStencilOp = 7682, DecrementStencilOp = 7683, IncrementWrapStencilOp = 34055, DecrementWrapStencilOp = 34056, InvertStencilOp = 5386, NeverStencilFunc = 512, LessStencilFunc = 513, EqualStencilFunc = 514, LessEqualStencilFunc = 515, GreaterStencilFunc = 516, NotEqualStencilFunc = 517, GreaterEqualStencilFunc = 518, AlwaysStencilFunc = 519, NeverCompare = 512, LessCompare = 513, EqualCompare = 514, LessEqualCompare = 515, GreaterCompare = 516, NotEqualCompare = 517, GreaterEqualCompare = 518, AlwaysCompare = 519, StaticDrawUsage = 35044, DynamicDrawUsage = 35048, StreamDrawUsage = 35040, StaticReadUsage = 35045, DynamicReadUsage = 35049, StreamReadUsage = 35041, StaticCopyUsage = 35046, DynamicCopyUsage = 35050, StreamCopyUsage = 35042, GLSL1 = "100", GLSL3 = "300 es", WebGLCoordinateSystem = 2e3, WebGPUCoordinateSystem = 2001;
          class EventDispatcher {
            addEventListener(type, listener) {
              this._listeners === void 0 && (this._listeners = {});
              let listeners = this._listeners;
              listeners[type] === void 0 && (listeners[type] = []), listeners[type].indexOf(listener) === -1 && listeners[type].push(listener);
            }
            hasEventListener(type, listener) {
              if (this._listeners === void 0)
                return !1;
              let listeners = this._listeners;
              return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
            }
            removeEventListener(type, listener) {
              if (this._listeners === void 0)
                return;
              let listenerArray = this._listeners[type];
              if (listenerArray !== void 0) {
                let index = listenerArray.indexOf(listener);
                index !== -1 && listenerArray.splice(index, 1);
              }
            }
            dispatchEvent(event) {
              if (this._listeners === void 0)
                return;
              let listenerArray = this._listeners[event.type];
              if (listenerArray !== void 0) {
                event.target = this;
                let array = listenerArray.slice(0);
                for (let i = 0, l = array.length; i < l; i++)
                  array[i].call(this, event);
                event.target = null;
              }
            }
          }
          let _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], _seed = 1234567, DEG2RAD = Math.PI / 180, RAD2DEG = 180 / Math.PI;
          function generateUUID() {
            let d0 = Math.random() * 4294967295 | 0, d1 = Math.random() * 4294967295 | 0, d2 = Math.random() * 4294967295 | 0, d3 = Math.random() * 4294967295 | 0;
            return (_lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255]).toLowerCase();
          }
          function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
          }
          function euclideanModulo(n, m) {
            return (n % m + m) % m;
          }
          function mapLinear(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
          }
          function inverseLerp(x, y, value) {
            return x !== y ? (value - x) / (y - x) : 0;
          }
          function lerp(x, y, t) {
            return (1 - t) * x + t * y;
          }
          function damp(x, y, lambda, dt) {
            return lerp(x, y, 1 - Math.exp(-lambda * dt));
          }
          function pingpong(x, length = 1) {
            return length - Math.abs(euclideanModulo(x, length * 2) - length);
          }
          function smoothstep(x, min, max) {
            return x <= min ? 0 : x >= max ? 1 : (x = (x - min) / (max - min), x * x * (3 - 2 * x));
          }
          function smootherstep(x, min, max) {
            return x <= min ? 0 : x >= max ? 1 : (x = (x - min) / (max - min), x * x * x * (x * (x * 6 - 15) + 10));
          }
          function randInt(low, high) {
            return low + Math.floor(Math.random() * (high - low + 1));
          }
          function randFloat(low, high) {
            return low + Math.random() * (high - low);
          }
          function randFloatSpread(range) {
            return range * (0.5 - Math.random());
          }
          function seededRandom(s) {
            s !== void 0 && (_seed = s);
            let t = _seed += 1831565813;
            return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
          }
          function degToRad(degrees) {
            return degrees * DEG2RAD;
          }
          function radToDeg(radians) {
            return radians * RAD2DEG;
          }
          function isPowerOfTwo(value) {
            return (value & value - 1) == 0 && value !== 0;
          }
          function ceilPowerOfTwo(value) {
            return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
          }
          function floorPowerOfTwo(value) {
            return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
          }
          function setQuaternionFromProperEuler(q, a, b, c, order) {
            let cos = Math.cos, sin = Math.sin, c2 = cos(b / 2), s2 = sin(b / 2), c13 = cos((a + c) / 2), s13 = sin((a + c) / 2), c1_3 = cos((a - c) / 2), s1_3 = sin((a - c) / 2), c3_1 = cos((c - a) / 2), s3_1 = sin((c - a) / 2);
            switch (order) {
              case "XYX":
                q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                break;
              case "YZY":
                q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                break;
              case "ZXZ":
                q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                break;
              case "XZX":
                q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                break;
              case "YXY":
                q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                break;
              case "ZYZ":
                q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                break;
              default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
            }
          }
          function denormalize(value, array) {
            switch (array.constructor) {
              case Float32Array:
                return value;
              case Uint32Array:
                return value / 4294967295;
              case Uint16Array:
                return value / 65535;
              case Uint8Array:
                return value / 255;
              case Int32Array:
                return Math.max(value / 2147483647, -1);
              case Int16Array:
                return Math.max(value / 32767, -1);
              case Int8Array:
                return Math.max(value / 127, -1);
              default:
                throw new Error("Invalid component type.");
            }
          }
          function normalize(value, array) {
            switch (array.constructor) {
              case Float32Array:
                return value;
              case Uint32Array:
                return Math.round(value * 4294967295);
              case Uint16Array:
                return Math.round(value * 65535);
              case Uint8Array:
                return Math.round(value * 255);
              case Int32Array:
                return Math.round(value * 2147483647);
              case Int16Array:
                return Math.round(value * 32767);
              case Int8Array:
                return Math.round(value * 127);
              default:
                throw new Error("Invalid component type.");
            }
          }
          let MathUtils = { DEG2RAD, RAD2DEG, generateUUID, clamp, euclideanModulo, mapLinear, inverseLerp, lerp, damp, pingpong, smoothstep, smootherstep, randInt, randFloat, randFloatSpread, seededRandom, degToRad, radToDeg, isPowerOfTwo, ceilPowerOfTwo, floorPowerOfTwo, setQuaternionFromProperEuler, normalize, denormalize };
          class Vector2 {
            constructor(x = 0, y = 0) {
              Vector2.prototype.isVector2 = !0, this.x = x, this.y = y;
            }
            get width() {
              return this.x;
            }
            set width(value) {
              this.x = value;
            }
            get height() {
              return this.y;
            }
            set height(value) {
              this.y = value;
            }
            set(x, y) {
              return this.x = x, this.y = y, this;
            }
            setScalar(scalar) {
              return this.x = scalar, this.y = scalar, this;
            }
            setX(x) {
              return this.x = x, this;
            }
            setY(y) {
              return this.y = y, this;
            }
            setComponent(index, value) {
              switch (index) {
                case 0:
                  this.x = value;
                  break;
                case 1:
                  this.y = value;
                  break;
                default:
                  throw new Error("index is out of range: " + index);
              }
              return this;
            }
            getComponent(index) {
              switch (index) {
                case 0:
                  return this.x;
                case 1:
                  return this.y;
                default:
                  throw new Error("index is out of range: " + index);
              }
            }
            clone() {
              return new this.constructor(this.x, this.y);
            }
            copy(v) {
              return this.x = v.x, this.y = v.y, this;
            }
            add(v) {
              return this.x += v.x, this.y += v.y, this;
            }
            addScalar(s) {
              return this.x += s, this.y += s, this;
            }
            addVectors(a, b) {
              return this.x = a.x + b.x, this.y = a.y + b.y, this;
            }
            addScaledVector(v, s) {
              return this.x += v.x * s, this.y += v.y * s, this;
            }
            sub(v) {
              return this.x -= v.x, this.y -= v.y, this;
            }
            subScalar(s) {
              return this.x -= s, this.y -= s, this;
            }
            subVectors(a, b) {
              return this.x = a.x - b.x, this.y = a.y - b.y, this;
            }
            multiply(v) {
              return this.x *= v.x, this.y *= v.y, this;
            }
            multiplyScalar(scalar) {
              return this.x *= scalar, this.y *= scalar, this;
            }
            divide(v) {
              return this.x /= v.x, this.y /= v.y, this;
            }
            divideScalar(scalar) {
              return this.multiplyScalar(1 / scalar);
            }
            applyMatrix3(m) {
              let x = this.x, y = this.y, e = m.elements;
              return this.x = e[0] * x + e[3] * y + e[6], this.y = e[1] * x + e[4] * y + e[7], this;
            }
            min(v) {
              return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this;
            }
            max(v) {
              return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this;
            }
            clamp(min, max) {
              return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), this;
            }
            clampScalar(minVal, maxVal) {
              return this.x = Math.max(minVal, Math.min(maxVal, this.x)), this.y = Math.max(minVal, Math.min(maxVal, this.y)), this;
            }
            clampLength(min, max) {
              let length = this.length();
              return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
            }
            floor() {
              return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
            }
            ceil() {
              return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
            }
            round() {
              return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            }
            roundToZero() {
              return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
            }
            negate() {
              return this.x = -this.x, this.y = -this.y, this;
            }
            dot(v) {
              return this.x * v.x + this.y * v.y;
            }
            cross(v) {
              return this.x * v.y - this.y * v.x;
            }
            lengthSq() {
              return this.x * this.x + this.y * this.y;
            }
            length() {
              return Math.sqrt(this.x * this.x + this.y * this.y);
            }
            manhattanLength() {
              return Math.abs(this.x) + Math.abs(this.y);
            }
            normalize() {
              return this.divideScalar(this.length() || 1);
            }
            angle() {
              return Math.atan2(-this.y, -this.x) + Math.PI;
            }
            angleTo(v) {
              let denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
              if (denominator === 0)
                return Math.PI / 2;
              let theta = this.dot(v) / denominator;
              return Math.acos(clamp(theta, -1, 1));
            }
            distanceTo(v) {
              return Math.sqrt(this.distanceToSquared(v));
            }
            distanceToSquared(v) {
              let dx = this.x - v.x, dy = this.y - v.y;
              return dx * dx + dy * dy;
            }
            manhattanDistanceTo(v) {
              return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
            }
            setLength(length) {
              return this.normalize().multiplyScalar(length);
            }
            lerp(v, alpha) {
              return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this;
            }
            lerpVectors(v1, v2, alpha) {
              return this.x = v1.x + (v2.x - v1.x) * alpha, this.y = v1.y + (v2.y - v1.y) * alpha, this;
            }
            equals(v) {
              return v.x === this.x && v.y === this.y;
            }
            fromArray(array, offset = 0) {
              return this.x = array[offset], this.y = array[offset + 1], this;
            }
            toArray(array = [], offset = 0) {
              return array[offset] = this.x, array[offset + 1] = this.y, array;
            }
            fromBufferAttribute(attribute, index) {
              return this.x = attribute.getX(index), this.y = attribute.getY(index), this;
            }
            rotateAround(center, angle) {
              let c = Math.cos(angle), s = Math.sin(angle), x = this.x - center.x, y = this.y - center.y;
              return this.x = x * c - y * s + center.x, this.y = x * s + y * c + center.y, this;
            }
            random() {
              return this.x = Math.random(), this.y = Math.random(), this;
            }
            *[Symbol.iterator]() {
              yield this.x, yield this.y;
            }
          }
          class Matrix3 {
            constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
              Matrix3.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], n11 !== void 0 && this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
            }
            set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
              let te = this.elements;
              return te[0] = n11, te[1] = n21, te[2] = n31, te[3] = n12, te[4] = n22, te[5] = n32, te[6] = n13, te[7] = n23, te[8] = n33, this;
            }
            identity() {
              return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
            }
            copy(m) {
              let te = this.elements, me = m.elements;
              return te[0] = me[0], te[1] = me[1], te[2] = me[2], te[3] = me[3], te[4] = me[4], te[5] = me[5], te[6] = me[6], te[7] = me[7], te[8] = me[8], this;
            }
            extractBasis(xAxis, yAxis, zAxis) {
              return xAxis.setFromMatrix3Column(this, 0), yAxis.setFromMatrix3Column(this, 1), zAxis.setFromMatrix3Column(this, 2), this;
            }
            setFromMatrix4(m) {
              let me = m.elements;
              return this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]), this;
            }
            multiply(m) {
              return this.multiplyMatrices(this, m);
            }
            premultiply(m) {
              return this.multiplyMatrices(m, this);
            }
            multiplyMatrices(a, b) {
              let ae = a.elements, be = b.elements, te = this.elements, a11 = ae[0], a12 = ae[3], a13 = ae[6], a21 = ae[1], a22 = ae[4], a23 = ae[7], a31 = ae[2], a32 = ae[5], a33 = ae[8], b11 = be[0], b12 = be[3], b13 = be[6], b21 = be[1], b22 = be[4], b23 = be[7], b31 = be[2], b32 = be[5], b33 = be[8];
              return te[0] = a11 * b11 + a12 * b21 + a13 * b31, te[3] = a11 * b12 + a12 * b22 + a13 * b32, te[6] = a11 * b13 + a12 * b23 + a13 * b33, te[1] = a21 * b11 + a22 * b21 + a23 * b31, te[4] = a21 * b12 + a22 * b22 + a23 * b32, te[7] = a21 * b13 + a22 * b23 + a23 * b33, te[2] = a31 * b11 + a32 * b21 + a33 * b31, te[5] = a31 * b12 + a32 * b22 + a33 * b32, te[8] = a31 * b13 + a32 * b23 + a33 * b33, this;
            }
            multiplyScalar(s) {
              let te = this.elements;
              return te[0] *= s, te[3] *= s, te[6] *= s, te[1] *= s, te[4] *= s, te[7] *= s, te[2] *= s, te[5] *= s, te[8] *= s, this;
            }
            determinant() {
              let te = this.elements, a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
              return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
            }
            invert() {
              let te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
              if (det === 0)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
              let detInv = 1 / det;
              return te[0] = t11 * detInv, te[1] = (n31 * n23 - n33 * n21) * detInv, te[2] = (n32 * n21 - n31 * n22) * detInv, te[3] = t12 * detInv, te[4] = (n33 * n11 - n31 * n13) * detInv, te[5] = (n31 * n12 - n32 * n11) * detInv, te[6] = t13 * detInv, te[7] = (n21 * n13 - n23 * n11) * detInv, te[8] = (n22 * n11 - n21 * n12) * detInv, this;
            }
            transpose() {
              let tmp2, m = this.elements;
              return tmp2 = m[1], m[1] = m[3], m[3] = tmp2, tmp2 = m[2], m[2] = m[6], m[6] = tmp2, tmp2 = m[5], m[5] = m[7], m[7] = tmp2, this;
            }
            getNormalMatrix(matrix4) {
              return this.setFromMatrix4(matrix4).invert().transpose();
            }
            transposeIntoArray(r) {
              let m = this.elements;
              return r[0] = m[0], r[1] = m[3], r[2] = m[6], r[3] = m[1], r[4] = m[4], r[5] = m[7], r[6] = m[2], r[7] = m[5], r[8] = m[8], this;
            }
            setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
              let c = Math.cos(rotation), s = Math.sin(rotation);
              return this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1), this;
            }
            scale(sx, sy) {
              return this.premultiply(_m3.makeScale(sx, sy)), this;
            }
            rotate(theta) {
              return this.premultiply(_m3.makeRotation(-theta)), this;
            }
            translate(tx, ty) {
              return this.premultiply(_m3.makeTranslation(tx, ty)), this;
            }
            makeTranslation(x, y) {
              return x.isVector2 ? this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1) : this.set(1, 0, x, 0, 1, y, 0, 0, 1), this;
            }
            makeRotation(theta) {
              let c = Math.cos(theta), s = Math.sin(theta);
              return this.set(c, -s, 0, s, c, 0, 0, 0, 1), this;
            }
            makeScale(x, y) {
              return this.set(x, 0, 0, 0, y, 0, 0, 0, 1), this;
            }
            equals(matrix) {
              let te = this.elements, me = matrix.elements;
              for (let i = 0; i < 9; i++)
                if (te[i] !== me[i])
                  return !1;
              return !0;
            }
            fromArray(array, offset = 0) {
              for (let i = 0; i < 9; i++)
                this.elements[i] = array[i + offset];
              return this;
            }
            toArray(array = [], offset = 0) {
              let te = this.elements;
              return array[offset] = te[0], array[offset + 1] = te[1], array[offset + 2] = te[2], array[offset + 3] = te[3], array[offset + 4] = te[4], array[offset + 5] = te[5], array[offset + 6] = te[6], array[offset + 7] = te[7], array[offset + 8] = te[8], array;
            }
            clone() {
              return new this.constructor().fromArray(this.elements);
            }
          }
          let _m3 = /* @__PURE__ */ new Matrix3();
          function arrayNeedsUint32(array) {
            for (let i = array.length - 1; i >= 0; --i)
              if (array[i] >= 65535)
                return !0;
            return !1;
          }
          let TYPED_ARRAYS = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
          function getTypedArray(type, buffer) {
            return new TYPED_ARRAYS[type](buffer);
          }
          function createElementNS(name) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", name);
          }
          function createCanvasElement() {
            let canvas = createElementNS("canvas");
            return canvas.style.display = "block", canvas;
          }
          let _cache = {};
          function warnOnce(message) {
            message in _cache || (_cache[message] = !0, console.warn(message));
          }
          let LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /* @__PURE__ */ new Matrix3().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199), LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /* @__PURE__ */ new Matrix3().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735), COLOR_SPACES = { [LinearSRGBColorSpace]: { transfer: LinearTransfer, primaries: Rec709Primaries, toReference: (color) => color, fromReference: (color) => color }, [SRGBColorSpace]: { transfer: SRGBTransfer, primaries: Rec709Primaries, toReference: (color) => color.convertSRGBToLinear(), fromReference: (color) => color.convertLinearToSRGB() }, [LinearDisplayP3ColorSpace]: { transfer: LinearTransfer, primaries: P3Primaries, toReference: (color) => color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB), fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3) }, [DisplayP3ColorSpace]: { transfer: SRGBTransfer, primaries: P3Primaries, toReference: (color) => color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB), fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB() } }, SUPPORTED_WORKING_COLOR_SPACES = new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]), ColorManagement = { enabled: !0, _workingColorSpace: LinearSRGBColorSpace, get workingColorSpace() {
            return this._workingColorSpace;
          }, set workingColorSpace(colorSpace) {
            if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace))
              throw new Error(`Unsupported working color space, "${colorSpace}".`);
            this._workingColorSpace = colorSpace;
          }, convert: function(color, sourceColorSpace, targetColorSpace) {
            if (this.enabled === !1 || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace)
              return color;
            let sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
            return COLOR_SPACES[targetColorSpace].fromReference(sourceToReference(color));
          }, fromWorkingColorSpace: function(color, targetColorSpace) {
            return this.convert(color, this._workingColorSpace, targetColorSpace);
          }, toWorkingColorSpace: function(color, sourceColorSpace) {
            return this.convert(color, sourceColorSpace, this._workingColorSpace);
          }, getPrimaries: function(colorSpace) {
            return COLOR_SPACES[colorSpace].primaries;
          }, getTransfer: function(colorSpace) {
            return colorSpace === NoColorSpace ? LinearTransfer : COLOR_SPACES[colorSpace].transfer;
          } };
          function SRGBToLinear(c) {
            return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
          }
          function LinearToSRGB(c) {
            return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
          }
          let _canvas;
          class ImageUtils {
            static getDataURL(image) {
              if (/^data:/i.test(image.src) || typeof HTMLCanvasElement == "undefined")
                return image.src;
              let canvas;
              if (image instanceof HTMLCanvasElement)
                canvas = image;
              else {
                _canvas === void 0 && (_canvas = createElementNS("canvas")), _canvas.width = image.width, _canvas.height = image.height;
                let context = _canvas.getContext("2d");
                image instanceof ImageData ? context.putImageData(image, 0, 0) : context.drawImage(image, 0, 0, image.width, image.height), canvas = _canvas;
              }
              return canvas.width > 2048 || canvas.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image), canvas.toDataURL("image/jpeg", 0.6)) : canvas.toDataURL("image/png");
            }
            static sRGBToLinear(image) {
              if (typeof HTMLImageElement != "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && image instanceof ImageBitmap) {
                let canvas = createElementNS("canvas");
                canvas.width = image.width, canvas.height = image.height;
                let context = canvas.getContext("2d");
                context.drawImage(image, 0, 0, image.width, image.height);
                let imageData = context.getImageData(0, 0, image.width, image.height), data = imageData.data;
                for (let i = 0; i < data.length; i++)
                  data[i] = SRGBToLinear(data[i] / 255) * 255;
                return context.putImageData(imageData, 0, 0), canvas;
              } else if (image.data) {
                let data = image.data.slice(0);
                for (let i = 0; i < data.length; i++)
                  data instanceof Uint8Array || data instanceof Uint8ClampedArray ? data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255) : data[i] = SRGBToLinear(data[i]);
                return { data, width: image.width, height: image.height };
              } else
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), image;
            }
          }
          let _sourceId = 0;
          class Source {
            constructor(data = null) {
              this.isSource = !0, Object.defineProperty(this, "id", { value: _sourceId++ }), this.uuid = generateUUID(), this.data = data, this.dataReady = !0, this.version = 0;
            }
            set needsUpdate(value) {
              value === !0 && this.version++;
            }
            toJSON(meta) {
              let isRootObject = meta === void 0 || typeof meta == "string";
              if (!isRootObject && meta.images[this.uuid] !== void 0)
                return meta.images[this.uuid];
              let output = { uuid: this.uuid, url: "" }, data = this.data;
              if (data !== null) {
                let url;
                if (Array.isArray(data)) {
                  url = [];
                  for (let i = 0, l = data.length; i < l; i++)
                    data[i].isDataTexture ? url.push(serializeImage(data[i].image)) : url.push(serializeImage(data[i]));
                } else
                  url = serializeImage(data);
                output.url = url;
              }
              return isRootObject || (meta.images[this.uuid] = output), output;
            }
          }
          function serializeImage(image) {
            return typeof HTMLImageElement != "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && image instanceof ImageBitmap ? ImageUtils.getDataURL(image) : image.data ? { data: Array.from(image.data), width: image.width, height: image.height, type: image.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
          }
          let _textureId = 0;
          class Texture extends EventDispatcher {
            constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
              super();
              this.isTexture = !0, Object.defineProperty(this, "id", { value: _textureId++ }), this.uuid = generateUUID(), this.name = "", this.source = new Source(image), this.mipmaps = [], this.mapping = mapping, this.channel = 0, this.wrapS = wrapS, this.wrapT = wrapT, this.magFilter = magFilter, this.minFilter = minFilter, this.anisotropy = anisotropy, this.format = format, this.internalFormat = null, this.type = type, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = colorSpace, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
            }
            get image() {
              return this.source.data;
            }
            set image(value = null) {
              this.source.data = value;
            }
            updateMatrix() {
              this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(source) {
              return this.name = source.name, this.source = source.source, this.mipmaps = source.mipmaps.slice(0), this.mapping = source.mapping, this.channel = source.channel, this.wrapS = source.wrapS, this.wrapT = source.wrapT, this.magFilter = source.magFilter, this.minFilter = source.minFilter, this.anisotropy = source.anisotropy, this.format = source.format, this.internalFormat = source.internalFormat, this.type = source.type, this.offset.copy(source.offset), this.repeat.copy(source.repeat), this.center.copy(source.center), this.rotation = source.rotation, this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrix.copy(source.matrix), this.generateMipmaps = source.generateMipmaps, this.premultiplyAlpha = source.premultiplyAlpha, this.flipY = source.flipY, this.unpackAlignment = source.unpackAlignment, this.colorSpace = source.colorSpace, this.userData = JSON.parse(JSON.stringify(source.userData)), this.needsUpdate = !0, this;
            }
            toJSON(meta) {
              let isRootObject = meta === void 0 || typeof meta == "string";
              if (!isRootObject && meta.textures[this.uuid] !== void 0)
                return meta.textures[this.uuid];
              let output = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(meta).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
              return Object.keys(this.userData).length > 0 && (output.userData = this.userData), isRootObject || (meta.textures[this.uuid] = output), output;
            }
            dispose() {
              this.dispatchEvent({ type: "dispose" });
            }
            transformUv(uv) {
              if (this.mapping !== UVMapping)
                return uv;
              if (uv.applyMatrix3(this.matrix), uv.x < 0 || uv.x > 1)
                switch (this.wrapS) {
                  case RepeatWrapping:
                    uv.x = uv.x - Math.floor(uv.x);
                    break;
                  case ClampToEdgeWrapping:
                    uv.x = uv.x < 0 ? 0 : 1;
                    break;
                  case MirroredRepeatWrapping:
                    Math.abs(Math.floor(uv.x) % 2) === 1 ? uv.x = Math.ceil(uv.x) - uv.x : uv.x = uv.x - Math.floor(uv.x);
                    break;
                }
              if (uv.y < 0 || uv.y > 1)
                switch (this.wrapT) {
                  case RepeatWrapping:
                    uv.y = uv.y - Math.floor(uv.y);
                    break;
                  case ClampToEdgeWrapping:
                    uv.y = uv.y < 0 ? 0 : 1;
                    break;
                  case MirroredRepeatWrapping:
                    Math.abs(Math.floor(uv.y) % 2) === 1 ? uv.y = Math.ceil(uv.y) - uv.y : uv.y = uv.y - Math.floor(uv.y);
                    break;
                }
              return this.flipY && (uv.y = 1 - uv.y), uv;
            }
            set needsUpdate(value) {
              value === !0 && (this.version++, this.source.needsUpdate = !0);
            }
            set needsPMREMUpdate(value) {
              value === !0 && this.pmremVersion++;
            }
          }
          Texture.DEFAULT_IMAGE = null, Texture.DEFAULT_MAPPING = UVMapping, Texture.DEFAULT_ANISOTROPY = 1;
          class Vector4 {
            constructor(x = 0, y = 0, z = 0, w = 1) {
              Vector4.prototype.isVector4 = !0, this.x = x, this.y = y, this.z = z, this.w = w;
            }
            get width() {
              return this.z;
            }
            set width(value) {
              this.z = value;
            }
            get height() {
              return this.w;
            }
            set height(value) {
              this.w = value;
            }
            set(x, y, z, w) {
              return this.x = x, this.y = y, this.z = z, this.w = w, this;
            }
            setScalar(scalar) {
              return this.x = scalar, this.y = scalar, this.z = scalar, this.w = scalar, this;
            }
            setX(x) {
              return this.x = x, this;
            }
            setY(y) {
              return this.y = y, this;
            }
            setZ(z) {
              return this.z = z, this;
            }
            setW(w) {
              return this.w = w, this;
            }
            setComponent(index, value) {
              switch (index) {
                case 0:
                  this.x = value;
                  break;
                case 1:
                  this.y = value;
                  break;
                case 2:
                  this.z = value;
                  break;
                case 3:
                  this.w = value;
                  break;
                default:
                  throw new Error("index is out of range: " + index);
              }
              return this;
            }
            getComponent(index) {
              switch (index) {
                case 0:
                  return this.x;
                case 1:
                  return this.y;
                case 2:
                  return this.z;
                case 3:
                  return this.w;
                default:
                  throw new Error("index is out of range: " + index);
              }
            }
            clone() {
              return new this.constructor(this.x, this.y, this.z, this.w);
            }
            copy(v) {
              return this.x = v.x, this.y = v.y, this.z = v.z, this.w = v.w !== void 0 ? v.w : 1, this;
            }
            add(v) {
              return this.x += v.x, this.y += v.y, this.z += v.z, this.w += v.w, this;
            }
            addScalar(s) {
              return this.x += s, this.y += s, this.z += s, this.w += s, this;
            }
            addVectors(a, b) {
              return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this;
            }
            addScaledVector(v, s) {
              return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this.w += v.w * s, this;
            }
            sub(v) {
              return this.x -= v.x, this.y -= v.y, this.z -= v.z, this.w -= v.w, this;
            }
            subScalar(s) {
              return this.x -= s, this.y -= s, this.z -= s, this.w -= s, this;
            }
            subVectors(a, b) {
              return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this;
            }
            multiply(v) {
              return this.x *= v.x, this.y *= v.y, this.z *= v.z, this.w *= v.w, this;
            }
            multiplyScalar(scalar) {
              return this.x *= scalar, this.y *= scalar, this.z *= scalar, this.w *= scalar, this;
            }
            applyMatrix4(m) {
              let x = this.x, y = this.y, z = this.z, w = this.w, e = m.elements;
              return this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w, this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w, this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w, this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w, this;
            }
            divideScalar(scalar) {
              return this.multiplyScalar(1 / scalar);
            }
            setAxisAngleFromQuaternion(q) {
              this.w = 2 * Math.acos(q.w);
              let s = Math.sqrt(1 - q.w * q.w);
              return s < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = q.x / s, this.y = q.y / s, this.z = q.z / s), this;
            }
            setAxisAngleFromRotationMatrix(m) {
              let angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
              if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
                if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2)
                  return this.set(1, 0, 0, 0), this;
                angle = Math.PI;
                let xx = (m11 + 1) / 2, yy = (m22 + 1) / 2, zz = (m33 + 1) / 2, xy = (m12 + m21) / 4, xz = (m13 + m31) / 4, yz = (m23 + m32) / 4;
                return xx > yy && xx > zz ? xx < epsilon ? (x = 0, y = 0.707106781, z = 0.707106781) : (x = Math.sqrt(xx), y = xy / x, z = xz / x) : yy > zz ? yy < epsilon ? (x = 0.707106781, y = 0, z = 0.707106781) : (y = Math.sqrt(yy), x = xy / y, z = yz / y) : zz < epsilon ? (x = 0.707106781, y = 0.707106781, z = 0) : (z = Math.sqrt(zz), x = xz / z, y = yz / z), this.set(x, y, z, angle), this;
              }
              let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
              return Math.abs(s) < 1e-3 && (s = 1), this.x = (m32 - m23) / s, this.y = (m13 - m31) / s, this.z = (m21 - m12) / s, this.w = Math.acos((m11 + m22 + m33 - 1) / 2), this;
            }
            min(v) {
              return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z), this.w = Math.min(this.w, v.w), this;
            }
            max(v) {
              return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z), this.w = Math.max(this.w, v.w), this;
            }
            clamp(min, max) {
              return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), this.z = Math.max(min.z, Math.min(max.z, this.z)), this.w = Math.max(min.w, Math.min(max.w, this.w)), this;
            }
            clampScalar(minVal, maxVal) {
              return this.x = Math.max(minVal, Math.min(maxVal, this.x)), this.y = Math.max(minVal, Math.min(maxVal, this.y)), this.z = Math.max(minVal, Math.min(maxVal, this.z)), this.w = Math.max(minVal, Math.min(maxVal, this.w)), this;
            }
            clampLength(min, max) {
              let length = this.length();
              return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
            }
            floor() {
              return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
            }
            ceil() {
              return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
            }
            round() {
              return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
            }
            roundToZero() {
              return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
            }
            negate() {
              return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
            }
            dot(v) {
              return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
            }
            lengthSq() {
              return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
            length() {
              return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
            manhattanLength() {
              return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
            }
            normalize() {
              return this.divideScalar(this.length() || 1);
            }
            setLength(length) {
              return this.normalize().multiplyScalar(length);
            }
            lerp(v, alpha) {
              return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha, this.w += (v.w - this.w) * alpha, this;
            }
            lerpVectors(v1, v2, alpha) {
              return this.x = v1.x + (v2.x - v1.x) * alpha, this.y = v1.y + (v2.y - v1.y) * alpha, this.z = v1.z + (v2.z - v1.z) * alpha, this.w = v1.w + (v2.w - v1.w) * alpha, this;
            }
            equals(v) {
              return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
            }
            fromArray(array, offset = 0) {
              return this.x = array[offset], this.y = array[offset + 1], this.z = array[offset + 2], this.w = array[offset + 3], this;
            }
            toArray(array = [], offset = 0) {
              return array[offset] = this.x, array[offset + 1] = this.y, array[offset + 2] = this.z, array[offset + 3] = this.w, array;
            }
            fromBufferAttribute(attribute, index) {
              return this.x = attribute.getX(index), this.y = attribute.getY(index), this.z = attribute.getZ(index), this.w = attribute.getW(index), this;
            }
            random() {
              return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
            }
            *[Symbol.iterator]() {
              yield this.x, yield this.y, yield this.z, yield this.w;
            }
          }
          class RenderTarget extends EventDispatcher {
            constructor(width = 1, height = 1, options = {}) {
              super();
              this.isRenderTarget = !0, this.width = width, this.height = height, this.depth = 1, this.scissor = new Vector4(0, 0, width, height), this.scissorTest = !1, this.viewport = new Vector4(0, 0, width, height);
              let image = { width, height, depth: 1 };
              options = Object.assign({ generateMipmaps: !1, internalFormat: null, minFilter: LinearFilter, depthBuffer: !0, stencilBuffer: !1, resolveDepthBuffer: !0, resolveStencilBuffer: !0, depthTexture: null, samples: 0, count: 1 }, options);
              let texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
              texture.flipY = !1, texture.generateMipmaps = options.generateMipmaps, texture.internalFormat = options.internalFormat, this.textures = [];
              let count = options.count;
              for (let i = 0; i < count; i++)
                this.textures[i] = texture.clone(), this.textures[i].isRenderTargetTexture = !0;
              this.depthBuffer = options.depthBuffer, this.stencilBuffer = options.stencilBuffer, this.resolveDepthBuffer = options.resolveDepthBuffer, this.resolveStencilBuffer = options.resolveStencilBuffer, this.depthTexture = options.depthTexture, this.samples = options.samples;
            }
            get texture() {
              return this.textures[0];
            }
            set texture(value) {
              this.textures[0] = value;
            }
            setSize(width, height, depth = 1) {
              if (this.width !== width || this.height !== height || this.depth !== depth) {
                this.width = width, this.height = height, this.depth = depth;
                for (let i = 0, il = this.textures.length; i < il; i++)
                  this.textures[i].image.width = width, this.textures[i].image.height = height, this.textures[i].image.depth = depth;
                this.dispose();
              }
              this.viewport.set(0, 0, width, height), this.scissor.set(0, 0, width, height);
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(source) {
              this.width = source.width, this.height = source.height, this.depth = source.depth, this.scissor.copy(source.scissor), this.scissorTest = source.scissorTest, this.viewport.copy(source.viewport), this.textures.length = 0;
              for (let i = 0, il = source.textures.length; i < il; i++)
                this.textures[i] = source.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
              let image = Object.assign({}, source.texture.image);
              return this.texture.source = new Source(image), this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer, this.resolveDepthBuffer = source.resolveDepthBuffer, this.resolveStencilBuffer = source.resolveStencilBuffer, source.depthTexture !== null && (this.depthTexture = source.depthTexture.clone()), this.samples = source.samples, this;
            }
            dispose() {
              this.dispatchEvent({ type: "dispose" });
            }
          }
          class WebGLRenderTarget extends RenderTarget {
            constructor(width = 1, height = 1, options = {}) {
              super(width, height, options);
              this.isWebGLRenderTarget = !0;
            }
          }
          class DataArrayTexture extends Texture {
            constructor(data = null, width = 1, height = 1, depth = 1) {
              super(null);
              this.isDataArrayTexture = !0, this.image = { data, width, height, depth }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
            }
          }
          class WebGLArrayRenderTarget extends WebGLRenderTarget {
            constructor(width = 1, height = 1, depth = 1, options = {}) {
              super(width, height, options);
              this.isWebGLArrayRenderTarget = !0, this.depth = depth, this.texture = new DataArrayTexture(null, width, height, depth), this.texture.isRenderTargetTexture = !0;
            }
          }
          class Data3DTexture extends Texture {
            constructor(data = null, width = 1, height = 1, depth = 1) {
              super(null);
              this.isData3DTexture = !0, this.image = { data, width, height, depth }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
            }
          }
          class WebGL3DRenderTarget extends WebGLRenderTarget {
            constructor(width = 1, height = 1, depth = 1, options = {}) {
              super(width, height, options);
              this.isWebGL3DRenderTarget = !0, this.depth = depth, this.texture = new Data3DTexture(null, width, height, depth), this.texture.isRenderTargetTexture = !0;
            }
          }
          class Quaternion {
            constructor(x = 0, y = 0, z = 0, w = 1) {
              this.isQuaternion = !0, this._x = x, this._y = y, this._z = z, this._w = w;
            }
            static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
              let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
              if (t === 0) {
                dst[dstOffset + 0] = x0, dst[dstOffset + 1] = y0, dst[dstOffset + 2] = z0, dst[dstOffset + 3] = w0;
                return;
              }
              if (t === 1) {
                dst[dstOffset + 0] = x1, dst[dstOffset + 1] = y1, dst[dstOffset + 2] = z1, dst[dstOffset + 3] = w1;
                return;
              }
              if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                let s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
                if (sqrSin > Number.EPSILON) {
                  let sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                  s = Math.sin(s * len) / sin, t = Math.sin(t * len) / sin;
                }
                let tDir = t * dir;
                if (x0 = x0 * s + x1 * tDir, y0 = y0 * s + y1 * tDir, z0 = z0 * s + z1 * tDir, w0 = w0 * s + w1 * tDir, s === 1 - t) {
                  let f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                  x0 *= f, y0 *= f, z0 *= f, w0 *= f;
                }
              }
              dst[dstOffset] = x0, dst[dstOffset + 1] = y0, dst[dstOffset + 2] = z0, dst[dstOffset + 3] = w0;
            }
            static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
              let x0 = src0[srcOffset0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
              return dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1, dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1, dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1, dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1, dst;
            }
            get x() {
              return this._x;
            }
            set x(value) {
              this._x = value, this._onChangeCallback();
            }
            get y() {
              return this._y;
            }
            set y(value) {
              this._y = value, this._onChangeCallback();
            }
            get z() {
              return this._z;
            }
            set z(value) {
              this._z = value, this._onChangeCallback();
            }
            get w() {
              return this._w;
            }
            set w(value) {
              this._w = value, this._onChangeCallback();
            }
            set(x, y, z, w) {
              return this._x = x, this._y = y, this._z = z, this._w = w, this._onChangeCallback(), this;
            }
            clone() {
              return new this.constructor(this._x, this._y, this._z, this._w);
            }
            copy(quaternion) {
              return this._x = quaternion.x, this._y = quaternion.y, this._z = quaternion.z, this._w = quaternion.w, this._onChangeCallback(), this;
            }
            setFromEuler(euler, update = !0) {
              let x = euler._x, y = euler._y, z = euler._z, order = euler._order, cos = Math.cos, sin = Math.sin, c1 = cos(x / 2), c2 = cos(y / 2), c3 = cos(z / 2), s1 = sin(x / 2), s2 = sin(y / 2), s3 = sin(z / 2);
              switch (order) {
                case "XYZ":
                  this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3;
                  break;
                case "YXZ":
                  this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3;
                  break;
                case "ZXY":
                  this._x = s1 * c2 * c3 - c1 * s2 * s3, this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3;
                  break;
                case "ZYX":
                  this._x = s1 * c2 * c3 - c1 * s2 * s3, this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3;
                  break;
                case "YZX":
                  this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3;
                  break;
                case "XZY":
                  this._x = s1 * c2 * c3 - c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3;
                  break;
                default:
                  console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
              }
              return update === !0 && this._onChangeCallback(), this;
            }
            setFromAxisAngle(axis, angle) {
              let halfAngle = angle / 2, s = Math.sin(halfAngle);
              return this._x = axis.x * s, this._y = axis.y * s, this._z = axis.z * s, this._w = Math.cos(halfAngle), this._onChangeCallback(), this;
            }
            setFromRotationMatrix(m) {
              let te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
              if (trace > 0) {
                let s = 0.5 / Math.sqrt(trace + 1);
                this._w = 0.25 / s, this._x = (m32 - m23) * s, this._y = (m13 - m31) * s, this._z = (m21 - m12) * s;
              } else if (m11 > m22 && m11 > m33) {
                let s = 2 * Math.sqrt(1 + m11 - m22 - m33);
                this._w = (m32 - m23) / s, this._x = 0.25 * s, this._y = (m12 + m21) / s, this._z = (m13 + m31) / s;
              } else if (m22 > m33) {
                let s = 2 * Math.sqrt(1 + m22 - m11 - m33);
                this._w = (m13 - m31) / s, this._x = (m12 + m21) / s, this._y = 0.25 * s, this._z = (m23 + m32) / s;
              } else {
                let s = 2 * Math.sqrt(1 + m33 - m11 - m22);
                this._w = (m21 - m12) / s, this._x = (m13 + m31) / s, this._y = (m23 + m32) / s, this._z = 0.25 * s;
              }
              return this._onChangeCallback(), this;
            }
            setFromUnitVectors(vFrom, vTo) {
              let r = vFrom.dot(vTo) + 1;
              return r < Number.EPSILON ? (r = 0, Math.abs(vFrom.x) > Math.abs(vFrom.z) ? (this._x = -vFrom.y, this._y = vFrom.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -vFrom.z, this._z = vFrom.y, this._w = r)) : (this._x = vFrom.y * vTo.z - vFrom.z * vTo.y, this._y = vFrom.z * vTo.x - vFrom.x * vTo.z, this._z = vFrom.x * vTo.y - vFrom.y * vTo.x, this._w = r), this.normalize();
            }
            angleTo(q) {
              return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
            }
            rotateTowards(q, step) {
              let angle = this.angleTo(q);
              if (angle === 0)
                return this;
              let t = Math.min(1, step / angle);
              return this.slerp(q, t), this;
            }
            identity() {
              return this.set(0, 0, 0, 1);
            }
            invert() {
              return this.conjugate();
            }
            conjugate() {
              return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
            }
            dot(v) {
              return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
            }
            lengthSq() {
              return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
            }
            length() {
              return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
            }
            normalize() {
              let l = this.length();
              return l === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (l = 1 / l, this._x = this._x * l, this._y = this._y * l, this._z = this._z * l, this._w = this._w * l), this._onChangeCallback(), this;
            }
            multiply(q) {
              return this.multiplyQuaternions(this, q);
            }
            premultiply(q) {
              return this.multiplyQuaternions(q, this);
            }
            multiplyQuaternions(a, b) {
              let qax = a._x, qay = a._y, qaz = a._z, qaw = a._w, qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
              return this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby, this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz, this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx, this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz, this._onChangeCallback(), this;
            }
            slerp(qb, t) {
              if (t === 0)
                return this;
              if (t === 1)
                return this.copy(qb);
              let x = this._x, y = this._y, z = this._z, w = this._w, cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
              if (cosHalfTheta < 0 ? (this._w = -qb._w, this._x = -qb._x, this._y = -qb._y, this._z = -qb._z, cosHalfTheta = -cosHalfTheta) : this.copy(qb), cosHalfTheta >= 1)
                return this._w = w, this._x = x, this._y = y, this._z = z, this;
              let sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
              if (sqrSinHalfTheta <= Number.EPSILON) {
                let s = 1 - t;
                return this._w = s * w + t * this._w, this._x = s * x + t * this._x, this._y = s * y + t * this._y, this._z = s * z + t * this._z, this.normalize(), this;
              }
              let sinHalfTheta = Math.sqrt(sqrSinHalfTheta), halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta), ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
              return this._w = w * ratioA + this._w * ratioB, this._x = x * ratioA + this._x * ratioB, this._y = y * ratioA + this._y * ratioB, this._z = z * ratioA + this._z * ratioB, this._onChangeCallback(), this;
            }
            slerpQuaternions(qa, qb, t) {
              return this.copy(qa).slerp(qb, t);
            }
            random() {
              let theta1 = 2 * Math.PI * Math.random(), theta2 = 2 * Math.PI * Math.random(), x0 = Math.random(), r1 = Math.sqrt(1 - x0), r2 = Math.sqrt(x0);
              return this.set(r1 * Math.sin(theta1), r1 * Math.cos(theta1), r2 * Math.sin(theta2), r2 * Math.cos(theta2));
            }
            equals(quaternion) {
              return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
            }
            fromArray(array, offset = 0) {
              return this._x = array[offset], this._y = array[offset + 1], this._z = array[offset + 2], this._w = array[offset + 3], this._onChangeCallback(), this;
            }
            toArray(array = [], offset = 0) {
              return array[offset] = this._x, array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._w, array;
            }
            fromBufferAttribute(attribute, index) {
              return this._x = attribute.getX(index), this._y = attribute.getY(index), this._z = attribute.getZ(index), this._w = attribute.getW(index), this._onChangeCallback(), this;
            }
            toJSON() {
              return this.toArray();
            }
            _onChange(callback) {
              return this._onChangeCallback = callback, this;
            }
            _onChangeCallback() {
            }
            *[Symbol.iterator]() {
              yield this._x, yield this._y, yield this._z, yield this._w;
            }
          }
          class Vector3 {
            constructor(x = 0, y = 0, z = 0) {
              Vector3.prototype.isVector3 = !0, this.x = x, this.y = y, this.z = z;
            }
            set(x, y, z) {
              return z === void 0 && (z = this.z), this.x = x, this.y = y, this.z = z, this;
            }
            setScalar(scalar) {
              return this.x = scalar, this.y = scalar, this.z = scalar, this;
            }
            setX(x) {
              return this.x = x, this;
            }
            setY(y) {
              return this.y = y, this;
            }
            setZ(z) {
              return this.z = z, this;
            }
            setComponent(index, value) {
              switch (index) {
                case 0:
                  this.x = value;
                  break;
                case 1:
                  this.y = value;
                  break;
                case 2:
                  this.z = value;
                  break;
                default:
                  throw new Error("index is out of range: " + index);
              }
              return this;
            }
            getComponent(index) {
              switch (index) {
                case 0:
                  return this.x;
                case 1:
                  return this.y;
                case 2:
                  return this.z;
                default:
                  throw new Error("index is out of range: " + index);
              }
            }
            clone() {
              return new this.constructor(this.x, this.y, this.z);
            }
            copy(v) {
              return this.x = v.x, this.y = v.y, this.z = v.z, this;
            }
            add(v) {
              return this.x += v.x, this.y += v.y, this.z += v.z, this;
            }
            addScalar(s) {
              return this.x += s, this.y += s, this.z += s, this;
            }
            addVectors(a, b) {
              return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;
            }
            addScaledVector(v, s) {
              return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this;
            }
            sub(v) {
              return this.x -= v.x, this.y -= v.y, this.z -= v.z, this;
            }
            subScalar(s) {
              return this.x -= s, this.y -= s, this.z -= s, this;
            }
            subVectors(a, b) {
              return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this;
            }
            multiply(v) {
              return this.x *= v.x, this.y *= v.y, this.z *= v.z, this;
            }
            multiplyScalar(scalar) {
              return this.x *= scalar, this.y *= scalar, this.z *= scalar, this;
            }
            multiplyVectors(a, b) {
              return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this;
            }
            applyEuler(euler) {
              return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
            }
            applyAxisAngle(axis, angle) {
              return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
            }
            applyMatrix3(m) {
              let x = this.x, y = this.y, z = this.z, e = m.elements;
              return this.x = e[0] * x + e[3] * y + e[6] * z, this.y = e[1] * x + e[4] * y + e[7] * z, this.z = e[2] * x + e[5] * y + e[8] * z, this;
            }
            applyNormalMatrix(m) {
              return this.applyMatrix3(m).normalize();
            }
            applyMatrix4(m) {
              let x = this.x, y = this.y, z = this.z, e = m.elements, w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
              return this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w, this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w, this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w, this;
            }
            applyQuaternion(q) {
              let vx = this.x, vy = this.y, vz = this.z, qx = q.x, qy = q.y, qz = q.z, qw = q.w, tx = 2 * (qy * vz - qz * vy), ty = 2 * (qz * vx - qx * vz), tz = 2 * (qx * vy - qy * vx);
              return this.x = vx + qw * tx + qy * tz - qz * ty, this.y = vy + qw * ty + qz * tx - qx * tz, this.z = vz + qw * tz + qx * ty - qy * tx, this;
            }
            project(camera) {
              return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
            }
            unproject(camera) {
              return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
            }
            transformDirection(m) {
              let x = this.x, y = this.y, z = this.z, e = m.elements;
              return this.x = e[0] * x + e[4] * y + e[8] * z, this.y = e[1] * x + e[5] * y + e[9] * z, this.z = e[2] * x + e[6] * y + e[10] * z, this.normalize();
            }
            divide(v) {
              return this.x /= v.x, this.y /= v.y, this.z /= v.z, this;
            }
            divideScalar(scalar) {
              return this.multiplyScalar(1 / scalar);
            }
            min(v) {
              return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z), this;
            }
            max(v) {
              return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z), this;
            }
            clamp(min, max) {
              return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), this.z = Math.max(min.z, Math.min(max.z, this.z)), this;
            }
            clampScalar(minVal, maxVal) {
              return this.x = Math.max(minVal, Math.min(maxVal, this.x)), this.y = Math.max(minVal, Math.min(maxVal, this.y)), this.z = Math.max(minVal, Math.min(maxVal, this.z)), this;
            }
            clampLength(min, max) {
              let length = this.length();
              return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
            }
            floor() {
              return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
            }
            ceil() {
              return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
            }
            round() {
              return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
            }
            roundToZero() {
              return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
            }
            negate() {
              return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
            }
            dot(v) {
              return this.x * v.x + this.y * v.y + this.z * v.z;
            }
            lengthSq() {
              return this.x * this.x + this.y * this.y + this.z * this.z;
            }
            length() {
              return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
            manhattanLength() {
              return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
            }
            normalize() {
              return this.divideScalar(this.length() || 1);
            }
            setLength(length) {
              return this.normalize().multiplyScalar(length);
            }
            lerp(v, alpha) {
              return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha, this;
            }
            lerpVectors(v1, v2, alpha) {
              return this.x = v1.x + (v2.x - v1.x) * alpha, this.y = v1.y + (v2.y - v1.y) * alpha, this.z = v1.z + (v2.z - v1.z) * alpha, this;
            }
            cross(v) {
              return this.crossVectors(this, v);
            }
            crossVectors(a, b) {
              let ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
              return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, this;
            }
            projectOnVector(v) {
              let denominator = v.lengthSq();
              if (denominator === 0)
                return this.set(0, 0, 0);
              let scalar = v.dot(this) / denominator;
              return this.copy(v).multiplyScalar(scalar);
            }
            projectOnPlane(planeNormal) {
              return _vector$c.copy(this).projectOnVector(planeNormal), this.sub(_vector$c);
            }
            reflect(normal) {
              return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
            }
            angleTo(v) {
              let denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
              if (denominator === 0)
                return Math.PI / 2;
              let theta = this.dot(v) / denominator;
              return Math.acos(clamp(theta, -1, 1));
            }
            distanceTo(v) {
              return Math.sqrt(this.distanceToSquared(v));
            }
            distanceToSquared(v) {
              let dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
              return dx * dx + dy * dy + dz * dz;
            }
            manhattanDistanceTo(v) {
              return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
            }
            setFromSpherical(s) {
              return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
            }
            setFromSphericalCoords(radius, phi, theta) {
              let sinPhiRadius = Math.sin(phi) * radius;
              return this.x = sinPhiRadius * Math.sin(theta), this.y = Math.cos(phi) * radius, this.z = sinPhiRadius * Math.cos(theta), this;
            }
            setFromCylindrical(c) {
              return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
            }
            setFromCylindricalCoords(radius, theta, y) {
              return this.x = radius * Math.sin(theta), this.y = y, this.z = radius * Math.cos(theta), this;
            }
            setFromMatrixPosition(m) {
              let e = m.elements;
              return this.x = e[12], this.y = e[13], this.z = e[14], this;
            }
            setFromMatrixScale(m) {
              let sx = this.setFromMatrixColumn(m, 0).length(), sy = this.setFromMatrixColumn(m, 1).length(), sz = this.setFromMatrixColumn(m, 2).length();
              return this.x = sx, this.y = sy, this.z = sz, this;
            }
            setFromMatrixColumn(m, index) {
              return this.fromArray(m.elements, index * 4);
            }
            setFromMatrix3Column(m, index) {
              return this.fromArray(m.elements, index * 3);
            }
            setFromEuler(e) {
              return this.x = e._x, this.y = e._y, this.z = e._z, this;
            }
            setFromColor(c) {
              return this.x = c.r, this.y = c.g, this.z = c.b, this;
            }
            equals(v) {
              return v.x === this.x && v.y === this.y && v.z === this.z;
            }
            fromArray(array, offset = 0) {
              return this.x = array[offset], this.y = array[offset + 1], this.z = array[offset + 2], this;
            }
            toArray(array = [], offset = 0) {
              return array[offset] = this.x, array[offset + 1] = this.y, array[offset + 2] = this.z, array;
            }
            fromBufferAttribute(attribute, index) {
              return this.x = attribute.getX(index), this.y = attribute.getY(index), this.z = attribute.getZ(index), this;
            }
            random() {
              return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
            }
            randomDirection() {
              let theta = Math.random() * Math.PI * 2, u = Math.random() * 2 - 1, c = Math.sqrt(1 - u * u);
              return this.x = c * Math.cos(theta), this.y = u, this.z = c * Math.sin(theta), this;
            }
            *[Symbol.iterator]() {
              yield this.x, yield this.y, yield this.z;
            }
          }
          let _vector$c = /* @__PURE__ */ new Vector3(), _quaternion$4 = /* @__PURE__ */ new Quaternion();
          class Box3 {
            constructor(min = new Vector3(1 / 0, 1 / 0, 1 / 0), max = new Vector3(-1 / 0, -1 / 0, -1 / 0)) {
              this.isBox3 = !0, this.min = min, this.max = max;
            }
            set(min, max) {
              return this.min.copy(min), this.max.copy(max), this;
            }
            setFromArray(array) {
              this.makeEmpty();
              for (let i = 0, il = array.length; i < il; i += 3)
                this.expandByPoint(_vector$b.fromArray(array, i));
              return this;
            }
            setFromBufferAttribute(attribute) {
              this.makeEmpty();
              for (let i = 0, il = attribute.count; i < il; i++)
                this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
              return this;
            }
            setFromPoints(points) {
              this.makeEmpty();
              for (let i = 0, il = points.length; i < il; i++)
                this.expandByPoint(points[i]);
              return this;
            }
            setFromCenterAndSize(center, size) {
              let halfSize = _vector$b.copy(size).multiplyScalar(0.5);
              return this.min.copy(center).sub(halfSize), this.max.copy(center).add(halfSize), this;
            }
            setFromObject(object, precise = !1) {
              return this.makeEmpty(), this.expandByObject(object, precise);
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(box) {
              return this.min.copy(box.min), this.max.copy(box.max), this;
            }
            makeEmpty() {
              return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
            }
            isEmpty() {
              return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
            }
            getCenter(target) {
              return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
            }
            getSize(target) {
              return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
            }
            expandByPoint(point) {
              return this.min.min(point), this.max.max(point), this;
            }
            expandByVector(vector) {
              return this.min.sub(vector), this.max.add(vector), this;
            }
            expandByScalar(scalar) {
              return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
            }
            expandByObject(object, precise = !1) {
              object.updateWorldMatrix(!1, !1);
              let geometry = object.geometry;
              if (geometry !== void 0) {
                let positionAttribute = geometry.getAttribute("position");
                if (precise === !0 && positionAttribute !== void 0 && object.isInstancedMesh !== !0)
                  for (let i = 0, l = positionAttribute.count; i < l; i++)
                    object.isMesh === !0 ? object.getVertexPosition(i, _vector$b) : _vector$b.fromBufferAttribute(positionAttribute, i), _vector$b.applyMatrix4(object.matrixWorld), this.expandByPoint(_vector$b);
                else
                  object.boundingBox !== void 0 ? (object.boundingBox === null && object.computeBoundingBox(), _box$4.copy(object.boundingBox)) : (geometry.boundingBox === null && geometry.computeBoundingBox(), _box$4.copy(geometry.boundingBox)), _box$4.applyMatrix4(object.matrixWorld), this.union(_box$4);
              }
              let children = object.children;
              for (let i = 0, l = children.length; i < l; i++)
                this.expandByObject(children[i], precise);
              return this;
            }
            containsPoint(point) {
              return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z);
            }
            containsBox(box) {
              return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
            }
            getParameter(point, target) {
              return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
            }
            intersectsBox(box) {
              return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z);
            }
            intersectsSphere(sphere) {
              return this.clampPoint(sphere.center, _vector$b), _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
            }
            intersectsPlane(plane) {
              let min, max;
              return plane.normal.x > 0 ? (min = plane.normal.x * this.min.x, max = plane.normal.x * this.max.x) : (min = plane.normal.x * this.max.x, max = plane.normal.x * this.min.x), plane.normal.y > 0 ? (min += plane.normal.y * this.min.y, max += plane.normal.y * this.max.y) : (min += plane.normal.y * this.max.y, max += plane.normal.y * this.min.y), plane.normal.z > 0 ? (min += plane.normal.z * this.min.z, max += plane.normal.z * this.max.z) : (min += plane.normal.z * this.max.z, max += plane.normal.z * this.min.z), min <= -plane.constant && max >= -plane.constant;
            }
            intersectsTriangle(triangle) {
              if (this.isEmpty())
                return !1;
              this.getCenter(_center), _extents.subVectors(this.max, _center), _v0$2.subVectors(triangle.a, _center), _v1$7.subVectors(triangle.b, _center), _v2$4.subVectors(triangle.c, _center), _f0.subVectors(_v1$7, _v0$2), _f1.subVectors(_v2$4, _v1$7), _f2.subVectors(_v0$2, _v2$4);
              let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
              return !satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents) || (axes = [1, 0, 0, 0, 1, 0, 0, 0, 1], !satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) ? !1 : (_triangleNormal.crossVectors(_f0, _f1), axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents));
            }
            clampPoint(point, target) {
              return target.copy(point).clamp(this.min, this.max);
            }
            distanceToPoint(point) {
              return this.clampPoint(point, _vector$b).distanceTo(point);
            }
            getBoundingSphere(target) {
              return this.isEmpty() ? target.makeEmpty() : (this.getCenter(target.center), target.radius = this.getSize(_vector$b).length() * 0.5), target;
            }
            intersect(box) {
              return this.min.max(box.min), this.max.min(box.max), this.isEmpty() && this.makeEmpty(), this;
            }
            union(box) {
              return this.min.min(box.min), this.max.max(box.max), this;
            }
            applyMatrix4(matrix) {
              return this.isEmpty() ? this : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix), this.setFromPoints(_points), this);
            }
            translate(offset) {
              return this.min.add(offset), this.max.add(offset), this;
            }
            equals(box) {
              return box.min.equals(this.min) && box.max.equals(this.max);
            }
          }
          let _points = [/* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3(), /* @__PURE__ */ new Vector3()], _vector$b = /* @__PURE__ */ new Vector3(), _box$4 = /* @__PURE__ */ new Box3(), _v0$2 = /* @__PURE__ */ new Vector3(), _v1$7 = /* @__PURE__ */ new Vector3(), _v2$4 = /* @__PURE__ */ new Vector3(), _f0 = /* @__PURE__ */ new Vector3(), _f1 = /* @__PURE__ */ new Vector3(), _f2 = /* @__PURE__ */ new Vector3(), _center = /* @__PURE__ */ new Vector3(), _extents = /* @__PURE__ */ new Vector3(), _triangleNormal = /* @__PURE__ */ new Vector3(), _testAxis = /* @__PURE__ */ new Vector3();
          function satForAxes(axes, v0, v1, v2, extents) {
            for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
              _testAxis.fromArray(axes, i);
              let r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z), p0 = v0.dot(_testAxis), p1 = v1.dot(_testAxis), p2 = v2.dot(_testAxis);
              if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r)
                return !1;
            }
            return !0;
          }
          let _box$3 = /* @__PURE__ */ new Box3(), _v1$6 = /* @__PURE__ */ new Vector3(), _v2$3 = /* @__PURE__ */ new Vector3();
          class Sphere {
            constructor(center = new Vector3(), radius = -1) {
              this.isSphere = !0, this.center = center, this.radius = radius;
            }
            set(center, radius) {
              return this.center.copy(center), this.radius = radius, this;
            }
            setFromPoints(points, optionalCenter) {
              let center = this.center;
              optionalCenter !== void 0 ? center.copy(optionalCenter) : _box$3.setFromPoints(points).getCenter(center);
              let maxRadiusSq = 0;
              for (let i = 0, il = points.length; i < il; i++)
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
              return this.radius = Math.sqrt(maxRadiusSq), this;
            }
            copy(sphere) {
              return this.center.copy(sphere.center), this.radius = sphere.radius, this;
            }
            isEmpty() {
              return this.radius < 0;
            }
            makeEmpty() {
              return this.center.set(0, 0, 0), this.radius = -1, this;
            }
            containsPoint(point) {
              return point.distanceToSquared(this.center) <= this.radius * this.radius;
            }
            distanceToPoint(point) {
              return point.distanceTo(this.center) - this.radius;
            }
            intersectsSphere(sphere) {
              let radiusSum = this.radius + sphere.radius;
              return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
            }
            intersectsBox(box) {
              return box.intersectsSphere(this);
            }
            intersectsPlane(plane) {
              return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
            }
            clampPoint(point, target) {
              let deltaLengthSq = this.center.distanceToSquared(point);
              return target.copy(point), deltaLengthSq > this.radius * this.radius && (target.sub(this.center).normalize(), target.multiplyScalar(this.radius).add(this.center)), target;
            }
            getBoundingBox(target) {
              return this.isEmpty() ? (target.makeEmpty(), target) : (target.set(this.center, this.center), target.expandByScalar(this.radius), target);
            }
            applyMatrix4(matrix) {
              return this.center.applyMatrix4(matrix), this.radius = this.radius * matrix.getMaxScaleOnAxis(), this;
            }
            translate(offset) {
              return this.center.add(offset), this;
            }
            expandByPoint(point) {
              if (this.isEmpty())
                return this.center.copy(point), this.radius = 0, this;
              _v1$6.subVectors(point, this.center);
              let lengthSq = _v1$6.lengthSq();
              if (lengthSq > this.radius * this.radius) {
                let length = Math.sqrt(lengthSq), delta = (length - this.radius) * 0.5;
                this.center.addScaledVector(_v1$6, delta / length), this.radius += delta;
              }
              return this;
            }
            union(sphere) {
              return sphere.isEmpty() ? this : this.isEmpty() ? (this.copy(sphere), this) : (this.center.equals(sphere.center) === !0 ? this.radius = Math.max(this.radius, sphere.radius) : (_v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius), this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3)), this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3))), this);
            }
            equals(sphere) {
              return sphere.center.equals(this.center) && sphere.radius === this.radius;
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }
          let _vector$a = /* @__PURE__ */ new Vector3(), _segCenter = /* @__PURE__ */ new Vector3(), _segDir = /* @__PURE__ */ new Vector3(), _diff = /* @__PURE__ */ new Vector3(), _edge1 = /* @__PURE__ */ new Vector3(), _edge2 = /* @__PURE__ */ new Vector3(), _normal$1 = /* @__PURE__ */ new Vector3();
          class Ray {
            constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
              this.origin = origin, this.direction = direction;
            }
            set(origin, direction) {
              return this.origin.copy(origin), this.direction.copy(direction), this;
            }
            copy(ray) {
              return this.origin.copy(ray.origin), this.direction.copy(ray.direction), this;
            }
            at(t, target) {
              return target.copy(this.origin).addScaledVector(this.direction, t);
            }
            lookAt(v) {
              return this.direction.copy(v).sub(this.origin).normalize(), this;
            }
            recast(t) {
              return this.origin.copy(this.at(t, _vector$a)), this;
            }
            closestPointToPoint(point, target) {
              target.subVectors(point, this.origin);
              let directionDistance = target.dot(this.direction);
              return directionDistance < 0 ? target.copy(this.origin) : target.copy(this.origin).addScaledVector(this.direction, directionDistance);
            }
            distanceToPoint(point) {
              return Math.sqrt(this.distanceSqToPoint(point));
            }
            distanceSqToPoint(point) {
              let directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
              return directionDistance < 0 ? this.origin.distanceToSquared(point) : (_vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance), _vector$a.distanceToSquared(point));
            }
            distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
              _segCenter.copy(v0).add(v1).multiplyScalar(0.5), _segDir.copy(v1).sub(v0).normalize(), _diff.copy(this.origin).sub(_segCenter);
              let segExtent = v0.distanceTo(v1) * 0.5, a01 = -this.direction.dot(_segDir), b0 = _diff.dot(this.direction), b1 = -_diff.dot(_segDir), c = _diff.lengthSq(), det = Math.abs(1 - a01 * a01), s0, s1, sqrDist, extDet;
              if (det > 0)
                if (s0 = a01 * b1 - b0, s1 = a01 * b0 - b1, extDet = segExtent * det, s0 >= 0)
                  if (s1 >= -extDet)
                    if (s1 <= extDet) {
                      let invDet = 1 / det;
                      s0 *= invDet, s1 *= invDet, sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    } else
                      s1 = segExtent, s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                  else
                    s1 = -segExtent, s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                else
                  s1 <= -extDet ? (s0 = Math.max(0, -(-a01 * segExtent + b0)), s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c) : s1 <= extDet ? (s0 = 0, s1 = Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = s1 * (s1 + 2 * b1) + c) : (s0 = Math.max(0, -(a01 * segExtent + b0)), s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c);
              else
                s1 = a01 > 0 ? -segExtent : segExtent, s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              return optionalPointOnRay && optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0), optionalPointOnSegment && optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1), sqrDist;
            }
            intersectSphere(sphere, target) {
              _vector$a.subVectors(sphere.center, this.origin);
              let tca = _vector$a.dot(this.direction), d2 = _vector$a.dot(_vector$a) - tca * tca, radius2 = sphere.radius * sphere.radius;
              if (d2 > radius2)
                return null;
              let thc = Math.sqrt(radius2 - d2), t0 = tca - thc, t1 = tca + thc;
              return t1 < 0 ? null : t0 < 0 ? this.at(t1, target) : this.at(t0, target);
            }
            intersectsSphere(sphere) {
              return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
            }
            distanceToPlane(plane) {
              let denominator = plane.normal.dot(this.direction);
              if (denominator === 0)
                return plane.distanceToPoint(this.origin) === 0 ? 0 : null;
              let t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
              return t >= 0 ? t : null;
            }
            intersectPlane(plane, target) {
              let t = this.distanceToPlane(plane);
              return t === null ? null : this.at(t, target);
            }
            intersectsPlane(plane) {
              let distToPoint = plane.distanceToPoint(this.origin);
              return distToPoint === 0 || plane.normal.dot(this.direction) * distToPoint < 0;
            }
            intersectBox(box, target) {
              let tmin, tmax, tymin, tymax, tzmin, tzmax, invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z, origin = this.origin;
              return invdirx >= 0 ? (tmin = (box.min.x - origin.x) * invdirx, tmax = (box.max.x - origin.x) * invdirx) : (tmin = (box.max.x - origin.x) * invdirx, tmax = (box.min.x - origin.x) * invdirx), invdiry >= 0 ? (tymin = (box.min.y - origin.y) * invdiry, tymax = (box.max.y - origin.y) * invdiry) : (tymin = (box.max.y - origin.y) * invdiry, tymax = (box.min.y - origin.y) * invdiry), tmin > tymax || tymin > tmax || ((tymin > tmin || isNaN(tmin)) && (tmin = tymin), (tymax < tmax || isNaN(tmax)) && (tmax = tymax), invdirz >= 0 ? (tzmin = (box.min.z - origin.z) * invdirz, tzmax = (box.max.z - origin.z) * invdirz) : (tzmin = (box.max.z - origin.z) * invdirz, tzmax = (box.min.z - origin.z) * invdirz), tmin > tzmax || tzmin > tmax) || ((tzmin > tmin || tmin !== tmin) && (tmin = tzmin), (tzmax < tmax || tmax !== tmax) && (tmax = tzmax), tmax < 0) ? null : this.at(tmin >= 0 ? tmin : tmax, target);
            }
            intersectsBox(box) {
              return this.intersectBox(box, _vector$a) !== null;
            }
            intersectTriangle(a, b, c, backfaceCulling, target) {
              _edge1.subVectors(b, a), _edge2.subVectors(c, a), _normal$1.crossVectors(_edge1, _edge2);
              let DdN = this.direction.dot(_normal$1), sign2;
              if (DdN > 0) {
                if (backfaceCulling)
                  return null;
                sign2 = 1;
              } else if (DdN < 0)
                sign2 = -1, DdN = -DdN;
              else
                return null;
              _diff.subVectors(this.origin, a);
              let DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
              if (DdQxE2 < 0)
                return null;
              let DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
              if (DdE1xQ < 0 || DdQxE2 + DdE1xQ > DdN)
                return null;
              let QdN = -sign2 * _diff.dot(_normal$1);
              return QdN < 0 ? null : this.at(QdN / DdN, target);
            }
            applyMatrix4(matrix4) {
              return this.origin.applyMatrix4(matrix4), this.direction.transformDirection(matrix4), this;
            }
            equals(ray) {
              return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }
          class Matrix4 {
            constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
              Matrix4.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], n11 !== void 0 && this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
            }
            set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
              let te = this.elements;
              return te[0] = n11, te[4] = n12, te[8] = n13, te[12] = n14, te[1] = n21, te[5] = n22, te[9] = n23, te[13] = n24, te[2] = n31, te[6] = n32, te[10] = n33, te[14] = n34, te[3] = n41, te[7] = n42, te[11] = n43, te[15] = n44, this;
            }
            identity() {
              return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
            }
            clone() {
              return new Matrix4().fromArray(this.elements);
            }
            copy(m) {
              let te = this.elements, me = m.elements;
              return te[0] = me[0], te[1] = me[1], te[2] = me[2], te[3] = me[3], te[4] = me[4], te[5] = me[5], te[6] = me[6], te[7] = me[7], te[8] = me[8], te[9] = me[9], te[10] = me[10], te[11] = me[11], te[12] = me[12], te[13] = me[13], te[14] = me[14], te[15] = me[15], this;
            }
            copyPosition(m) {
              let te = this.elements, me = m.elements;
              return te[12] = me[12], te[13] = me[13], te[14] = me[14], this;
            }
            setFromMatrix3(m) {
              let me = m.elements;
              return this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1), this;
            }
            extractBasis(xAxis, yAxis, zAxis) {
              return xAxis.setFromMatrixColumn(this, 0), yAxis.setFromMatrixColumn(this, 1), zAxis.setFromMatrixColumn(this, 2), this;
            }
            makeBasis(xAxis, yAxis, zAxis) {
              return this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1), this;
            }
            extractRotation(m) {
              let te = this.elements, me = m.elements, scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length(), scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length(), scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
              return te[0] = me[0] * scaleX, te[1] = me[1] * scaleX, te[2] = me[2] * scaleX, te[3] = 0, te[4] = me[4] * scaleY, te[5] = me[5] * scaleY, te[6] = me[6] * scaleY, te[7] = 0, te[8] = me[8] * scaleZ, te[9] = me[9] * scaleZ, te[10] = me[10] * scaleZ, te[11] = 0, te[12] = 0, te[13] = 0, te[14] = 0, te[15] = 1, this;
            }
            makeRotationFromEuler(euler) {
              let te = this.elements, x = euler.x, y = euler.y, z = euler.z, a = Math.cos(x), b = Math.sin(x), c = Math.cos(y), d = Math.sin(y), e = Math.cos(z), f = Math.sin(z);
              if (euler.order === "XYZ") {
                let ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e, te[4] = -c * f, te[8] = d, te[1] = af + be * d, te[5] = ae - bf * d, te[9] = -b * c, te[2] = bf - ae * d, te[6] = be + af * d, te[10] = a * c;
              } else if (euler.order === "YXZ") {
                let ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b, te[4] = de * b - cf, te[8] = a * d, te[1] = a * f, te[5] = a * e, te[9] = -b, te[2] = cf * b - de, te[6] = df + ce * b, te[10] = a * c;
              } else if (euler.order === "ZXY") {
                let ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce - df * b, te[4] = -a * f, te[8] = de + cf * b, te[1] = cf + de * b, te[5] = a * e, te[9] = df - ce * b, te[2] = -a * d, te[6] = b, te[10] = a * c;
              } else if (euler.order === "ZYX") {
                let ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e, te[4] = be * d - af, te[8] = ae * d + bf, te[1] = c * f, te[5] = bf * d + ae, te[9] = af * d - be, te[2] = -d, te[6] = b * c, te[10] = a * c;
              } else if (euler.order === "YZX") {
                let ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e, te[4] = bd - ac * f, te[8] = bc * f + ad, te[1] = f, te[5] = a * e, te[9] = -b * e, te[2] = -d * e, te[6] = ad * f + bc, te[10] = ac - bd * f;
              } else if (euler.order === "XZY") {
                let ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e, te[4] = -f, te[8] = d * e, te[1] = ac * f + bd, te[5] = a * e, te[9] = ad * f - bc, te[2] = bc * f - ad, te[6] = b * e, te[10] = bd * f + ac;
              }
              return te[3] = 0, te[7] = 0, te[11] = 0, te[12] = 0, te[13] = 0, te[14] = 0, te[15] = 1, this;
            }
            makeRotationFromQuaternion(q) {
              return this.compose(_zero, q, _one);
            }
            lookAt(eye, target, up) {
              let te = this.elements;
              return _z.subVectors(eye, target), _z.lengthSq() === 0 && (_z.z = 1), _z.normalize(), _x.crossVectors(up, _z), _x.lengthSq() === 0 && (Math.abs(up.z) === 1 ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(up, _z)), _x.normalize(), _y.crossVectors(_z, _x), te[0] = _x.x, te[4] = _y.x, te[8] = _z.x, te[1] = _x.y, te[5] = _y.y, te[9] = _z.y, te[2] = _x.z, te[6] = _y.z, te[10] = _z.z, this;
            }
            multiply(m) {
              return this.multiplyMatrices(this, m);
            }
            premultiply(m) {
              return this.multiplyMatrices(m, this);
            }
            multiplyMatrices(a, b) {
              let ae = a.elements, be = b.elements, te = this.elements, a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12], a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13], a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14], a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15], b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12], b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13], b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14], b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
              return te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44, this;
            }
            multiplyScalar(s) {
              let te = this.elements;
              return te[0] *= s, te[4] *= s, te[8] *= s, te[12] *= s, te[1] *= s, te[5] *= s, te[9] *= s, te[13] *= s, te[2] *= s, te[6] *= s, te[10] *= s, te[14] *= s, te[3] *= s, te[7] *= s, te[11] *= s, te[15] *= s, this;
            }
            determinant() {
              let te = this.elements, n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12], n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13], n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14], n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
              return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
            }
            transpose() {
              let te = this.elements, tmp2;
              return tmp2 = te[1], te[1] = te[4], te[4] = tmp2, tmp2 = te[2], te[2] = te[8], te[8] = tmp2, tmp2 = te[6], te[6] = te[9], te[9] = tmp2, tmp2 = te[3], te[3] = te[12], te[12] = tmp2, tmp2 = te[7], te[7] = te[13], te[13] = tmp2, tmp2 = te[11], te[11] = te[14], te[14] = tmp2, this;
            }
            setPosition(x, y, z) {
              let te = this.elements;
              return x.isVector3 ? (te[12] = x.x, te[13] = x.y, te[14] = x.z) : (te[12] = x, te[13] = y, te[14] = z), this;
            }
            invert() {
              let te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34, det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
              if (det === 0)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
              let detInv = 1 / det;
              return te[0] = t11 * detInv, te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv, te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv, te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv, te[4] = t12 * detInv, te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv, te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv, te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv, te[8] = t13 * detInv, te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv, te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv, te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv, te[12] = t14 * detInv, te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv, te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv, te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv, this;
            }
            scale(v) {
              let te = this.elements, x = v.x, y = v.y, z = v.z;
              return te[0] *= x, te[4] *= y, te[8] *= z, te[1] *= x, te[5] *= y, te[9] *= z, te[2] *= x, te[6] *= y, te[10] *= z, te[3] *= x, te[7] *= y, te[11] *= z, this;
            }
            getMaxScaleOnAxis() {
              let te = this.elements, scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2], scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6], scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
              return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
            }
            makeTranslation(x, y, z) {
              return x.isVector3 ? this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1) : this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1), this;
            }
            makeRotationX(theta) {
              let c = Math.cos(theta), s = Math.sin(theta);
              return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1), this;
            }
            makeRotationY(theta) {
              let c = Math.cos(theta), s = Math.sin(theta);
              return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1), this;
            }
            makeRotationZ(theta) {
              let c = Math.cos(theta), s = Math.sin(theta);
              return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
            }
            makeRotationAxis(axis, angle) {
              let c = Math.cos(angle), s = Math.sin(angle), t = 1 - c, x = axis.x, y = axis.y, z = axis.z, tx = t * x, ty = t * y;
              return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1), this;
            }
            makeScale(x, y, z) {
              return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1), this;
            }
            makeShear(xy, xz, yx, yz, zx, zy) {
              return this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1), this;
            }
            compose(position, quaternion, scale) {
              let te = this.elements, x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
              return te[0] = (1 - (yy + zz)) * sx, te[1] = (xy + wz) * sx, te[2] = (xz - wy) * sx, te[3] = 0, te[4] = (xy - wz) * sy, te[5] = (1 - (xx + zz)) * sy, te[6] = (yz + wx) * sy, te[7] = 0, te[8] = (xz + wy) * sz, te[9] = (yz - wx) * sz, te[10] = (1 - (xx + yy)) * sz, te[11] = 0, te[12] = position.x, te[13] = position.y, te[14] = position.z, te[15] = 1, this;
            }
            decompose(position, quaternion, scale) {
              let te = this.elements, sx = _v1$5.set(te[0], te[1], te[2]).length(), sy = _v1$5.set(te[4], te[5], te[6]).length(), sz = _v1$5.set(te[8], te[9], te[10]).length();
              this.determinant() < 0 && (sx = -sx), position.x = te[12], position.y = te[13], position.z = te[14], _m1$4.copy(this);
              let invSX = 1 / sx, invSY = 1 / sy, invSZ = 1 / sz;
              return _m1$4.elements[0] *= invSX, _m1$4.elements[1] *= invSX, _m1$4.elements[2] *= invSX, _m1$4.elements[4] *= invSY, _m1$4.elements[5] *= invSY, _m1$4.elements[6] *= invSY, _m1$4.elements[8] *= invSZ, _m1$4.elements[9] *= invSZ, _m1$4.elements[10] *= invSZ, quaternion.setFromRotationMatrix(_m1$4), scale.x = sx, scale.y = sy, scale.z = sz, this;
            }
            makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
              let te = this.elements, x = 2 * near / (right - left), y = 2 * near / (top - bottom), a = (right + left) / (right - left), b = (top + bottom) / (top - bottom), c, d;
              if (coordinateSystem === WebGLCoordinateSystem)
                c = -(far + near) / (far - near), d = -2 * far * near / (far - near);
              else if (coordinateSystem === WebGPUCoordinateSystem)
                c = -far / (far - near), d = -far * near / (far - near);
              else
                throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
              return te[0] = x, te[4] = 0, te[8] = a, te[12] = 0, te[1] = 0, te[5] = y, te[9] = b, te[13] = 0, te[2] = 0, te[6] = 0, te[10] = c, te[14] = d, te[3] = 0, te[7] = 0, te[11] = -1, te[15] = 0, this;
            }
            makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
              let te = this.elements, w = 1 / (right - left), h = 1 / (top - bottom), p = 1 / (far - near), x = (right + left) * w, y = (top + bottom) * h, z, zInv;
              if (coordinateSystem === WebGLCoordinateSystem)
                z = (far + near) * p, zInv = -2 * p;
              else if (coordinateSystem === WebGPUCoordinateSystem)
                z = near * p, zInv = -1 * p;
              else
                throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
              return te[0] = 2 * w, te[4] = 0, te[8] = 0, te[12] = -x, te[1] = 0, te[5] = 2 * h, te[9] = 0, te[13] = -y, te[2] = 0, te[6] = 0, te[10] = zInv, te[14] = -z, te[3] = 0, te[7] = 0, te[11] = 0, te[15] = 1, this;
            }
            equals(matrix) {
              let te = this.elements, me = matrix.elements;
              for (let i = 0; i < 16; i++)
                if (te[i] !== me[i])
                  return !1;
              return !0;
            }
            fromArray(array, offset = 0) {
              for (let i = 0; i < 16; i++)
                this.elements[i] = array[i + offset];
              return this;
            }
            toArray(array = [], offset = 0) {
              let te = this.elements;
              return array[offset] = te[0], array[offset + 1] = te[1], array[offset + 2] = te[2], array[offset + 3] = te[3], array[offset + 4] = te[4], array[offset + 5] = te[5], array[offset + 6] = te[6], array[offset + 7] = te[7], array[offset + 8] = te[8], array[offset + 9] = te[9], array[offset + 10] = te[10], array[offset + 11] = te[11], array[offset + 12] = te[12], array[offset + 13] = te[13], array[offset + 14] = te[14], array[offset + 15] = te[15], array;
            }
          }
          let _v1$5 = /* @__PURE__ */ new Vector3(), _m1$4 = /* @__PURE__ */ new Matrix4(), _zero = /* @__PURE__ */ new Vector3(0, 0, 0), _one = /* @__PURE__ */ new Vector3(1, 1, 1), _x = /* @__PURE__ */ new Vector3(), _y = /* @__PURE__ */ new Vector3(), _z = /* @__PURE__ */ new Vector3(), _matrix$2 = /* @__PURE__ */ new Matrix4(), _quaternion$3 = /* @__PURE__ */ new Quaternion();
          class Euler {
            constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
              this.isEuler = !0, this._x = x, this._y = y, this._z = z, this._order = order;
            }
            get x() {
              return this._x;
            }
            set x(value) {
              this._x = value, this._onChangeCallback();
            }
            get y() {
              return this._y;
            }
            set y(value) {
              this._y = value, this._onChangeCallback();
            }
            get z() {
              return this._z;
            }
            set z(value) {
              this._z = value, this._onChangeCallback();
            }
            get order() {
              return this._order;
            }
            set order(value) {
              this._order = value, this._onChangeCallback();
            }
            set(x, y, z, order = this._order) {
              return this._x = x, this._y = y, this._z = z, this._order = order, this._onChangeCallback(), this;
            }
            clone() {
              return new this.constructor(this._x, this._y, this._z, this._order);
            }
            copy(euler) {
              return this._x = euler._x, this._y = euler._y, this._z = euler._z, this._order = euler._order, this._onChangeCallback(), this;
            }
            setFromRotationMatrix(m, order = this._order, update = !0) {
              let te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
              switch (order) {
                case "XYZ":
                  this._y = Math.asin(clamp(m13, -1, 1)), Math.abs(m13) < 0.9999999 ? (this._x = Math.atan2(-m23, m33), this._z = Math.atan2(-m12, m11)) : (this._x = Math.atan2(m32, m22), this._z = 0);
                  break;
                case "YXZ":
                  this._x = Math.asin(-clamp(m23, -1, 1)), Math.abs(m23) < 0.9999999 ? (this._y = Math.atan2(m13, m33), this._z = Math.atan2(m21, m22)) : (this._y = Math.atan2(-m31, m11), this._z = 0);
                  break;
                case "ZXY":
                  this._x = Math.asin(clamp(m32, -1, 1)), Math.abs(m32) < 0.9999999 ? (this._y = Math.atan2(-m31, m33), this._z = Math.atan2(-m12, m22)) : (this._y = 0, this._z = Math.atan2(m21, m11));
                  break;
                case "ZYX":
                  this._y = Math.asin(-clamp(m31, -1, 1)), Math.abs(m31) < 0.9999999 ? (this._x = Math.atan2(m32, m33), this._z = Math.atan2(m21, m11)) : (this._x = 0, this._z = Math.atan2(-m12, m22));
                  break;
                case "YZX":
                  this._z = Math.asin(clamp(m21, -1, 1)), Math.abs(m21) < 0.9999999 ? (this._x = Math.atan2(-m23, m22), this._y = Math.atan2(-m31, m11)) : (this._x = 0, this._y = Math.atan2(m13, m33));
                  break;
                case "XZY":
                  this._z = Math.asin(-clamp(m12, -1, 1)), Math.abs(m12) < 0.9999999 ? (this._x = Math.atan2(m32, m22), this._y = Math.atan2(m13, m11)) : (this._x = Math.atan2(-m23, m33), this._y = 0);
                  break;
                default:
                  console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
              }
              return this._order = order, update === !0 && this._onChangeCallback(), this;
            }
            setFromQuaternion(q, order, update) {
              return _matrix$2.makeRotationFromQuaternion(q), this.setFromRotationMatrix(_matrix$2, order, update);
            }
            setFromVector3(v, order = this._order) {
              return this.set(v.x, v.y, v.z, order);
            }
            reorder(newOrder) {
              return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, newOrder);
            }
            equals(euler) {
              return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
            }
            fromArray(array) {
              return this._x = array[0], this._y = array[1], this._z = array[2], array[3] !== void 0 && (this._order = array[3]), this._onChangeCallback(), this;
            }
            toArray(array = [], offset = 0) {
              return array[offset] = this._x, array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._order, array;
            }
            _onChange(callback) {
              return this._onChangeCallback = callback, this;
            }
            _onChangeCallback() {
            }
            *[Symbol.iterator]() {
              yield this._x, yield this._y, yield this._z, yield this._order;
            }
          }
          Euler.DEFAULT_ORDER = "XYZ";
          class Layers {
            constructor() {
              this.mask = 1 | 0;
            }
            set(channel) {
              this.mask = (1 << channel | 0) >>> 0;
            }
            enable(channel) {
              this.mask |= 1 << channel | 0;
            }
            enableAll() {
              this.mask = 4294967295 | 0;
            }
            toggle(channel) {
              this.mask ^= 1 << channel | 0;
            }
            disable(channel) {
              this.mask &= ~(1 << channel | 0);
            }
            disableAll() {
              this.mask = 0;
            }
            test(layers) {
              return (this.mask & layers.mask) != 0;
            }
            isEnabled(channel) {
              return (this.mask & (1 << channel | 0)) != 0;
            }
          }
          let _object3DId = 0, _v1$4 = /* @__PURE__ */ new Vector3(), _q1 = /* @__PURE__ */ new Quaternion(), _m1$3 = /* @__PURE__ */ new Matrix4(), _target = /* @__PURE__ */ new Vector3(), _position$3 = /* @__PURE__ */ new Vector3(), _scale$2 = /* @__PURE__ */ new Vector3(), _quaternion$2 = /* @__PURE__ */ new Quaternion(), _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0), _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0), _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1), _addedEvent = { type: "added" }, _removedEvent = { type: "removed" }, _childaddedEvent = { type: "childadded", child: null }, _childremovedEvent = { type: "childremoved", child: null };
          class Object3D extends EventDispatcher {
            constructor() {
              super();
              this.isObject3D = !0, Object.defineProperty(this, "id", { value: _object3DId++ }), this.uuid = generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DEFAULT_UP.clone();
              let position = new Vector3(), rotation = new Euler(), quaternion = new Quaternion(), scale = new Vector3(1, 1, 1);
              function onRotationChange() {
                quaternion.setFromEuler(rotation, !1);
              }
              function onQuaternionChange() {
                rotation.setFromQuaternion(quaternion, void 0, !1);
              }
              rotation._onChange(onRotationChange), quaternion._onChange(onQuaternionChange), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: position }, rotation: { configurable: !0, enumerable: !0, value: rotation }, quaternion: { configurable: !0, enumerable: !0, value: quaternion }, scale: { configurable: !0, enumerable: !0, value: scale }, modelViewMatrix: { value: new Matrix4() }, normalMatrix: { value: new Matrix3() } }), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
            }
            onBeforeShadow() {
            }
            onAfterShadow() {
            }
            onBeforeRender() {
            }
            onAfterRender() {
            }
            applyMatrix4(matrix) {
              this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
            }
            applyQuaternion(q) {
              return this.quaternion.premultiply(q), this;
            }
            setRotationFromAxisAngle(axis, angle) {
              this.quaternion.setFromAxisAngle(axis, angle);
            }
            setRotationFromEuler(euler) {
              this.quaternion.setFromEuler(euler, !0);
            }
            setRotationFromMatrix(m) {
              this.quaternion.setFromRotationMatrix(m);
            }
            setRotationFromQuaternion(q) {
              this.quaternion.copy(q);
            }
            rotateOnAxis(axis, angle) {
              return _q1.setFromAxisAngle(axis, angle), this.quaternion.multiply(_q1), this;
            }
            rotateOnWorldAxis(axis, angle) {
              return _q1.setFromAxisAngle(axis, angle), this.quaternion.premultiply(_q1), this;
            }
            rotateX(angle) {
              return this.rotateOnAxis(_xAxis, angle);
            }
            rotateY(angle) {
              return this.rotateOnAxis(_yAxis, angle);
            }
            rotateZ(angle) {
              return this.rotateOnAxis(_zAxis, angle);
            }
            translateOnAxis(axis, distance) {
              return _v1$4.copy(axis).applyQuaternion(this.quaternion), this.position.add(_v1$4.multiplyScalar(distance)), this;
            }
            translateX(distance) {
              return this.translateOnAxis(_xAxis, distance);
            }
            translateY(distance) {
              return this.translateOnAxis(_yAxis, distance);
            }
            translateZ(distance) {
              return this.translateOnAxis(_zAxis, distance);
            }
            localToWorld(vector) {
              return this.updateWorldMatrix(!0, !1), vector.applyMatrix4(this.matrixWorld);
            }
            worldToLocal(vector) {
              return this.updateWorldMatrix(!0, !1), vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
            }
            lookAt(x, y, z) {
              x.isVector3 ? _target.copy(x) : _target.set(x, y, z);
              let parent = this.parent;
              this.updateWorldMatrix(!0, !1), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$3.lookAt(_position$3, _target, this.up) : _m1$3.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$3), parent && (_m1$3.extractRotation(parent.matrixWorld), _q1.setFromRotationMatrix(_m1$3), this.quaternion.premultiply(_q1.invert()));
            }
            add(object) {
              if (arguments.length > 1) {
                for (let i = 0; i < arguments.length; i++)
                  this.add(arguments[i]);
                return this;
              }
              return object === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", object), this) : (object && object.isObject3D ? (object.removeFromParent(), object.parent = this, this.children.push(object), object.dispatchEvent(_addedEvent), _childaddedEvent.child = object, this.dispatchEvent(_childaddedEvent), _childaddedEvent.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object), this);
            }
            remove(object) {
              if (arguments.length > 1) {
                for (let i = 0; i < arguments.length; i++)
                  this.remove(arguments[i]);
                return this;
              }
              let index = this.children.indexOf(object);
              return index !== -1 && (object.parent = null, this.children.splice(index, 1), object.dispatchEvent(_removedEvent), _childremovedEvent.child = object, this.dispatchEvent(_childremovedEvent), _childremovedEvent.child = null), this;
            }
            removeFromParent() {
              let parent = this.parent;
              return parent !== null && parent.remove(this), this;
            }
            clear() {
              return this.remove(...this.children);
            }
            attach(object) {
              return this.updateWorldMatrix(!0, !1), _m1$3.copy(this.matrixWorld).invert(), object.parent !== null && (object.parent.updateWorldMatrix(!0, !1), _m1$3.multiply(object.parent.matrixWorld)), object.applyMatrix4(_m1$3), object.removeFromParent(), object.parent = this, this.children.push(object), object.updateWorldMatrix(!1, !0), object.dispatchEvent(_addedEvent), _childaddedEvent.child = object, this.dispatchEvent(_childaddedEvent), _childaddedEvent.child = null, this;
            }
            getObjectById(id) {
              return this.getObjectByProperty("id", id);
            }
            getObjectByName(name) {
              return this.getObjectByProperty("name", name);
            }
            getObjectByProperty(name, value) {
              if (this[name] === value)
                return this;
              for (let i = 0, l = this.children.length; i < l; i++) {
                let object = this.children[i].getObjectByProperty(name, value);
                if (object !== void 0)
                  return object;
              }
            }
            getObjectsByProperty(name, value, result = []) {
              this[name] === value && result.push(this);
              let children = this.children;
              for (let i = 0, l = children.length; i < l; i++)
                children[i].getObjectsByProperty(name, value, result);
              return result;
            }
            getWorldPosition(target) {
              return this.updateWorldMatrix(!0, !1), target.setFromMatrixPosition(this.matrixWorld);
            }
            getWorldQuaternion(target) {
              return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, target, _scale$2), target;
            }
            getWorldScale(target) {
              return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, _quaternion$2, target), target;
            }
            getWorldDirection(target) {
              this.updateWorldMatrix(!0, !1);
              let e = this.matrixWorld.elements;
              return target.set(e[8], e[9], e[10]).normalize();
            }
            raycast() {
            }
            traverse(callback) {
              callback(this);
              let children = this.children;
              for (let i = 0, l = children.length; i < l; i++)
                children[i].traverse(callback);
            }
            traverseVisible(callback) {
              if (this.visible === !1)
                return;
              callback(this);
              let children = this.children;
              for (let i = 0, l = children.length; i < l; i++)
                children[i].traverseVisible(callback);
            }
            traverseAncestors(callback) {
              let parent = this.parent;
              parent !== null && (callback(parent), parent.traverseAncestors(callback));
            }
            updateMatrix() {
              this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
            }
            updateMatrixWorld(force) {
              this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || force) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, force = !0);
              let children = this.children;
              for (let i = 0, l = children.length; i < l; i++) {
                let child = children[i];
                (child.matrixWorldAutoUpdate === !0 || force === !0) && child.updateMatrixWorld(force);
              }
            }
            updateWorldMatrix(updateParents, updateChildren) {
              let parent = this.parent;
              if (updateParents === !0 && parent !== null && parent.matrixWorldAutoUpdate === !0 && parent.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), updateChildren === !0) {
                let children = this.children;
                for (let i = 0, l = children.length; i < l; i++) {
                  let child = children[i];
                  child.matrixWorldAutoUpdate === !0 && child.updateWorldMatrix(!1, !0);
                }
              }
            }
            toJSON(meta) {
              let isRootObject = meta === void 0 || typeof meta == "string", output = {};
              isRootObject && (meta = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, output.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" });
              let object = {};
              object.uuid = this.uuid, object.type = this.type, this.name !== "" && (object.name = this.name), this.castShadow === !0 && (object.castShadow = !0), this.receiveShadow === !0 && (object.receiveShadow = !0), this.visible === !1 && (object.visible = !1), this.frustumCulled === !1 && (object.frustumCulled = !1), this.renderOrder !== 0 && (object.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (object.userData = this.userData), object.layers = this.layers.mask, object.matrix = this.matrix.toArray(), object.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (object.matrixAutoUpdate = !1), this.isInstancedMesh && (object.type = "InstancedMesh", object.count = this.count, object.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (object.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (object.type = "BatchedMesh", object.perObjectFrustumCulled = this.perObjectFrustumCulled, object.sortObjects = this.sortObjects, object.drawRanges = this._drawRanges, object.reservedRanges = this._reservedRanges, object.visibility = this._visibility, object.active = this._active, object.bounds = this._bounds.map((bound) => ({ boxInitialized: bound.boxInitialized, boxMin: bound.box.min.toArray(), boxMax: bound.box.max.toArray(), sphereInitialized: bound.sphereInitialized, sphereRadius: bound.sphere.radius, sphereCenter: bound.sphere.center.toArray() })), object.maxGeometryCount = this._maxGeometryCount, object.maxVertexCount = this._maxVertexCount, object.maxIndexCount = this._maxIndexCount, object.geometryInitialized = this._geometryInitialized, object.geometryCount = this._geometryCount, object.matricesTexture = this._matricesTexture.toJSON(meta), this.boundingSphere !== null && (object.boundingSphere = { center: object.boundingSphere.center.toArray(), radius: object.boundingSphere.radius }), this.boundingBox !== null && (object.boundingBox = { min: object.boundingBox.min.toArray(), max: object.boundingBox.max.toArray() }));
              function serialize(library, element) {
                return library[element.uuid] === void 0 && (library[element.uuid] = element.toJSON(meta)), element.uuid;
              }
              if (this.isScene)
                this.background && (this.background.isColor ? object.background = this.background.toJSON() : this.background.isTexture && (object.background = this.background.toJSON(meta).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (object.environment = this.environment.toJSON(meta).uuid);
              else if (this.isMesh || this.isLine || this.isPoints) {
                object.geometry = serialize(meta.geometries, this.geometry);
                let parameters = this.geometry.parameters;
                if (parameters !== void 0 && parameters.shapes !== void 0) {
                  let shapes = parameters.shapes;
                  if (Array.isArray(shapes))
                    for (let i = 0, l = shapes.length; i < l; i++) {
                      let shape = shapes[i];
                      serialize(meta.shapes, shape);
                    }
                  else
                    serialize(meta.shapes, shapes);
                }
              }
              if (this.isSkinnedMesh && (object.bindMode = this.bindMode, object.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (serialize(meta.skeletons, this.skeleton), object.skeleton = this.skeleton.uuid)), this.material !== void 0)
                if (Array.isArray(this.material)) {
                  let uuids = [];
                  for (let i = 0, l = this.material.length; i < l; i++)
                    uuids.push(serialize(meta.materials, this.material[i]));
                  object.material = uuids;
                } else
                  object.material = serialize(meta.materials, this.material);
              if (this.children.length > 0) {
                object.children = [];
                for (let i = 0; i < this.children.length; i++)
                  object.children.push(this.children[i].toJSON(meta).object);
              }
              if (this.animations.length > 0) {
                object.animations = [];
                for (let i = 0; i < this.animations.length; i++) {
                  let animation = this.animations[i];
                  object.animations.push(serialize(meta.animations, animation));
                }
              }
              if (isRootObject) {
                let geometries = extractFromCache(meta.geometries), materials = extractFromCache(meta.materials), textures = extractFromCache(meta.textures), images = extractFromCache(meta.images), shapes = extractFromCache(meta.shapes), skeletons = extractFromCache(meta.skeletons), animations = extractFromCache(meta.animations), nodes = extractFromCache(meta.nodes);
                geometries.length > 0 && (output.geometries = geometries), materials.length > 0 && (output.materials = materials), textures.length > 0 && (output.textures = textures), images.length > 0 && (output.images = images), shapes.length > 0 && (output.shapes = shapes), skeletons.length > 0 && (output.skeletons = skeletons), animations.length > 0 && (output.animations = animations), nodes.length > 0 && (output.nodes = nodes);
              }
              return output.object = object, output;
              function extractFromCache(cache) {
                let values = [];
                for (let key in cache) {
                  let data = cache[key];
                  delete data.metadata, values.push(data);
                }
                return values;
              }
            }
            clone(recursive) {
              return new this.constructor().copy(this, recursive);
            }
            copy(source, recursive = !0) {
              if (this.name = source.name, this.up.copy(source.up), this.position.copy(source.position), this.rotation.order = source.rotation.order, this.quaternion.copy(source.quaternion), this.scale.copy(source.scale), this.matrix.copy(source.matrix), this.matrixWorld.copy(source.matrixWorld), this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate, this.layers.mask = source.layers.mask, this.visible = source.visible, this.castShadow = source.castShadow, this.receiveShadow = source.receiveShadow, this.frustumCulled = source.frustumCulled, this.renderOrder = source.renderOrder, this.animations = source.animations.slice(), this.userData = JSON.parse(JSON.stringify(source.userData)), recursive === !0)
                for (let i = 0; i < source.children.length; i++) {
                  let child = source.children[i];
                  this.add(child.clone());
                }
              return this;
            }
          }
          Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0), Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0, Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
          let _v0$1 = /* @__PURE__ */ new Vector3(), _v1$3 = /* @__PURE__ */ new Vector3(), _v2$2 = /* @__PURE__ */ new Vector3(), _v3$2 = /* @__PURE__ */ new Vector3(), _vab = /* @__PURE__ */ new Vector3(), _vac = /* @__PURE__ */ new Vector3(), _vbc = /* @__PURE__ */ new Vector3(), _vap = /* @__PURE__ */ new Vector3(), _vbp = /* @__PURE__ */ new Vector3(), _vcp = /* @__PURE__ */ new Vector3();
          class Triangle {
            constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
              this.a = a, this.b = b, this.c = c;
            }
            static getNormal(a, b, c, target) {
              target.subVectors(c, b), _v0$1.subVectors(a, b), target.cross(_v0$1);
              let targetLengthSq = target.lengthSq();
              return targetLengthSq > 0 ? target.multiplyScalar(1 / Math.sqrt(targetLengthSq)) : target.set(0, 0, 0);
            }
            static getBarycoord(point, a, b, c, target) {
              _v0$1.subVectors(c, a), _v1$3.subVectors(b, a), _v2$2.subVectors(point, a);
              let dot00 = _v0$1.dot(_v0$1), dot01 = _v0$1.dot(_v1$3), dot02 = _v0$1.dot(_v2$2), dot11 = _v1$3.dot(_v1$3), dot12 = _v1$3.dot(_v2$2), denom = dot00 * dot11 - dot01 * dot01;
              if (denom === 0)
                return target.set(0, 0, 0), null;
              let invDenom = 1 / denom, u = (dot11 * dot02 - dot01 * dot12) * invDenom, v = (dot00 * dot12 - dot01 * dot02) * invDenom;
              return target.set(1 - u - v, v, u);
            }
            static containsPoint(point, a, b, c) {
              return this.getBarycoord(point, a, b, c, _v3$2) === null ? !1 : _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
            }
            static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
              return this.getBarycoord(point, p1, p2, p3, _v3$2) === null ? (target.x = 0, target.y = 0, "z" in target && (target.z = 0), "w" in target && (target.w = 0), null) : (target.setScalar(0), target.addScaledVector(v1, _v3$2.x), target.addScaledVector(v2, _v3$2.y), target.addScaledVector(v3, _v3$2.z), target);
            }
            static isFrontFacing(a, b, c, direction) {
              return _v0$1.subVectors(c, b), _v1$3.subVectors(a, b), _v0$1.cross(_v1$3).dot(direction) < 0;
            }
            set(a, b, c) {
              return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;
            }
            setFromPointsAndIndices(points, i0, i1, i2) {
              return this.a.copy(points[i0]), this.b.copy(points[i1]), this.c.copy(points[i2]), this;
            }
            setFromAttributeAndIndices(attribute, i0, i1, i2) {
              return this.a.fromBufferAttribute(attribute, i0), this.b.fromBufferAttribute(attribute, i1), this.c.fromBufferAttribute(attribute, i2), this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(triangle) {
              return this.a.copy(triangle.a), this.b.copy(triangle.b), this.c.copy(triangle.c), this;
            }
            getArea() {
              return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), _v0$1.cross(_v1$3).length() * 0.5;
            }
            getMidpoint(target) {
              return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
            }
            getNormal(target) {
              return Triangle.getNormal(this.a, this.b, this.c, target);
            }
            getPlane(target) {
              return target.setFromCoplanarPoints(this.a, this.b, this.c);
            }
            getBarycoord(point, target) {
              return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
            }
            getInterpolation(point, v1, v2, v3, target) {
              return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
            }
            containsPoint(point) {
              return Triangle.containsPoint(point, this.a, this.b, this.c);
            }
            isFrontFacing(direction) {
              return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
            }
            intersectsBox(box) {
              return box.intersectsTriangle(this);
            }
            closestPointToPoint(p, target) {
              let a = this.a, b = this.b, c = this.c, v, w;
              _vab.subVectors(b, a), _vac.subVectors(c, a), _vap.subVectors(p, a);
              let d1 = _vab.dot(_vap), d2 = _vac.dot(_vap);
              if (d1 <= 0 && d2 <= 0)
                return target.copy(a);
              _vbp.subVectors(p, b);
              let d3 = _vab.dot(_vbp), d4 = _vac.dot(_vbp);
              if (d3 >= 0 && d4 <= d3)
                return target.copy(b);
              let vc = d1 * d4 - d3 * d2;
              if (vc <= 0 && d1 >= 0 && d3 <= 0)
                return v = d1 / (d1 - d3), target.copy(a).addScaledVector(_vab, v);
              _vcp.subVectors(p, c);
              let d5 = _vab.dot(_vcp), d6 = _vac.dot(_vcp);
              if (d6 >= 0 && d5 <= d6)
                return target.copy(c);
              let vb = d5 * d2 - d1 * d6;
              if (vb <= 0 && d2 >= 0 && d6 <= 0)
                return w = d2 / (d2 - d6), target.copy(a).addScaledVector(_vac, w);
              let va = d3 * d6 - d5 * d4;
              if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0)
                return _vbc.subVectors(c, b), w = (d4 - d3) / (d4 - d3 + (d5 - d6)), target.copy(b).addScaledVector(_vbc, w);
              let denom = 1 / (va + vb + vc);
              return v = vb * denom, w = vc * denom, target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
            }
            equals(triangle) {
              return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
            }
          }
          let _colorKeywords = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, _hslA = { h: 0, s: 0, l: 0 }, _hslB = { h: 0, s: 0, l: 0 };
          function hue2rgb(p, q, t) {
            return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + (q - p) * 6 * t : t < 1 / 2 ? q : t < 2 / 3 ? p + (q - p) * 6 * (2 / 3 - t) : p;
          }
          class Color {
            constructor(r, g, b) {
              return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(r, g, b);
            }
            set(r, g, b) {
              if (g === void 0 && b === void 0) {
                let value = r;
                value && value.isColor ? this.copy(value) : typeof value == "number" ? this.setHex(value) : typeof value == "string" && this.setStyle(value);
              } else
                this.setRGB(r, g, b);
              return this;
            }
            setScalar(scalar) {
              return this.r = scalar, this.g = scalar, this.b = scalar, this;
            }
            setHex(hex, colorSpace = SRGBColorSpace) {
              return hex = Math.floor(hex), this.r = (hex >> 16 & 255) / 255, this.g = (hex >> 8 & 255) / 255, this.b = (hex & 255) / 255, ColorManagement.toWorkingColorSpace(this, colorSpace), this;
            }
            setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
              return this.r = r, this.g = g, this.b = b, ColorManagement.toWorkingColorSpace(this, colorSpace), this;
            }
            setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
              if (h = euclideanModulo(h, 1), s = clamp(s, 0, 1), l = clamp(l, 0, 1), s === 0)
                this.r = this.g = this.b = l;
              else {
                let p = l <= 0.5 ? l * (1 + s) : l + s - l * s, q = 2 * l - p;
                this.r = hue2rgb(q, p, h + 1 / 3), this.g = hue2rgb(q, p, h), this.b = hue2rgb(q, p, h - 1 / 3);
              }
              return ColorManagement.toWorkingColorSpace(this, colorSpace), this;
            }
            setStyle(style, colorSpace = SRGBColorSpace) {
              function handleAlpha(string) {
                string !== void 0 && parseFloat(string) < 1 && console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
              }
              let m;
              if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
                let color, name = m[1], components = m[2];
                switch (name) {
                  case "rgb":
                  case "rgba":
                    if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))
                      return handleAlpha(color[4]), this.setRGB(Math.min(255, parseInt(color[1], 10)) / 255, Math.min(255, parseInt(color[2], 10)) / 255, Math.min(255, parseInt(color[3], 10)) / 255, colorSpace);
                    if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))
                      return handleAlpha(color[4]), this.setRGB(Math.min(100, parseInt(color[1], 10)) / 100, Math.min(100, parseInt(color[2], 10)) / 100, Math.min(100, parseInt(color[3], 10)) / 100, colorSpace);
                    break;
                  case "hsl":
                  case "hsla":
                    if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))
                      return handleAlpha(color[4]), this.setHSL(parseFloat(color[1]) / 360, parseFloat(color[2]) / 100, parseFloat(color[3]) / 100, colorSpace);
                    break;
                  default:
                    console.warn("THREE.Color: Unknown color model " + style);
                }
              } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
                let hex = m[1], size = hex.length;
                if (size === 3)
                  return this.setRGB(parseInt(hex.charAt(0), 16) / 15, parseInt(hex.charAt(1), 16) / 15, parseInt(hex.charAt(2), 16) / 15, colorSpace);
                if (size === 6)
                  return this.setHex(parseInt(hex, 16), colorSpace);
                console.warn("THREE.Color: Invalid hex color " + style);
              } else if (style && style.length > 0)
                return this.setColorName(style, colorSpace);
              return this;
            }
            setColorName(style, colorSpace = SRGBColorSpace) {
              let hex = _colorKeywords[style.toLowerCase()];
              return hex !== void 0 ? this.setHex(hex, colorSpace) : console.warn("THREE.Color: Unknown color " + style), this;
            }
            clone() {
              return new this.constructor(this.r, this.g, this.b);
            }
            copy(color) {
              return this.r = color.r, this.g = color.g, this.b = color.b, this;
            }
            copySRGBToLinear(color) {
              return this.r = SRGBToLinear(color.r), this.g = SRGBToLinear(color.g), this.b = SRGBToLinear(color.b), this;
            }
            copyLinearToSRGB(color) {
              return this.r = LinearToSRGB(color.r), this.g = LinearToSRGB(color.g), this.b = LinearToSRGB(color.b), this;
            }
            convertSRGBToLinear() {
              return this.copySRGBToLinear(this), this;
            }
            convertLinearToSRGB() {
              return this.copyLinearToSRGB(this), this;
            }
            getHex(colorSpace = SRGBColorSpace) {
              return ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace), Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
            }
            getHexString(colorSpace = SRGBColorSpace) {
              return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
            }
            getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
              ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
              let r = _color.r, g = _color.g, b = _color.b, max = Math.max(r, g, b), min = Math.min(r, g, b), hue, saturation, lightness = (min + max) / 2;
              if (min === max)
                hue = 0, saturation = 0;
              else {
                let delta = max - min;
                switch (saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min), max) {
                  case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                  case g:
                    hue = (b - r) / delta + 2;
                    break;
                  case b:
                    hue = (r - g) / delta + 4;
                    break;
                }
                hue /= 6;
              }
              return target.h = hue, target.s = saturation, target.l = lightness, target;
            }
            getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
              return ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace), target.r = _color.r, target.g = _color.g, target.b = _color.b, target;
            }
            getStyle(colorSpace = SRGBColorSpace) {
              ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
              let r = _color.r, g = _color.g, b = _color.b;
              return colorSpace !== SRGBColorSpace ? `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})` : `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
            }
            offsetHSL(h, s, l) {
              return this.getHSL(_hslA), this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
            }
            add(color) {
              return this.r += color.r, this.g += color.g, this.b += color.b, this;
            }
            addColors(color1, color2) {
              return this.r = color1.r + color2.r, this.g = color1.g + color2.g, this.b = color1.b + color2.b, this;
            }
            addScalar(s) {
              return this.r += s, this.g += s, this.b += s, this;
            }
            sub(color) {
              return this.r = Math.max(0, this.r - color.r), this.g = Math.max(0, this.g - color.g), this.b = Math.max(0, this.b - color.b), this;
            }
            multiply(color) {
              return this.r *= color.r, this.g *= color.g, this.b *= color.b, this;
            }
            multiplyScalar(s) {
              return this.r *= s, this.g *= s, this.b *= s, this;
            }
            lerp(color, alpha) {
              return this.r += (color.r - this.r) * alpha, this.g += (color.g - this.g) * alpha, this.b += (color.b - this.b) * alpha, this;
            }
            lerpColors(color1, color2, alpha) {
              return this.r = color1.r + (color2.r - color1.r) * alpha, this.g = color1.g + (color2.g - color1.g) * alpha, this.b = color1.b + (color2.b - color1.b) * alpha, this;
            }
            lerpHSL(color, alpha) {
              this.getHSL(_hslA), color.getHSL(_hslB);
              let h = lerp(_hslA.h, _hslB.h, alpha), s = lerp(_hslA.s, _hslB.s, alpha), l = lerp(_hslA.l, _hslB.l, alpha);
              return this.setHSL(h, s, l), this;
            }
            setFromVector3(v) {
              return this.r = v.x, this.g = v.y, this.b = v.z, this;
            }
            applyMatrix3(m) {
              let r = this.r, g = this.g, b = this.b, e = m.elements;
              return this.r = e[0] * r + e[3] * g + e[6] * b, this.g = e[1] * r + e[4] * g + e[7] * b, this.b = e[2] * r + e[5] * g + e[8] * b, this;
            }
            equals(c) {
              return c.r === this.r && c.g === this.g && c.b === this.b;
            }
            fromArray(array, offset = 0) {
              return this.r = array[offset], this.g = array[offset + 1], this.b = array[offset + 2], this;
            }
            toArray(array = [], offset = 0) {
              return array[offset] = this.r, array[offset + 1] = this.g, array[offset + 2] = this.b, array;
            }
            fromBufferAttribute(attribute, index) {
              return this.r = attribute.getX(index), this.g = attribute.getY(index), this.b = attribute.getZ(index), this;
            }
            toJSON() {
              return this.getHex();
            }
            *[Symbol.iterator]() {
              yield this.r, yield this.g, yield this.b;
            }
          }
          let _color = /* @__PURE__ */ new Color();
          Color.NAMES = _colorKeywords;
          let _materialId = 0;
          class Material extends EventDispatcher {
            constructor() {
              super();
              this.isMaterial = !0, Object.defineProperty(this, "id", { value: _materialId++ }), this.uuid = generateUUID(), this.name = "", this.type = "Material", this.blending = NormalBlending, this.side = FrontSide, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Color(0, 0, 0), this.blendAlpha = 0, this.depthFunc = LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
            }
            get alphaTest() {
              return this._alphaTest;
            }
            set alphaTest(value) {
              this._alphaTest > 0 != value > 0 && this.version++, this._alphaTest = value;
            }
            onBuild() {
            }
            onBeforeRender() {
            }
            onBeforeCompile() {
            }
            customProgramCacheKey() {
              return this.onBeforeCompile.toString();
            }
            setValues(values) {
              if (values !== void 0)
                for (let key in values) {
                  let newValue = values[key];
                  if (newValue === void 0) {
                    console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
                    continue;
                  }
                  let currentValue = this[key];
                  if (currentValue === void 0) {
                    console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
                    continue;
                  }
                  currentValue && currentValue.isColor ? currentValue.set(newValue) : currentValue && currentValue.isVector3 && newValue && newValue.isVector3 ? currentValue.copy(newValue) : this[key] = newValue;
                }
            }
            toJSON(meta) {
              let isRootObject = meta === void 0 || typeof meta == "string";
              isRootObject && (meta = { textures: {}, images: {} });
              let data = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } };
              data.uuid = this.uuid, data.type = this.type, this.name !== "" && (data.name = this.name), this.color && this.color.isColor && (data.color = this.color.getHex()), this.roughness !== void 0 && (data.roughness = this.roughness), this.metalness !== void 0 && (data.metalness = this.metalness), this.sheen !== void 0 && (data.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (data.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (data.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (data.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (data.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (data.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (data.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (data.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (data.shininess = this.shininess), this.clearcoat !== void 0 && (data.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (data.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid, data.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (data.dispersion = this.dispersion), this.iridescence !== void 0 && (data.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (data.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (data.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid), this.anisotropy !== void 0 && (data.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (data.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid), this.map && this.map.isTexture && (data.map = this.map.toJSON(meta).uuid), this.matcap && this.matcap.isTexture && (data.matcap = this.matcap.toJSON(meta).uuid), this.alphaMap && this.alphaMap.isTexture && (data.alphaMap = this.alphaMap.toJSON(meta).uuid), this.lightMap && this.lightMap.isTexture && (data.lightMap = this.lightMap.toJSON(meta).uuid, data.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (data.aoMap = this.aoMap.toJSON(meta).uuid, data.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (data.bumpMap = this.bumpMap.toJSON(meta).uuid, data.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (data.normalMap = this.normalMap.toJSON(meta).uuid, data.normalMapType = this.normalMapType, data.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (data.displacementMap = this.displacementMap.toJSON(meta).uuid, data.displacementScale = this.displacementScale, data.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (data.roughnessMap = this.roughnessMap.toJSON(meta).uuid), this.metalnessMap && this.metalnessMap.isTexture && (data.metalnessMap = this.metalnessMap.toJSON(meta).uuid), this.emissiveMap && this.emissiveMap.isTexture && (data.emissiveMap = this.emissiveMap.toJSON(meta).uuid), this.specularMap && this.specularMap.isTexture && (data.specularMap = this.specularMap.toJSON(meta).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid), this.specularColorMap && this.specularColorMap.isTexture && (data.specularColorMap = this.specularColorMap.toJSON(meta).uuid), this.envMap && this.envMap.isTexture && (data.envMap = this.envMap.toJSON(meta).uuid, this.combine !== void 0 && (data.combine = this.combine)), this.envMapRotation !== void 0 && (data.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (data.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (data.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (data.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (data.gradientMap = this.gradientMap.toJSON(meta).uuid), this.transmission !== void 0 && (data.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (data.transmissionMap = this.transmissionMap.toJSON(meta).uuid), this.thickness !== void 0 && (data.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (data.thicknessMap = this.thicknessMap.toJSON(meta).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (data.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (data.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (data.size = this.size), this.shadowSide !== null && (data.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (data.sizeAttenuation = this.sizeAttenuation), this.blending !== NormalBlending && (data.blending = this.blending), this.side !== FrontSide && (data.side = this.side), this.vertexColors === !0 && (data.vertexColors = !0), this.opacity < 1 && (data.opacity = this.opacity), this.transparent === !0 && (data.transparent = !0), this.blendSrc !== SrcAlphaFactor && (data.blendSrc = this.blendSrc), this.blendDst !== OneMinusSrcAlphaFactor && (data.blendDst = this.blendDst), this.blendEquation !== AddEquation && (data.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (data.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (data.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (data.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (data.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (data.blendAlpha = this.blendAlpha), this.depthFunc !== LessEqualDepth && (data.depthFunc = this.depthFunc), this.depthTest === !1 && (data.depthTest = this.depthTest), this.depthWrite === !1 && (data.depthWrite = this.depthWrite), this.colorWrite === !1 && (data.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (data.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== AlwaysStencilFunc && (data.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (data.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (data.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== KeepStencilOp && (data.stencilFail = this.stencilFail), this.stencilZFail !== KeepStencilOp && (data.stencilZFail = this.stencilZFail), this.stencilZPass !== KeepStencilOp && (data.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (data.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (data.rotation = this.rotation), this.polygonOffset === !0 && (data.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (data.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (data.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (data.linewidth = this.linewidth), this.dashSize !== void 0 && (data.dashSize = this.dashSize), this.gapSize !== void 0 && (data.gapSize = this.gapSize), this.scale !== void 0 && (data.scale = this.scale), this.dithering === !0 && (data.dithering = !0), this.alphaTest > 0 && (data.alphaTest = this.alphaTest), this.alphaHash === !0 && (data.alphaHash = !0), this.alphaToCoverage === !0 && (data.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (data.premultipliedAlpha = !0), this.forceSinglePass === !0 && (data.forceSinglePass = !0), this.wireframe === !0 && (data.wireframe = !0), this.wireframeLinewidth > 1 && (data.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (data.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (data.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (data.flatShading = !0), this.visible === !1 && (data.visible = !1), this.toneMapped === !1 && (data.toneMapped = !1), this.fog === !1 && (data.fog = !1), Object.keys(this.userData).length > 0 && (data.userData = this.userData);
              function extractFromCache(cache) {
                let values = [];
                for (let key in cache) {
                  let data2 = cache[key];
                  delete data2.metadata, values.push(data2);
                }
                return values;
              }
              if (isRootObject) {
                let textures = extractFromCache(meta.textures), images = extractFromCache(meta.images);
                textures.length > 0 && (data.textures = textures), images.length > 0 && (data.images = images);
              }
              return data;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(source) {
              this.name = source.name, this.blending = source.blending, this.side = source.side, this.vertexColors = source.vertexColors, this.opacity = source.opacity, this.transparent = source.transparent, this.blendSrc = source.blendSrc, this.blendDst = source.blendDst, this.blendEquation = source.blendEquation, this.blendSrcAlpha = source.blendSrcAlpha, this.blendDstAlpha = source.blendDstAlpha, this.blendEquationAlpha = source.blendEquationAlpha, this.blendColor.copy(source.blendColor), this.blendAlpha = source.blendAlpha, this.depthFunc = source.depthFunc, this.depthTest = source.depthTest, this.depthWrite = source.depthWrite, this.stencilWriteMask = source.stencilWriteMask, this.stencilFunc = source.stencilFunc, this.stencilRef = source.stencilRef, this.stencilFuncMask = source.stencilFuncMask, this.stencilFail = source.stencilFail, this.stencilZFail = source.stencilZFail, this.stencilZPass = source.stencilZPass, this.stencilWrite = source.stencilWrite;
              let srcPlanes = source.clippingPlanes, dstPlanes = null;
              if (srcPlanes !== null) {
                let n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (let i = 0; i !== n; ++i)
                  dstPlanes[i] = srcPlanes[i].clone();
              }
              return this.clippingPlanes = dstPlanes, this.clipIntersection = source.clipIntersection, this.clipShadows = source.clipShadows, this.shadowSide = source.shadowSide, this.colorWrite = source.colorWrite, this.precision = source.precision, this.polygonOffset = source.polygonOffset, this.polygonOffsetFactor = source.polygonOffsetFactor, this.polygonOffsetUnits = source.polygonOffsetUnits, this.dithering = source.dithering, this.alphaTest = source.alphaTest, this.alphaHash = source.alphaHash, this.alphaToCoverage = source.alphaToCoverage, this.premultipliedAlpha = source.premultipliedAlpha, this.forceSinglePass = source.forceSinglePass, this.visible = source.visible, this.toneMapped = source.toneMapped, this.userData = JSON.parse(JSON.stringify(source.userData)), this;
            }
            dispose() {
              this.dispatchEvent({ type: "dispose" });
            }
            set needsUpdate(value) {
              value === !0 && this.version++;
            }
          }
          class MeshBasicMaterial extends Material {
            constructor(parameters) {
              super();
              this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler(), this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.color.copy(source.color), this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapRotation.copy(source.envMapRotation), this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.fog = source.fog, this;
            }
          }
          let _tables = /* @__PURE__ */ _generateTables();
          function _generateTables() {
            let buffer = new ArrayBuffer(4), floatView = new Float32Array(buffer), uint32View = new Uint32Array(buffer), baseTable = new Uint32Array(512), shiftTable = new Uint32Array(512);
            for (let i = 0; i < 256; ++i) {
              let e = i - 127;
              e < -27 ? (baseTable[i] = 0, baseTable[i | 256] = 32768, shiftTable[i] = 24, shiftTable[i | 256] = 24) : e < -14 ? (baseTable[i] = 1024 >> -e - 14, baseTable[i | 256] = 1024 >> -e - 14 | 32768, shiftTable[i] = -e - 1, shiftTable[i | 256] = -e - 1) : e <= 15 ? (baseTable[i] = e + 15 << 10, baseTable[i | 256] = e + 15 << 10 | 32768, shiftTable[i] = 13, shiftTable[i | 256] = 13) : e < 128 ? (baseTable[i] = 31744, baseTable[i | 256] = 64512, shiftTable[i] = 24, shiftTable[i | 256] = 24) : (baseTable[i] = 31744, baseTable[i | 256] = 64512, shiftTable[i] = 13, shiftTable[i | 256] = 13);
            }
            let mantissaTable = new Uint32Array(2048), exponentTable = new Uint32Array(64), offsetTable = new Uint32Array(64);
            for (let i = 1; i < 1024; ++i) {
              let m = i << 13, e = 0;
              for (; (m & 8388608) == 0; )
                m <<= 1, e -= 8388608;
              m &= ~8388608, e += 947912704, mantissaTable[i] = m | e;
            }
            for (let i = 1024; i < 2048; ++i)
              mantissaTable[i] = 939524096 + (i - 1024 << 13);
            for (let i = 1; i < 31; ++i)
              exponentTable[i] = i << 23;
            exponentTable[31] = 1199570944, exponentTable[32] = 2147483648;
            for (let i = 33; i < 63; ++i)
              exponentTable[i] = 2147483648 + (i - 32 << 23);
            exponentTable[63] = 3347054592;
            for (let i = 1; i < 64; ++i)
              i !== 32 && (offsetTable[i] = 1024);
            return { floatView, uint32View, baseTable, shiftTable, mantissaTable, exponentTable, offsetTable };
          }
          function toHalfFloat(val) {
            Math.abs(val) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), val = clamp(val, -65504, 65504), _tables.floatView[0] = val;
            let f = _tables.uint32View[0], e = f >> 23 & 511;
            return _tables.baseTable[e] + ((f & 8388607) >> _tables.shiftTable[e]);
          }
          function fromHalfFloat(val) {
            let m = val >> 10;
            return _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 1023)] + _tables.exponentTable[m], _tables.floatView[0];
          }
          let DataUtils = { toHalfFloat, fromHalfFloat }, _vector$9 = /* @__PURE__ */ new Vector3(), _vector2$1 = /* @__PURE__ */ new Vector2();
          class BufferAttribute {
            constructor(array, itemSize, normalized = !1) {
              if (Array.isArray(array))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
              this.isBufferAttribute = !0, this.name = "", this.array = array, this.itemSize = itemSize, this.count = array !== void 0 ? array.length / itemSize : 0, this.normalized = normalized, this.usage = StaticDrawUsage, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = FloatType, this.version = 0;
            }
            onUploadCallback() {
            }
            set needsUpdate(value) {
              value === !0 && this.version++;
            }
            get updateRange() {
              return warnOnce("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
            }
            setUsage(value) {
              return this.usage = value, this;
            }
            addUpdateRange(start, count) {
              this.updateRanges.push({ start, count });
            }
            clearUpdateRanges() {
              this.updateRanges.length = 0;
            }
            copy(source) {
              return this.name = source.name, this.array = new source.array.constructor(source.array), this.itemSize = source.itemSize, this.count = source.count, this.normalized = source.normalized, this.usage = source.usage, this.gpuType = source.gpuType, this;
            }
            copyAt(index1, attribute, index2) {
              index1 *= this.itemSize, index2 *= attribute.itemSize;
              for (let i = 0, l = this.itemSize; i < l; i++)
                this.array[index1 + i] = attribute.array[index2 + i];
              return this;
            }
            copyArray(array) {
              return this.array.set(array), this;
            }
            applyMatrix3(m) {
              if (this.itemSize === 2)
                for (let i = 0, l = this.count; i < l; i++)
                  _vector2$1.fromBufferAttribute(this, i), _vector2$1.applyMatrix3(m), this.setXY(i, _vector2$1.x, _vector2$1.y);
              else if (this.itemSize === 3)
                for (let i = 0, l = this.count; i < l; i++)
                  _vector$9.fromBufferAttribute(this, i), _vector$9.applyMatrix3(m), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
              return this;
            }
            applyMatrix4(m) {
              for (let i = 0, l = this.count; i < l; i++)
                _vector$9.fromBufferAttribute(this, i), _vector$9.applyMatrix4(m), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
              return this;
            }
            applyNormalMatrix(m) {
              for (let i = 0, l = this.count; i < l; i++)
                _vector$9.fromBufferAttribute(this, i), _vector$9.applyNormalMatrix(m), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
              return this;
            }
            transformDirection(m) {
              for (let i = 0, l = this.count; i < l; i++)
                _vector$9.fromBufferAttribute(this, i), _vector$9.transformDirection(m), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
              return this;
            }
            set(value, offset = 0) {
              return this.array.set(value, offset), this;
            }
            getComponent(index, component) {
              let value = this.array[index * this.itemSize + component];
              return this.normalized && (value = denormalize(value, this.array)), value;
            }
            setComponent(index, component, value) {
              return this.normalized && (value = normalize(value, this.array)), this.array[index * this.itemSize + component] = value, this;
            }
            getX(index) {
              let x = this.array[index * this.itemSize];
              return this.normalized && (x = denormalize(x, this.array)), x;
            }
            setX(index, x) {
              return this.normalized && (x = normalize(x, this.array)), this.array[index * this.itemSize] = x, this;
            }
            getY(index) {
              let y = this.array[index * this.itemSize + 1];
              return this.normalized && (y = denormalize(y, this.array)), y;
            }
            setY(index, y) {
              return this.normalized && (y = normalize(y, this.array)), this.array[index * this.itemSize + 1] = y, this;
            }
            getZ(index) {
              let z = this.array[index * this.itemSize + 2];
              return this.normalized && (z = denormalize(z, this.array)), z;
            }
            setZ(index, z) {
              return this.normalized && (z = normalize(z, this.array)), this.array[index * this.itemSize + 2] = z, this;
            }
            getW(index) {
              let w = this.array[index * this.itemSize + 3];
              return this.normalized && (w = denormalize(w, this.array)), w;
            }
            setW(index, w) {
              return this.normalized && (w = normalize(w, this.array)), this.array[index * this.itemSize + 3] = w, this;
            }
            setXY(index, x, y) {
              return index *= this.itemSize, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array)), this.array[index + 0] = x, this.array[index + 1] = y, this;
            }
            setXYZ(index, x, y, z) {
              return index *= this.itemSize, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array), z = normalize(z, this.array)), this.array[index + 0] = x, this.array[index + 1] = y, this.array[index + 2] = z, this;
            }
            setXYZW(index, x, y, z, w) {
              return index *= this.itemSize, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array), z = normalize(z, this.array), w = normalize(w, this.array)), this.array[index + 0] = x, this.array[index + 1] = y, this.array[index + 2] = z, this.array[index + 3] = w, this;
            }
            onUpload(callback) {
              return this.onUploadCallback = callback, this;
            }
            clone() {
              return new this.constructor(this.array, this.itemSize).copy(this);
            }
            toJSON() {
              let data = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
              return this.name !== "" && (data.name = this.name), this.usage !== StaticDrawUsage && (data.usage = this.usage), data;
            }
          }
          class Int8BufferAttribute extends BufferAttribute {
            constructor(array, itemSize, normalized) {
              super(new Int8Array(array), itemSize, normalized);
            }
          }
          class Uint8BufferAttribute extends BufferAttribute {
            constructor(array, itemSize, normalized) {
              super(new Uint8Array(array), itemSize, normalized);
            }
          }
          class Uint8ClampedBufferAttribute extends BufferAttribute {
            constructor(array, itemSize, normalized) {
              super(new Uint8ClampedArray(array), itemSize, normalized);
            }
          }
          class Int16BufferAttribute extends BufferAttribute {
            constructor(array, itemSize, normalized) {
              super(new Int16Array(array), itemSize, normalized);
            }
          }
          class Uint16BufferAttribute extends BufferAttribute {
            constructor(array, itemSize, normalized) {
              super(new Uint16Array(array), itemSize, normalized);
            }
          }
          class Int32BufferAttribute extends BufferAttribute {
            constructor(array, itemSize, normalized) {
              super(new Int32Array(array), itemSize, normalized);
            }
          }
          class Uint32BufferAttribute extends BufferAttribute {
            constructor(array, itemSize, normalized) {
              super(new Uint32Array(array), itemSize, normalized);
            }
          }
          class Float16BufferAttribute extends BufferAttribute {
            constructor(array, itemSize, normalized) {
              super(new Uint16Array(array), itemSize, normalized);
              this.isFloat16BufferAttribute = !0;
            }
            getX(index) {
              let x = fromHalfFloat(this.array[index * this.itemSize]);
              return this.normalized && (x = denormalize(x, this.array)), x;
            }
            setX(index, x) {
              return this.normalized && (x = normalize(x, this.array)), this.array[index * this.itemSize] = toHalfFloat(x), this;
            }
            getY(index) {
              let y = fromHalfFloat(this.array[index * this.itemSize + 1]);
              return this.normalized && (y = denormalize(y, this.array)), y;
            }
            setY(index, y) {
              return this.normalized && (y = normalize(y, this.array)), this.array[index * this.itemSize + 1] = toHalfFloat(y), this;
            }
            getZ(index) {
              let z = fromHalfFloat(this.array[index * this.itemSize + 2]);
              return this.normalized && (z = denormalize(z, this.array)), z;
            }
            setZ(index, z) {
              return this.normalized && (z = normalize(z, this.array)), this.array[index * this.itemSize + 2] = toHalfFloat(z), this;
            }
            getW(index) {
              let w = fromHalfFloat(this.array[index * this.itemSize + 3]);
              return this.normalized && (w = denormalize(w, this.array)), w;
            }
            setW(index, w) {
              return this.normalized && (w = normalize(w, this.array)), this.array[index * this.itemSize + 3] = toHalfFloat(w), this;
            }
            setXY(index, x, y) {
              return index *= this.itemSize, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array)), this.array[index + 0] = toHalfFloat(x), this.array[index + 1] = toHalfFloat(y), this;
            }
            setXYZ(index, x, y, z) {
              return index *= this.itemSize, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array), z = normalize(z, this.array)), this.array[index + 0] = toHalfFloat(x), this.array[index + 1] = toHalfFloat(y), this.array[index + 2] = toHalfFloat(z), this;
            }
            setXYZW(index, x, y, z, w) {
              return index *= this.itemSize, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array), z = normalize(z, this.array), w = normalize(w, this.array)), this.array[index + 0] = toHalfFloat(x), this.array[index + 1] = toHalfFloat(y), this.array[index + 2] = toHalfFloat(z), this.array[index + 3] = toHalfFloat(w), this;
            }
          }
          class Float32BufferAttribute extends BufferAttribute {
            constructor(array, itemSize, normalized) {
              super(new Float32Array(array), itemSize, normalized);
            }
          }
          let _id$2 = 0, _m1$2 = /* @__PURE__ */ new Matrix4(), _obj = /* @__PURE__ */ new Object3D(), _offset = /* @__PURE__ */ new Vector3(), _box$2 = /* @__PURE__ */ new Box3(), _boxMorphTargets = /* @__PURE__ */ new Box3(), _vector$8 = /* @__PURE__ */ new Vector3();
          class BufferGeometry extends EventDispatcher {
            constructor() {
              super();
              this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: _id$2++ }), this.uuid = generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
            }
            getIndex() {
              return this.index;
            }
            setIndex(index) {
              return Array.isArray(index) ? this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1) : this.index = index, this;
            }
            getAttribute(name) {
              return this.attributes[name];
            }
            setAttribute(name, attribute) {
              return this.attributes[name] = attribute, this;
            }
            deleteAttribute(name) {
              return delete this.attributes[name], this;
            }
            hasAttribute(name) {
              return this.attributes[name] !== void 0;
            }
            addGroup(start, count, materialIndex = 0) {
              this.groups.push({ start, count, materialIndex });
            }
            clearGroups() {
              this.groups = [];
            }
            setDrawRange(start, count) {
              this.drawRange.start = start, this.drawRange.count = count;
            }
            applyMatrix4(matrix) {
              let position = this.attributes.position;
              position !== void 0 && (position.applyMatrix4(matrix), position.needsUpdate = !0);
              let normal = this.attributes.normal;
              if (normal !== void 0) {
                let normalMatrix = new Matrix3().getNormalMatrix(matrix);
                normal.applyNormalMatrix(normalMatrix), normal.needsUpdate = !0;
              }
              let tangent = this.attributes.tangent;
              return tangent !== void 0 && (tangent.transformDirection(matrix), tangent.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
            }
            applyQuaternion(q) {
              return _m1$2.makeRotationFromQuaternion(q), this.applyMatrix4(_m1$2), this;
            }
            rotateX(angle) {
              return _m1$2.makeRotationX(angle), this.applyMatrix4(_m1$2), this;
            }
            rotateY(angle) {
              return _m1$2.makeRotationY(angle), this.applyMatrix4(_m1$2), this;
            }
            rotateZ(angle) {
              return _m1$2.makeRotationZ(angle), this.applyMatrix4(_m1$2), this;
            }
            translate(x, y, z) {
              return _m1$2.makeTranslation(x, y, z), this.applyMatrix4(_m1$2), this;
            }
            scale(x, y, z) {
              return _m1$2.makeScale(x, y, z), this.applyMatrix4(_m1$2), this;
            }
            lookAt(vector) {
              return _obj.lookAt(vector), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this;
            }
            center() {
              return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this;
            }
            setFromPoints(points) {
              let position = [];
              for (let i = 0, l = points.length; i < l; i++) {
                let point = points[i];
                position.push(point.x, point.y, point.z || 0);
              }
              return this.setAttribute("position", new Float32BufferAttribute(position, 3)), this;
            }
            computeBoundingBox() {
              this.boundingBox === null && (this.boundingBox = new Box3());
              let position = this.attributes.position, morphAttributesPosition = this.morphAttributes.position;
              if (position && position.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new Vector3(-1 / 0, -1 / 0, -1 / 0), new Vector3(1 / 0, 1 / 0, 1 / 0));
                return;
              }
              if (position !== void 0) {
                if (this.boundingBox.setFromBufferAttribute(position), morphAttributesPosition)
                  for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                    let morphAttribute = morphAttributesPosition[i];
                    _box$2.setFromBufferAttribute(morphAttribute), this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$2.min), this.boundingBox.expandByPoint(_vector$8), _vector$8.addVectors(this.boundingBox.max, _box$2.max), this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$2.min), this.boundingBox.expandByPoint(_box$2.max));
                  }
              } else
                this.boundingBox.makeEmpty();
              (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
            }
            computeBoundingSphere() {
              this.boundingSphere === null && (this.boundingSphere = new Sphere());
              let position = this.attributes.position, morphAttributesPosition = this.morphAttributes.position;
              if (position && position.isGLBufferAttribute) {
                console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new Vector3(), 1 / 0);
                return;
              }
              if (position) {
                let center = this.boundingSphere.center;
                if (_box$2.setFromBufferAttribute(position), morphAttributesPosition)
                  for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                    let morphAttribute = morphAttributesPosition[i];
                    _boxMorphTargets.setFromBufferAttribute(morphAttribute), this.morphTargetsRelative ? (_vector$8.addVectors(_box$2.min, _boxMorphTargets.min), _box$2.expandByPoint(_vector$8), _vector$8.addVectors(_box$2.max, _boxMorphTargets.max), _box$2.expandByPoint(_vector$8)) : (_box$2.expandByPoint(_boxMorphTargets.min), _box$2.expandByPoint(_boxMorphTargets.max));
                  }
                _box$2.getCenter(center);
                let maxRadiusSq = 0;
                for (let i = 0, il = position.count; i < il; i++)
                  _vector$8.fromBufferAttribute(position, i), maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                if (morphAttributesPosition)
                  for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                    let morphAttribute = morphAttributesPosition[i], morphTargetsRelative = this.morphTargetsRelative;
                    for (let j = 0, jl = morphAttribute.count; j < jl; j++)
                      _vector$8.fromBufferAttribute(morphAttribute, j), morphTargetsRelative && (_offset.fromBufferAttribute(position, j), _vector$8.add(_offset)), maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                  }
                this.boundingSphere.radius = Math.sqrt(maxRadiusSq), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
              }
            }
            computeTangents() {
              let index = this.index, attributes = this.attributes;
              if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
                console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                return;
              }
              let positionAttribute = attributes.position, normalAttribute = attributes.normal, uvAttribute = attributes.uv;
              this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
              let tangentAttribute = this.getAttribute("tangent"), tan1 = [], tan2 = [];
              for (let i = 0; i < positionAttribute.count; i++)
                tan1[i] = new Vector3(), tan2[i] = new Vector3();
              let vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
              function handleTriangle(a, b, c) {
                vA.fromBufferAttribute(positionAttribute, a), vB.fromBufferAttribute(positionAttribute, b), vC.fromBufferAttribute(positionAttribute, c), uvA.fromBufferAttribute(uvAttribute, a), uvB.fromBufferAttribute(uvAttribute, b), uvC.fromBufferAttribute(uvAttribute, c), vB.sub(vA), vC.sub(vA), uvB.sub(uvA), uvC.sub(uvA);
                let r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
                !isFinite(r) || (sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r), tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r), tan1[a].add(sdir), tan1[b].add(sdir), tan1[c].add(sdir), tan2[a].add(tdir), tan2[b].add(tdir), tan2[c].add(tdir));
              }
              let groups = this.groups;
              groups.length === 0 && (groups = [{ start: 0, count: index.count }]);
              for (let i = 0, il = groups.length; i < il; ++i) {
                let group = groups[i], start = group.start, count = group.count;
                for (let j = start, jl = start + count; j < jl; j += 3)
                  handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));
              }
              let tmp2 = new Vector3(), tmp22 = new Vector3(), n = new Vector3(), n2 = new Vector3();
              function handleVertex(v) {
                n.fromBufferAttribute(normalAttribute, v), n2.copy(n);
                let t = tan1[v];
                tmp2.copy(t), tmp2.sub(n.multiplyScalar(n.dot(t))).normalize(), tmp22.crossVectors(n2, t);
                let w = tmp22.dot(tan2[v]) < 0 ? -1 : 1;
                tangentAttribute.setXYZW(v, tmp2.x, tmp2.y, tmp2.z, w);
              }
              for (let i = 0, il = groups.length; i < il; ++i) {
                let group = groups[i], start = group.start, count = group.count;
                for (let j = start, jl = start + count; j < jl; j += 3)
                  handleVertex(index.getX(j + 0)), handleVertex(index.getX(j + 1)), handleVertex(index.getX(j + 2));
              }
            }
            computeVertexNormals() {
              let index = this.index, positionAttribute = this.getAttribute("position");
              if (positionAttribute !== void 0) {
                let normalAttribute = this.getAttribute("normal");
                if (normalAttribute === void 0)
                  normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3), this.setAttribute("normal", normalAttribute);
                else
                  for (let i = 0, il = normalAttribute.count; i < il; i++)
                    normalAttribute.setXYZ(i, 0, 0, 0);
                let pA = new Vector3(), pB = new Vector3(), pC = new Vector3(), nA = new Vector3(), nB = new Vector3(), nC = new Vector3(), cb = new Vector3(), ab = new Vector3();
                if (index)
                  for (let i = 0, il = index.count; i < il; i += 3) {
                    let vA = index.getX(i + 0), vB = index.getX(i + 1), vC = index.getX(i + 2);
                    pA.fromBufferAttribute(positionAttribute, vA), pB.fromBufferAttribute(positionAttribute, vB), pC.fromBufferAttribute(positionAttribute, vC), cb.subVectors(pC, pB), ab.subVectors(pA, pB), cb.cross(ab), nA.fromBufferAttribute(normalAttribute, vA), nB.fromBufferAttribute(normalAttribute, vB), nC.fromBufferAttribute(normalAttribute, vC), nA.add(cb), nB.add(cb), nC.add(cb), normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z), normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z), normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
                  }
                else
                  for (let i = 0, il = positionAttribute.count; i < il; i += 3)
                    pA.fromBufferAttribute(positionAttribute, i + 0), pB.fromBufferAttribute(positionAttribute, i + 1), pC.fromBufferAttribute(positionAttribute, i + 2), cb.subVectors(pC, pB), ab.subVectors(pA, pB), cb.cross(ab), normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z), normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z), normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
                this.normalizeNormals(), normalAttribute.needsUpdate = !0;
              }
            }
            normalizeNormals() {
              let normals = this.attributes.normal;
              for (let i = 0, il = normals.count; i < il; i++)
                _vector$8.fromBufferAttribute(normals, i), _vector$8.normalize(), normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
            }
            toNonIndexed() {
              function convertBufferAttribute(attribute, indices2) {
                let array = attribute.array, itemSize = attribute.itemSize, normalized = attribute.normalized, array2 = new array.constructor(indices2.length * itemSize), index = 0, index2 = 0;
                for (let i = 0, l = indices2.length; i < l; i++) {
                  attribute.isInterleavedBufferAttribute ? index = indices2[i] * attribute.data.stride + attribute.offset : index = indices2[i] * itemSize;
                  for (let j = 0; j < itemSize; j++)
                    array2[index2++] = array[index++];
                }
                return new BufferAttribute(array2, itemSize, normalized);
              }
              if (this.index === null)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
              let geometry2 = new BufferGeometry(), indices = this.index.array, attributes = this.attributes;
              for (let name in attributes) {
                let attribute = attributes[name], newAttribute = convertBufferAttribute(attribute, indices);
                geometry2.setAttribute(name, newAttribute);
              }
              let morphAttributes = this.morphAttributes;
              for (let name in morphAttributes) {
                let morphArray = [], morphAttribute = morphAttributes[name];
                for (let i = 0, il = morphAttribute.length; i < il; i++) {
                  let attribute = morphAttribute[i], newAttribute = convertBufferAttribute(attribute, indices);
                  morphArray.push(newAttribute);
                }
                geometry2.morphAttributes[name] = morphArray;
              }
              geometry2.morphTargetsRelative = this.morphTargetsRelative;
              let groups = this.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                let group = groups[i];
                geometry2.addGroup(group.start, group.count, group.materialIndex);
              }
              return geometry2;
            }
            toJSON() {
              let data = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
              if (data.uuid = this.uuid, data.type = this.type, this.name !== "" && (data.name = this.name), Object.keys(this.userData).length > 0 && (data.userData = this.userData), this.parameters !== void 0) {
                let parameters = this.parameters;
                for (let key in parameters)
                  parameters[key] !== void 0 && (data[key] = parameters[key]);
                return data;
              }
              data.data = { attributes: {} };
              let index = this.index;
              index !== null && (data.data.index = { type: index.array.constructor.name, array: Array.prototype.slice.call(index.array) });
              let attributes = this.attributes;
              for (let key in attributes) {
                let attribute = attributes[key];
                data.data.attributes[key] = attribute.toJSON(data.data);
              }
              let morphAttributes = {}, hasMorphAttributes = !1;
              for (let key in this.morphAttributes) {
                let attributeArray = this.morphAttributes[key], array = [];
                for (let i = 0, il = attributeArray.length; i < il; i++) {
                  let attribute = attributeArray[i];
                  array.push(attribute.toJSON(data.data));
                }
                array.length > 0 && (morphAttributes[key] = array, hasMorphAttributes = !0);
              }
              hasMorphAttributes && (data.data.morphAttributes = morphAttributes, data.data.morphTargetsRelative = this.morphTargetsRelative);
              let groups = this.groups;
              groups.length > 0 && (data.data.groups = JSON.parse(JSON.stringify(groups)));
              let boundingSphere = this.boundingSphere;
              return boundingSphere !== null && (data.data.boundingSphere = { center: boundingSphere.center.toArray(), radius: boundingSphere.radius }), data;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(source) {
              this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
              let data = {};
              this.name = source.name;
              let index = source.index;
              index !== null && this.setIndex(index.clone(data));
              let attributes = source.attributes;
              for (let name in attributes) {
                let attribute = attributes[name];
                this.setAttribute(name, attribute.clone(data));
              }
              let morphAttributes = source.morphAttributes;
              for (let name in morphAttributes) {
                let array = [], morphAttribute = morphAttributes[name];
                for (let i = 0, l = morphAttribute.length; i < l; i++)
                  array.push(morphAttribute[i].clone(data));
                this.morphAttributes[name] = array;
              }
              this.morphTargetsRelative = source.morphTargetsRelative;
              let groups = source.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                let group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
              }
              let boundingBox = source.boundingBox;
              boundingBox !== null && (this.boundingBox = boundingBox.clone());
              let boundingSphere = source.boundingSphere;
              return boundingSphere !== null && (this.boundingSphere = boundingSphere.clone()), this.drawRange.start = source.drawRange.start, this.drawRange.count = source.drawRange.count, this.userData = source.userData, this;
            }
            dispose() {
              this.dispatchEvent({ type: "dispose" });
            }
          }
          let _inverseMatrix$3 = /* @__PURE__ */ new Matrix4(), _ray$3 = /* @__PURE__ */ new Ray(), _sphere$6 = /* @__PURE__ */ new Sphere(), _sphereHitAt = /* @__PURE__ */ new Vector3(), _vA$1 = /* @__PURE__ */ new Vector3(), _vB$1 = /* @__PURE__ */ new Vector3(), _vC$1 = /* @__PURE__ */ new Vector3(), _tempA = /* @__PURE__ */ new Vector3(), _morphA = /* @__PURE__ */ new Vector3(), _uvA$1 = /* @__PURE__ */ new Vector2(), _uvB$1 = /* @__PURE__ */ new Vector2(), _uvC$1 = /* @__PURE__ */ new Vector2(), _normalA = /* @__PURE__ */ new Vector3(), _normalB = /* @__PURE__ */ new Vector3(), _normalC = /* @__PURE__ */ new Vector3(), _intersectionPoint = /* @__PURE__ */ new Vector3(), _intersectionPointWorld = /* @__PURE__ */ new Vector3();
          class Mesh extends Object3D {
            constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
              super();
              this.isMesh = !0, this.type = "Mesh", this.geometry = geometry, this.material = material, this.updateMorphTargets();
            }
            copy(source, recursive) {
              return super.copy(source, recursive), source.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = source.morphTargetInfluences.slice()), source.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary)), this.material = Array.isArray(source.material) ? source.material.slice() : source.material, this.geometry = source.geometry, this;
            }
            updateMorphTargets() {
              let morphAttributes = this.geometry.morphAttributes, keys = Object.keys(morphAttributes);
              if (keys.length > 0) {
                let morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== void 0) {
                  this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                  for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                    let name = morphAttribute[m].name || String(m);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[name] = m;
                  }
                }
              }
            }
            getVertexPosition(index, target) {
              let geometry = this.geometry, position = geometry.attributes.position, morphPosition = geometry.morphAttributes.position, morphTargetsRelative = geometry.morphTargetsRelative;
              target.fromBufferAttribute(position, index);
              let morphInfluences = this.morphTargetInfluences;
              if (morphPosition && morphInfluences) {
                _morphA.set(0, 0, 0);
                for (let i = 0, il = morphPosition.length; i < il; i++) {
                  let influence = morphInfluences[i], morphAttribute = morphPosition[i];
                  influence !== 0 && (_tempA.fromBufferAttribute(morphAttribute, index), morphTargetsRelative ? _morphA.addScaledVector(_tempA, influence) : _morphA.addScaledVector(_tempA.sub(target), influence));
                }
                target.add(_morphA);
              }
              return target;
            }
            raycast(raycaster, intersects2) {
              let geometry = this.geometry, material = this.material, matrixWorld = this.matrixWorld;
              material !== void 0 && (geometry.boundingSphere === null && geometry.computeBoundingSphere(), _sphere$6.copy(geometry.boundingSphere), _sphere$6.applyMatrix4(matrixWorld), _ray$3.copy(raycaster.ray).recast(raycaster.near), !(_sphere$6.containsPoint(_ray$3.origin) === !1 && (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null || _ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2)) && (_inverseMatrix$3.copy(matrixWorld).invert(), _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3), !(geometry.boundingBox !== null && _ray$3.intersectsBox(geometry.boundingBox) === !1) && this._computeIntersections(raycaster, intersects2, _ray$3)));
            }
            _computeIntersections(raycaster, intersects2, rayLocalSpace) {
              let intersection, geometry = this.geometry, material = this.material, index = geometry.index, position = geometry.attributes.position, uv = geometry.attributes.uv, uv1 = geometry.attributes.uv1, normal = geometry.attributes.normal, groups = geometry.groups, drawRange = geometry.drawRange;
              if (index !== null)
                if (Array.isArray(material))
                  for (let i = 0, il = groups.length; i < il; i++) {
                    let group = groups[i], groupMaterial = material[group.materialIndex], start = Math.max(group.start, drawRange.start), end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                    for (let j = start, jl = end; j < jl; j += 3) {
                      let a = index.getX(j), b = index.getX(j + 1), c = index.getX(j + 2);
                      intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c), intersection && (intersection.faceIndex = Math.floor(j / 3), intersection.face.materialIndex = group.materialIndex, intersects2.push(intersection));
                    }
                  }
                else {
                  let start = Math.max(0, drawRange.start), end = Math.min(index.count, drawRange.start + drawRange.count);
                  for (let i = start, il = end; i < il; i += 3) {
                    let a = index.getX(i), b = index.getX(i + 1), c = index.getX(i + 2);
                    intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c), intersection && (intersection.faceIndex = Math.floor(i / 3), intersects2.push(intersection));
                  }
                }
              else if (position !== void 0)
                if (Array.isArray(material))
                  for (let i = 0, il = groups.length; i < il; i++) {
                    let group = groups[i], groupMaterial = material[group.materialIndex], start = Math.max(group.start, drawRange.start), end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                    for (let j = start, jl = end; j < jl; j += 3) {
                      let a = j, b = j + 1, c = j + 2;
                      intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c), intersection && (intersection.faceIndex = Math.floor(j / 3), intersection.face.materialIndex = group.materialIndex, intersects2.push(intersection));
                    }
                  }
                else {
                  let start = Math.max(0, drawRange.start), end = Math.min(position.count, drawRange.start + drawRange.count);
                  for (let i = start, il = end; i < il; i += 3) {
                    let a = i, b = i + 1, c = i + 2;
                    intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c), intersection && (intersection.faceIndex = Math.floor(i / 3), intersects2.push(intersection));
                  }
                }
            }
          }
          function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
            let intersect2;
            if (material.side === BackSide ? intersect2 = ray.intersectTriangle(pC, pB, pA, !0, point) : intersect2 = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point), intersect2 === null)
              return null;
            _intersectionPointWorld.copy(point), _intersectionPointWorld.applyMatrix4(object.matrixWorld);
            let distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
            return distance < raycaster.near || distance > raycaster.far ? null : { distance, point: _intersectionPointWorld.clone(), object };
          }
          function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
            object.getVertexPosition(a, _vA$1), object.getVertexPosition(b, _vB$1), object.getVertexPosition(c, _vC$1);
            let intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
            if (intersection) {
              uv && (_uvA$1.fromBufferAttribute(uv, a), _uvB$1.fromBufferAttribute(uv, b), _uvC$1.fromBufferAttribute(uv, c), intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2())), uv1 && (_uvA$1.fromBufferAttribute(uv1, a), _uvB$1.fromBufferAttribute(uv1, b), _uvC$1.fromBufferAttribute(uv1, c), intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2())), normal && (_normalA.fromBufferAttribute(normal, a), _normalB.fromBufferAttribute(normal, b), _normalC.fromBufferAttribute(normal, c), intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3()), intersection.normal.dot(ray.direction) > 0 && intersection.normal.multiplyScalar(-1));
              let face = { a, b, c, normal: new Vector3(), materialIndex: 0 };
              Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal), intersection.face = face;
            }
            return intersection;
          }
          class BoxGeometry extends BufferGeometry {
            constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
              super();
              this.type = "BoxGeometry", this.parameters = { width, height, depth, widthSegments, heightSegments, depthSegments };
              let scope = this;
              widthSegments = Math.floor(widthSegments), heightSegments = Math.floor(heightSegments), depthSegments = Math.floor(depthSegments);
              let indices = [], vertices = [], normals = [], uvs = [], numberOfVertices = 0, groupStart = 0;
              buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0), buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1), buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2), buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3), buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4), buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5), this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
              function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
                let segmentWidth = width2 / gridX, segmentHeight = height2 / gridY, widthHalf = width2 / 2, heightHalf = height2 / 2, depthHalf = depth2 / 2, gridX1 = gridX + 1, gridY1 = gridY + 1, vertexCounter = 0, groupCount = 0, vector = new Vector3();
                for (let iy = 0; iy < gridY1; iy++) {
                  let y = iy * segmentHeight - heightHalf;
                  for (let ix = 0; ix < gridX1; ix++) {
                    let x = ix * segmentWidth - widthHalf;
                    vector[u] = x * udir, vector[v] = y * vdir, vector[w] = depthHalf, vertices.push(vector.x, vector.y, vector.z), vector[u] = 0, vector[v] = 0, vector[w] = depth2 > 0 ? 1 : -1, normals.push(vector.x, vector.y, vector.z), uvs.push(ix / gridX), uvs.push(1 - iy / gridY), vertexCounter += 1;
                  }
                }
                for (let iy = 0; iy < gridY; iy++)
                  for (let ix = 0; ix < gridX; ix++) {
                    let a = numberOfVertices + ix + gridX1 * iy, b = numberOfVertices + ix + gridX1 * (iy + 1), c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1), d = numberOfVertices + (ix + 1) + gridX1 * iy;
                    indices.push(a, b, d), indices.push(b, c, d), groupCount += 6;
                  }
                scope.addGroup(groupStart, groupCount, materialIndex), groupStart += groupCount, numberOfVertices += vertexCounter;
              }
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            static fromJSON(data) {
              return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            }
          }
          function cloneUniforms(src) {
            let dst = {};
            for (let u in src) {
              dst[u] = {};
              for (let p in src[u]) {
                let property = src[u][p];
                property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion) ? property.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), dst[u][p] = null) : dst[u][p] = property.clone() : Array.isArray(property) ? dst[u][p] = property.slice() : dst[u][p] = property;
              }
            }
            return dst;
          }
          function mergeUniforms(uniforms) {
            let merged = {};
            for (let u = 0; u < uniforms.length; u++) {
              let tmp2 = cloneUniforms(uniforms[u]);
              for (let p in tmp2)
                merged[p] = tmp2[p];
            }
            return merged;
          }
          function cloneUniformsGroups(src) {
            let dst = [];
            for (let u = 0; u < src.length; u++)
              dst.push(src[u].clone());
            return dst;
          }
          function getUnlitUniformColorSpace(renderer) {
            let currentRenderTarget = renderer.getRenderTarget();
            return currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === !0 ? currentRenderTarget.texture.colorSpace : ColorManagement.workingColorSpace;
          }
          let UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
          var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
          class ShaderMaterial extends Material {
            constructor(parameters) {
              super();
              this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                clipCullDistance: !1,
                multiDraw: !1
              }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, parameters !== void 0 && this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.fragmentShader = source.fragmentShader, this.vertexShader = source.vertexShader, this.uniforms = cloneUniforms(source.uniforms), this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups), this.defines = Object.assign({}, source.defines), this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.fog = source.fog, this.lights = source.lights, this.clipping = source.clipping, this.extensions = Object.assign({}, source.extensions), this.glslVersion = source.glslVersion, this;
            }
            toJSON(meta) {
              let data = super.toJSON(meta);
              data.glslVersion = this.glslVersion, data.uniforms = {};
              for (let name in this.uniforms) {
                let value = this.uniforms[name].value;
                value && value.isTexture ? data.uniforms[name] = { type: "t", value: value.toJSON(meta).uuid } : value && value.isColor ? data.uniforms[name] = { type: "c", value: value.getHex() } : value && value.isVector2 ? data.uniforms[name] = { type: "v2", value: value.toArray() } : value && value.isVector3 ? data.uniforms[name] = { type: "v3", value: value.toArray() } : value && value.isVector4 ? data.uniforms[name] = { type: "v4", value: value.toArray() } : value && value.isMatrix3 ? data.uniforms[name] = { type: "m3", value: value.toArray() } : value && value.isMatrix4 ? data.uniforms[name] = { type: "m4", value: value.toArray() } : data.uniforms[name] = { value };
              }
              Object.keys(this.defines).length > 0 && (data.defines = this.defines), data.vertexShader = this.vertexShader, data.fragmentShader = this.fragmentShader, data.lights = this.lights, data.clipping = this.clipping;
              let extensions = {};
              for (let key in this.extensions)
                this.extensions[key] === !0 && (extensions[key] = !0);
              return Object.keys(extensions).length > 0 && (data.extensions = extensions), data;
            }
          }
          class Camera extends Object3D {
            constructor() {
              super();
              this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Matrix4(), this.projectionMatrix = new Matrix4(), this.projectionMatrixInverse = new Matrix4(), this.coordinateSystem = WebGLCoordinateSystem;
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.matrixWorldInverse.copy(source.matrixWorldInverse), this.projectionMatrix.copy(source.projectionMatrix), this.projectionMatrixInverse.copy(source.projectionMatrixInverse), this.coordinateSystem = source.coordinateSystem, this;
            }
            getWorldDirection(target) {
              return super.getWorldDirection(target).negate();
            }
            updateMatrixWorld(force) {
              super.updateMatrixWorld(force), this.matrixWorldInverse.copy(this.matrixWorld).invert();
            }
            updateWorldMatrix(updateParents, updateChildren) {
              super.updateWorldMatrix(updateParents, updateChildren), this.matrixWorldInverse.copy(this.matrixWorld).invert();
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }
          let _v3$1 = /* @__PURE__ */ new Vector3(), _minTarget = /* @__PURE__ */ new Vector2(), _maxTarget = /* @__PURE__ */ new Vector2();
          class PerspectiveCamera extends Camera {
            constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
              super();
              this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = fov2, this.zoom = 1, this.near = near, this.far = far, this.focus = 10, this.aspect = aspect2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.fov = source.fov, this.zoom = source.zoom, this.near = source.near, this.far = source.far, this.focus = source.focus, this.aspect = source.aspect, this.view = source.view === null ? null : Object.assign({}, source.view), this.filmGauge = source.filmGauge, this.filmOffset = source.filmOffset, this;
            }
            setFocalLength(focalLength) {
              let vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
              this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope), this.updateProjectionMatrix();
            }
            getFocalLength() {
              let vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
              return 0.5 * this.getFilmHeight() / vExtentSlope;
            }
            getEffectiveFOV() {
              return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
            }
            getFilmWidth() {
              return this.filmGauge * Math.min(this.aspect, 1);
            }
            getFilmHeight() {
              return this.filmGauge / Math.max(this.aspect, 1);
            }
            getViewBounds(distance, minTarget, maxTarget) {
              _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z), _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
            }
            getViewSize(distance, target) {
              return this.getViewBounds(distance, _minTarget, _maxTarget), target.subVectors(_maxTarget, _minTarget);
            }
            setViewOffset(fullWidth, fullHeight, x, y, width, height) {
              this.aspect = fullWidth / fullHeight, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = fullWidth, this.view.fullHeight = fullHeight, this.view.offsetX = x, this.view.offsetY = y, this.view.width = width, this.view.height = height, this.updateProjectionMatrix();
            }
            clearViewOffset() {
              this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
            }
            updateProjectionMatrix() {
              let near = this.near, top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
              if (this.view !== null && this.view.enabled) {
                let fullWidth = view.fullWidth, fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth, top -= view.offsetY * height / fullHeight, width *= view.width / fullWidth, height *= view.height / fullHeight;
              }
              let skew = this.filmOffset;
              skew !== 0 && (left += near * skew / this.getFilmWidth()), this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
            }
            toJSON(meta) {
              let data = super.toJSON(meta);
              return data.object.fov = this.fov, data.object.zoom = this.zoom, data.object.near = this.near, data.object.far = this.far, data.object.focus = this.focus, data.object.aspect = this.aspect, this.view !== null && (data.object.view = Object.assign({}, this.view)), data.object.filmGauge = this.filmGauge, data.object.filmOffset = this.filmOffset, data;
            }
          }
          let fov = -90, aspect = 1;
          class CubeCamera extends Object3D {
            constructor(near, far, renderTarget) {
              super();
              this.type = "CubeCamera", this.renderTarget = renderTarget, this.coordinateSystem = null, this.activeMipmapLevel = 0;
              let cameraPX = new PerspectiveCamera(fov, aspect, near, far);
              cameraPX.layers = this.layers, this.add(cameraPX);
              let cameraNX = new PerspectiveCamera(fov, aspect, near, far);
              cameraNX.layers = this.layers, this.add(cameraNX);
              let cameraPY = new PerspectiveCamera(fov, aspect, near, far);
              cameraPY.layers = this.layers, this.add(cameraPY);
              let cameraNY = new PerspectiveCamera(fov, aspect, near, far);
              cameraNY.layers = this.layers, this.add(cameraNY);
              let cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
              cameraPZ.layers = this.layers, this.add(cameraPZ);
              let cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
              cameraNZ.layers = this.layers, this.add(cameraNZ);
            }
            updateCoordinateSystem() {
              let coordinateSystem = this.coordinateSystem, cameras = this.children.concat(), [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
              for (let camera of cameras)
                this.remove(camera);
              if (coordinateSystem === WebGLCoordinateSystem)
                cameraPX.up.set(0, 1, 0), cameraPX.lookAt(1, 0, 0), cameraNX.up.set(0, 1, 0), cameraNX.lookAt(-1, 0, 0), cameraPY.up.set(0, 0, -1), cameraPY.lookAt(0, 1, 0), cameraNY.up.set(0, 0, 1), cameraNY.lookAt(0, -1, 0), cameraPZ.up.set(0, 1, 0), cameraPZ.lookAt(0, 0, 1), cameraNZ.up.set(0, 1, 0), cameraNZ.lookAt(0, 0, -1);
              else if (coordinateSystem === WebGPUCoordinateSystem)
                cameraPX.up.set(0, -1, 0), cameraPX.lookAt(-1, 0, 0), cameraNX.up.set(0, -1, 0), cameraNX.lookAt(1, 0, 0), cameraPY.up.set(0, 0, 1), cameraPY.lookAt(0, 1, 0), cameraNY.up.set(0, 0, -1), cameraNY.lookAt(0, -1, 0), cameraPZ.up.set(0, -1, 0), cameraPZ.lookAt(0, 0, 1), cameraNZ.up.set(0, -1, 0), cameraNZ.lookAt(0, 0, -1);
              else
                throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
              for (let camera of cameras)
                this.add(camera), camera.updateMatrixWorld();
            }
            update(renderer, scene) {
              this.parent === null && this.updateMatrixWorld();
              let { renderTarget, activeMipmapLevel } = this;
              this.coordinateSystem !== renderer.coordinateSystem && (this.coordinateSystem = renderer.coordinateSystem, this.updateCoordinateSystem());
              let [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children, currentRenderTarget = renderer.getRenderTarget(), currentActiveCubeFace = renderer.getActiveCubeFace(), currentActiveMipmapLevel = renderer.getActiveMipmapLevel(), currentXrEnabled = renderer.xr.enabled;
              renderer.xr.enabled = !1;
              let generateMipmaps = renderTarget.texture.generateMipmaps;
              renderTarget.texture.generateMipmaps = !1, renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel), renderer.render(scene, cameraPX), renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel), renderer.render(scene, cameraNX), renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel), renderer.render(scene, cameraPY), renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel), renderer.render(scene, cameraNY), renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel), renderer.render(scene, cameraPZ), renderTarget.texture.generateMipmaps = generateMipmaps, renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel), renderer.render(scene, cameraNZ), renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel), renderer.xr.enabled = currentXrEnabled, renderTarget.texture.needsPMREMUpdate = !0;
            }
          }
          class CubeTexture extends Texture {
            constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
              images = images !== void 0 ? images : [], mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
              super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
              this.isCubeTexture = !0, this.flipY = !1;
            }
            get images() {
              return this.image;
            }
            set images(value) {
              this.image = value;
            }
          }
          class WebGLCubeRenderTarget extends WebGLRenderTarget {
            constructor(size = 1, options = {}) {
              super(size, size, options);
              this.isWebGLCubeRenderTarget = !0;
              let image = { width: size, height: size, depth: 1 }, images = [image, image, image, image, image, image];
              this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : !1, this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
            }
            fromEquirectangularTexture(renderer, texture) {
              this.texture.type = texture.type, this.texture.colorSpace = texture.colorSpace, this.texture.generateMipmaps = texture.generateMipmaps, this.texture.minFilter = texture.minFilter, this.texture.magFilter = texture.magFilter;
              let shader = { uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, geometry = new BoxGeometry(5, 5, 5), material = new ShaderMaterial({ name: "CubemapFromEquirect", uniforms: cloneUniforms(shader.uniforms), vertexShader: shader.vertexShader, fragmentShader: shader.fragmentShader, side: BackSide, blending: NoBlending });
              material.uniforms.tEquirect.value = texture;
              let mesh = new Mesh(geometry, material), currentMinFilter = texture.minFilter;
              return texture.minFilter === LinearMipmapLinearFilter && (texture.minFilter = LinearFilter), new CubeCamera(1, 10, this).update(renderer, mesh), texture.minFilter = currentMinFilter, mesh.geometry.dispose(), mesh.material.dispose(), this;
            }
            clear(renderer, color, depth, stencil) {
              let currentRenderTarget = renderer.getRenderTarget();
              for (let i = 0; i < 6; i++)
                renderer.setRenderTarget(this, i), renderer.clear(color, depth, stencil);
              renderer.setRenderTarget(currentRenderTarget);
            }
          }
          let _vector1 = /* @__PURE__ */ new Vector3(), _vector2 = /* @__PURE__ */ new Vector3(), _normalMatrix = /* @__PURE__ */ new Matrix3();
          class Plane {
            constructor(normal = new Vector3(1, 0, 0), constant = 0) {
              this.isPlane = !0, this.normal = normal, this.constant = constant;
            }
            set(normal, constant) {
              return this.normal.copy(normal), this.constant = constant, this;
            }
            setComponents(x, y, z, w) {
              return this.normal.set(x, y, z), this.constant = w, this;
            }
            setFromNormalAndCoplanarPoint(normal, point) {
              return this.normal.copy(normal), this.constant = -point.dot(this.normal), this;
            }
            setFromCoplanarPoints(a, b, c) {
              let normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
              return this.setFromNormalAndCoplanarPoint(normal, a), this;
            }
            copy(plane) {
              return this.normal.copy(plane.normal), this.constant = plane.constant, this;
            }
            normalize() {
              let inverseNormalLength = 1 / this.normal.length();
              return this.normal.multiplyScalar(inverseNormalLength), this.constant *= inverseNormalLength, this;
            }
            negate() {
              return this.constant *= -1, this.normal.negate(), this;
            }
            distanceToPoint(point) {
              return this.normal.dot(point) + this.constant;
            }
            distanceToSphere(sphere) {
              return this.distanceToPoint(sphere.center) - sphere.radius;
            }
            projectPoint(point, target) {
              return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
            }
            intersectLine(line, target) {
              let direction = line.delta(_vector1), denominator = this.normal.dot(direction);
              if (denominator === 0)
                return this.distanceToPoint(line.start) === 0 ? target.copy(line.start) : null;
              let t = -(line.start.dot(this.normal) + this.constant) / denominator;
              return t < 0 || t > 1 ? null : target.copy(line.start).addScaledVector(direction, t);
            }
            intersectsLine(line) {
              let startSign = this.distanceToPoint(line.start), endSign = this.distanceToPoint(line.end);
              return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
            }
            intersectsBox(box) {
              return box.intersectsPlane(this);
            }
            intersectsSphere(sphere) {
              return sphere.intersectsPlane(this);
            }
            coplanarPoint(target) {
              return target.copy(this.normal).multiplyScalar(-this.constant);
            }
            applyMatrix4(matrix, optionalNormalMatrix) {
              let normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix), referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix), normal = this.normal.applyMatrix3(normalMatrix).normalize();
              return this.constant = -referencePoint.dot(normal), this;
            }
            translate(offset) {
              return this.constant -= offset.dot(this.normal), this;
            }
            equals(plane) {
              return plane.normal.equals(this.normal) && plane.constant === this.constant;
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }
          let _sphere$5 = /* @__PURE__ */ new Sphere(), _vector$7 = /* @__PURE__ */ new Vector3();
          class Frustum {
            constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
              this.planes = [p0, p1, p2, p3, p4, p5];
            }
            set(p0, p1, p2, p3, p4, p5) {
              let planes = this.planes;
              return planes[0].copy(p0), planes[1].copy(p1), planes[2].copy(p2), planes[3].copy(p3), planes[4].copy(p4), planes[5].copy(p5), this;
            }
            copy(frustum) {
              let planes = this.planes;
              for (let i = 0; i < 6; i++)
                planes[i].copy(frustum.planes[i]);
              return this;
            }
            setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {
              let planes = this.planes, me = m.elements, me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3], me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7], me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11], me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
              if (planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize(), planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize(), planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize(), planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize(), planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize(), coordinateSystem === WebGLCoordinateSystem)
                planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
              else if (coordinateSystem === WebGPUCoordinateSystem)
                planes[5].setComponents(me2, me6, me10, me14).normalize();
              else
                throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
              return this;
            }
            intersectsObject(object) {
              if (object.boundingSphere !== void 0)
                object.boundingSphere === null && object.computeBoundingSphere(), _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
              else {
                let geometry = object.geometry;
                geometry.boundingSphere === null && geometry.computeBoundingSphere(), _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
              }
              return this.intersectsSphere(_sphere$5);
            }
            intersectsSprite(sprite) {
              return _sphere$5.center.set(0, 0, 0), _sphere$5.radius = 0.7071067811865476, _sphere$5.applyMatrix4(sprite.matrixWorld), this.intersectsSphere(_sphere$5);
            }
            intersectsSphere(sphere) {
              let planes = this.planes, center = sphere.center, negRadius = -sphere.radius;
              for (let i = 0; i < 6; i++)
                if (planes[i].distanceToPoint(center) < negRadius)
                  return !1;
              return !0;
            }
            intersectsBox(box) {
              let planes = this.planes;
              for (let i = 0; i < 6; i++) {
                let plane = planes[i];
                if (_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x, _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y, _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z, plane.distanceToPoint(_vector$7) < 0)
                  return !1;
              }
              return !0;
            }
            containsPoint(point) {
              let planes = this.planes;
              for (let i = 0; i < 6; i++)
                if (planes[i].distanceToPoint(point) < 0)
                  return !1;
              return !0;
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }
          function WebGLAnimation() {
            let context = null, isAnimating = !1, animationLoop = null, requestId = null;
            function onAnimationFrame(time, frame) {
              animationLoop(time, frame), requestId = context.requestAnimationFrame(onAnimationFrame);
            }
            return { start: function() {
              isAnimating !== !0 && animationLoop !== null && (requestId = context.requestAnimationFrame(onAnimationFrame), isAnimating = !0);
            }, stop: function() {
              context.cancelAnimationFrame(requestId), isAnimating = !1;
            }, setAnimationLoop: function(callback) {
              animationLoop = callback;
            }, setContext: function(value) {
              context = value;
            } };
          }
          function WebGLAttributes(gl) {
            let buffers = new WeakMap();
            function createBuffer(attribute, bufferType) {
              let array = attribute.array, usage = attribute.usage, size = array.byteLength, buffer = gl.createBuffer();
              gl.bindBuffer(bufferType, buffer), gl.bufferData(bufferType, array, usage), attribute.onUploadCallback();
              let type;
              if (array instanceof Float32Array)
                type = gl.FLOAT;
              else if (array instanceof Uint16Array)
                attribute.isFloat16BufferAttribute ? type = gl.HALF_FLOAT : type = gl.UNSIGNED_SHORT;
              else if (array instanceof Int16Array)
                type = gl.SHORT;
              else if (array instanceof Uint32Array)
                type = gl.UNSIGNED_INT;
              else if (array instanceof Int32Array)
                type = gl.INT;
              else if (array instanceof Int8Array)
                type = gl.BYTE;
              else if (array instanceof Uint8Array)
                type = gl.UNSIGNED_BYTE;
              else if (array instanceof Uint8ClampedArray)
                type = gl.UNSIGNED_BYTE;
              else
                throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
              return { buffer, type, bytesPerElement: array.BYTES_PER_ELEMENT, version: attribute.version, size };
            }
            function updateBuffer(buffer, attribute, bufferType) {
              let array = attribute.array, updateRange = attribute._updateRange, updateRanges = attribute.updateRanges;
              if (gl.bindBuffer(bufferType, buffer), updateRange.count === -1 && updateRanges.length === 0 && gl.bufferSubData(bufferType, 0, array), updateRanges.length !== 0) {
                for (let i = 0, l = updateRanges.length; i < l; i++) {
                  let range = updateRanges[i];
                  gl.bufferSubData(bufferType, range.start * array.BYTES_PER_ELEMENT, array, range.start, range.count);
                }
                attribute.clearUpdateRanges();
              }
              updateRange.count !== -1 && (gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count), updateRange.count = -1), attribute.onUploadCallback();
            }
            function get(attribute) {
              return attribute.isInterleavedBufferAttribute && (attribute = attribute.data), buffers.get(attribute);
            }
            function remove(attribute) {
              attribute.isInterleavedBufferAttribute && (attribute = attribute.data);
              let data = buffers.get(attribute);
              data && (gl.deleteBuffer(data.buffer), buffers.delete(attribute));
            }
            function update(attribute, bufferType) {
              if (attribute.isGLBufferAttribute) {
                let cached = buffers.get(attribute);
                (!cached || cached.version < attribute.version) && buffers.set(attribute, { buffer: attribute.buffer, type: attribute.type, bytesPerElement: attribute.elementSize, version: attribute.version });
                return;
              }
              attribute.isInterleavedBufferAttribute && (attribute = attribute.data);
              let data = buffers.get(attribute);
              if (data === void 0)
                buffers.set(attribute, createBuffer(attribute, bufferType));
              else if (data.version < attribute.version) {
                if (data.size !== attribute.array.byteLength)
                  throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                updateBuffer(data.buffer, attribute, bufferType), data.version = attribute.version;
              }
            }
            return { get, remove, update };
          }
          class PlaneGeometry extends BufferGeometry {
            constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
              super();
              this.type = "PlaneGeometry", this.parameters = { width, height, widthSegments, heightSegments };
              let width_half = width / 2, height_half = height / 2, gridX = Math.floor(widthSegments), gridY = Math.floor(heightSegments), gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, indices = [], vertices = [], normals = [], uvs = [];
              for (let iy = 0; iy < gridY1; iy++) {
                let y = iy * segment_height - height_half;
                for (let ix = 0; ix < gridX1; ix++) {
                  let x = ix * segment_width - width_half;
                  vertices.push(x, -y, 0), normals.push(0, 0, 1), uvs.push(ix / gridX), uvs.push(1 - iy / gridY);
                }
              }
              for (let iy = 0; iy < gridY; iy++)
                for (let ix = 0; ix < gridX; ix++) {
                  let a = ix + gridX1 * iy, b = ix + gridX1 * (iy + 1), c = ix + 1 + gridX1 * (iy + 1), d = ix + 1 + gridX1 * iy;
                  indices.push(a, b, d), indices.push(b, c, d);
                }
              this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            static fromJSON(data) {
              return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
            }
          }
          var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, alphatest_fragment = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, batching_pars_vertex = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, batching_vertex = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );", colorspace_pars_fragment = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, lights_fragment_begin = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, morphinstance_vertex = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, morphcolor_vertex = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, opaque_fragment = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`, shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
          let ShaderChunk = { alphahash_fragment, alphahash_pars_fragment, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, batching_pars_vertex, batching_vertex, begin_vertex, beginnormal_vertex, bsdfs, iridescence_fragment, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, colorspace_fragment, colorspace_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_physical_pars_fragment, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_pars_fragment, lights_lambert_fragment, lights_lambert_pars_fragment, lights_pars_begin, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphinstance_vertex, morphcolor_vertex, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, iridescence_pars_fragment, opaque_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, worldpos_vertex, background_vert: `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, background_frag: `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, backgroundCube_frag: `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, depth_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, meshbasic_vert: `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, shadow_vert: `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}` }, UniformsLib = { common: { diffuse: { value: /* @__PURE__ */ new Color(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: /* @__PURE__ */ new Matrix3() }, alphaMap: { value: null }, alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: /* @__PURE__ */ new Matrix3() } }, envmap: {
            envMap: { value: null },
            envMapRotation: { value: /* @__PURE__ */ new Matrix3() },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 }
          }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: /* @__PURE__ */ new Matrix3() } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: /* @__PURE__ */ new Matrix3() } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: /* @__PURE__ */ new Matrix3() }, normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: /* @__PURE__ */ new Color(16777215) } }, lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: { value: [], properties: { direction: {}, color: {} } },
            directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } },
            spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
            pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
            rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
            ltc_1: { value: null },
            ltc_2: { value: null }
          }, points: { diffuse: { value: /* @__PURE__ */ new Color(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() }, alphaTest: { value: 0 }, uvTransform: { value: /* @__PURE__ */ new Matrix3() } }, sprite: { diffuse: { value: /* @__PURE__ */ new Color(16777215) }, opacity: { value: 1 }, center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: /* @__PURE__ */ new Matrix3() }, alphaMap: { value: null }, alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() }, alphaTest: { value: 0 } } }, ShaderLib = { basic: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]), vertexShader: ShaderChunk.meshbasic_vert, fragmentShader: ShaderChunk.meshbasic_frag }, lambert: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: /* @__PURE__ */ new Color(0) } }]), vertexShader: ShaderChunk.meshlambert_vert, fragmentShader: ShaderChunk.meshlambert_frag }, phong: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: /* @__PURE__ */ new Color(0) }, specular: { value: /* @__PURE__ */ new Color(1118481) }, shininess: { value: 30 } }]), vertexShader: ShaderChunk.meshphong_vert, fragmentShader: ShaderChunk.meshphong_frag }, standard: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: /* @__PURE__ */ new Color(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }, toon: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: /* @__PURE__ */ new Color(0) } }]), vertexShader: ShaderChunk.meshtoon_vert, fragmentShader: ShaderChunk.meshtoon_frag }, matcap: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, { matcap: { value: null } }]), vertexShader: ShaderChunk.meshmatcap_vert, fragmentShader: ShaderChunk.meshmatcap_frag }, points: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.points, UniformsLib.fog]), vertexShader: ShaderChunk.points_vert, fragmentShader: ShaderChunk.points_frag }, dashed: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: ShaderChunk.linedashed_vert, fragmentShader: ShaderChunk.linedashed_frag }, depth: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]), vertexShader: ShaderChunk.depth_vert, fragmentShader: ShaderChunk.depth_frag }, normal: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, { opacity: { value: 1 } }]), vertexShader: ShaderChunk.meshnormal_vert, fragmentShader: ShaderChunk.meshnormal_frag }, sprite: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.sprite, UniformsLib.fog]), vertexShader: ShaderChunk.sprite_vert, fragmentShader: ShaderChunk.sprite_frag }, background: { uniforms: { uvTransform: { value: /* @__PURE__ */ new Matrix3() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: ShaderChunk.background_vert, fragmentShader: ShaderChunk.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 }, backgroundRotation: { value: /* @__PURE__ */ new Matrix3() } }, vertexShader: ShaderChunk.backgroundCube_vert, fragmentShader: ShaderChunk.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: ShaderChunk.cube_vert, fragmentShader: ShaderChunk.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: ShaderChunk.equirect_vert, fragmentShader: ShaderChunk.equirect_frag }, distanceRGBA: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, { referencePosition: { value: /* @__PURE__ */ new Vector3() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: ShaderChunk.distanceRGBA_vert, fragmentShader: ShaderChunk.distanceRGBA_frag }, shadow: { uniforms: /* @__PURE__ */ mergeUniforms([UniformsLib.lights, UniformsLib.fog, { color: { value: /* @__PURE__ */ new Color(0) }, opacity: { value: 1 } }]), vertexShader: ShaderChunk.shadow_vert, fragmentShader: ShaderChunk.shadow_frag } };
          ShaderLib.physical = { uniforms: /* @__PURE__ */ mergeUniforms([ShaderLib.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() }, clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }, dispersion: { value: 0 }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() }, sheen: { value: 0 }, sheenColor: { value: /* @__PURE__ */ new Color(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() }, transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() }, attenuationDistance: { value: 0 }, attenuationColor: { value: /* @__PURE__ */ new Color(0) }, specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() }, anisotropyVector: { value: /* @__PURE__ */ new Vector2() }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag };
          let _rgb = { r: 0, b: 0, g: 0 }, _e1$1 = /* @__PURE__ */ new Euler(), _m1$1 = /* @__PURE__ */ new Matrix4();
          function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
            let clearColor = new Color(0), clearAlpha = alpha === !0 ? 0 : 1, planeMesh, boxMesh, currentBackground = null, currentBackgroundVersion = 0, currentTonemapping = null;
            function getBackground(scene) {
              let background = scene.isScene === !0 ? scene.background : null;
              return background && background.isTexture && (background = (scene.backgroundBlurriness > 0 ? cubeuvmaps : cubemaps).get(background)), background;
            }
            function render(scene) {
              let forceClear = !1, background = getBackground(scene);
              background === null ? setClear(clearColor, clearAlpha) : background && background.isColor && (setClear(background, 1), forceClear = !0);
              let environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
              environmentBlendMode === "additive" ? state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha) : environmentBlendMode === "alpha-blend" && state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha), (renderer.autoClear || forceClear) && renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
            }
            function addToRenderList(renderList, scene) {
              let background = getBackground(scene);
              background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping) ? (boxMesh === void 0 && (boxMesh = new Mesh(new BoxGeometry(1e4, 1e4, 1e4), new ShaderMaterial({ name: "BackgroundCubeMaterial", uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms), vertexShader: ShaderLib.backgroundCube.vertexShader, fragmentShader: ShaderLib.backgroundCube.fragmentShader, side: BackSide, depthTest: !1, depthWrite: !1, fog: !1 })), boxMesh.geometry.deleteAttribute("normal"), boxMesh.geometry.deleteAttribute("uv"), boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
                this.matrixWorld.copyPosition(camera.matrixWorld);
              }, Object.defineProperty(boxMesh.material, "envMap", { get: function() {
                return this.uniforms.envMap.value;
              } }), objects.update(boxMesh)), _e1$1.copy(scene.backgroundRotation), _e1$1.x *= -1, _e1$1.y *= -1, _e1$1.z *= -1, background.isCubeTexture && background.isRenderTargetTexture === !1 && (_e1$1.y *= -1, _e1$1.z *= -1), boxMesh.material.uniforms.envMap.value = background, boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === !1 ? -1 : 1, boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness, boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity, boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)), boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer, (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) && (boxMesh.material.needsUpdate = !0, currentBackground = background, currentBackgroundVersion = background.version, currentTonemapping = renderer.toneMapping), boxMesh.layers.enableAll(), renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null)) : background && background.isTexture && (planeMesh === void 0 && (planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({ name: "BackgroundMaterial", uniforms: cloneUniforms(ShaderLib.background.uniforms), vertexShader: ShaderLib.background.vertexShader, fragmentShader: ShaderLib.background.fragmentShader, side: FrontSide, depthTest: !1, depthWrite: !1, fog: !1 })), planeMesh.geometry.deleteAttribute("normal"), Object.defineProperty(planeMesh.material, "map", { get: function() {
                return this.uniforms.t2D.value;
              } }), objects.update(planeMesh)), planeMesh.material.uniforms.t2D.value = background, planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity, planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer, background.matrixAutoUpdate === !0 && background.updateMatrix(), planeMesh.material.uniforms.uvTransform.value.copy(background.matrix), (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) && (planeMesh.material.needsUpdate = !0, currentBackground = background, currentBackgroundVersion = background.version, currentTonemapping = renderer.toneMapping), planeMesh.layers.enableAll(), renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null));
            }
            function setClear(color, alpha2) {
              color.getRGB(_rgb, getUnlitUniformColorSpace(renderer)), state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
            }
            return { getClearColor: function() {
              return clearColor;
            }, setClearColor: function(color, alpha2 = 1) {
              clearColor.set(color), clearAlpha = alpha2, setClear(clearColor, clearAlpha);
            }, getClearAlpha: function() {
              return clearAlpha;
            }, setClearAlpha: function(alpha2) {
              clearAlpha = alpha2, setClear(clearColor, clearAlpha);
            }, render, addToRenderList };
          }
          function WebGLBindingStates(gl, attributes) {
            let maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), bindingStates = {}, defaultState = createBindingState(null), currentState = defaultState, forceUpdate = !1;
            function setup(object, material, program, geometry, index) {
              let updateBuffers = !1, state = getBindingState(geometry, program, material);
              currentState !== state && (currentState = state, bindVertexArrayObject(currentState.object)), updateBuffers = needsUpdate(object, geometry, program, index), updateBuffers && saveCache(object, geometry, program, index), index !== null && attributes.update(index, gl.ELEMENT_ARRAY_BUFFER), (updateBuffers || forceUpdate) && (forceUpdate = !1, setupVertexAttributes(object, material, program, geometry), index !== null && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer));
            }
            function createVertexArrayObject() {
              return gl.createVertexArray();
            }
            function bindVertexArrayObject(vao) {
              return gl.bindVertexArray(vao);
            }
            function deleteVertexArrayObject(vao) {
              return gl.deleteVertexArray(vao);
            }
            function getBindingState(geometry, program, material) {
              let wireframe = material.wireframe === !0, programMap = bindingStates[geometry.id];
              programMap === void 0 && (programMap = {}, bindingStates[geometry.id] = programMap);
              let stateMap = programMap[program.id];
              stateMap === void 0 && (stateMap = {}, programMap[program.id] = stateMap);
              let state = stateMap[wireframe];
              return state === void 0 && (state = createBindingState(createVertexArrayObject()), stateMap[wireframe] = state), state;
            }
            function createBindingState(vao) {
              let newAttributes = [], enabledAttributes = [], attributeDivisors = [];
              for (let i = 0; i < maxVertexAttributes; i++)
                newAttributes[i] = 0, enabledAttributes[i] = 0, attributeDivisors[i] = 0;
              return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes,
                enabledAttributes,
                attributeDivisors,
                object: vao,
                attributes: {},
                index: null
              };
            }
            function needsUpdate(object, geometry, program, index) {
              let cachedAttributes = currentState.attributes, geometryAttributes = geometry.attributes, attributesNum = 0, programAttributes = program.getAttributes();
              for (let name in programAttributes)
                if (programAttributes[name].location >= 0) {
                  let cachedAttribute = cachedAttributes[name], geometryAttribute = geometryAttributes[name];
                  if (geometryAttribute === void 0 && (name === "instanceMatrix" && object.instanceMatrix && (geometryAttribute = object.instanceMatrix), name === "instanceColor" && object.instanceColor && (geometryAttribute = object.instanceColor)), cachedAttribute === void 0 || cachedAttribute.attribute !== geometryAttribute || geometryAttribute && cachedAttribute.data !== geometryAttribute.data)
                    return !0;
                  attributesNum++;
                }
              return currentState.attributesNum !== attributesNum || currentState.index !== index;
            }
            function saveCache(object, geometry, program, index) {
              let cache = {}, attributes2 = geometry.attributes, attributesNum = 0, programAttributes = program.getAttributes();
              for (let name in programAttributes)
                if (programAttributes[name].location >= 0) {
                  let attribute = attributes2[name];
                  attribute === void 0 && (name === "instanceMatrix" && object.instanceMatrix && (attribute = object.instanceMatrix), name === "instanceColor" && object.instanceColor && (attribute = object.instanceColor));
                  let data = {};
                  data.attribute = attribute, attribute && attribute.data && (data.data = attribute.data), cache[name] = data, attributesNum++;
                }
              currentState.attributes = cache, currentState.attributesNum = attributesNum, currentState.index = index;
            }
            function initAttributes() {
              let newAttributes = currentState.newAttributes;
              for (let i = 0, il = newAttributes.length; i < il; i++)
                newAttributes[i] = 0;
            }
            function enableAttribute(attribute) {
              enableAttributeAndDivisor(attribute, 0);
            }
            function enableAttributeAndDivisor(attribute, meshPerAttribute) {
              let newAttributes = currentState.newAttributes, enabledAttributes = currentState.enabledAttributes, attributeDivisors = currentState.attributeDivisors;
              newAttributes[attribute] = 1, enabledAttributes[attribute] === 0 && (gl.enableVertexAttribArray(attribute), enabledAttributes[attribute] = 1), attributeDivisors[attribute] !== meshPerAttribute && (gl.vertexAttribDivisor(attribute, meshPerAttribute), attributeDivisors[attribute] = meshPerAttribute);
            }
            function disableUnusedAttributes() {
              let newAttributes = currentState.newAttributes, enabledAttributes = currentState.enabledAttributes;
              for (let i = 0, il = enabledAttributes.length; i < il; i++)
                enabledAttributes[i] !== newAttributes[i] && (gl.disableVertexAttribArray(i), enabledAttributes[i] = 0);
            }
            function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
              integer === !0 ? gl.vertexAttribIPointer(index, size, type, stride, offset) : gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
            }
            function setupVertexAttributes(object, material, program, geometry) {
              initAttributes();
              let geometryAttributes = geometry.attributes, programAttributes = program.getAttributes(), materialDefaultAttributeValues = material.defaultAttributeValues;
              for (let name in programAttributes) {
                let programAttribute = programAttributes[name];
                if (programAttribute.location >= 0) {
                  let geometryAttribute = geometryAttributes[name];
                  if (geometryAttribute === void 0 && (name === "instanceMatrix" && object.instanceMatrix && (geometryAttribute = object.instanceMatrix), name === "instanceColor" && object.instanceColor && (geometryAttribute = object.instanceColor)), geometryAttribute !== void 0) {
                    let normalized = geometryAttribute.normalized, size = geometryAttribute.itemSize, attribute = attributes.get(geometryAttribute);
                    if (attribute === void 0)
                      continue;
                    let buffer = attribute.buffer, type = attribute.type, bytesPerElement = attribute.bytesPerElement, integer = type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                      let data = geometryAttribute.data, stride = data.stride, offset = geometryAttribute.offset;
                      if (data.isInstancedInterleavedBuffer) {
                        for (let i = 0; i < programAttribute.locationSize; i++)
                          enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
                        object.isInstancedMesh !== !0 && geometry._maxInstanceCount === void 0 && (geometry._maxInstanceCount = data.meshPerAttribute * data.count);
                      } else
                        for (let i = 0; i < programAttribute.locationSize; i++)
                          enableAttribute(programAttribute.location + i);
                      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                      for (let i = 0; i < programAttribute.locationSize; i++)
                        vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i) * bytesPerElement, integer);
                    } else {
                      if (geometryAttribute.isInstancedBufferAttribute) {
                        for (let i = 0; i < programAttribute.locationSize; i++)
                          enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
                        object.isInstancedMesh !== !0 && geometry._maxInstanceCount === void 0 && (geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count);
                      } else
                        for (let i = 0; i < programAttribute.locationSize; i++)
                          enableAttribute(programAttribute.location + i);
                      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                      for (let i = 0; i < programAttribute.locationSize; i++)
                        vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i * bytesPerElement, integer);
                    }
                  } else if (materialDefaultAttributeValues !== void 0) {
                    let value = materialDefaultAttributeValues[name];
                    if (value !== void 0)
                      switch (value.length) {
                        case 2:
                          gl.vertexAttrib2fv(programAttribute.location, value);
                          break;
                        case 3:
                          gl.vertexAttrib3fv(programAttribute.location, value);
                          break;
                        case 4:
                          gl.vertexAttrib4fv(programAttribute.location, value);
                          break;
                        default:
                          gl.vertexAttrib1fv(programAttribute.location, value);
                      }
                  }
                }
              }
              disableUnusedAttributes();
            }
            function dispose() {
              reset();
              for (let geometryId in bindingStates) {
                let programMap = bindingStates[geometryId];
                for (let programId in programMap) {
                  let stateMap = programMap[programId];
                  for (let wireframe in stateMap)
                    deleteVertexArrayObject(stateMap[wireframe].object), delete stateMap[wireframe];
                  delete programMap[programId];
                }
                delete bindingStates[geometryId];
              }
            }
            function releaseStatesOfGeometry(geometry) {
              if (bindingStates[geometry.id] === void 0)
                return;
              let programMap = bindingStates[geometry.id];
              for (let programId in programMap) {
                let stateMap = programMap[programId];
                for (let wireframe in stateMap)
                  deleteVertexArrayObject(stateMap[wireframe].object), delete stateMap[wireframe];
                delete programMap[programId];
              }
              delete bindingStates[geometry.id];
            }
            function releaseStatesOfProgram(program) {
              for (let geometryId in bindingStates) {
                let programMap = bindingStates[geometryId];
                if (programMap[program.id] === void 0)
                  continue;
                let stateMap = programMap[program.id];
                for (let wireframe in stateMap)
                  deleteVertexArrayObject(stateMap[wireframe].object), delete stateMap[wireframe];
                delete programMap[program.id];
              }
            }
            function reset() {
              resetDefaultState(), forceUpdate = !0, currentState !== defaultState && (currentState = defaultState, bindVertexArrayObject(currentState.object));
            }
            function resetDefaultState() {
              defaultState.geometry = null, defaultState.program = null, defaultState.wireframe = !1;
            }
            return { setup, reset, resetDefaultState, dispose, releaseStatesOfGeometry, releaseStatesOfProgram, initAttributes, enableAttribute, disableUnusedAttributes };
          }
          function WebGLBufferRenderer(gl, extensions, info) {
            let mode;
            function setMode(value) {
              mode = value;
            }
            function render(start, count) {
              gl.drawArrays(mode, start, count), info.update(count, mode, 1);
            }
            function renderInstances(start, count, primcount) {
              primcount !== 0 && (gl.drawArraysInstanced(mode, start, count, primcount), info.update(count, mode, primcount));
            }
            function renderMultiDraw(starts, counts, drawCount) {
              if (drawCount === 0)
                return;
              let extension = extensions.get("WEBGL_multi_draw");
              if (extension === null)
                for (let i = 0; i < drawCount; i++)
                  this.render(starts[i], counts[i]);
              else {
                extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
                let elementCount = 0;
                for (let i = 0; i < drawCount; i++)
                  elementCount += counts[i];
                info.update(elementCount, mode, 1);
              }
            }
            function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
              if (drawCount === 0)
                return;
              let extension = extensions.get("WEBGL_multi_draw");
              if (extension === null)
                for (let i = 0; i < starts.length; i++)
                  renderInstances(starts[i], counts[i], primcount[i]);
              else {
                extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
                let elementCount = 0;
                for (let i = 0; i < drawCount; i++)
                  elementCount += counts[i];
                for (let i = 0; i < primcount.length; i++)
                  info.update(elementCount, mode, primcount[i]);
              }
            }
            this.setMode = setMode, this.render = render, this.renderInstances = renderInstances, this.renderMultiDraw = renderMultiDraw, this.renderMultiDrawInstances = renderMultiDrawInstances;
          }
          function WebGLCapabilities(gl, extensions, parameters, utils) {
            let maxAnisotropy;
            function getMaxAnisotropy() {
              if (maxAnisotropy !== void 0)
                return maxAnisotropy;
              if (extensions.has("EXT_texture_filter_anisotropic") === !0) {
                let extension = extensions.get("EXT_texture_filter_anisotropic");
                maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
              } else
                maxAnisotropy = 0;
              return maxAnisotropy;
            }
            function textureFormatReadable(textureFormat) {
              return !(textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT));
            }
            function textureTypeReadable(textureType) {
              let halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float"));
              return !(textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && textureType !== FloatType && !halfFloatSupportedByExt);
            }
            function getMaxPrecision(precision2) {
              if (precision2 === "highp") {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0)
                  return "highp";
                precision2 = "mediump";
              }
              return precision2 === "mediump" && gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
            }
            let precision = parameters.precision !== void 0 ? parameters.precision : "highp", maxPrecision = getMaxPrecision(precision);
            maxPrecision !== precision && (console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead."), precision = maxPrecision);
            let logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === !0, maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE), maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE), maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS), maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS), maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS), vertexTextures = maxVertexTextures > 0, maxSamples = gl.getParameter(gl.MAX_SAMPLES);
            return {
              isWebGL2: !0,
              getMaxAnisotropy,
              getMaxPrecision,
              textureFormatReadable,
              textureTypeReadable,
              precision,
              logarithmicDepthBuffer,
              maxTextures,
              maxVertexTextures,
              maxTextureSize,
              maxCubemapSize,
              maxAttributes,
              maxVertexUniforms,
              maxVaryings,
              maxFragmentUniforms,
              vertexTextures,
              maxSamples
            };
          }
          function WebGLClipping(properties) {
            let scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = !1, renderingShadows = !1, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: !1 };
            this.uniform = uniform, this.numPlanes = 0, this.numIntersection = 0, this.init = function(planes, enableLocalClipping) {
              let enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
              return localClippingEnabled = enableLocalClipping, numGlobalPlanes = planes.length, enabled;
            }, this.beginShadows = function() {
              renderingShadows = !0, projectPlanes(null);
            }, this.endShadows = function() {
              renderingShadows = !1;
            }, this.setGlobalState = function(planes, camera) {
              globalState = projectPlanes(planes, camera, 0);
            }, this.setState = function(material, camera, useCache) {
              let planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows, materialProperties = properties.get(material);
              if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows)
                renderingShadows ? projectPlanes(null) : resetGlobalState();
              else {
                let nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = materialProperties.clippingState || null;
                uniform.value = dstArray, dstArray = projectPlanes(planes, camera, lGlobal, useCache);
                for (let i = 0; i !== lGlobal; ++i)
                  dstArray[i] = globalState[i];
                materialProperties.clippingState = dstArray, this.numIntersection = clipIntersection ? this.numPlanes : 0, this.numPlanes += nGlobal;
              }
            };
            function resetGlobalState() {
              uniform.value !== globalState && (uniform.value = globalState, uniform.needsUpdate = numGlobalPlanes > 0), scope.numPlanes = numGlobalPlanes, scope.numIntersection = 0;
            }
            function projectPlanes(planes, camera, dstOffset, skipTransform) {
              let nPlanes = planes !== null ? planes.length : 0, dstArray = null;
              if (nPlanes !== 0) {
                if (dstArray = uniform.value, skipTransform !== !0 || dstArray === null) {
                  let flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                  viewNormalMatrix.getNormalMatrix(viewMatrix), (dstArray === null || dstArray.length < flatSize) && (dstArray = new Float32Array(flatSize));
                  for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4)
                    plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix), plane.normal.toArray(dstArray, i4), dstArray[i4 + 3] = plane.constant;
                }
                uniform.value = dstArray, uniform.needsUpdate = !0;
              }
              return scope.numPlanes = nPlanes, scope.numIntersection = 0, dstArray;
            }
          }
          function WebGLCubeMaps(renderer) {
            let cubemaps = new WeakMap();
            function mapTextureMapping(texture, mapping) {
              return mapping === EquirectangularReflectionMapping ? texture.mapping = CubeReflectionMapping : mapping === EquirectangularRefractionMapping && (texture.mapping = CubeRefractionMapping), texture;
            }
            function get(texture) {
              if (texture && texture.isTexture) {
                let mapping = texture.mapping;
                if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping)
                  if (cubemaps.has(texture)) {
                    let cubemap = cubemaps.get(texture).texture;
                    return mapTextureMapping(cubemap, texture.mapping);
                  } else {
                    let image = texture.image;
                    if (image && image.height > 0) {
                      let renderTarget = new WebGLCubeRenderTarget(image.height);
                      return renderTarget.fromEquirectangularTexture(renderer, texture), cubemaps.set(texture, renderTarget), texture.addEventListener("dispose", onTextureDispose), mapTextureMapping(renderTarget.texture, texture.mapping);
                    } else
                      return null;
                  }
              }
              return texture;
            }
            function onTextureDispose(event) {
              let texture = event.target;
              texture.removeEventListener("dispose", onTextureDispose);
              let cubemap = cubemaps.get(texture);
              cubemap !== void 0 && (cubemaps.delete(texture), cubemap.dispose());
            }
            function dispose() {
              cubemaps = new WeakMap();
            }
            return { get, dispose };
          }
          class OrthographicCamera extends Camera {
            constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
              super();
              this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = left, this.right = right, this.top = top, this.bottom = bottom, this.near = near, this.far = far, this.updateProjectionMatrix();
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.left = source.left, this.right = source.right, this.top = source.top, this.bottom = source.bottom, this.near = source.near, this.far = source.far, this.zoom = source.zoom, this.view = source.view === null ? null : Object.assign({}, source.view), this;
            }
            setViewOffset(fullWidth, fullHeight, x, y, width, height) {
              this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = fullWidth, this.view.fullHeight = fullHeight, this.view.offsetX = x, this.view.offsetY = y, this.view.width = width, this.view.height = height, this.updateProjectionMatrix();
            }
            clearViewOffset() {
              this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
            }
            updateProjectionMatrix() {
              let dx = (this.right - this.left) / (2 * this.zoom), dy = (this.top - this.bottom) / (2 * this.zoom), cx = (this.right + this.left) / 2, cy = (this.top + this.bottom) / 2, left = cx - dx, right = cx + dx, top = cy + dy, bottom = cy - dy;
              if (this.view !== null && this.view.enabled) {
                let scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom, scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                left += scaleW * this.view.offsetX, right = left + scaleW * this.view.width, top -= scaleH * this.view.offsetY, bottom = top - scaleH * this.view.height;
              }
              this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
            }
            toJSON(meta) {
              let data = super.toJSON(meta);
              return data.object.zoom = this.zoom, data.object.left = this.left, data.object.right = this.right, data.object.top = this.top, data.object.bottom = this.bottom, data.object.near = this.near, data.object.far = this.far, this.view !== null && (data.object.view = Object.assign({}, this.view)), data;
            }
          }
          let LOD_MIN = 4, EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], MAX_SAMPLES = 20, _flatCamera = /* @__PURE__ */ new OrthographicCamera(), _clearColor = /* @__PURE__ */ new Color(), _oldTarget = null, _oldActiveCubeFace = 0, _oldActiveMipmapLevel = 0, _oldXrEnabled = !1, PHI = (1 + Math.sqrt(5)) / 2, INV_PHI = 1 / PHI, _axisDirections = [/* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0), /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0), /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI), /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI), /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI), /* @__PURE__ */ new Vector3(0, PHI, INV_PHI), /* @__PURE__ */ new Vector3(-1, 1, -1), /* @__PURE__ */ new Vector3(1, 1, -1), /* @__PURE__ */ new Vector3(-1, 1, 1), /* @__PURE__ */ new Vector3(1, 1, 1)];
          class PMREMGenerator {
            constructor(renderer) {
              this._renderer = renderer, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
            }
            fromScene(scene, sigma = 0, near = 0.1, far = 100) {
              _oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(), _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), _oldXrEnabled = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
              let cubeUVRenderTarget = this._allocateTargets();
              return cubeUVRenderTarget.depthBuffer = !0, this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget), sigma > 0 && this._blur(cubeUVRenderTarget, 0, 0, sigma), this._applyPMREM(cubeUVRenderTarget), this._cleanup(cubeUVRenderTarget), cubeUVRenderTarget;
            }
            fromEquirectangular(equirectangular, renderTarget = null) {
              return this._fromTexture(equirectangular, renderTarget);
            }
            fromCubemap(cubemap, renderTarget = null) {
              return this._fromTexture(cubemap, renderTarget);
            }
            compileCubemapShader() {
              this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial(), this._compileMaterial(this._cubemapMaterial));
            }
            compileEquirectangularShader() {
              this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial(), this._compileMaterial(this._equirectMaterial));
            }
            dispose() {
              this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
            }
            _setSize(cubeSize) {
              this._lodMax = Math.floor(Math.log2(cubeSize)), this._cubeSize = Math.pow(2, this._lodMax);
            }
            _dispose() {
              this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
              for (let i = 0; i < this._lodPlanes.length; i++)
                this._lodPlanes[i].dispose();
            }
            _cleanup(outputTarget) {
              this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel), this._renderer.xr.enabled = _oldXrEnabled, outputTarget.scissorTest = !1, _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
            }
            _fromTexture(texture, renderTarget) {
              texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ? this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width) : this._setSize(texture.image.width / 4), _oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(), _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), _oldXrEnabled = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
              let cubeUVRenderTarget = renderTarget || this._allocateTargets();
              return this._textureToCubeUV(texture, cubeUVRenderTarget), this._applyPMREM(cubeUVRenderTarget), this._cleanup(cubeUVRenderTarget), cubeUVRenderTarget;
            }
            _allocateTargets() {
              let width = 3 * Math.max(this._cubeSize, 16 * 7), height = 4 * this._cubeSize, params = { magFilter: LinearFilter, minFilter: LinearFilter, generateMipmaps: !1, type: HalfFloatType, format: RGBAFormat, colorSpace: LinearSRGBColorSpace, depthBuffer: !1 }, cubeUVRenderTarget = _createRenderTarget(width, height, params);
              if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
                this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = _createRenderTarget(width, height, params);
                let { _lodMax } = this;
                ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax)), this._blurMaterial = _getBlurShader(_lodMax, width, height);
              }
              return cubeUVRenderTarget;
            }
            _compileMaterial(material) {
              let tmpMesh = new Mesh(this._lodPlanes[0], material);
              this._renderer.compile(tmpMesh, _flatCamera);
            }
            _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
              let fov2 = 90, aspect2 = 1, cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far), upSign = [1, -1, 1, 1, 1, 1], forwardSign = [1, 1, 1, -1, -1, -1], renderer = this._renderer, originalAutoClear = renderer.autoClear, toneMapping = renderer.toneMapping;
              renderer.getClearColor(_clearColor), renderer.toneMapping = NoToneMapping, renderer.autoClear = !1;
              let backgroundMaterial = new MeshBasicMaterial({ name: "PMREM.Background", side: BackSide, depthWrite: !1, depthTest: !1 }), backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial), useSolidColor = !1, background = scene.background;
              background ? background.isColor && (backgroundMaterial.color.copy(background), scene.background = null, useSolidColor = !0) : (backgroundMaterial.color.copy(_clearColor), useSolidColor = !0);
              for (let i = 0; i < 6; i++) {
                let col = i % 3;
                col === 0 ? (cubeCamera.up.set(0, upSign[i], 0), cubeCamera.lookAt(forwardSign[i], 0, 0)) : col === 1 ? (cubeCamera.up.set(0, 0, upSign[i]), cubeCamera.lookAt(0, forwardSign[i], 0)) : (cubeCamera.up.set(0, upSign[i], 0), cubeCamera.lookAt(0, 0, forwardSign[i]));
                let size = this._cubeSize;
                _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size), renderer.setRenderTarget(cubeUVRenderTarget), useSolidColor && renderer.render(backgroundBox, cubeCamera), renderer.render(scene, cubeCamera);
              }
              backgroundBox.geometry.dispose(), backgroundBox.material.dispose(), renderer.toneMapping = toneMapping, renderer.autoClear = originalAutoClear, scene.background = background;
            }
            _textureToCubeUV(texture, cubeUVRenderTarget) {
              let renderer = this._renderer, isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
              isCubeTexture ? (this._cubemapMaterial === null && (this._cubemapMaterial = _getCubemapMaterial()), this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = _getEquirectMaterial());
              let material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial, mesh = new Mesh(this._lodPlanes[0], material), uniforms = material.uniforms;
              uniforms.envMap.value = texture;
              let size = this._cubeSize;
              _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size), renderer.setRenderTarget(cubeUVRenderTarget), renderer.render(mesh, _flatCamera);
            }
            _applyPMREM(cubeUVRenderTarget) {
              let renderer = this._renderer, autoClear = renderer.autoClear;
              renderer.autoClear = !1;
              let n = this._lodPlanes.length;
              for (let i = 1; i < n; i++) {
                let sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
                this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
              }
              renderer.autoClear = autoClear;
            }
            _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
              let pingPongRenderTarget = this._pingPongRenderTarget;
              this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis), this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
            }
            _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
              let renderer = this._renderer, blurMaterial = this._blurMaterial;
              direction !== "latitudinal" && direction !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
              let STANDARD_DEVIATIONS = 3, blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial), blurUniforms = blurMaterial.uniforms, pixels = this._sizeLods[lodIn] - 1, radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1), sigmaPixels = sigmaRadians / radiansPerPixel, samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
              samples > MAX_SAMPLES && console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
              let weights = [], sum = 0;
              for (let i = 0; i < MAX_SAMPLES; ++i) {
                let x2 = i / sigmaPixels, weight = Math.exp(-x2 * x2 / 2);
                weights.push(weight), i === 0 ? sum += weight : i < samples && (sum += 2 * weight);
              }
              for (let i = 0; i < weights.length; i++)
                weights[i] = weights[i] / sum;
              blurUniforms.envMap.value = targetIn.texture, blurUniforms.samples.value = samples, blurUniforms.weights.value = weights, blurUniforms.latitudinal.value = direction === "latitudinal", poleAxis && (blurUniforms.poleAxis.value = poleAxis);
              let { _lodMax } = this;
              blurUniforms.dTheta.value = radiansPerPixel, blurUniforms.mipInt.value = _lodMax - lodIn;
              let outputSize = this._sizeLods[lodOut], x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0), y = 4 * (this._cubeSize - outputSize);
              _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize), renderer.setRenderTarget(targetOut), renderer.render(blurMesh, _flatCamera);
            }
          }
          function _createPlanes(lodMax) {
            let lodPlanes = [], sizeLods = [], sigmas = [], lod = lodMax, totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
            for (let i = 0; i < totalLods; i++) {
              let sizeLod = Math.pow(2, lod);
              sizeLods.push(sizeLod);
              let sigma = 1 / sizeLod;
              i > lodMax - LOD_MIN ? sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1] : i === 0 && (sigma = 0), sigmas.push(sigma);
              let texelSize = 1 / (sizeLod - 2), min = -texelSize, max = 1 + texelSize, uv1 = [min, min, max, min, max, max, min, min, max, max, min, max], cubeFaces = 6, vertices = 6, positionSize = 3, uvSize = 2, faceIndexSize = 1, position = new Float32Array(positionSize * vertices * cubeFaces), uv = new Float32Array(uvSize * vertices * cubeFaces), faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
              for (let face = 0; face < cubeFaces; face++) {
                let x = face % 3 * 2 / 3 - 1, y = face > 2 ? 0 : -1, coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
                position.set(coordinates, positionSize * vertices * face), uv.set(uv1, uvSize * vertices * face);
                let fill = [face, face, face, face, face, face];
                faceIndex.set(fill, faceIndexSize * vertices * face);
              }
              let planes = new BufferGeometry();
              planes.setAttribute("position", new BufferAttribute(position, positionSize)), planes.setAttribute("uv", new BufferAttribute(uv, uvSize)), planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize)), lodPlanes.push(planes), lod > LOD_MIN && lod--;
            }
            return { lodPlanes, sizeLods, sigmas };
          }
          function _createRenderTarget(width, height, params) {
            let cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
            return cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping, cubeUVRenderTarget.texture.name = "PMREM.cubeUv", cubeUVRenderTarget.scissorTest = !0, cubeUVRenderTarget;
          }
          function _setViewport(target, x, y, width, height) {
            target.viewport.set(x, y, width, height), target.scissor.set(x, y, width, height);
          }
          function _getBlurShader(lodMax, width, height) {
            let weights = new Float32Array(MAX_SAMPLES), poleAxis = new Vector3(0, 1, 0);
            return new ShaderMaterial({ name: "SphericalGaussianBlur", defines: { n: MAX_SAMPLES, CUBEUV_TEXEL_WIDTH: 1 / width, CUBEUV_TEXEL_HEIGHT: 1 / height, CUBEUV_MAX_MIP: `${lodMax}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: weights }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: poleAxis } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: NoBlending, depthTest: !1, depthWrite: !1 });
          }
          function _getEquirectMaterial() {
            return new ShaderMaterial({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: NoBlending, depthTest: !1, depthWrite: !1 });
          }
          function _getCubemapMaterial() {
            return new ShaderMaterial({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: _getCommonVertexShader(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: NoBlending, depthTest: !1, depthWrite: !1 });
          }
          function _getCommonVertexShader() {
            return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
          }
          function WebGLCubeUVMaps(renderer) {
            let cubeUVmaps = new WeakMap(), pmremGenerator = null;
            function get(texture) {
              if (texture && texture.isTexture) {
                let mapping = texture.mapping, isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping, isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
                if (isEquirectMap || isCubeMap) {
                  let renderTarget = cubeUVmaps.get(texture), currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;
                  if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion)
                    return pmremGenerator === null && (pmremGenerator = new PMREMGenerator(renderer)), renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget), renderTarget.texture.pmremVersion = texture.pmremVersion, cubeUVmaps.set(texture, renderTarget), renderTarget.texture;
                  if (renderTarget !== void 0)
                    return renderTarget.texture;
                  {
                    let image = texture.image;
                    return isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image) ? (pmremGenerator === null && (pmremGenerator = new PMREMGenerator(renderer)), renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture), renderTarget.texture.pmremVersion = texture.pmremVersion, cubeUVmaps.set(texture, renderTarget), texture.addEventListener("dispose", onTextureDispose), renderTarget.texture) : null;
                  }
                }
              }
              return texture;
            }
            function isCubeTextureComplete(image) {
              let count = 0, length = 6;
              for (let i = 0; i < length; i++)
                image[i] !== void 0 && count++;
              return count === length;
            }
            function onTextureDispose(event) {
              let texture = event.target;
              texture.removeEventListener("dispose", onTextureDispose);
              let cubemapUV = cubeUVmaps.get(texture);
              cubemapUV !== void 0 && (cubeUVmaps.delete(texture), cubemapUV.dispose());
            }
            function dispose() {
              cubeUVmaps = new WeakMap(), pmremGenerator !== null && (pmremGenerator.dispose(), pmremGenerator = null);
            }
            return { get, dispose };
          }
          function WebGLExtensions(gl) {
            let extensions = {};
            function getExtension(name) {
              if (extensions[name] !== void 0)
                return extensions[name];
              let extension;
              switch (name) {
                case "WEBGL_depth_texture":
                  extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                  break;
                case "EXT_texture_filter_anisotropic":
                  extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                  break;
                case "WEBGL_compressed_texture_s3tc":
                  extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                  break;
                case "WEBGL_compressed_texture_pvrtc":
                  extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                  break;
                default:
                  extension = gl.getExtension(name);
              }
              return extensions[name] = extension, extension;
            }
            return { has: function(name) {
              return getExtension(name) !== null;
            }, init: function() {
              getExtension("EXT_color_buffer_float"), getExtension("WEBGL_clip_cull_distance"), getExtension("OES_texture_float_linear"), getExtension("EXT_color_buffer_half_float"), getExtension("WEBGL_multisampled_render_to_texture"), getExtension("WEBGL_render_shared_exponent");
            }, get: function(name) {
              let extension = getExtension(name);
              return extension === null && console.warn("THREE.WebGLRenderer: " + name + " extension not supported."), extension;
            } };
          }
          function WebGLGeometries(gl, attributes, info, bindingStates) {
            let geometries = {}, wireframeAttributes = new WeakMap();
            function onGeometryDispose(event) {
              let geometry = event.target;
              geometry.index !== null && attributes.remove(geometry.index);
              for (let name in geometry.attributes)
                attributes.remove(geometry.attributes[name]);
              for (let name in geometry.morphAttributes) {
                let array = geometry.morphAttributes[name];
                for (let i = 0, l = array.length; i < l; i++)
                  attributes.remove(array[i]);
              }
              geometry.removeEventListener("dispose", onGeometryDispose), delete geometries[geometry.id];
              let attribute = wireframeAttributes.get(geometry);
              attribute && (attributes.remove(attribute), wireframeAttributes.delete(geometry)), bindingStates.releaseStatesOfGeometry(geometry), geometry.isInstancedBufferGeometry === !0 && delete geometry._maxInstanceCount, info.memory.geometries--;
            }
            function get(object, geometry) {
              return geometries[geometry.id] === !0 || (geometry.addEventListener("dispose", onGeometryDispose), geometries[geometry.id] = !0, info.memory.geometries++), geometry;
            }
            function update(geometry) {
              let geometryAttributes = geometry.attributes;
              for (let name in geometryAttributes)
                attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
              let morphAttributes = geometry.morphAttributes;
              for (let name in morphAttributes) {
                let array = morphAttributes[name];
                for (let i = 0, l = array.length; i < l; i++)
                  attributes.update(array[i], gl.ARRAY_BUFFER);
              }
            }
            function updateWireframeAttribute(geometry) {
              let indices = [], geometryIndex = geometry.index, geometryPosition = geometry.attributes.position, version = 0;
              if (geometryIndex !== null) {
                let array = geometryIndex.array;
                version = geometryIndex.version;
                for (let i = 0, l = array.length; i < l; i += 3) {
                  let a = array[i + 0], b = array[i + 1], c = array[i + 2];
                  indices.push(a, b, b, c, c, a);
                }
              } else if (geometryPosition !== void 0) {
                let array = geometryPosition.array;
                version = geometryPosition.version;
                for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
                  let a = i + 0, b = i + 1, c = i + 2;
                  indices.push(a, b, b, c, c, a);
                }
              } else
                return;
              let attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
              attribute.version = version;
              let previousAttribute = wireframeAttributes.get(geometry);
              previousAttribute && attributes.remove(previousAttribute), wireframeAttributes.set(geometry, attribute);
            }
            function getWireframeAttribute(geometry) {
              let currentAttribute = wireframeAttributes.get(geometry);
              if (currentAttribute) {
                let geometryIndex = geometry.index;
                geometryIndex !== null && currentAttribute.version < geometryIndex.version && updateWireframeAttribute(geometry);
              } else
                updateWireframeAttribute(geometry);
              return wireframeAttributes.get(geometry);
            }
            return { get, update, getWireframeAttribute };
          }
          function WebGLIndexedBufferRenderer(gl, extensions, info) {
            let mode;
            function setMode(value) {
              mode = value;
            }
            let type, bytesPerElement;
            function setIndex(value) {
              type = value.type, bytesPerElement = value.bytesPerElement;
            }
            function render(start, count) {
              gl.drawElements(mode, count, type, start * bytesPerElement), info.update(count, mode, 1);
            }
            function renderInstances(start, count, primcount) {
              primcount !== 0 && (gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount), info.update(count, mode, primcount));
            }
            function renderMultiDraw(starts, counts, drawCount) {
              if (drawCount === 0)
                return;
              let extension = extensions.get("WEBGL_multi_draw");
              if (extension === null)
                for (let i = 0; i < drawCount; i++)
                  this.render(starts[i] / bytesPerElement, counts[i]);
              else {
                extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
                let elementCount = 0;
                for (let i = 0; i < drawCount; i++)
                  elementCount += counts[i];
                info.update(elementCount, mode, 1);
              }
            }
            function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
              if (drawCount === 0)
                return;
              let extension = extensions.get("WEBGL_multi_draw");
              if (extension === null)
                for (let i = 0; i < starts.length; i++)
                  renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i]);
              else {
                extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
                let elementCount = 0;
                for (let i = 0; i < drawCount; i++)
                  elementCount += counts[i];
                for (let i = 0; i < primcount.length; i++)
                  info.update(elementCount, mode, primcount[i]);
              }
            }
            this.setMode = setMode, this.setIndex = setIndex, this.render = render, this.renderInstances = renderInstances, this.renderMultiDraw = renderMultiDraw, this.renderMultiDrawInstances = renderMultiDrawInstances;
          }
          function WebGLInfo(gl) {
            let memory = { geometries: 0, textures: 0 }, render = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
            function update(count, mode, instanceCount) {
              switch (render.calls++, mode) {
                case gl.TRIANGLES:
                  render.triangles += instanceCount * (count / 3);
                  break;
                case gl.LINES:
                  render.lines += instanceCount * (count / 2);
                  break;
                case gl.LINE_STRIP:
                  render.lines += instanceCount * (count - 1);
                  break;
                case gl.LINE_LOOP:
                  render.lines += instanceCount * count;
                  break;
                case gl.POINTS:
                  render.points += instanceCount * count;
                  break;
                default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
                  break;
              }
            }
            function reset() {
              render.calls = 0, render.triangles = 0, render.points = 0, render.lines = 0;
            }
            return { memory, render, programs: null, autoReset: !0, reset, update };
          }
          function WebGLMorphtargets(gl, capabilities, textures) {
            let morphTextures = new WeakMap(), morph = new Vector4();
            function update(object, geometry, program) {
              let objectInfluences = object.morphTargetInfluences, morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color, morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0, entry = morphTextures.get(geometry);
              if (entry === void 0 || entry.count !== morphTargetsCount) {
                let disposeTexture = function() {
                  texture.dispose(), morphTextures.delete(geometry), geometry.removeEventListener("dispose", disposeTexture);
                };
                entry !== void 0 && entry.texture.dispose();
                let hasMorphPosition = geometry.morphAttributes.position !== void 0, hasMorphNormals = geometry.morphAttributes.normal !== void 0, hasMorphColors = geometry.morphAttributes.color !== void 0, morphTargets = geometry.morphAttributes.position || [], morphNormals = geometry.morphAttributes.normal || [], morphColors = geometry.morphAttributes.color || [], vertexDataCount = 0;
                hasMorphPosition === !0 && (vertexDataCount = 1), hasMorphNormals === !0 && (vertexDataCount = 2), hasMorphColors === !0 && (vertexDataCount = 3);
                let width = geometry.attributes.position.count * vertexDataCount, height = 1;
                width > capabilities.maxTextureSize && (height = Math.ceil(width / capabilities.maxTextureSize), width = capabilities.maxTextureSize);
                let buffer = new Float32Array(width * height * 4 * morphTargetsCount), texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
                texture.type = FloatType, texture.needsUpdate = !0;
                let vertexDataStride = vertexDataCount * 4;
                for (let i = 0; i < morphTargetsCount; i++) {
                  let morphTarget = morphTargets[i], morphNormal = morphNormals[i], morphColor = morphColors[i], offset = width * height * 4 * i;
                  for (let j = 0; j < morphTarget.count; j++) {
                    let stride = j * vertexDataStride;
                    hasMorphPosition === !0 && (morph.fromBufferAttribute(morphTarget, j), buffer[offset + stride + 0] = morph.x, buffer[offset + stride + 1] = morph.y, buffer[offset + stride + 2] = morph.z, buffer[offset + stride + 3] = 0), hasMorphNormals === !0 && (morph.fromBufferAttribute(morphNormal, j), buffer[offset + stride + 4] = morph.x, buffer[offset + stride + 5] = morph.y, buffer[offset + stride + 6] = morph.z, buffer[offset + stride + 7] = 0), hasMorphColors === !0 && (morph.fromBufferAttribute(morphColor, j), buffer[offset + stride + 8] = morph.x, buffer[offset + stride + 9] = morph.y, buffer[offset + stride + 10] = morph.z, buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1);
                  }
                }
                entry = { count: morphTargetsCount, texture, size: new Vector2(width, height) }, morphTextures.set(geometry, entry), geometry.addEventListener("dispose", disposeTexture);
              }
              if (object.isInstancedMesh === !0 && object.morphTexture !== null)
                program.getUniforms().setValue(gl, "morphTexture", object.morphTexture, textures);
              else {
                let morphInfluencesSum = 0;
                for (let i = 0; i < objectInfluences.length; i++)
                  morphInfluencesSum += objectInfluences[i];
                let morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
                program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence), program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
              }
              program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures), program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
            }
            return { update };
          }
          class WebGLMultiview {
            constructor(renderer, extensions, gl) {
              if (this.renderer = renderer, this.DEFAULT_NUMVIEWS = 2, this.maxNumViews = 0, this.gl = gl, this.extensions = extensions, this.available = this.extensions.has("OCULUS_multiview"), this.available) {
                let extension = this.extensions.get("OCULUS_multiview");
                this.maxNumViews = this.gl.getParameter(extension.MAX_VIEWS_OVR), this.mat4 = [], this.mat3 = [], this.cameraArray = [];
                for (var i = 0; i < this.maxNumViews; i++)
                  this.mat4[i] = new Matrix4(), this.mat3[i] = new Matrix3();
              }
            }
            getCameraArray(camera) {
              return camera.isArrayCamera ? camera.cameras : (this.cameraArray[0] = camera, this.cameraArray);
            }
            updateCameraProjectionMatricesUniform(camera, uniforms) {
              for (var cameras = this.getCameraArray(camera), i = 0; i < cameras.length; i++)
                this.mat4[i].copy(cameras[i].projectionMatrix);
              uniforms.setValue(this.gl, "projectionMatrices", this.mat4);
            }
            updateCameraViewMatricesUniform(camera, uniforms) {
              for (var cameras = this.getCameraArray(camera), i = 0; i < cameras.length; i++)
                this.mat4[i].copy(cameras[i].matrixWorldInverse);
              uniforms.setValue(this.gl, "viewMatrices", this.mat4);
            }
            updateObjectMatricesUniforms(object, camera, uniforms) {
              for (var cameras = this.getCameraArray(camera), i = 0; i < cameras.length; i++)
                this.mat4[i].multiplyMatrices(cameras[i].matrixWorldInverse, object.matrixWorld), this.mat3[i].getNormalMatrix(this.mat4[i]);
              uniforms.setValue(this.gl, "modelViewMatrices", this.mat4), uniforms.setValue(this.gl, "normalMatrices", this.mat3);
            }
          }
          function WebGLObjects(gl, geometries, attributes, info) {
            let updateMap = new WeakMap();
            function update(object) {
              let frame = info.render.frame, geometry = object.geometry, buffergeometry = geometries.get(object, geometry);
              if (updateMap.get(buffergeometry) !== frame && (geometries.update(buffergeometry), updateMap.set(buffergeometry, frame)), object.isInstancedMesh && (object.hasEventListener("dispose", onInstancedMeshDispose) === !1 && object.addEventListener("dispose", onInstancedMeshDispose), updateMap.get(object) !== frame && (attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER), object.instanceColor !== null && attributes.update(object.instanceColor, gl.ARRAY_BUFFER), updateMap.set(object, frame))), object.isSkinnedMesh) {
                let skeleton = object.skeleton;
                updateMap.get(skeleton) !== frame && (skeleton.update(), updateMap.set(skeleton, frame));
              }
              return buffergeometry;
            }
            function dispose() {
              updateMap = new WeakMap();
            }
            function onInstancedMeshDispose(event) {
              let instancedMesh = event.target;
              instancedMesh.removeEventListener("dispose", onInstancedMeshDispose), attributes.remove(instancedMesh.instanceMatrix), instancedMesh.instanceColor !== null && attributes.remove(instancedMesh.instanceColor);
            }
            return { update, dispose };
          }
          class DepthTexture extends Texture {
            constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
              if (format = format !== void 0 ? format : DepthFormat, format !== DepthFormat && format !== DepthStencilFormat)
                throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
              type === void 0 && format === DepthFormat && (type = UnsignedIntType), type === void 0 && format === DepthStencilFormat && (type = UnsignedInt248Type);
              super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
              this.isDepthTexture = !0, this.image = { width, height }, this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter, this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
            }
            copy(source) {
              return super.copy(source), this.compareFunction = source.compareFunction, this;
            }
            toJSON(meta) {
              let data = super.toJSON(meta);
              return this.compareFunction !== null && (data.compareFunction = this.compareFunction), data;
            }
          }
          let emptyTexture = /* @__PURE__ */ new Texture(), emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
          emptyShadowTexture.compareFunction = LessEqualCompare;
          let emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture(), empty3dTexture = /* @__PURE__ */ new Data3DTexture(), emptyCubeTexture = /* @__PURE__ */ new CubeTexture(), arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array(16), mat3array = new Float32Array(9), mat2array = new Float32Array(4);
          function flatten(array, nBlocks, blockSize) {
            let firstElem = array[0];
            if (firstElem <= 0 || firstElem > 0)
              return array;
            let n = nBlocks * blockSize, r = arrayCacheF32[n];
            if (r === void 0 && (r = new Float32Array(n), arrayCacheF32[n] = r), nBlocks !== 0) {
              firstElem.toArray(r, 0);
              for (let i = 1, offset = 0; i !== nBlocks; ++i)
                offset += blockSize, array[i].toArray(r, offset);
            }
            return r;
          }
          function arraysEqual(a, b) {
            if (a.length !== b.length)
              return !1;
            for (let i = 0, l = a.length; i < l; i++)
              if (a[i] !== b[i])
                return !1;
            return !0;
          }
          function copyArray(a, b) {
            for (let i = 0, l = b.length; i < l; i++)
              a[i] = b[i];
          }
          function allocTexUnits(textures, n) {
            let r = arrayCacheI32[n];
            r === void 0 && (r = new Int32Array(n), arrayCacheI32[n] = r);
            for (let i = 0; i !== n; ++i)
              r[i] = textures.allocateTextureUnit();
            return r;
          }
          function setValueV1f(gl, v) {
            let cache = this.cache;
            cache[0] !== v && (gl.uniform1f(this.addr, v), cache[0] = v);
          }
          function setValueV2f(gl, v) {
            let cache = this.cache;
            if (v.x !== void 0)
              (cache[0] !== v.x || cache[1] !== v.y) && (gl.uniform2f(this.addr, v.x, v.y), cache[0] = v.x, cache[1] = v.y);
            else {
              if (arraysEqual(cache, v))
                return;
              gl.uniform2fv(this.addr, v), copyArray(cache, v);
            }
          }
          function setValueV3f(gl, v) {
            let cache = this.cache;
            if (v.x !== void 0)
              (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) && (gl.uniform3f(this.addr, v.x, v.y, v.z), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z);
            else if (v.r !== void 0)
              (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) && (gl.uniform3f(this.addr, v.r, v.g, v.b), cache[0] = v.r, cache[1] = v.g, cache[2] = v.b);
            else {
              if (arraysEqual(cache, v))
                return;
              gl.uniform3fv(this.addr, v), copyArray(cache, v);
            }
          }
          function setValueV4f(gl, v) {
            let cache = this.cache;
            if (v.x !== void 0)
              (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) && (gl.uniform4f(this.addr, v.x, v.y, v.z, v.w), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z, cache[3] = v.w);
            else {
              if (arraysEqual(cache, v))
                return;
              gl.uniform4fv(this.addr, v), copyArray(cache, v);
            }
          }
          function setValueM2(gl, v) {
            let cache = this.cache, elements = v.elements;
            if (elements === void 0) {
              if (arraysEqual(cache, v))
                return;
              gl.uniformMatrix2fv(this.addr, !1, v), copyArray(cache, v);
            } else {
              if (arraysEqual(cache, elements))
                return;
              mat2array.set(elements), gl.uniformMatrix2fv(this.addr, !1, mat2array), copyArray(cache, elements);
            }
          }
          function setValueM3(gl, v) {
            let cache = this.cache, elements = v.elements;
            if (elements === void 0) {
              if (arraysEqual(cache, v))
                return;
              gl.uniformMatrix3fv(this.addr, !1, v), copyArray(cache, v);
            } else {
              if (arraysEqual(cache, elements))
                return;
              mat3array.set(elements), gl.uniformMatrix3fv(this.addr, !1, mat3array), copyArray(cache, elements);
            }
          }
          function setValueM4(gl, v) {
            let cache = this.cache, elements = v.elements;
            if (elements === void 0) {
              if (arraysEqual(cache, v))
                return;
              gl.uniformMatrix4fv(this.addr, !1, v), copyArray(cache, v);
            } else {
              if (arraysEqual(cache, elements))
                return;
              mat4array.set(elements), gl.uniformMatrix4fv(this.addr, !1, mat4array), copyArray(cache, elements);
            }
          }
          function setValueV1i(gl, v) {
            let cache = this.cache;
            cache[0] !== v && (gl.uniform1i(this.addr, v), cache[0] = v);
          }
          function setValueV2i(gl, v) {
            let cache = this.cache;
            if (v.x !== void 0)
              (cache[0] !== v.x || cache[1] !== v.y) && (gl.uniform2i(this.addr, v.x, v.y), cache[0] = v.x, cache[1] = v.y);
            else {
              if (arraysEqual(cache, v))
                return;
              gl.uniform2iv(this.addr, v), copyArray(cache, v);
            }
          }
          function setValueV3i(gl, v) {
            let cache = this.cache;
            if (v.x !== void 0)
              (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) && (gl.uniform3i(this.addr, v.x, v.y, v.z), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z);
            else {
              if (arraysEqual(cache, v))
                return;
              gl.uniform3iv(this.addr, v), copyArray(cache, v);
            }
          }
          function setValueV4i(gl, v) {
            let cache = this.cache;
            if (v.x !== void 0)
              (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) && (gl.uniform4i(this.addr, v.x, v.y, v.z, v.w), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z, cache[3] = v.w);
            else {
              if (arraysEqual(cache, v))
                return;
              gl.uniform4iv(this.addr, v), copyArray(cache, v);
            }
          }
          function setValueV1ui(gl, v) {
            let cache = this.cache;
            cache[0] !== v && (gl.uniform1ui(this.addr, v), cache[0] = v);
          }
          function setValueV2ui(gl, v) {
            let cache = this.cache;
            if (v.x !== void 0)
              (cache[0] !== v.x || cache[1] !== v.y) && (gl.uniform2ui(this.addr, v.x, v.y), cache[0] = v.x, cache[1] = v.y);
            else {
              if (arraysEqual(cache, v))
                return;
              gl.uniform2uiv(this.addr, v), copyArray(cache, v);
            }
          }
          function setValueV3ui(gl, v) {
            let cache = this.cache;
            if (v.x !== void 0)
              (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) && (gl.uniform3ui(this.addr, v.x, v.y, v.z), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z);
            else {
              if (arraysEqual(cache, v))
                return;
              gl.uniform3uiv(this.addr, v), copyArray(cache, v);
            }
          }
          function setValueV4ui(gl, v) {
            let cache = this.cache;
            if (v.x !== void 0)
              (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) && (gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z, cache[3] = v.w);
            else {
              if (arraysEqual(cache, v))
                return;
              gl.uniform4uiv(this.addr, v), copyArray(cache, v);
            }
          }
          function setValueT1(gl, v, textures) {
            let cache = this.cache, unit = textures.allocateTextureUnit();
            cache[0] !== unit && (gl.uniform1i(this.addr, unit), cache[0] = unit);
            let emptyTexture2D = this.type === gl.SAMPLER_2D_SHADOW ? emptyShadowTexture : emptyTexture;
            textures.setTexture2D(v || emptyTexture2D, unit);
          }
          function setValueT3D1(gl, v, textures) {
            let cache = this.cache, unit = textures.allocateTextureUnit();
            cache[0] !== unit && (gl.uniform1i(this.addr, unit), cache[0] = unit), textures.setTexture3D(v || empty3dTexture, unit);
          }
          function setValueT6(gl, v, textures) {
            let cache = this.cache, unit = textures.allocateTextureUnit();
            cache[0] !== unit && (gl.uniform1i(this.addr, unit), cache[0] = unit), textures.setTextureCube(v || emptyCubeTexture, unit);
          }
          function setValueT2DArray1(gl, v, textures) {
            let cache = this.cache, unit = textures.allocateTextureUnit();
            cache[0] !== unit && (gl.uniform1i(this.addr, unit), cache[0] = unit), textures.setTexture2DArray(v || emptyArrayTexture, unit);
          }
          function getSingularSetter(type) {
            switch (type) {
              case 5126:
                return setValueV1f;
              case 35664:
                return setValueV2f;
              case 35665:
                return setValueV3f;
              case 35666:
                return setValueV4f;
              case 35674:
                return setValueM2;
              case 35675:
                return setValueM3;
              case 35676:
                return setValueM4;
              case 5124:
              case 35670:
                return setValueV1i;
              case 35667:
              case 35671:
                return setValueV2i;
              case 35668:
              case 35672:
                return setValueV3i;
              case 35669:
              case 35673:
                return setValueV4i;
              case 5125:
                return setValueV1ui;
              case 36294:
                return setValueV2ui;
              case 36295:
                return setValueV3ui;
              case 36296:
                return setValueV4ui;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return setValueT1;
              case 35679:
              case 36299:
              case 36307:
                return setValueT3D1;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return setValueT6;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return setValueT2DArray1;
            }
          }
          function setValueV1fArray(gl, v) {
            gl.uniform1fv(this.addr, v);
          }
          function setValueV2fArray(gl, v) {
            let data = flatten(v, this.size, 2);
            gl.uniform2fv(this.addr, data);
          }
          function setValueV3fArray(gl, v) {
            let data = flatten(v, this.size, 3);
            gl.uniform3fv(this.addr, data);
          }
          function setValueV4fArray(gl, v) {
            let data = flatten(v, this.size, 4);
            gl.uniform4fv(this.addr, data);
          }
          function setValueM2Array(gl, v) {
            let data = flatten(v, this.size, 4);
            gl.uniformMatrix2fv(this.addr, !1, data);
          }
          function setValueM3Array(gl, v) {
            let data = flatten(v, this.size, 9);
            gl.uniformMatrix3fv(this.addr, !1, data);
          }
          function setValueM4Array(gl, v) {
            let data = flatten(v, this.size, 16);
            gl.uniformMatrix4fv(this.addr, !1, data);
          }
          function setValueV1iArray(gl, v) {
            gl.uniform1iv(this.addr, v);
          }
          function setValueV2iArray(gl, v) {
            gl.uniform2iv(this.addr, v);
          }
          function setValueV3iArray(gl, v) {
            gl.uniform3iv(this.addr, v);
          }
          function setValueV4iArray(gl, v) {
            gl.uniform4iv(this.addr, v);
          }
          function setValueV1uiArray(gl, v) {
            gl.uniform1uiv(this.addr, v);
          }
          function setValueV2uiArray(gl, v) {
            gl.uniform2uiv(this.addr, v);
          }
          function setValueV3uiArray(gl, v) {
            gl.uniform3uiv(this.addr, v);
          }
          function setValueV4uiArray(gl, v) {
            gl.uniform4uiv(this.addr, v);
          }
          function setValueT1Array(gl, v, textures) {
            let cache = this.cache, n = v.length, units = allocTexUnits(textures, n);
            arraysEqual(cache, units) || (gl.uniform1iv(this.addr, units), copyArray(cache, units));
            for (let i = 0; i !== n; ++i)
              textures.setTexture2D(v[i] || emptyTexture, units[i]);
          }
          function setValueT3DArray(gl, v, textures) {
            let cache = this.cache, n = v.length, units = allocTexUnits(textures, n);
            arraysEqual(cache, units) || (gl.uniform1iv(this.addr, units), copyArray(cache, units));
            for (let i = 0; i !== n; ++i)
              textures.setTexture3D(v[i] || empty3dTexture, units[i]);
          }
          function setValueT6Array(gl, v, textures) {
            let cache = this.cache, n = v.length, units = allocTexUnits(textures, n);
            arraysEqual(cache, units) || (gl.uniform1iv(this.addr, units), copyArray(cache, units));
            for (let i = 0; i !== n; ++i)
              textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
          }
          function setValueT2DArrayArray(gl, v, textures) {
            let cache = this.cache, n = v.length, units = allocTexUnits(textures, n);
            arraysEqual(cache, units) || (gl.uniform1iv(this.addr, units), copyArray(cache, units));
            for (let i = 0; i !== n; ++i)
              textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
          }
          function getPureArraySetter(type) {
            switch (type) {
              case 5126:
                return setValueV1fArray;
              case 35664:
                return setValueV2fArray;
              case 35665:
                return setValueV3fArray;
              case 35666:
                return setValueV4fArray;
              case 35674:
                return setValueM2Array;
              case 35675:
                return setValueM3Array;
              case 35676:
                return setValueM4Array;
              case 5124:
              case 35670:
                return setValueV1iArray;
              case 35667:
              case 35671:
                return setValueV2iArray;
              case 35668:
              case 35672:
                return setValueV3iArray;
              case 35669:
              case 35673:
                return setValueV4iArray;
              case 5125:
                return setValueV1uiArray;
              case 36294:
                return setValueV2uiArray;
              case 36295:
                return setValueV3uiArray;
              case 36296:
                return setValueV4uiArray;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return setValueT1Array;
              case 35679:
              case 36299:
              case 36307:
                return setValueT3DArray;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return setValueT6Array;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return setValueT2DArrayArray;
            }
          }
          class SingleUniform {
            constructor(id, activeInfo, addr) {
              this.id = id, this.addr = addr, this.cache = [], this.type = activeInfo.type, this.setValue = getSingularSetter(activeInfo.type);
            }
          }
          class PureArrayUniform {
            constructor(id, activeInfo, addr) {
              this.id = id, this.addr = addr, this.cache = [], this.type = activeInfo.type, this.size = activeInfo.size, this.setValue = getPureArraySetter(activeInfo.type);
            }
          }
          class StructuredUniform {
            constructor(id) {
              this.id = id, this.seq = [], this.map = {};
            }
            setValue(gl, value, textures) {
              let seq = this.seq;
              for (let i = 0, n = seq.length; i !== n; ++i) {
                let u = seq[i];
                u.setValue(gl, value[u.id], textures);
              }
            }
          }
          let RePathPart = /(\w+)(\])?(\[|\.)?/g;
          function addUniform(container, uniformObject) {
            container.seq.push(uniformObject), container.map[uniformObject.id] = uniformObject;
          }
          function parseUniform(activeInfo, addr, container) {
            let path = activeInfo.name, pathLength = path.length;
            for (RePathPart.lastIndex = 0; ; ) {
              let match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === "]", subscript = match[3];
              if (idIsIndex && (id = id | 0), subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
                addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                break;
              } else {
                let next = container.map[id];
                next === void 0 && (next = new StructuredUniform(id), addUniform(container, next)), container = next;
              }
            }
          }
          class WebGLUniforms {
            constructor(gl, program) {
              this.seq = [], this.map = {};
              let n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
              for (let i = 0; i < n; ++i) {
                let info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
                parseUniform(info, addr, this);
              }
            }
            setValue(gl, name, value, textures) {
              let u = this.map[name];
              u !== void 0 && u.setValue(gl, value, textures);
            }
            setOptional(gl, object, name) {
              let v = object[name];
              v !== void 0 && this.setValue(gl, name, v);
            }
            static upload(gl, seq, values, textures) {
              for (let i = 0, n = seq.length; i !== n; ++i) {
                let u = seq[i], v = values[u.id];
                v.needsUpdate !== !1 && u.setValue(gl, v.value, textures);
              }
            }
            static seqWithValue(seq, values) {
              let r = [];
              for (let i = 0, n = seq.length; i !== n; ++i) {
                let u = seq[i];
                u.id in values && r.push(u);
              }
              return r;
            }
          }
          function WebGLShader(gl, type, string) {
            let shader = gl.createShader(type);
            return gl.shaderSource(shader, string), gl.compileShader(shader), shader;
          }
          let COMPLETION_STATUS_KHR = 37297, programIdCount = 0;
          function handleSource(string, errorLine) {
            let lines = string.split(`
`), lines2 = [], from = Math.max(errorLine - 6, 0), to = Math.min(errorLine + 6, lines.length);
            for (let i = from; i < to; i++) {
              let line = i + 1;
              lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
            }
            return lines2.join(`
`);
          }
          function getEncodingComponents(colorSpace) {
            let workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace), encodingPrimaries = ColorManagement.getPrimaries(colorSpace), gamutMapping;
            switch (workingPrimaries === encodingPrimaries ? gamutMapping = "" : workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries ? gamutMapping = "LinearDisplayP3ToLinearSRGB" : workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries && (gamutMapping = "LinearSRGBToLinearDisplayP3"), colorSpace) {
              case LinearSRGBColorSpace:
              case LinearDisplayP3ColorSpace:
                return [gamutMapping, "LinearTransferOETF"];
              case SRGBColorSpace:
              case DisplayP3ColorSpace:
                return [gamutMapping, "sRGBTransferOETF"];
              default:
                return console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace), [gamutMapping, "LinearTransferOETF"];
            }
          }
          function getShaderErrors(gl, shader, type) {
            let status = gl.getShaderParameter(shader, gl.COMPILE_STATUS), errors = gl.getShaderInfoLog(shader).trim();
            if (status && errors === "")
              return "";
            let errorMatches = /ERROR: 0:(\d+)/.exec(errors);
            if (errorMatches) {
              let errorLine = parseInt(errorMatches[1]);
              return type.toUpperCase() + `

` + errors + `

` + handleSource(gl.getShaderSource(shader), errorLine);
            } else
              return errors;
          }
          function getTexelEncodingFunction(functionName, colorSpace) {
            let components = getEncodingComponents(colorSpace);
            return `vec4 ${functionName}( vec4 value ) { return ${components[0]}( ${components[1]}( value ) ); }`;
          }
          function getToneMappingFunction(functionName, toneMapping) {
            let toneMappingName;
            switch (toneMapping) {
              case LinearToneMapping:
                toneMappingName = "Linear";
                break;
              case ReinhardToneMapping:
                toneMappingName = "Reinhard";
                break;
              case CineonToneMapping:
                toneMappingName = "OptimizedCineon";
                break;
              case ACESFilmicToneMapping:
                toneMappingName = "ACESFilmic";
                break;
              case AgXToneMapping:
                toneMappingName = "AgX";
                break;
              case NeutralToneMapping:
                toneMappingName = "Neutral";
                break;
              case CustomToneMapping:
                toneMappingName = "Custom";
                break;
              default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping), toneMappingName = "Linear";
            }
            return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
          }
          function generateVertexExtensions(parameters) {
            return [parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", parameters.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(filterEmptyLine).join(`
`);
          }
          function generateDefines(defines) {
            let chunks = [];
            for (let name in defines) {
              let value = defines[name];
              value !== !1 && chunks.push("#define " + name + " " + value);
            }
            return chunks.join(`
`);
          }
          function fetchAttributeLocations(gl, program) {
            let attributes = {}, n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
            for (let i = 0; i < n; i++) {
              let info = gl.getActiveAttrib(program, i), name = info.name, locationSize = 1;
              info.type === gl.FLOAT_MAT2 && (locationSize = 2), info.type === gl.FLOAT_MAT3 && (locationSize = 3), info.type === gl.FLOAT_MAT4 && (locationSize = 4), attributes[name] = { type: info.type, location: gl.getAttribLocation(program, name), locationSize };
            }
            return attributes;
          }
          function filterEmptyLine(string) {
            return string !== "";
          }
          function replaceLightNums(string, parameters) {
            let numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
            return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
          }
          function replaceClippingPlaneNums(string, parameters) {
            return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
          }
          let includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
          function resolveIncludes(string) {
            return string.replace(includePattern, includeReplacer);
          }
          let shaderChunkMap = new Map();
          function includeReplacer(match, include) {
            let string = ShaderChunk[include];
            if (string === void 0) {
              let newInclude = shaderChunkMap.get(include);
              if (newInclude !== void 0)
                string = ShaderChunk[newInclude], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
              else
                throw new Error("Can not resolve #include <" + include + ">");
            }
            return resolveIncludes(string);
          }
          let unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
          function unrollLoops(string) {
            return string.replace(unrollLoopPattern, loopReplacer);
          }
          function loopReplacer(match, start, end, snippet) {
            let string = "";
            for (let i = parseInt(start); i < parseInt(end); i++)
              string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
            return string;
          }
          function generatePrecision(parameters) {
            let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
            return parameters.precision === "highp" ? precisionstring += `
#define HIGH_PRECISION` : parameters.precision === "mediump" ? precisionstring += `
#define MEDIUM_PRECISION` : parameters.precision === "lowp" && (precisionstring += `
#define LOW_PRECISION`), precisionstring;
          }
          function generateShadowMapTypeDefine(parameters) {
            let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
            return parameters.shadowMapType === PCFShadowMap ? shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF" : parameters.shadowMapType === PCFSoftShadowMap ? shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT" : parameters.shadowMapType === VSMShadowMap && (shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM"), shadowMapTypeDefine;
          }
          function generateEnvMapTypeDefine(parameters) {
            let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
            if (parameters.envMap)
              switch (parameters.envMapMode) {
                case CubeReflectionMapping:
                case CubeRefractionMapping:
                  envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                  break;
                case CubeUVReflectionMapping:
                  envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
                  break;
              }
            return envMapTypeDefine;
          }
          function generateEnvMapModeDefine(parameters) {
            let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
            if (parameters.envMap)
              switch (parameters.envMapMode) {
                case CubeRefractionMapping:
                  envMapModeDefine = "ENVMAP_MODE_REFRACTION";
                  break;
              }
            return envMapModeDefine;
          }
          function generateEnvMapBlendingDefine(parameters) {
            let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
            if (parameters.envMap)
              switch (parameters.combine) {
                case MultiplyOperation:
                  envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case MixOperation:
                  envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                  break;
                case AddOperation:
                  envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
                  break;
              }
            return envMapBlendingDefine;
          }
          function generateCubeUVSize(parameters) {
            let imageHeight = parameters.envMapCubeUVHeight;
            if (imageHeight === null)
              return null;
            let maxMip = Math.log2(imageHeight) - 2, texelHeight = 1 / imageHeight;
            return { texelWidth: 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16)), texelHeight, maxMip };
          }
          function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
            let gl = renderer.getContext(), defines = parameters.defines, vertexShader = parameters.vertexShader, fragmentShader = parameters.fragmentShader, shadowMapTypeDefine = generateShadowMapTypeDefine(parameters), envMapTypeDefine = generateEnvMapTypeDefine(parameters), envMapModeDefine = generateEnvMapModeDefine(parameters), envMapBlendingDefine = generateEnvMapBlendingDefine(parameters), envMapCubeUVSize = generateCubeUVSize(parameters), customVertexExtensions = generateVertexExtensions(parameters), customDefines = generateDefines(defines), program = gl.createProgram(), prefixVertex, prefixFragment, versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + `
` : "", numMultiviewViews = parameters.numMultiviewViews;
            parameters.isRawShaderMaterial ? (prefixVertex = ["#define SHADER_TYPE " + parameters.shaderType, "#define SHADER_NAME " + parameters.shaderName, customDefines].filter(filterEmptyLine).join(`
`), prefixVertex.length > 0 && (prefixVertex += `
`), prefixFragment = ["#define SHADER_TYPE " + parameters.shaderType, "#define SHADER_NAME " + parameters.shaderName, customDefines].filter(filterEmptyLine).join(`
`), prefixFragment.length > 0 && (prefixFragment += `
`)) : (prefixVertex = [
              generatePrecision(parameters),
              "#define SHADER_TYPE " + parameters.shaderType,
              "#define SHADER_NAME " + parameters.shaderName,
              customDefines,
              parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
              parameters.batching ? "#define USE_BATCHING" : "",
              parameters.instancing ? "#define USE_INSTANCING" : "",
              parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
              parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
              parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
              parameters.map ? "#define USE_MAP" : "",
              parameters.envMap ? "#define USE_ENVMAP" : "",
              parameters.envMap ? "#define " + envMapModeDefine : "",
              parameters.lightMap ? "#define USE_LIGHTMAP" : "",
              parameters.aoMap ? "#define USE_AOMAP" : "",
              parameters.bumpMap ? "#define USE_BUMPMAP" : "",
              parameters.normalMap ? "#define USE_NORMALMAP" : "",
              parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
              parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
              parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
              parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
              parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
              parameters.specularMap ? "#define USE_SPECULARMAP" : "",
              parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
              parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
              parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
              parameters.transmission ? "#define USE_TRANSMISSION" : "",
              parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
              parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
              parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
              parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
              parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
              parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
              parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
              parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
              parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
              parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
              parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
              parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
              parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
              parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
              parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
              parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
              parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
              parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
              parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
              parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
              parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
              parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
              parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
              parameters.vertexTangents && parameters.flatShading === !1 ? "#define USE_TANGENT" : "",
              parameters.vertexColors ? "#define USE_COLOR" : "",
              parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              parameters.vertexUv1s ? "#define USE_UV1" : "",
              parameters.vertexUv2s ? "#define USE_UV2" : "",
              parameters.vertexUv3s ? "#define USE_UV3" : "",
              parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
              parameters.flatShading ? "#define FLAT_SHADED" : "",
              parameters.skinning ? "#define USE_SKINNING" : "",
              parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
              parameters.morphNormals && parameters.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
              parameters.morphColors ? "#define USE_MORPHCOLORS" : "",
              parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "",
              parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
              parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
              parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
              parameters.flipSided ? "#define FLIP_SIDED" : "",
              parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
              parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
              parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "#ifdef USE_INSTANCING_MORPH",
              "	uniform sampler2D morphTexture;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_UV1",
              "	attribute vec2 uv1;",
              "#endif",
              "#ifdef USE_UV2",
              "	attribute vec2 uv2;",
              "#endif",
              "#ifdef USE_UV3",
              "	attribute vec2 uv3;",
              "#endif",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "	attribute vec3 morphTarget0;",
              "	attribute vec3 morphTarget1;",
              "	attribute vec3 morphTarget2;",
              "	attribute vec3 morphTarget3;",
              "	#ifdef USE_MORPHNORMALS",
              "		attribute vec3 morphNormal0;",
              "		attribute vec3 morphNormal1;",
              "		attribute vec3 morphNormal2;",
              "		attribute vec3 morphNormal3;",
              "	#else",
              "		attribute vec3 morphTarget4;",
              "		attribute vec3 morphTarget5;",
              "		attribute vec3 morphTarget6;",
              "		attribute vec3 morphTarget7;",
              "	#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`
            ].filter(filterEmptyLine).join(`
`), prefixFragment = [
              generatePrecision(parameters),
              "#define SHADER_TYPE " + parameters.shaderType,
              "#define SHADER_NAME " + parameters.shaderName,
              customDefines,
              parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
              parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
              parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
              parameters.map ? "#define USE_MAP" : "",
              parameters.matcap ? "#define USE_MATCAP" : "",
              parameters.envMap ? "#define USE_ENVMAP" : "",
              parameters.envMap ? "#define " + envMapTypeDefine : "",
              parameters.envMap ? "#define " + envMapModeDefine : "",
              parameters.envMap ? "#define " + envMapBlendingDefine : "",
              envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
              envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
              envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
              parameters.lightMap ? "#define USE_LIGHTMAP" : "",
              parameters.aoMap ? "#define USE_AOMAP" : "",
              parameters.bumpMap ? "#define USE_BUMPMAP" : "",
              parameters.normalMap ? "#define USE_NORMALMAP" : "",
              parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
              parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
              parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
              parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
              parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              parameters.dispersion ? "#define USE_DISPERSION" : "",
              parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
              parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
              parameters.specularMap ? "#define USE_SPECULARMAP" : "",
              parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
              parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
              parameters.alphaTest ? "#define USE_ALPHATEST" : "",
              parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
              parameters.sheen ? "#define USE_SHEEN" : "",
              parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              parameters.transmission ? "#define USE_TRANSMISSION" : "",
              parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              parameters.vertexTangents && parameters.flatShading === !1 ? "#define USE_TANGENT" : "",
              parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
              parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              parameters.vertexUv1s ? "#define USE_UV1" : "",
              parameters.vertexUv2s ? "#define USE_UV2" : "",
              parameters.vertexUv3s ? "#define USE_UV3" : "",
              parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
              parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
              parameters.flatShading ? "#define FLAT_SHADED" : "",
              parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
              parameters.flipSided ? "#define FLIP_SIDED" : "",
              parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
              parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
              parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
              parameters.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "",
              parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
              parameters.dithering ? "#define DITHERING" : "",
              parameters.opaque ? "#define OPAQUE" : "",
              ShaderChunk.colorspace_pars_fragment,
              getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
              parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
              `
`
            ].filter(filterEmptyLine).join(`
`)), vertexShader = resolveIncludes(vertexShader), vertexShader = replaceLightNums(vertexShader, parameters), vertexShader = replaceClippingPlaneNums(vertexShader, parameters), fragmentShader = resolveIncludes(fragmentShader), fragmentShader = replaceLightNums(fragmentShader, parameters), fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters), vertexShader = unrollLoops(vertexShader), fragmentShader = unrollLoops(fragmentShader), parameters.isRawShaderMaterial !== !0 && (versionString = `#version 300 es
`, prefixVertex = [customVertexExtensions, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + prefixVertex, prefixFragment = ["#define varying in", parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + prefixFragment, numMultiviewViews > 0 && (prefixVertex = ["#extension GL_OVR_multiview : require", "layout(num_views = " + numMultiviewViews + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join(`
`) + `
` + prefixVertex, prefixVertex = prefixVertex.replace(["uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;"].join(`
`), ["uniform mat4 modelViewMatrices[" + numMultiviewViews + "];", "uniform mat4 projectionMatrices[" + numMultiviewViews + "];", "uniform mat4 viewMatrices[" + numMultiviewViews + "];", "uniform mat3 normalMatrices[" + numMultiviewViews + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]", "#define projectionMatrix projectionMatrices[VIEW_ID]", "#define viewMatrix viewMatrices[VIEW_ID]", "#define normalMatrix normalMatrices[VIEW_ID]"].join(`
`)), prefixFragment = ["#extension GL_OVR_multiview : require", "#define VIEW_ID gl_ViewID_OVR"].join(`
`) + `
` + prefixFragment, prefixFragment = prefixFragment.replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + numMultiviewViews + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join(`
`))));
            let vertexGlsl = versionString + prefixVertex + vertexShader, fragmentGlsl = versionString + prefixFragment + fragmentShader, glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl), glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
            gl.attachShader(program, glVertexShader), gl.attachShader(program, glFragmentShader), parameters.index0AttributeName !== void 0 ? gl.bindAttribLocation(program, 0, parameters.index0AttributeName) : parameters.morphTargets === !0 && gl.bindAttribLocation(program, 0, "position"), gl.linkProgram(program);
            function onFirstUse(self2) {
              if (renderer.debug.checkShaderErrors) {
                let programLog = gl.getProgramInfoLog(program).trim(), vertexLog = gl.getShaderInfoLog(glVertexShader).trim(), fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim(), runnable = !0, haveDiagnostics = !0;
                if (gl.getProgramParameter(program, gl.LINK_STATUS) === !1)
                  if (runnable = !1, typeof renderer.debug.onShaderError == "function")
                    renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
                  else {
                    let vertexErrors = getShaderErrors(gl, glVertexShader, "vertex"), fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + `

Material Name: ` + self2.name + `
Material Type: ` + self2.type + `

Program Info Log: ` + programLog + `
` + vertexErrors + `
` + fragmentErrors);
                  }
                else
                  programLog !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", programLog) : (vertexLog === "" || fragmentLog === "") && (haveDiagnostics = !1);
                haveDiagnostics && (self2.diagnostics = { runnable, programLog, vertexShader: { log: vertexLog, prefix: prefixVertex }, fragmentShader: { log: fragmentLog, prefix: prefixFragment } });
              }
              gl.deleteShader(glVertexShader), gl.deleteShader(glFragmentShader), cachedUniforms = new WebGLUniforms(gl, program), cachedAttributes = fetchAttributeLocations(gl, program);
            }
            let cachedUniforms;
            this.getUniforms = function() {
              return cachedUniforms === void 0 && onFirstUse(this), cachedUniforms;
            };
            let cachedAttributes;
            this.getAttributes = function() {
              return cachedAttributes === void 0 && onFirstUse(this), cachedAttributes;
            };
            let programReady = parameters.rendererExtensionParallelShaderCompile === !1;
            return this.isReady = function() {
              return programReady === !1 && (programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR)), programReady;
            }, this.destroy = function() {
              bindingStates.releaseStatesOfProgram(this), gl.deleteProgram(program), this.program = void 0;
            }, this.type = parameters.shaderType, this.name = parameters.shaderName, this.id = programIdCount++, this.cacheKey = cacheKey, this.usedTimes = 1, this.program = program, this.vertexShader = glVertexShader, this.fragmentShader = glFragmentShader, this.numMultiviewViews = numMultiviewViews, this;
          }
          let _id$1 = 0;
          class WebGLShaderCache {
            constructor() {
              this.shaderCache = new Map(), this.materialCache = new Map();
            }
            update(material) {
              let vertexShader = material.vertexShader, fragmentShader = material.fragmentShader, vertexShaderStage = this._getShaderStage(vertexShader), fragmentShaderStage = this._getShaderStage(fragmentShader), materialShaders = this._getShaderCacheForMaterial(material);
              return materialShaders.has(vertexShaderStage) === !1 && (materialShaders.add(vertexShaderStage), vertexShaderStage.usedTimes++), materialShaders.has(fragmentShaderStage) === !1 && (materialShaders.add(fragmentShaderStage), fragmentShaderStage.usedTimes++), this;
            }
            remove(material) {
              let materialShaders = this.materialCache.get(material);
              for (let shaderStage of materialShaders)
                shaderStage.usedTimes--, shaderStage.usedTimes === 0 && this.shaderCache.delete(shaderStage.code);
              return this.materialCache.delete(material), this;
            }
            getVertexShaderID(material) {
              return this._getShaderStage(material.vertexShader).id;
            }
            getFragmentShaderID(material) {
              return this._getShaderStage(material.fragmentShader).id;
            }
            dispose() {
              this.shaderCache.clear(), this.materialCache.clear();
            }
            _getShaderCacheForMaterial(material) {
              let cache = this.materialCache, set = cache.get(material);
              return set === void 0 && (set = new Set(), cache.set(material, set)), set;
            }
            _getShaderStage(code) {
              let cache = this.shaderCache, stage = cache.get(code);
              return stage === void 0 && (stage = new WebGLShaderStage(code), cache.set(code, stage)), stage;
            }
          }
          class WebGLShaderStage {
            constructor(code) {
              this.id = _id$1++, this.code = code, this.usedTimes = 0;
            }
          }
          function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
            let _programLayers = new Layers(), _customShaders = new WebGLShaderCache(), _activeChannels = new Set(), programs = [], logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer, SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures, precision = capabilities.precision, shaderIDs = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
            function getChannel(value) {
              return _activeChannels.add(value), value === 0 ? "uv" : `uv${value}`;
            }
            function getParameters(material, lights, shadows, scene, object) {
              let fog = scene.fog, geometry = object.geometry, environment = material.isMeshStandardMaterial ? scene.environment : null, envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment), envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null, shaderID = shaderIDs[material.type];
              material.precision !== null && (precision = capabilities.getMaxPrecision(material.precision), precision !== material.precision && console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead."));
              let morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color, morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0, morphTextureStride = 0;
              geometry.morphAttributes.position !== void 0 && (morphTextureStride = 1), geometry.morphAttributes.normal !== void 0 && (morphTextureStride = 2), geometry.morphAttributes.color !== void 0 && (morphTextureStride = 3);
              let vertexShader, fragmentShader, customVertexShaderID, customFragmentShaderID;
              if (shaderID) {
                let shader = ShaderLib[shaderID];
                vertexShader = shader.vertexShader, fragmentShader = shader.fragmentShader;
              } else
                vertexShader = material.vertexShader, fragmentShader = material.fragmentShader, _customShaders.update(material), customVertexShaderID = _customShaders.getVertexShaderID(material), customFragmentShaderID = _customShaders.getFragmentShaderID(material);
              let currentRenderTarget = renderer.getRenderTarget(), numMultiviewViews = currentRenderTarget && currentRenderTarget.isWebGLMultiviewRenderTarget ? currentRenderTarget.numViews : 0, IS_INSTANCEDMESH = object.isInstancedMesh === !0, IS_BATCHEDMESH = object.isBatchedMesh === !0, HAS_MAP = !!material.map, HAS_MATCAP = !!material.matcap, HAS_ENVMAP = !!envMap, HAS_AOMAP = !!material.aoMap, HAS_LIGHTMAP = !!material.lightMap, HAS_BUMPMAP = !!material.bumpMap, HAS_NORMALMAP = !!material.normalMap, HAS_DISPLACEMENTMAP = !!material.displacementMap, HAS_EMISSIVEMAP = !!material.emissiveMap, HAS_METALNESSMAP = !!material.metalnessMap, HAS_ROUGHNESSMAP = !!material.roughnessMap, HAS_ANISOTROPY = material.anisotropy > 0, HAS_CLEARCOAT = material.clearcoat > 0, HAS_DISPERSION = material.dispersion > 0, HAS_IRIDESCENCE = material.iridescence > 0, HAS_SHEEN = material.sheen > 0, HAS_TRANSMISSION = material.transmission > 0, HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap, HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap, HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap, HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap, HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap, HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap, HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap, HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap, HAS_SPECULARMAP = !!material.specularMap, HAS_SPECULAR_COLORMAP = !!material.specularColorMap, HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap, HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap, HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap, HAS_GRADIENTMAP = !!material.gradientMap, HAS_ALPHAMAP = !!material.alphaMap, HAS_ALPHATEST = material.alphaTest > 0, HAS_ALPHAHASH = !!material.alphaHash, HAS_EXTENSIONS = !!material.extensions, toneMapping = NoToneMapping;
              material.toneMapped && (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === !0) && (toneMapping = renderer.toneMapping);
              let parameters = {
                shaderID,
                shaderType: material.type,
                shaderName: material.name,
                vertexShader,
                fragmentShader,
                defines: material.defines,
                customVertexShaderID,
                customFragmentShaderID,
                isRawShaderMaterial: material.isRawShaderMaterial === !0,
                glslVersion: material.glslVersion,
                precision,
                batching: IS_BATCHEDMESH,
                instancing: IS_INSTANCEDMESH,
                instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
                instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
                supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
                numMultiviewViews,
                outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === !0 ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
                alphaToCoverage: !!material.alphaToCoverage,
                map: HAS_MAP,
                matcap: HAS_MATCAP,
                envMap: HAS_ENVMAP,
                envMapMode: HAS_ENVMAP && envMap.mapping,
                envMapCubeUVHeight,
                aoMap: HAS_AOMAP,
                lightMap: HAS_LIGHTMAP,
                bumpMap: HAS_BUMPMAP,
                normalMap: HAS_NORMALMAP,
                displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
                emissiveMap: HAS_EMISSIVEMAP,
                normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
                normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
                metalnessMap: HAS_METALNESSMAP,
                roughnessMap: HAS_ROUGHNESSMAP,
                anisotropy: HAS_ANISOTROPY,
                anisotropyMap: HAS_ANISOTROPYMAP,
                clearcoat: HAS_CLEARCOAT,
                clearcoatMap: HAS_CLEARCOATMAP,
                clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
                clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
                dispersion: HAS_DISPERSION,
                iridescence: HAS_IRIDESCENCE,
                iridescenceMap: HAS_IRIDESCENCEMAP,
                iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
                sheen: HAS_SHEEN,
                sheenColorMap: HAS_SHEEN_COLORMAP,
                sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
                specularMap: HAS_SPECULARMAP,
                specularColorMap: HAS_SPECULAR_COLORMAP,
                specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
                transmission: HAS_TRANSMISSION,
                transmissionMap: HAS_TRANSMISSIONMAP,
                thicknessMap: HAS_THICKNESSMAP,
                gradientMap: HAS_GRADIENTMAP,
                opaque: material.transparent === !1 && material.blending === NormalBlending && material.alphaToCoverage === !1,
                alphaMap: HAS_ALPHAMAP,
                alphaTest: HAS_ALPHATEST,
                alphaHash: HAS_ALPHAHASH,
                combine: material.combine,
                mapUv: HAS_MAP && getChannel(material.map.channel),
                aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
                lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
                bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
                normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
                displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
                emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
                metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
                roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
                anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
                clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
                clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
                iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
                iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
                sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
                sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
                specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
                specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
                specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
                transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
                thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
                alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
                vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
                vertexColors: material.vertexColors,
                vertexAlphas: material.vertexColors === !0 && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
                pointsUvs: object.isPoints === !0 && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
                fog: !!fog,
                useFog: material.fog === !0,
                fogExp2: !!fog && fog.isFogExp2,
                flatShading: material.flatShading === !0,
                sizeAttenuation: material.sizeAttenuation === !0,
                logarithmicDepthBuffer,
                skinning: object.isSkinnedMesh === !0,
                morphTargets: geometry.morphAttributes.position !== void 0,
                morphNormals: geometry.morphAttributes.normal !== void 0,
                morphColors: geometry.morphAttributes.color !== void 0,
                morphTargetsCount,
                morphTextureStride,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numSpotLightMaps: lights.spotLightMap.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
                numDirLightShadows: lights.directionalShadowMap.length,
                numPointLightShadows: lights.pointShadowMap.length,
                numSpotLightShadows: lights.spotShadowMap.length,
                numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
                numLightProbes: lights.numLightProbes,
                numClippingPlanes: clipping.numPlanes,
                numClipIntersection: clipping.numIntersection,
                dithering: material.dithering,
                shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping,
                useLegacyLights: renderer._useLegacyLights,
                decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === !0 && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
                premultipliedAlpha: material.premultipliedAlpha,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                useDepthPacking: material.depthPacking >= 0,
                depthPacking: material.depthPacking || 0,
                index0AttributeName: material.index0AttributeName,
                extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === !0 && extensions.has("WEBGL_clip_cull_distance"),
                extensionMultiDraw: HAS_EXTENSIONS && material.extensions.multiDraw === !0 && extensions.has("WEBGL_multi_draw"),
                rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
                customProgramCacheKey: material.customProgramCacheKey()
              };
              return parameters.vertexUv1s = _activeChannels.has(1), parameters.vertexUv2s = _activeChannels.has(2), parameters.vertexUv3s = _activeChannels.has(3), _activeChannels.clear(), parameters;
            }
            function getProgramCacheKey(parameters) {
              let array = [];
              if (parameters.shaderID ? array.push(parameters.shaderID) : (array.push(parameters.customVertexShaderID), array.push(parameters.customFragmentShaderID)), parameters.defines !== void 0)
                for (let name in parameters.defines)
                  array.push(name), array.push(parameters.defines[name]);
              return parameters.isRawShaderMaterial === !1 && (getProgramCacheKeyParameters(array, parameters), getProgramCacheKeyBooleans(array, parameters), array.push(renderer.outputColorSpace)), array.push(parameters.customProgramCacheKey), array.join();
            }
            function getProgramCacheKeyParameters(array, parameters) {
              array.push(parameters.precision), array.push(parameters.outputColorSpace), array.push(parameters.envMapMode), array.push(parameters.envMapCubeUVHeight), array.push(parameters.mapUv), array.push(parameters.alphaMapUv), array.push(parameters.lightMapUv), array.push(parameters.aoMapUv), array.push(parameters.bumpMapUv), array.push(parameters.normalMapUv), array.push(parameters.displacementMapUv), array.push(parameters.emissiveMapUv), array.push(parameters.metalnessMapUv), array.push(parameters.roughnessMapUv), array.push(parameters.anisotropyMapUv), array.push(parameters.clearcoatMapUv), array.push(parameters.clearcoatNormalMapUv), array.push(parameters.clearcoatRoughnessMapUv), array.push(parameters.iridescenceMapUv), array.push(parameters.iridescenceThicknessMapUv), array.push(parameters.sheenColorMapUv), array.push(parameters.sheenRoughnessMapUv), array.push(parameters.specularMapUv), array.push(parameters.specularColorMapUv), array.push(parameters.specularIntensityMapUv), array.push(parameters.transmissionMapUv), array.push(parameters.thicknessMapUv), array.push(parameters.combine), array.push(parameters.fogExp2), array.push(parameters.sizeAttenuation), array.push(parameters.morphTargetsCount), array.push(parameters.morphAttributeCount), array.push(parameters.numDirLights), array.push(parameters.numPointLights), array.push(parameters.numSpotLights), array.push(parameters.numSpotLightMaps), array.push(parameters.numHemiLights), array.push(parameters.numRectAreaLights), array.push(parameters.numDirLightShadows), array.push(parameters.numPointLightShadows), array.push(parameters.numSpotLightShadows), array.push(parameters.numSpotLightShadowsWithMaps), array.push(parameters.numLightProbes), array.push(parameters.shadowMapType), array.push(parameters.toneMapping), array.push(parameters.numClippingPlanes), array.push(parameters.numClipIntersection), array.push(parameters.depthPacking);
            }
            function getProgramCacheKeyBooleans(array, parameters) {
              _programLayers.disableAll(), parameters.supportsVertexTextures && _programLayers.enable(0), parameters.instancing && _programLayers.enable(1), parameters.instancingColor && _programLayers.enable(2), parameters.instancingMorph && _programLayers.enable(3), parameters.matcap && _programLayers.enable(4), parameters.envMap && _programLayers.enable(5), parameters.normalMapObjectSpace && _programLayers.enable(6), parameters.normalMapTangentSpace && _programLayers.enable(7), parameters.clearcoat && _programLayers.enable(8), parameters.iridescence && _programLayers.enable(9), parameters.alphaTest && _programLayers.enable(10), parameters.vertexColors && _programLayers.enable(11), parameters.vertexAlphas && _programLayers.enable(12), parameters.vertexUv1s && _programLayers.enable(13), parameters.vertexUv2s && _programLayers.enable(14), parameters.vertexUv3s && _programLayers.enable(15), parameters.vertexTangents && _programLayers.enable(16), parameters.anisotropy && _programLayers.enable(17), parameters.alphaHash && _programLayers.enable(18), parameters.batching && _programLayers.enable(19), parameters.dispersion && _programLayers.enable(20), array.push(_programLayers.mask), _programLayers.disableAll(), parameters.fog && _programLayers.enable(0), parameters.useFog && _programLayers.enable(1), parameters.flatShading && _programLayers.enable(2), parameters.logarithmicDepthBuffer && _programLayers.enable(3), parameters.skinning && _programLayers.enable(4), parameters.morphTargets && _programLayers.enable(5), parameters.morphNormals && _programLayers.enable(6), parameters.morphColors && _programLayers.enable(7), parameters.premultipliedAlpha && _programLayers.enable(8), parameters.shadowMapEnabled && _programLayers.enable(9), parameters.useLegacyLights && _programLayers.enable(10), parameters.doubleSided && _programLayers.enable(11), parameters.flipSided && _programLayers.enable(12), parameters.useDepthPacking && _programLayers.enable(13), parameters.dithering && _programLayers.enable(14), parameters.transmission && _programLayers.enable(15), parameters.sheen && _programLayers.enable(16), parameters.opaque && _programLayers.enable(17), parameters.pointsUvs && _programLayers.enable(18), parameters.decodeVideoTexture && _programLayers.enable(19), parameters.alphaToCoverage && _programLayers.enable(20), parameters.numMultiviewViews && _programLayers.enable(21), array.push(_programLayers.mask);
            }
            function getUniforms(material) {
              let shaderID = shaderIDs[material.type], uniforms;
              if (shaderID) {
                let shader = ShaderLib[shaderID];
                uniforms = UniformsUtils.clone(shader.uniforms);
              } else
                uniforms = material.uniforms;
              return uniforms;
            }
            function acquireProgram(parameters, cacheKey) {
              let program;
              for (let p = 0, pl = programs.length; p < pl; p++) {
                let preexistingProgram = programs[p];
                if (preexistingProgram.cacheKey === cacheKey) {
                  program = preexistingProgram, ++program.usedTimes;
                  break;
                }
              }
              return program === void 0 && (program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates), programs.push(program)), program;
            }
            function releaseProgram(program) {
              if (--program.usedTimes == 0) {
                let i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1], programs.pop(), program.destroy();
              }
            }
            function releaseShaderCache(material) {
              _customShaders.remove(material);
            }
            function dispose() {
              _customShaders.dispose();
            }
            return {
              getParameters,
              getProgramCacheKey,
              getUniforms,
              acquireProgram,
              releaseProgram,
              releaseShaderCache,
              programs,
              dispose
            };
          }
          function WebGLProperties() {
            let properties = new WeakMap();
            function get(object) {
              let map = properties.get(object);
              return map === void 0 && (map = {}, properties.set(object, map)), map;
            }
            function remove(object) {
              properties.delete(object);
            }
            function update(object, key, value) {
              properties.get(object)[key] = value;
            }
            function dispose() {
              properties = new WeakMap();
            }
            return { get, remove, update, dispose };
          }
          function painterSortStable(a, b) {
            return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;
          }
          function reversePainterSortStable(a, b) {
            return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id;
          }
          function WebGLRenderList() {
            let renderItems = [], renderItemsIndex = 0, opaque = [], transmissive = [], transparent = [];
            function init() {
              renderItemsIndex = 0, opaque.length = 0, transmissive.length = 0, transparent.length = 0;
            }
            function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
              let renderItem = renderItems[renderItemsIndex];
              return renderItem === void 0 ? (renderItem = { id: object.id, object, geometry, material, groupOrder, renderOrder: object.renderOrder, z, group }, renderItems[renderItemsIndex] = renderItem) : (renderItem.id = object.id, renderItem.object = object, renderItem.geometry = geometry, renderItem.material = material, renderItem.groupOrder = groupOrder, renderItem.renderOrder = object.renderOrder, renderItem.z = z, renderItem.group = group), renderItemsIndex++, renderItem;
            }
            function push(object, geometry, material, groupOrder, z, group) {
              let renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
              material.transmission > 0 ? transmissive.push(renderItem) : material.transparent === !0 ? transparent.push(renderItem) : opaque.push(renderItem);
            }
            function unshift(object, geometry, material, groupOrder, z, group) {
              let renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
              material.transmission > 0 ? transmissive.unshift(renderItem) : material.transparent === !0 ? transparent.unshift(renderItem) : opaque.unshift(renderItem);
            }
            function sort(customOpaqueSort, customTransparentSort) {
              opaque.length > 1 && opaque.sort(customOpaqueSort || painterSortStable), transmissive.length > 1 && transmissive.sort(customTransparentSort || reversePainterSortStable), transparent.length > 1 && transparent.sort(customTransparentSort || reversePainterSortStable);
            }
            function finish() {
              for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
                let renderItem = renderItems[i];
                if (renderItem.id === null)
                  break;
                renderItem.id = null, renderItem.object = null, renderItem.geometry = null, renderItem.material = null, renderItem.group = null;
              }
            }
            return { opaque, transmissive, transparent, init, push, unshift, finish, sort };
          }
          function WebGLRenderLists() {
            let lists = new WeakMap();
            function get(scene, renderCallDepth) {
              let listArray = lists.get(scene), list;
              return listArray === void 0 ? (list = new WebGLRenderList(), lists.set(scene, [list])) : renderCallDepth >= listArray.length ? (list = new WebGLRenderList(), listArray.push(list)) : list = listArray[renderCallDepth], list;
            }
            function dispose() {
              lists = new WeakMap();
            }
            return { get, dispose };
          }
          function UniformsCache() {
            let lights = {};
            return { get: function(light) {
              if (lights[light.id] !== void 0)
                return lights[light.id];
              let uniforms;
              switch (light.type) {
                case "DirectionalLight":
                  uniforms = { direction: new Vector3(), color: new Color() };
                  break;
                case "SpotLight":
                  uniforms = { position: new Vector3(), direction: new Vector3(), color: new Color(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
                  break;
                case "PointLight":
                  uniforms = { position: new Vector3(), color: new Color(), distance: 0, decay: 0 };
                  break;
                case "HemisphereLight":
                  uniforms = { direction: new Vector3(), skyColor: new Color(), groundColor: new Color() };
                  break;
                case "RectAreaLight":
                  uniforms = { color: new Color(), position: new Vector3(), halfWidth: new Vector3(), halfHeight: new Vector3() };
                  break;
              }
              return lights[light.id] = uniforms, uniforms;
            } };
          }
          function ShadowUniformsCache() {
            let lights = {};
            return { get: function(light) {
              if (lights[light.id] !== void 0)
                return lights[light.id];
              let uniforms;
              switch (light.type) {
                case "DirectionalLight":
                  uniforms = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2() };
                  break;
                case "SpotLight":
                  uniforms = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2() };
                  break;
                case "PointLight":
                  uniforms = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
                  break;
              }
              return lights[light.id] = uniforms, uniforms;
            } };
          }
          let nextVersion = 0;
          function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
            return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
          }
          function WebGLLights(extensions) {
            let cache = new UniformsCache(), shadowCache = ShadowUniformsCache(), state = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 };
            for (let i = 0; i < 9; i++)
              state.probe.push(new Vector3());
            let vector3 = new Vector3(), matrix4 = new Matrix4(), matrix42 = new Matrix4();
            function setup(lights, useLegacyLights) {
              let r = 0, g = 0, b = 0;
              for (let i = 0; i < 9; i++)
                state.probe[i].set(0, 0, 0);
              let directionalLength = 0, pointLength = 0, spotLength = 0, rectAreaLength = 0, hemiLength = 0, numDirectionalShadows = 0, numPointShadows = 0, numSpotShadows = 0, numSpotMaps = 0, numSpotShadowsWithMaps = 0, numLightProbes = 0;
              lights.sort(shadowCastingAndTexturingLightsFirst);
              let scaleFactor = useLegacyLights === !0 ? Math.PI : 1;
              for (let i = 0, l = lights.length; i < l; i++) {
                let light = lights[i], color = light.color, intensity = light.intensity, distance = light.distance, shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
                if (light.isAmbientLight)
                  r += color.r * intensity * scaleFactor, g += color.g * intensity * scaleFactor, b += color.b * intensity * scaleFactor;
                else if (light.isLightProbe) {
                  for (let j = 0; j < 9; j++)
                    state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
                  numLightProbes++;
                } else if (light.isDirectionalLight) {
                  let uniforms = cache.get(light);
                  if (uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor), light.castShadow) {
                    let shadow = light.shadow, shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias, shadowUniforms.shadowNormalBias = shadow.normalBias, shadowUniforms.shadowRadius = shadow.radius, shadowUniforms.shadowMapSize = shadow.mapSize, state.directionalShadow[directionalLength] = shadowUniforms, state.directionalShadowMap[directionalLength] = shadowMap, state.directionalShadowMatrix[directionalLength] = light.shadow.matrix, numDirectionalShadows++;
                  }
                  state.directional[directionalLength] = uniforms, directionalLength++;
                } else if (light.isSpotLight) {
                  let uniforms = cache.get(light);
                  uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor), uniforms.distance = distance, uniforms.coneCos = Math.cos(light.angle), uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra)), uniforms.decay = light.decay, state.spot[spotLength] = uniforms;
                  let shadow = light.shadow;
                  if (light.map && (state.spotLightMap[numSpotMaps] = light.map, numSpotMaps++, shadow.updateMatrices(light), light.castShadow && numSpotShadowsWithMaps++), state.spotLightMatrix[spotLength] = shadow.matrix, light.castShadow) {
                    let shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias, shadowUniforms.shadowNormalBias = shadow.normalBias, shadowUniforms.shadowRadius = shadow.radius, shadowUniforms.shadowMapSize = shadow.mapSize, state.spotShadow[spotLength] = shadowUniforms, state.spotShadowMap[spotLength] = shadowMap, numSpotShadows++;
                  }
                  spotLength++;
                } else if (light.isRectAreaLight) {
                  let uniforms = cache.get(light);
                  uniforms.color.copy(color).multiplyScalar(intensity), uniforms.halfWidth.set(light.width * 0.5, 0, 0), uniforms.halfHeight.set(0, light.height * 0.5, 0), state.rectArea[rectAreaLength] = uniforms, rectAreaLength++;
                } else if (light.isPointLight) {
                  let uniforms = cache.get(light);
                  if (uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor), uniforms.distance = light.distance, uniforms.decay = light.decay, light.castShadow) {
                    let shadow = light.shadow, shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias, shadowUniforms.shadowNormalBias = shadow.normalBias, shadowUniforms.shadowRadius = shadow.radius, shadowUniforms.shadowMapSize = shadow.mapSize, shadowUniforms.shadowCameraNear = shadow.camera.near, shadowUniforms.shadowCameraFar = shadow.camera.far, state.pointShadow[pointLength] = shadowUniforms, state.pointShadowMap[pointLength] = shadowMap, state.pointShadowMatrix[pointLength] = light.shadow.matrix, numPointShadows++;
                  }
                  state.point[pointLength] = uniforms, pointLength++;
                } else if (light.isHemisphereLight) {
                  let uniforms = cache.get(light);
                  uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor), uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor), state.hemi[hemiLength] = uniforms, hemiLength++;
                }
              }
              rectAreaLength > 0 && (extensions.has("OES_texture_float_linear") === !0 ? (state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : (state.rectAreaLTC1 = UniformsLib.LTC_HALF_1, state.rectAreaLTC2 = UniformsLib.LTC_HALF_2)), state.ambient[0] = r, state.ambient[1] = g, state.ambient[2] = b;
              let hash = state.hash;
              (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) && (state.directional.length = directionalLength, state.spot.length = spotLength, state.rectArea.length = rectAreaLength, state.point.length = pointLength, state.hemi.length = hemiLength, state.directionalShadow.length = numDirectionalShadows, state.directionalShadowMap.length = numDirectionalShadows, state.pointShadow.length = numPointShadows, state.pointShadowMap.length = numPointShadows, state.spotShadow.length = numSpotShadows, state.spotShadowMap.length = numSpotShadows, state.directionalShadowMatrix.length = numDirectionalShadows, state.pointShadowMatrix.length = numPointShadows, state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps, state.spotLightMap.length = numSpotMaps, state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps, state.numLightProbes = numLightProbes, hash.directionalLength = directionalLength, hash.pointLength = pointLength, hash.spotLength = spotLength, hash.rectAreaLength = rectAreaLength, hash.hemiLength = hemiLength, hash.numDirectionalShadows = numDirectionalShadows, hash.numPointShadows = numPointShadows, hash.numSpotShadows = numSpotShadows, hash.numSpotMaps = numSpotMaps, hash.numLightProbes = numLightProbes, state.version = nextVersion++);
            }
            function setupView(lights, camera) {
              let directionalLength = 0, pointLength = 0, spotLength = 0, rectAreaLength = 0, hemiLength = 0, viewMatrix = camera.matrixWorldInverse;
              for (let i = 0, l = lights.length; i < l; i++) {
                let light = lights[i];
                if (light.isDirectionalLight) {
                  let uniforms = state.directional[directionalLength];
                  uniforms.direction.setFromMatrixPosition(light.matrixWorld), vector3.setFromMatrixPosition(light.target.matrixWorld), uniforms.direction.sub(vector3), uniforms.direction.transformDirection(viewMatrix), directionalLength++;
                } else if (light.isSpotLight) {
                  let uniforms = state.spot[spotLength];
                  uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), uniforms.direction.setFromMatrixPosition(light.matrixWorld), vector3.setFromMatrixPosition(light.target.matrixWorld), uniforms.direction.sub(vector3), uniforms.direction.transformDirection(viewMatrix), spotLength++;
                } else if (light.isRectAreaLight) {
                  let uniforms = state.rectArea[rectAreaLength];
                  uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), matrix42.identity(), matrix4.copy(light.matrixWorld), matrix4.premultiply(viewMatrix), matrix42.extractRotation(matrix4), uniforms.halfWidth.set(light.width * 0.5, 0, 0), uniforms.halfHeight.set(0, light.height * 0.5, 0), uniforms.halfWidth.applyMatrix4(matrix42), uniforms.halfHeight.applyMatrix4(matrix42), rectAreaLength++;
                } else if (light.isPointLight) {
                  let uniforms = state.point[pointLength];
                  uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), pointLength++;
                } else if (light.isHemisphereLight) {
                  let uniforms = state.hemi[hemiLength];
                  uniforms.direction.setFromMatrixPosition(light.matrixWorld), uniforms.direction.transformDirection(viewMatrix), hemiLength++;
                }
              }
            }
            return { setup, setupView, state };
          }
          function WebGLRenderState(extensions) {
            let lights = new WebGLLights(extensions), lightsArray = [], shadowsArray = [];
            function init(camera) {
              state.camera = camera, lightsArray.length = 0, shadowsArray.length = 0;
            }
            function pushLight(light) {
              lightsArray.push(light);
            }
            function pushShadow(shadowLight) {
              shadowsArray.push(shadowLight);
            }
            function setupLights(useLegacyLights) {
              lights.setup(lightsArray, useLegacyLights);
            }
            function setupLightsView(camera) {
              lights.setupView(lightsArray, camera);
            }
            let state = { lightsArray, shadowsArray, camera: null, lights, transmissionRenderTarget: {} };
            return { init, state, setupLights, setupLightsView, pushLight, pushShadow };
          }
          function WebGLRenderStates(extensions) {
            let renderStates = new WeakMap();
            function get(scene, renderCallDepth = 0) {
              let renderStateArray = renderStates.get(scene), renderState;
              return renderStateArray === void 0 ? (renderState = new WebGLRenderState(extensions), renderStates.set(scene, [renderState])) : renderCallDepth >= renderStateArray.length ? (renderState = new WebGLRenderState(extensions), renderStateArray.push(renderState)) : renderState = renderStateArray[renderCallDepth], renderState;
            }
            function dispose() {
              renderStates = new WeakMap();
            }
            return { get, dispose };
          }
          class MeshDepthMaterial extends Material {
            constructor(parameters) {
              super();
              this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.depthPacking = source.depthPacking, this.map = source.map, this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this;
            }
          }
          class MeshDistanceMaterial extends Material {
            constructor(parameters) {
              super();
              this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.map = source.map, this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this;
            }
          }
          let vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
          function WebGLShadowMap(renderer, objects, capabilities) {
            let _frustum2 = new Frustum(), _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize, shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide }, shadowMaterialVertical = new ShaderMaterial({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Vector2() }, radius: { value: 4 } }, vertexShader: vertex, fragmentShader: fragment }), shadowMaterialHorizontal = shadowMaterialVertical.clone();
            shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
            let fullScreenTri = new BufferGeometry();
            fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
            let fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical), scope = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap;
            let _previousType = this.type;
            this.render = function(lights, scene, camera) {
              if (scope.enabled === !1 || scope.autoUpdate === !1 && scope.needsUpdate === !1 || lights.length === 0)
                return;
              let currentRenderTarget = renderer.getRenderTarget(), activeCubeFace = renderer.getActiveCubeFace(), activeMipmapLevel = renderer.getActiveMipmapLevel(), _state = renderer.state;
              _state.setBlending(NoBlending), _state.buffers.color.setClear(1, 1, 1, 1), _state.buffers.depth.setTest(!0), _state.setScissorTest(!1);
              let toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap, fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
              for (let i = 0, il = lights.length; i < il; i++) {
                let light = lights[i], shadow = light.shadow;
                if (shadow === void 0) {
                  console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
                  continue;
                }
                if (shadow.autoUpdate === !1 && shadow.needsUpdate === !1)
                  continue;
                _shadowMapSize.copy(shadow.mapSize);
                let shadowFrameExtents = shadow.getFrameExtents();
                if (_shadowMapSize.multiply(shadowFrameExtents), _viewportSize.copy(shadow.mapSize), (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) && (_shadowMapSize.x > _maxTextureSize && (_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x), _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x, shadow.mapSize.x = _viewportSize.x), _shadowMapSize.y > _maxTextureSize && (_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y), _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y, shadow.mapSize.y = _viewportSize.y)), shadow.map === null || toVSM === !0 || fromVSM === !0) {
                  let pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
                  shadow.map !== null && shadow.map.dispose(), shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars), shadow.map.texture.name = light.name + ".shadowMap", shadow.camera.updateProjectionMatrix();
                }
                renderer.setRenderTarget(shadow.map), renderer.clear();
                let viewportCount = shadow.getViewportCount();
                for (let vp = 0; vp < viewportCount; vp++) {
                  let viewport = shadow.getViewport(vp);
                  _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w), _state.viewport(_viewport), shadow.updateMatrices(light, vp), _frustum2 = shadow.getFrustum(), renderObject(scene, camera, shadow.camera, light, this.type);
                }
                shadow.isPointLightShadow !== !0 && this.type === VSMShadowMap && VSMPass(shadow, camera), shadow.needsUpdate = !1;
              }
              _previousType = this.type, scope.needsUpdate = !1, renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
            };
            function VSMPass(shadow, camera) {
              let geometry = objects.update(fullScreenMesh);
              shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples && (shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples, shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples, shadowMaterialVertical.needsUpdate = !0, shadowMaterialHorizontal.needsUpdate = !0), shadow.mapPass === null && (shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y)), shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture, shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize, shadowMaterialVertical.uniforms.radius.value = shadow.radius, renderer.setRenderTarget(shadow.mapPass), renderer.clear(), renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null), shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture, shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize, shadowMaterialHorizontal.uniforms.radius.value = shadow.radius, renderer.setRenderTarget(shadow.map), renderer.clear(), renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
            }
            function getDepthMaterial(object, material, light, type) {
              let result = null, customMaterial = light.isPointLight === !0 ? object.customDistanceMaterial : object.customDepthMaterial;
              if (customMaterial !== void 0)
                result = customMaterial;
              else if (result = light.isPointLight === !0 ? _distanceMaterial : _depthMaterial, renderer.localClippingEnabled && material.clipShadows === !0 && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
                let keyA = result.uuid, keyB = material.uuid, materialsForVariant = _materialCache[keyA];
                materialsForVariant === void 0 && (materialsForVariant = {}, _materialCache[keyA] = materialsForVariant);
                let cachedMaterial = materialsForVariant[keyB];
                cachedMaterial === void 0 && (cachedMaterial = result.clone(), materialsForVariant[keyB] = cachedMaterial, material.addEventListener("dispose", onMaterialDispose)), result = cachedMaterial;
              }
              if (result.visible = material.visible, result.wireframe = material.wireframe, type === VSMShadowMap ? result.side = material.shadowSide !== null ? material.shadowSide : material.side : result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side], result.alphaMap = material.alphaMap, result.alphaTest = material.alphaTest, result.map = material.map, result.clipShadows = material.clipShadows, result.clippingPlanes = material.clippingPlanes, result.clipIntersection = material.clipIntersection, result.displacementMap = material.displacementMap, result.displacementScale = material.displacementScale, result.displacementBias = material.displacementBias, result.wireframeLinewidth = material.wireframeLinewidth, result.linewidth = material.linewidth, light.isPointLight === !0 && result.isMeshDistanceMaterial === !0) {
                let materialProperties = renderer.properties.get(result);
                materialProperties.light = light;
              }
              return result;
            }
            function renderObject(object, camera, shadowCamera, light, type) {
              if (object.visible === !1)
                return;
              if (object.layers.test(camera.layers) && (object.isMesh || object.isLine || object.isPoints) && (object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum2.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                let geometry = objects.update(object), material = object.material;
                if (Array.isArray(material)) {
                  let groups = geometry.groups;
                  for (let k = 0, kl = groups.length; k < kl; k++) {
                    let group = groups[k], groupMaterial = material[group.materialIndex];
                    if (groupMaterial && groupMaterial.visible) {
                      let depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
                      object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group), renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group), object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
                    }
                  }
                } else if (material.visible) {
                  let depthMaterial = getDepthMaterial(object, material, light, type);
                  object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null), renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null), object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
                }
              }
              let children = object.children;
              for (let i = 0, l = children.length; i < l; i++)
                renderObject(children[i], camera, shadowCamera, light, type);
            }
            function onMaterialDispose(event) {
              event.target.removeEventListener("dispose", onMaterialDispose);
              for (let id in _materialCache) {
                let cache = _materialCache[id], uuid = event.target.uuid;
                uuid in cache && (cache[uuid].dispose(), delete cache[uuid]);
              }
            }
          }
          function WebGLState(gl) {
            function ColorBuffer() {
              let locked = !1, color = new Vector4(), currentColorMask = null, currentColorClear = new Vector4(0, 0, 0, 0);
              return { setMask: function(colorMask) {
                currentColorMask !== colorMask && !locked && (gl.colorMask(colorMask, colorMask, colorMask, colorMask), currentColorMask = colorMask);
              }, setLocked: function(lock) {
                locked = lock;
              }, setClear: function(r, g, b, a, premultipliedAlpha) {
                premultipliedAlpha === !0 && (r *= a, g *= a, b *= a), color.set(r, g, b, a), currentColorClear.equals(color) === !1 && (gl.clearColor(r, g, b, a), currentColorClear.copy(color));
              }, reset: function() {
                locked = !1, currentColorMask = null, currentColorClear.set(-1, 0, 0, 0);
              } };
            }
            function DepthBuffer() {
              let locked = !1, currentDepthMask = null, currentDepthFunc = null, currentDepthClear = null;
              return { setTest: function(depthTest) {
                depthTest ? enable(gl.DEPTH_TEST) : disable(gl.DEPTH_TEST);
              }, setMask: function(depthMask) {
                currentDepthMask !== depthMask && !locked && (gl.depthMask(depthMask), currentDepthMask = depthMask);
              }, setFunc: function(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                  switch (depthFunc) {
                    case NeverDepth:
                      gl.depthFunc(gl.NEVER);
                      break;
                    case AlwaysDepth:
                      gl.depthFunc(gl.ALWAYS);
                      break;
                    case LessDepth:
                      gl.depthFunc(gl.LESS);
                      break;
                    case LessEqualDepth:
                      gl.depthFunc(gl.LEQUAL);
                      break;
                    case EqualDepth:
                      gl.depthFunc(gl.EQUAL);
                      break;
                    case GreaterEqualDepth:
                      gl.depthFunc(gl.GEQUAL);
                      break;
                    case GreaterDepth:
                      gl.depthFunc(gl.GREATER);
                      break;
                    case NotEqualDepth:
                      gl.depthFunc(gl.NOTEQUAL);
                      break;
                    default:
                      gl.depthFunc(gl.LEQUAL);
                  }
                  currentDepthFunc = depthFunc;
                }
              }, setLocked: function(lock) {
                locked = lock;
              }, setClear: function(depth) {
                currentDepthClear !== depth && (gl.clearDepth(depth), currentDepthClear = depth);
              }, reset: function() {
                locked = !1, currentDepthMask = null, currentDepthFunc = null, currentDepthClear = null;
              } };
            }
            function StencilBuffer() {
              let locked = !1, currentStencilMask = null, currentStencilFunc = null, currentStencilRef = null, currentStencilFuncMask = null, currentStencilFail = null, currentStencilZFail = null, currentStencilZPass = null, currentStencilClear = null;
              return { setTest: function(stencilTest) {
                locked || (stencilTest ? enable(gl.STENCIL_TEST) : disable(gl.STENCIL_TEST));
              }, setMask: function(stencilMask) {
                currentStencilMask !== stencilMask && !locked && (gl.stencilMask(stencilMask), currentStencilMask = stencilMask);
              }, setFunc: function(stencilFunc, stencilRef, stencilMask) {
                (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) && (gl.stencilFunc(stencilFunc, stencilRef, stencilMask), currentStencilFunc = stencilFunc, currentStencilRef = stencilRef, currentStencilFuncMask = stencilMask);
              }, setOp: function(stencilFail, stencilZFail, stencilZPass) {
                (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) && (gl.stencilOp(stencilFail, stencilZFail, stencilZPass), currentStencilFail = stencilFail, currentStencilZFail = stencilZFail, currentStencilZPass = stencilZPass);
              }, setLocked: function(lock) {
                locked = lock;
              }, setClear: function(stencil) {
                currentStencilClear !== stencil && (gl.clearStencil(stencil), currentStencilClear = stencil);
              }, reset: function() {
                locked = !1, currentStencilMask = null, currentStencilFunc = null, currentStencilRef = null, currentStencilFuncMask = null, currentStencilFail = null, currentStencilZFail = null, currentStencilZPass = null, currentStencilClear = null;
              } };
            }
            let colorBuffer = new ColorBuffer(), depthBuffer = new DepthBuffer(), stencilBuffer = new StencilBuffer(), uboBindings = new WeakMap(), uboProgramMap = new WeakMap(), enabledCapabilities = {}, currentBoundFramebuffers = {}, currentDrawbuffers = new WeakMap(), defaultDrawbuffers = [], currentProgram = null, currentBlendingEnabled = !1, currentBlending = null, currentBlendEquation = null, currentBlendSrc = null, currentBlendDst = null, currentBlendEquationAlpha = null, currentBlendSrcAlpha = null, currentBlendDstAlpha = null, currentBlendColor = new Color(0, 0, 0), currentBlendAlpha = 0, currentPremultipledAlpha = !1, currentFlipSided = null, currentCullFace = null, currentLineWidth = null, currentPolygonOffsetFactor = null, currentPolygonOffsetUnits = null, maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS), lineWidthAvailable = !1, version = 0, glVersion = gl.getParameter(gl.VERSION);
            glVersion.indexOf("WebGL") !== -1 ? (version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]), lineWidthAvailable = version >= 1) : glVersion.indexOf("OpenGL ES") !== -1 && (version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]), lineWidthAvailable = version >= 2);
            let currentTextureSlot = null, currentBoundTextures = {}, scissorParam = gl.getParameter(gl.SCISSOR_BOX), viewportParam = gl.getParameter(gl.VIEWPORT), currentScissor = new Vector4().fromArray(scissorParam), currentViewport = new Vector4().fromArray(viewportParam);
            function createTexture(type, target, count, dimensions) {
              let data = new Uint8Array(4), texture = gl.createTexture();
              gl.bindTexture(type, texture), gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST), gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
              for (let i = 0; i < count; i++)
                type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ? gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data) : gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
              return texture;
            }
            let emptyTextures = {};
            emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1), emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6), emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1), emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1), colorBuffer.setClear(0, 0, 0, 1), depthBuffer.setClear(1), stencilBuffer.setClear(0), enable(gl.DEPTH_TEST), depthBuffer.setFunc(LessEqualDepth), setFlipSided(!1), setCullFace(CullFaceBack), enable(gl.CULL_FACE), setBlending(NoBlending);
            function enable(id) {
              enabledCapabilities[id] !== !0 && (gl.enable(id), enabledCapabilities[id] = !0);
            }
            function disable(id) {
              enabledCapabilities[id] !== !1 && (gl.disable(id), enabledCapabilities[id] = !1);
            }
            function bindFramebuffer(target, framebuffer) {
              return currentBoundFramebuffers[target] !== framebuffer ? (gl.bindFramebuffer(target, framebuffer), currentBoundFramebuffers[target] = framebuffer, target === gl.DRAW_FRAMEBUFFER && (currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer), target === gl.FRAMEBUFFER && (currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer), !0) : !1;
            }
            function drawBuffers(renderTarget, framebuffer) {
              let drawBuffers2 = defaultDrawbuffers, needsUpdate = !1;
              if (renderTarget) {
                drawBuffers2 = currentDrawbuffers.get(framebuffer), drawBuffers2 === void 0 && (drawBuffers2 = [], currentDrawbuffers.set(framebuffer, drawBuffers2));
                let textures = renderTarget.textures;
                if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
                  for (let i = 0, il = textures.length; i < il; i++)
                    drawBuffers2[i] = gl.COLOR_ATTACHMENT0 + i;
                  drawBuffers2.length = textures.length, needsUpdate = !0;
                }
              } else
                drawBuffers2[0] !== gl.BACK && (drawBuffers2[0] = gl.BACK, needsUpdate = !0);
              needsUpdate && gl.drawBuffers(drawBuffers2);
            }
            function useProgram(program) {
              return currentProgram !== program ? (gl.useProgram(program), currentProgram = program, !0) : !1;
            }
            let equationToGL = { [AddEquation]: gl.FUNC_ADD, [SubtractEquation]: gl.FUNC_SUBTRACT, [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT };
            equationToGL[MinEquation] = gl.MIN, equationToGL[MaxEquation] = gl.MAX;
            let factorToGL = { [ZeroFactor]: gl.ZERO, [OneFactor]: gl.ONE, [SrcColorFactor]: gl.SRC_COLOR, [SrcAlphaFactor]: gl.SRC_ALPHA, [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE, [DstColorFactor]: gl.DST_COLOR, [DstAlphaFactor]: gl.DST_ALPHA, [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR, [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA, [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR, [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA, [ConstantColorFactor]: gl.CONSTANT_COLOR, [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR, [ConstantAlphaFactor]: gl.CONSTANT_ALPHA, [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA };
            function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
              if (blending === NoBlending) {
                currentBlendingEnabled === !0 && (disable(gl.BLEND), currentBlendingEnabled = !1);
                return;
              }
              if (currentBlendingEnabled === !1 && (enable(gl.BLEND), currentBlendingEnabled = !0), blending !== CustomBlending) {
                if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                  if ((currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) && (gl.blendEquation(gl.FUNC_ADD), currentBlendEquation = AddEquation, currentBlendEquationAlpha = AddEquation), premultipliedAlpha)
                    switch (blending) {
                      case NormalBlending:
                        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                      case AdditiveBlending:
                        gl.blendFunc(gl.ONE, gl.ONE);
                        break;
                      case SubtractiveBlending:
                        gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                        break;
                      case MultiplyBlending:
                        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                        break;
                      default:
                        console.error("THREE.WebGLState: Invalid blending: ", blending);
                        break;
                    }
                  else
                    switch (blending) {
                      case NormalBlending:
                        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                      case AdditiveBlending:
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        break;
                      case SubtractiveBlending:
                        gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                        break;
                      case MultiplyBlending:
                        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                        break;
                      default:
                        console.error("THREE.WebGLState: Invalid blending: ", blending);
                        break;
                    }
                  currentBlendSrc = null, currentBlendDst = null, currentBlendSrcAlpha = null, currentBlendDstAlpha = null, currentBlendColor.set(0, 0, 0), currentBlendAlpha = 0, currentBlending = blending, currentPremultipledAlpha = premultipliedAlpha;
                }
                return;
              }
              blendEquationAlpha = blendEquationAlpha || blendEquation, blendSrcAlpha = blendSrcAlpha || blendSrc, blendDstAlpha = blendDstAlpha || blendDst, (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) && (gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]), currentBlendEquation = blendEquation, currentBlendEquationAlpha = blendEquationAlpha), (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) && (gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]), currentBlendSrc = blendSrc, currentBlendDst = blendDst, currentBlendSrcAlpha = blendSrcAlpha, currentBlendDstAlpha = blendDstAlpha), (blendColor.equals(currentBlendColor) === !1 || blendAlpha !== currentBlendAlpha) && (gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha), currentBlendColor.copy(blendColor), currentBlendAlpha = blendAlpha), currentBlending = blending, currentPremultipledAlpha = !1;
            }
            function setMaterial(material, frontFaceCW) {
              material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
              let flipSided = material.side === BackSide;
              frontFaceCW && (flipSided = !flipSided), setFlipSided(flipSided), material.blending === NormalBlending && material.transparent === !1 ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha), depthBuffer.setFunc(material.depthFunc), depthBuffer.setTest(material.depthTest), depthBuffer.setMask(material.depthWrite), colorBuffer.setMask(material.colorWrite);
              let stencilWrite = material.stencilWrite;
              stencilBuffer.setTest(stencilWrite), stencilWrite && (stencilBuffer.setMask(material.stencilWriteMask), stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask), stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass)), setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits), material.alphaToCoverage === !0 ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
            }
            function setFlipSided(flipSided) {
              currentFlipSided !== flipSided && (flipSided ? gl.frontFace(gl.CW) : gl.frontFace(gl.CCW), currentFlipSided = flipSided);
            }
            function setCullFace(cullFace) {
              cullFace !== CullFaceNone ? (enable(gl.CULL_FACE), cullFace !== currentCullFace && (cullFace === CullFaceBack ? gl.cullFace(gl.BACK) : cullFace === CullFaceFront ? gl.cullFace(gl.FRONT) : gl.cullFace(gl.FRONT_AND_BACK))) : disable(gl.CULL_FACE), currentCullFace = cullFace;
            }
            function setLineWidth(width) {
              width !== currentLineWidth && (lineWidthAvailable && gl.lineWidth(width), currentLineWidth = width);
            }
            function setPolygonOffset(polygonOffset, factor, units) {
              polygonOffset ? (enable(gl.POLYGON_OFFSET_FILL), (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) && (gl.polygonOffset(factor, units), currentPolygonOffsetFactor = factor, currentPolygonOffsetUnits = units)) : disable(gl.POLYGON_OFFSET_FILL);
            }
            function setScissorTest(scissorTest) {
              scissorTest ? enable(gl.SCISSOR_TEST) : disable(gl.SCISSOR_TEST);
            }
            function activeTexture(webglSlot) {
              webglSlot === void 0 && (webglSlot = gl.TEXTURE0 + maxTextures - 1), currentTextureSlot !== webglSlot && (gl.activeTexture(webglSlot), currentTextureSlot = webglSlot);
            }
            function bindTexture(webglType, webglTexture, webglSlot) {
              webglSlot === void 0 && (currentTextureSlot === null ? webglSlot = gl.TEXTURE0 + maxTextures - 1 : webglSlot = currentTextureSlot);
              let boundTexture = currentBoundTextures[webglSlot];
              boundTexture === void 0 && (boundTexture = { type: void 0, texture: void 0 }, currentBoundTextures[webglSlot] = boundTexture), (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) && (currentTextureSlot !== webglSlot && (gl.activeTexture(webglSlot), currentTextureSlot = webglSlot), gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]), boundTexture.type = webglType, boundTexture.texture = webglTexture);
            }
            function unbindTexture() {
              let boundTexture = currentBoundTextures[currentTextureSlot];
              boundTexture !== void 0 && boundTexture.type !== void 0 && (gl.bindTexture(boundTexture.type, null), boundTexture.type = void 0, boundTexture.texture = void 0);
            }
            function compressedTexImage2D() {
              try {
                gl.compressedTexImage2D.apply(gl, arguments);
              } catch (error) {
                console.error("THREE.WebGLState:", error);
              }
            }
            function compressedTexImage3D() {
              try {
                gl.compressedTexImage3D.apply(gl, arguments);
              } catch (error) {
                console.error("THREE.WebGLState:", error);
              }
            }
            function texSubImage2D() {
              try {
                gl.texSubImage2D.apply(gl, arguments);
              } catch (error) {
                console.error("THREE.WebGLState:", error);
              }
            }
            function texSubImage3D() {
              try {
                gl.texSubImage3D.apply(gl, arguments);
              } catch (error) {
                console.error("THREE.WebGLState:", error);
              }
            }
            function compressedTexSubImage2D() {
              try {
                gl.compressedTexSubImage2D.apply(gl, arguments);
              } catch (error) {
                console.error("THREE.WebGLState:", error);
              }
            }
            function compressedTexSubImage3D() {
              try {
                gl.compressedTexSubImage3D.apply(gl, arguments);
              } catch (error) {
                console.error("THREE.WebGLState:", error);
              }
            }
            function texStorage2D() {
              try {
                gl.texStorage2D.apply(gl, arguments);
              } catch (error) {
                console.error("THREE.WebGLState:", error);
              }
            }
            function texStorage3D() {
              try {
                gl.texStorage3D.apply(gl, arguments);
              } catch (error) {
                console.error("THREE.WebGLState:", error);
              }
            }
            function texImage2D() {
              try {
                gl.texImage2D.apply(gl, arguments);
              } catch (error) {
                console.error("THREE.WebGLState:", error);
              }
            }
            function texImage3D() {
              try {
                gl.texImage3D.apply(gl, arguments);
              } catch (error) {
                console.error("THREE.WebGLState:", error);
              }
            }
            function scissor(scissor2) {
              currentScissor.equals(scissor2) === !1 && (gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w), currentScissor.copy(scissor2));
            }
            function viewport(viewport2) {
              currentViewport.equals(viewport2) === !1 && (gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w), currentViewport.copy(viewport2));
            }
            function updateUBOMapping(uniformsGroup, program) {
              let mapping = uboProgramMap.get(program);
              mapping === void 0 && (mapping = new WeakMap(), uboProgramMap.set(program, mapping));
              let blockIndex = mapping.get(uniformsGroup);
              blockIndex === void 0 && (blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name), mapping.set(uniformsGroup, blockIndex));
            }
            function uniformBlockBinding(uniformsGroup, program) {
              let blockIndex = uboProgramMap.get(program).get(uniformsGroup);
              uboBindings.get(program) !== blockIndex && (gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex), uboBindings.set(program, blockIndex));
            }
            function reset() {
              gl.disable(gl.BLEND), gl.disable(gl.CULL_FACE), gl.disable(gl.DEPTH_TEST), gl.disable(gl.POLYGON_OFFSET_FILL), gl.disable(gl.SCISSOR_TEST), gl.disable(gl.STENCIL_TEST), gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), gl.blendEquation(gl.FUNC_ADD), gl.blendFunc(gl.ONE, gl.ZERO), gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO), gl.blendColor(0, 0, 0, 0), gl.colorMask(!0, !0, !0, !0), gl.clearColor(0, 0, 0, 0), gl.depthMask(!0), gl.depthFunc(gl.LESS), gl.clearDepth(1), gl.stencilMask(4294967295), gl.stencilFunc(gl.ALWAYS, 0, 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP), gl.clearStencil(0), gl.cullFace(gl.BACK), gl.frontFace(gl.CCW), gl.polygonOffset(0, 0), gl.activeTexture(gl.TEXTURE0), gl.bindFramebuffer(gl.FRAMEBUFFER, null), gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null), gl.useProgram(null), gl.lineWidth(1), gl.scissor(0, 0, gl.canvas.width, gl.canvas.height), gl.viewport(0, 0, gl.canvas.width, gl.canvas.height), enabledCapabilities = {}, currentTextureSlot = null, currentBoundTextures = {}, currentBoundFramebuffers = {}, currentDrawbuffers = new WeakMap(), defaultDrawbuffers = [], currentProgram = null, currentBlendingEnabled = !1, currentBlending = null, currentBlendEquation = null, currentBlendSrc = null, currentBlendDst = null, currentBlendEquationAlpha = null, currentBlendSrcAlpha = null, currentBlendDstAlpha = null, currentBlendColor = new Color(0, 0, 0), currentBlendAlpha = 0, currentPremultipledAlpha = !1, currentFlipSided = null, currentCullFace = null, currentLineWidth = null, currentPolygonOffsetFactor = null, currentPolygonOffsetUnits = null, currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height), currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height), colorBuffer.reset(), depthBuffer.reset(), stencilBuffer.reset();
            }
            return { buffers: { color: colorBuffer, depth: depthBuffer, stencil: stencilBuffer }, enable, disable, bindFramebuffer, drawBuffers, useProgram, setBlending, setMaterial, setFlipSided, setCullFace, setLineWidth, setPolygonOffset, setScissorTest, activeTexture, bindTexture, unbindTexture, compressedTexImage2D, compressedTexImage3D, texImage2D, texImage3D, updateUBOMapping, uniformBlockBinding, texStorage2D, texStorage3D, texSubImage2D, texSubImage3D, compressedTexSubImage2D, compressedTexSubImage3D, scissor, viewport, reset };
          }
          function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
            let multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null, supportsInvalidateFramebuffer = typeof navigator == "undefined" ? !1 : /OculusBrowser/g.test(navigator.userAgent), multiviewExt = extensions.has("OCULUS_multiview") ? extensions.get("OCULUS_multiview") : null, _imageDimensions = new Vector2(), _videoTextures = new WeakMap(), _canvas2, _sources = new WeakMap(), _deferredUploads = [], _deferTextureUploads = !1, useOffscreenCanvas = !1;
            try {
              useOffscreenCanvas = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
            } catch (err) {
            }
            function createCanvas(width, height) {
              return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
            }
            function resizeImage(image, needsNewCanvas, maxSize) {
              let scale = 1, dimensions = getDimensions(image);
              if ((dimensions.width > maxSize || dimensions.height > maxSize) && (scale = maxSize / Math.max(dimensions.width, dimensions.height)), scale < 1)
                if (typeof HTMLImageElement != "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && image instanceof ImageBitmap || typeof VideoFrame != "undefined" && image instanceof VideoFrame) {
                  let width = Math.floor(scale * dimensions.width), height = Math.floor(scale * dimensions.height);
                  _canvas2 === void 0 && (_canvas2 = createCanvas(width, height));
                  let canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
                  return canvas.width = width, canvas.height = height, canvas.getContext("2d").drawImage(image, 0, 0, width, height), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + dimensions.width + "x" + dimensions.height + ") to (" + width + "x" + height + ")."), canvas;
                } else
                  return "data" in image && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + dimensions.width + "x" + dimensions.height + ")."), image;
              return image;
            }
            function textureNeedsGenerateMipmaps(texture) {
              return texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
            }
            function generateMipmap(target) {
              _gl.generateMipmap(target);
            }
            function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = !1) {
              if (internalFormatName !== null) {
                if (_gl[internalFormatName] !== void 0)
                  return _gl[internalFormatName];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
              }
              let internalFormat = glFormat;
              if (glFormat === _gl.RED && (glType === _gl.FLOAT && (internalFormat = _gl.R32F), glType === _gl.HALF_FLOAT && (internalFormat = _gl.R16F), glType === _gl.UNSIGNED_BYTE && (internalFormat = _gl.R8)), glFormat === _gl.RED_INTEGER && (glType === _gl.UNSIGNED_BYTE && (internalFormat = _gl.R8UI), glType === _gl.UNSIGNED_SHORT && (internalFormat = _gl.R16UI), glType === _gl.UNSIGNED_INT && (internalFormat = _gl.R32UI), glType === _gl.BYTE && (internalFormat = _gl.R8I), glType === _gl.SHORT && (internalFormat = _gl.R16I), glType === _gl.INT && (internalFormat = _gl.R32I)), glFormat === _gl.RG && (glType === _gl.FLOAT && (internalFormat = _gl.RG32F), glType === _gl.HALF_FLOAT && (internalFormat = _gl.RG16F), glType === _gl.UNSIGNED_BYTE && (internalFormat = _gl.RG8)), glFormat === _gl.RG_INTEGER && (glType === _gl.UNSIGNED_BYTE && (internalFormat = _gl.RG8UI), glType === _gl.UNSIGNED_SHORT && (internalFormat = _gl.RG16UI), glType === _gl.UNSIGNED_INT && (internalFormat = _gl.RG32UI), glType === _gl.BYTE && (internalFormat = _gl.RG8I), glType === _gl.SHORT && (internalFormat = _gl.RG16I), glType === _gl.INT && (internalFormat = _gl.RG32I)), glFormat === _gl.RGB && glType === _gl.UNSIGNED_INT_5_9_9_9_REV && (internalFormat = _gl.RGB9_E5), glFormat === _gl.RGBA) {
                let transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
                glType === _gl.FLOAT && (internalFormat = _gl.RGBA32F), glType === _gl.HALF_FLOAT && (internalFormat = _gl.RGBA16F), glType === _gl.UNSIGNED_BYTE && (internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8), glType === _gl.UNSIGNED_SHORT_4_4_4_4 && (internalFormat = _gl.RGBA4), glType === _gl.UNSIGNED_SHORT_5_5_5_1 && (internalFormat = _gl.RGB5_A1);
              }
              return (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) && extensions.get("EXT_color_buffer_float"), internalFormat;
            }
            function getMipLevels(texture, image) {
              return textureNeedsGenerateMipmaps(texture) === !0 || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ? Math.log2(Math.max(image.width, image.height)) + 1 : texture.mipmaps !== void 0 && texture.mipmaps.length > 0 ? texture.mipmaps.length : texture.isCompressedTexture && Array.isArray(texture.image) ? image.mipmaps.length : 1;
            }
            function onTextureDispose(event) {
              let texture = event.target;
              texture.removeEventListener("dispose", onTextureDispose), deallocateTexture(texture), texture.isVideoTexture && _videoTextures.delete(texture);
            }
            function onRenderTargetDispose(event) {
              let renderTarget = event.target;
              renderTarget.removeEventListener("dispose", onRenderTargetDispose), deallocateRenderTarget(renderTarget);
            }
            function deallocateTexture(texture) {
              let textureProperties = properties.get(texture);
              if (textureProperties.__webglInit === void 0)
                return;
              let source = texture.source, webglTextures = _sources.get(source);
              if (webglTextures) {
                let webglTexture = webglTextures[textureProperties.__cacheKey];
                webglTexture.usedTimes--, webglTexture.usedTimes === 0 && deleteTexture(texture), Object.keys(webglTextures).length === 0 && _sources.delete(source);
              }
              properties.remove(texture);
            }
            function deleteTexture(texture) {
              let textureProperties = properties.get(texture);
              _gl.deleteTexture(textureProperties.__webglTexture);
              let source = texture.source, webglTextures = _sources.get(source);
              delete webglTextures[textureProperties.__cacheKey], info.memory.textures--;
            }
            function deallocateRenderTarget(renderTarget) {
              let renderTargetProperties = properties.get(renderTarget);
              if (renderTarget.depthTexture && renderTarget.depthTexture.dispose(), renderTarget.isWebGLCubeRenderTarget)
                for (let i = 0; i < 6; i++) {
                  if (Array.isArray(renderTargetProperties.__webglFramebuffer[i]))
                    for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++)
                      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
                  else
                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                  renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                }
              else {
                if (Array.isArray(renderTargetProperties.__webglFramebuffer))
                  for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++)
                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
                else
                  _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                if (renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer), renderTargetProperties.__webglMultisampledFramebuffer && _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer), renderTargetProperties.__webglColorRenderbuffer)
                  for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++)
                    renderTargetProperties.__webglColorRenderbuffer[i] && _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
                renderTargetProperties.__webglDepthRenderbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
              }
              let textures = renderTarget.textures;
              for (let i = 0, il = textures.length; i < il; i++) {
                let attachmentProperties = properties.get(textures[i]);
                attachmentProperties.__webglTexture && (_gl.deleteTexture(attachmentProperties.__webglTexture), info.memory.textures--), properties.remove(textures[i]);
              }
              properties.remove(renderTarget);
            }
            let textureUnits = 0;
            function resetTextureUnits() {
              textureUnits = 0;
            }
            function allocateTextureUnit() {
              let textureUnit = textureUnits;
              return textureUnit >= capabilities.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures), textureUnits += 1, textureUnit;
            }
            function getTextureCacheKey(texture) {
              let array = [];
              return array.push(texture.wrapS), array.push(texture.wrapT), array.push(texture.wrapR || 0), array.push(texture.magFilter), array.push(texture.minFilter), array.push(texture.anisotropy), array.push(texture.internalFormat), array.push(texture.format), array.push(texture.type), array.push(texture.generateMipmaps), array.push(texture.premultiplyAlpha), array.push(texture.flipY), array.push(texture.unpackAlignment), array.push(texture.colorSpace), array.join();
            }
            function setTexture2D(texture, slot) {
              let textureProperties = properties.get(texture);
              if (texture.isVideoTexture && updateVideoTexture(texture), texture.isRenderTargetTexture === !1 && texture.version > 0 && textureProperties.__version !== texture.version) {
                let image = texture.image;
                if (image === null)
                  console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                else if (image.complete === !1)
                  console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
                else if (uploadTexture(textureProperties, texture, slot))
                  return;
              }
              state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
            }
            function setTexture2DArray(texture, slot) {
              let textureProperties = properties.get(texture);
              if (texture.version > 0 && textureProperties.__version !== texture.version) {
                uploadTexture(textureProperties, texture, slot);
                return;
              }
              state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
            }
            function setTexture3D(texture, slot) {
              let textureProperties = properties.get(texture);
              if (texture.version > 0 && textureProperties.__version !== texture.version) {
                uploadTexture(textureProperties, texture, slot);
                return;
              }
              state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
            }
            function setTextureCube(texture, slot) {
              let textureProperties = properties.get(texture);
              if (texture.version > 0 && textureProperties.__version !== texture.version) {
                uploadCubeTexture(textureProperties, texture, slot);
                return;
              }
              state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
            }
            let wrappingToGL = { [RepeatWrapping]: _gl.REPEAT, [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE, [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT }, filterToGL = { [NearestFilter]: _gl.NEAREST, [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST, [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR, [LinearFilter]: _gl.LINEAR, [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST, [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR }, compareToGL = { [NeverCompare]: _gl.NEVER, [AlwaysCompare]: _gl.ALWAYS, [LessCompare]: _gl.LESS, [LessEqualCompare]: _gl.LEQUAL, [EqualCompare]: _gl.EQUAL, [GreaterEqualCompare]: _gl.GEQUAL, [GreaterCompare]: _gl.GREATER, [NotEqualCompare]: _gl.NOTEQUAL };
            function setTextureParameters(textureType, texture) {
              if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === !1 && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]), _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]), (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) && _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]), _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]), _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]), texture.compareFunction && (_gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE), _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction])), extensions.has("EXT_texture_filter_anisotropic") === !0) {
                if (texture.magFilter === NearestFilter || texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter || texture.type === FloatType && extensions.has("OES_texture_float_linear") === !1)
                  return;
                if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                  let extension = extensions.get("EXT_texture_filter_anisotropic");
                  _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy())), properties.get(texture).__currentAnisotropy = texture.anisotropy;
                }
              }
            }
            function initTexture(textureProperties, texture) {
              let forceUpload = !1;
              textureProperties.__webglInit === void 0 && (textureProperties.__webglInit = !0, texture.addEventListener("dispose", onTextureDispose));
              let source = texture.source, webglTextures = _sources.get(source);
              webglTextures === void 0 && (webglTextures = {}, _sources.set(source, webglTextures));
              let textureCacheKey = getTextureCacheKey(texture);
              if (textureCacheKey !== textureProperties.__cacheKey) {
                webglTextures[textureCacheKey] === void 0 && (webglTextures[textureCacheKey] = { texture: _gl.createTexture(), usedTimes: 0 }, info.memory.textures++, forceUpload = !0), webglTextures[textureCacheKey].usedTimes++;
                let webglTexture = webglTextures[textureProperties.__cacheKey];
                webglTexture !== void 0 && (webglTextures[textureProperties.__cacheKey].usedTimes--, webglTexture.usedTimes === 0 && deleteTexture(texture)), textureProperties.__cacheKey = textureCacheKey, textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
              }
              return forceUpload;
            }
            function setDeferTextureUploads(deferFlag) {
              _deferTextureUploads = deferFlag;
            }
            function runDeferredUploads() {
              let previousDeferSetting = _deferTextureUploads;
              _deferTextureUploads = !1;
              for (let upload of _deferredUploads)
                uploadTexture(upload.textureProperties, upload.texture, upload.slot), upload.texture.isPendingDeferredUpload = !1;
              _deferredUploads = [], _deferTextureUploads = previousDeferSetting;
            }
            function uploadTexture(textureProperties, texture, slot) {
              if (_deferTextureUploads)
                return texture.isPendingDeferredUpload || (texture.isPendingDeferredUpload = !0, _deferredUploads.push({ textureProperties, texture, slot })), !1;
              let textureType = _gl.TEXTURE_2D;
              (texture.isDataArrayTexture || texture.isCompressedArrayTexture) && (textureType = _gl.TEXTURE_2D_ARRAY), texture.isData3DTexture && (textureType = _gl.TEXTURE_3D);
              let forceUpload = initTexture(textureProperties, texture), source = texture.source;
              state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
              let sourceProperties = properties.get(source);
              if (source.version !== sourceProperties.__version || forceUpload === !0) {
                state.activeTexture(_gl.TEXTURE0 + slot);
                let workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace), texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace), unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha), _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment), _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
                let image = resizeImage(texture.image, !1, capabilities.maxTextureSize);
                image = verifyColorSpace(texture, image);
                let glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
                setTextureParameters(textureType, texture);
                let mipmap, mipmaps = texture.mipmaps, useTexStorage = texture.isVideoTexture !== !0, allocateMemory = sourceProperties.__version === void 0 || forceUpload === !0, dataReady = source.dataReady, levels = getMipLevels(texture, image);
                if (texture.isDepthTexture)
                  glInternalFormat = _gl.DEPTH_COMPONENT16, texture.type === FloatType ? glInternalFormat = _gl.DEPTH_COMPONENT32F : texture.type === UnsignedIntType ? glInternalFormat = _gl.DEPTH_COMPONENT24 : texture.type === UnsignedInt248Type && (glInternalFormat = _gl.DEPTH24_STENCIL8), allocateMemory && (useTexStorage ? state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height) : state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null));
                else if (texture.isDataTexture)
                  if (mipmaps.length > 0) {
                    useTexStorage && allocateMemory && state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                    for (let i = 0, il = mipmaps.length; i < il; i++)
                      mipmap = mipmaps[i], useTexStorage ? dataReady && state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data) : state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    texture.generateMipmaps = !1;
                  } else
                    useTexStorage ? (allocateMemory && state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height), dataReady && state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data)) : state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                else if (texture.isCompressedTexture)
                  if (texture.isCompressedArrayTexture) {
                    useTexStorage && allocateMemory && state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
                    for (let i = 0, il = mipmaps.length; i < il; i++)
                      mipmap = mipmaps[i], texture.format !== RGBAFormat ? glFormat !== null ? useTexStorage ? dataReady && state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0) : state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : useTexStorage ? dataReady && state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data) : state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
                  } else {
                    useTexStorage && allocateMemory && state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                    for (let i = 0, il = mipmaps.length; i < il; i++)
                      mipmap = mipmaps[i], texture.format !== RGBAFormat ? glFormat !== null ? useTexStorage ? dataReady && state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data) : state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : useTexStorage ? dataReady && state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data) : state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                  }
                else if (texture.isDataArrayTexture)
                  useTexStorage ? (allocateMemory && state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth), dataReady && state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data)) : state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                else if (texture.isData3DTexture)
                  useTexStorage ? (allocateMemory && state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth), dataReady && state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data)) : state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                else if (texture.isFramebufferTexture) {
                  if (allocateMemory)
                    if (useTexStorage)
                      state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
                    else {
                      let width = image.width, height = image.height;
                      for (let i = 0; i < levels; i++)
                        state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null), width >>= 1, height >>= 1;
                    }
                } else if (mipmaps.length > 0) {
                  if (useTexStorage && allocateMemory) {
                    let dimensions = getDimensions(mipmaps[0]);
                    state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
                  }
                  for (let i = 0, il = mipmaps.length; i < il; i++)
                    mipmap = mipmaps[i], useTexStorage ? dataReady && state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap) : state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
                  texture.generateMipmaps = !1;
                } else if (useTexStorage) {
                  if (allocateMemory) {
                    let dimensions = getDimensions(image);
                    state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
                  }
                  dataReady && state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
                } else
                  state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
                textureNeedsGenerateMipmaps(texture) && generateMipmap(textureType), sourceProperties.__version = source.version, texture.onUpdate && texture.onUpdate(texture);
              }
              return textureProperties.__version = texture.version, !0;
            }
            function uploadCubeTexture(textureProperties, texture, slot) {
              if (texture.image.length !== 6)
                return;
              let forceUpload = initTexture(textureProperties, texture), source = texture.source;
              state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
              let sourceProperties = properties.get(source);
              if (source.version !== sourceProperties.__version || forceUpload === !0) {
                state.activeTexture(_gl.TEXTURE0 + slot);
                let workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace), texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace), unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha), _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment), _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
                let isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture, isDataTexture = texture.image[0] && texture.image[0].isDataTexture, cubeImage = [];
                for (let i = 0; i < 6; i++)
                  !isCompressed && !isDataTexture ? cubeImage[i] = resizeImage(texture.image[i], !0, capabilities.maxCubemapSize) : cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i], cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
                let image = cubeImage[0], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace), useTexStorage = texture.isVideoTexture !== !0, allocateMemory = sourceProperties.__version === void 0 || forceUpload === !0, dataReady = source.dataReady, levels = getMipLevels(texture, image);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
                let mipmaps;
                if (isCompressed) {
                  useTexStorage && allocateMemory && state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
                  for (let i = 0; i < 6; i++) {
                    mipmaps = cubeImage[i].mipmaps;
                    for (let j = 0; j < mipmaps.length; j++) {
                      let mipmap = mipmaps[j];
                      texture.format !== RGBAFormat ? glFormat !== null ? useTexStorage ? dataReady && state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data) : state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : useTexStorage ? dataReady && state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                  }
                } else {
                  if (mipmaps = texture.mipmaps, useTexStorage && allocateMemory) {
                    mipmaps.length > 0 && levels++;
                    let dimensions = getDimensions(cubeImage[0]);
                    state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
                  }
                  for (let i = 0; i < 6; i++)
                    if (isDataTexture) {
                      useTexStorage ? dataReady && state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                      for (let j = 0; j < mipmaps.length; j++) {
                        let mipmapImage = mipmaps[j].image[i].image;
                        useTexStorage ? dataReady && state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                      }
                    } else {
                      useTexStorage ? dataReady && state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
                      for (let j = 0; j < mipmaps.length; j++) {
                        let mipmap = mipmaps[j];
                        useTexStorage ? dataReady && state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
                      }
                    }
                }
                textureNeedsGenerateMipmaps(texture) && generateMipmap(_gl.TEXTURE_CUBE_MAP), sourceProperties.__version = source.version, texture.onUpdate && texture.onUpdate(texture);
              }
              textureProperties.__version = texture.version;
            }
            function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
              let glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
              if (!properties.get(renderTarget).__hasExternalTextures) {
                let width = Math.max(1, renderTarget.width >> level), height = Math.max(1, renderTarget.height >> level);
                renderTarget.isWebGLMultiviewRenderTarget === !0 ? state.texStorage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.numViews) : textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ? state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null) : state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
              }
              state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
              let multisampled = useMultisampledRTT(renderTarget);
              renderTarget.isWebGLMultiviewRenderTarget === !0 ? multisampled ? multiviewExt.framebufferTextureMultisampleMultiviewOVR(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget), 0, renderTarget.numViews) : multiviewExt.framebufferTextureMultiviewOVR(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(texture).__webglTexture, 0, 0, renderTarget.numViews) : (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) && (multisampled ? multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget)) : _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level)), state.bindFramebuffer(_gl.FRAMEBUFFER, null);
            }
            function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
              if (_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer), renderTarget.isWebGLMultiviewRenderTarget === !0) {
                let useMultisample = useMultisampledRTT(renderTarget), numViews = renderTarget.numViews, depthTexture = renderTarget.depthTexture, glInternalFormat = _gl.DEPTH_COMPONENT24, glDepthAttachment = _gl.DEPTH_ATTACHMENT;
                depthTexture && depthTexture.isDepthTexture && (depthTexture.type === FloatType ? glInternalFormat = _gl.DEPTH_COMPONENT32F : depthTexture.type === UnsignedInt248Type && (glInternalFormat = _gl.DEPTH24_STENCIL8, glDepthAttachment = _gl.DEPTH_STENCIL_ATTACHMENT));
                let depthStencilTexture = properties.get(renderTarget.depthTexture).__webglTexture;
                depthStencilTexture === void 0 && (depthStencilTexture = _gl.createTexture(), _gl.bindTexture(_gl.TEXTURE_2D_ARRAY, depthStencilTexture), _gl.texStorage3D(_gl.TEXTURE_2D_ARRAY, 1, glInternalFormat, renderTarget.width, renderTarget.height, numViews)), useMultisample ? multiviewExt.framebufferTextureMultisampleMultiviewOVR(_gl.FRAMEBUFFER, glDepthAttachment, depthStencilTexture, 0, getRenderTargetSamples(renderTarget), 0, numViews) : multiviewExt.framebufferTextureMultiviewOVR(_gl.FRAMEBUFFER, glDepthAttachment, depthStencilTexture, 0, 0, numViews);
              } else if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                let glInternalFormat = _gl.DEPTH_COMPONENT24;
                if (isMultisample || useMultisampledRTT(renderTarget)) {
                  let depthTexture = renderTarget.depthTexture;
                  depthTexture && depthTexture.isDepthTexture && (depthTexture.type === FloatType ? glInternalFormat = _gl.DEPTH_COMPONENT32F : depthTexture.type === UnsignedIntType && (glInternalFormat = _gl.DEPTH_COMPONENT24));
                  let samples = getRenderTargetSamples(renderTarget);
                  useMultisampledRTT(renderTarget) ? multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height) : _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                } else
                  _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
              } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                let samples = getRenderTargetSamples(renderTarget);
                isMultisample && useMultisampledRTT(renderTarget) === !1 ? _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height) : useMultisampledRTT(renderTarget) ? multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height) : _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height), _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
              } else {
                let textures = renderTarget.textures;
                for (let i = 0; i < textures.length; i++) {
                  let texture = textures[i], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace), samples = getRenderTargetSamples(renderTarget);
                  isMultisample && useMultisampledRTT(renderTarget) === !1 ? _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height) : useMultisampledRTT(renderTarget) ? multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height) : _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
                }
              }
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
            }
            function setupDepthTexture(framebuffer, renderTarget) {
              if (renderTarget && renderTarget.isWebGLCubeRenderTarget)
                throw new Error("Depth Texture with cube render targets is not supported");
              if (state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), !(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture))
                throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
              (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) && (renderTarget.depthTexture.image.width = renderTarget.width, renderTarget.depthTexture.image.height = renderTarget.height, renderTarget.depthTexture.needsUpdate = !0), setTexture2D(renderTarget.depthTexture, 0), renderTarget.depthTexture.image.depth != 1 ? setTexture2DArray(renderTarget.depthTexture, 0) : setTexture2D(renderTarget.depthTexture, 0);
              let webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture, samples = getRenderTargetSamples(renderTarget);
              if (renderTarget.isWebGLMultiviewRenderTarget === !0) {
                let useMultisample = useMultisampledRTT(renderTarget), numViews = renderTarget.numViews;
                if (renderTarget.depthTexture.format === DepthFormat)
                  useMultisample ? multiviewExt.framebufferTextureMultisampleMultiviewOVR(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, webglDepthTexture, 0, samples, 0, numViews) : multiviewExt.framebufferTextureMultiviewOVR(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, webglDepthTexture, 0, 0, numViews);
                else if (renderTarget.depthTexture.format === DepthStencilFormat)
                  useMultisample ? multiviewExt.framebufferTextureMultisampleMultiviewOVR(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, webglDepthTexture, 0, samples, 0, numViews) : multiviewExt.framebufferTextureMultiviewOVR(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, webglDepthTexture, 0, 0, numViews);
                else
                  throw new Error("Unknown depthTexture format");
              } else if (renderTarget.depthTexture.format === DepthFormat)
                useMultisampledRTT(renderTarget) ? multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples) : _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
              else if (renderTarget.depthTexture.format === DepthStencilFormat)
                useMultisampledRTT(renderTarget) ? multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples) : _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
              else
                throw new Error("Unknown depthTexture format");
            }
            function setupDepthRenderbuffer(renderTarget) {
              let renderTargetProperties = properties.get(renderTarget), isCube = renderTarget.isWebGLCubeRenderTarget === !0;
              if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
                if (isCube)
                  throw new Error("target.depthTexture not supported in Cube render targets");
                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
              } else if (isCube) {
                renderTargetProperties.__webglDepthbuffer = [];
                for (let i = 0; i < 6; i++)
                  state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]), renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, !1);
              } else
                state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer), renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, !1);
              state.bindFramebuffer(_gl.FRAMEBUFFER, null);
            }
            function rebindTextures(renderTarget, colorTexture, depthTexture) {
              let renderTargetProperties = properties.get(renderTarget);
              colorTexture !== void 0 && setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0), depthTexture !== void 0 && setupDepthRenderbuffer(renderTarget);
            }
            function setupRenderTarget(renderTarget) {
              let texture = renderTarget.texture, renderTargetProperties = properties.get(renderTarget), textureProperties = properties.get(texture);
              renderTarget.addEventListener("dispose", onRenderTargetDispose);
              let textures = renderTarget.textures, isCube = renderTarget.isWebGLCubeRenderTarget === !0, isMultipleRenderTargets = textures.length > 1;
              if (isMultipleRenderTargets || (textureProperties.__webglTexture === void 0 && (textureProperties.__webglTexture = _gl.createTexture()), textureProperties.__version = texture.version, info.memory.textures++), isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (let i = 0; i < 6; i++)
                  if (texture.mipmaps && texture.mipmaps.length > 0) {
                    renderTargetProperties.__webglFramebuffer[i] = [];
                    for (let level = 0; level < texture.mipmaps.length; level++)
                      renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();
                  } else
                    renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
              } else {
                if (texture.mipmaps && texture.mipmaps.length > 0) {
                  renderTargetProperties.__webglFramebuffer = [];
                  for (let level = 0; level < texture.mipmaps.length; level++)
                    renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
                } else
                  renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
                if (isMultipleRenderTargets)
                  for (let i = 0, il = textures.length; i < il; i++) {
                    let attachmentProperties = properties.get(textures[i]);
                    attachmentProperties.__webglTexture === void 0 && (attachmentProperties.__webglTexture = _gl.createTexture(), info.memory.textures++);
                  }
                if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === !1) {
                  renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer(), renderTargetProperties.__webglColorRenderbuffer = [], state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                  for (let i = 0; i < textures.length; i++) {
                    let texture2 = textures[i];
                    renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer(), _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
                    let glFormat = utils.convert(texture2.format, texture2.colorSpace), glType = utils.convert(texture2.type), glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === !0), samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height), _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
                  }
                  _gl.bindRenderbuffer(_gl.RENDERBUFFER, null), renderTarget.depthBuffer && (renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, !0)), state.bindFramebuffer(_gl.FRAMEBUFFER, null);
                }
              }
              if (isCube) {
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture), setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
                for (let i = 0; i < 6; i++)
                  if (texture.mipmaps && texture.mipmaps.length > 0)
                    for (let level = 0; level < texture.mipmaps.length; level++)
                      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);
                  else
                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
                textureNeedsGenerateMipmaps(texture) && generateMipmap(_gl.TEXTURE_CUBE_MAP), state.unbindTexture();
              } else if (isMultipleRenderTargets) {
                for (let i = 0, il = textures.length; i < il; i++) {
                  let attachment = textures[i], attachmentProperties = properties.get(attachment);
                  state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture), setTextureParameters(_gl.TEXTURE_2D, attachment), setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0), textureNeedsGenerateMipmaps(attachment) && generateMipmap(_gl.TEXTURE_2D);
                }
                state.unbindTexture();
              } else {
                let glTextureType = _gl.TEXTURE_2D;
                if ((renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) && (glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY), renderTarget.isWebGLMultiviewRenderTarget === !0 && (glTextureType = _gl.TEXTURE_2D_ARRAY), state.bindTexture(glTextureType, textureProperties.__webglTexture), setTextureParameters(glTextureType, texture), texture.mipmaps && texture.mipmaps.length > 0)
                  for (let level = 0; level < texture.mipmaps.length; level++)
                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
                else
                  setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
                textureNeedsGenerateMipmaps(texture) && generateMipmap(glTextureType), state.unbindTexture();
              }
              (renderTarget.depthBuffer || renderTarget.isWebGLMultiviewRenderTarget === !0) && this.setupDepthRenderbuffer(renderTarget);
            }
            function updateRenderTargetMipmap(renderTarget) {
              let textures = renderTarget.textures;
              for (let i = 0, il = textures.length; i < il; i++) {
                let texture = textures[i];
                if (textureNeedsGenerateMipmaps(texture)) {
                  let target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D, webglTexture = properties.get(texture).__webglTexture;
                  state.bindTexture(target, webglTexture), generateMipmap(target), state.unbindTexture();
                }
              }
            }
            let invalidationArrayRead = [], invalidationArrayDraw = [];
            function updateMultisampleRenderTarget(renderTarget) {
              if (renderTarget.samples > 0) {
                if (useMultisampledRTT(renderTarget) === !1) {
                  let textures = renderTarget.textures, width = renderTarget.width, height = renderTarget.height, mask = _gl.COLOR_BUFFER_BIT, depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT, renderTargetProperties = properties.get(renderTarget), isMultipleRenderTargets = textures.length > 1;
                  if (isMultipleRenderTargets)
                    for (let i = 0; i < textures.length; i++)
                      state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer), _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null), state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer), _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
                  state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer), state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                  for (let i = 0; i < textures.length; i++) {
                    if (renderTarget.resolveDepthBuffer && (renderTarget.depthBuffer && (mask |= _gl.DEPTH_BUFFER_BIT), renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer && (mask |= _gl.STENCIL_BUFFER_BIT)), isMultipleRenderTargets) {
                      _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
                      let webglTexture = properties.get(textures[i]).__webglTexture;
                      _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
                    }
                    _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST), supportsInvalidateFramebuffer === !0 && (invalidationArrayRead.length = 0, invalidationArrayDraw.length = 0, invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i), renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === !1 && (invalidationArrayRead.push(depthStyle), invalidationArrayDraw.push(depthStyle), _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw)), _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead));
                  }
                  if (state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null), state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null), isMultipleRenderTargets)
                    for (let i = 0; i < textures.length; i++) {
                      state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer), _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
                      let webglTexture = properties.get(textures[i]).__webglTexture;
                      state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer), _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
                    }
                  state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                } else if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === !1 && supportsInvalidateFramebuffer) {
                  let depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
                  _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
                }
              }
            }
            function getRenderTargetSamples(renderTarget) {
              return Math.min(capabilities.maxSamples, renderTarget.samples);
            }
            function useMultisampledRTT(renderTarget) {
              let renderTargetProperties = properties.get(renderTarget);
              return renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === !0 && renderTargetProperties.__useRenderToTexture !== !1;
            }
            function updateVideoTexture(texture) {
              let frame = info.render.frame;
              _videoTextures.get(texture) !== frame && (_videoTextures.set(texture, frame), texture.update());
            }
            function verifyColorSpace(texture, image) {
              let colorSpace = texture.colorSpace, format = texture.format, type = texture.type;
              return texture.isCompressedTexture === !0 || texture.isVideoTexture === !0 || colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace && (ColorManagement.getTransfer(colorSpace) === SRGBTransfer ? (format !== RGBAFormat || type !== UnsignedByteType) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace)), image;
            }
            function getDimensions(image) {
              return typeof HTMLImageElement != "undefined" && image instanceof HTMLImageElement ? (_imageDimensions.width = image.naturalWidth || image.width, _imageDimensions.height = image.naturalHeight || image.height) : typeof VideoFrame != "undefined" && image instanceof VideoFrame ? (_imageDimensions.width = image.displayWidth, _imageDimensions.height = image.displayHeight) : (_imageDimensions.width = image.width, _imageDimensions.height = image.height), _imageDimensions;
            }
            this.allocateTextureUnit = allocateTextureUnit, this.resetTextureUnits = resetTextureUnits, this.setTexture2D = setTexture2D, this.setTexture2DArray = setTexture2DArray, this.setTexture3D = setTexture3D, this.setTextureCube = setTextureCube, this.rebindTextures = rebindTextures, this.uploadTexture = uploadTexture, this.setupRenderTarget = setupRenderTarget, this.updateRenderTargetMipmap = updateRenderTargetMipmap, this.updateMultisampleRenderTarget = updateMultisampleRenderTarget, this.setupDepthTexture = setupDepthTexture, this.setupDepthRenderbuffer = setupDepthRenderbuffer, this.setupFrameBufferTexture = setupFrameBufferTexture, this.useMultisampledRTT = useMultisampledRTT, this.runDeferredUploads = runDeferredUploads, this.setDeferTextureUploads = setDeferTextureUploads;
          }
          function WebGLUtils(gl, extensions) {
            function convert(p, colorSpace = NoColorSpace) {
              let extension, transfer = ColorManagement.getTransfer(colorSpace);
              if (p === UnsignedByteType)
                return gl.UNSIGNED_BYTE;
              if (p === UnsignedShort4444Type)
                return gl.UNSIGNED_SHORT_4_4_4_4;
              if (p === UnsignedShort5551Type)
                return gl.UNSIGNED_SHORT_5_5_5_1;
              if (p === UnsignedInt5999Type)
                return gl.UNSIGNED_INT_5_9_9_9_REV;
              if (p === ByteType)
                return gl.BYTE;
              if (p === ShortType)
                return gl.SHORT;
              if (p === UnsignedShortType)
                return gl.UNSIGNED_SHORT;
              if (p === IntType)
                return gl.INT;
              if (p === UnsignedIntType)
                return gl.UNSIGNED_INT;
              if (p === FloatType)
                return gl.FLOAT;
              if (p === HalfFloatType)
                return gl.HALF_FLOAT;
              if (p === AlphaFormat)
                return gl.ALPHA;
              if (p === RGBFormat)
                return gl.RGB;
              if (p === RGBAFormat)
                return gl.RGBA;
              if (p === LuminanceFormat)
                return gl.LUMINANCE;
              if (p === LuminanceAlphaFormat)
                return gl.LUMINANCE_ALPHA;
              if (p === DepthFormat)
                return gl.DEPTH_COMPONENT;
              if (p === DepthStencilFormat)
                return gl.DEPTH_STENCIL;
              if (p === RedFormat)
                return gl.RED;
              if (p === RedIntegerFormat)
                return gl.RED_INTEGER;
              if (p === RGFormat)
                return gl.RG;
              if (p === RGIntegerFormat)
                return gl.RG_INTEGER;
              if (p === RGBAIntegerFormat)
                return gl.RGBA_INTEGER;
              if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format)
                if (transfer === SRGBTransfer)
                  if (extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb"), extension !== null) {
                    if (p === RGB_S3TC_DXT1_Format)
                      return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT1_Format)
                      return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT3_Format)
                      return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (p === RGBA_S3TC_DXT5_Format)
                      return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                  } else
                    return null;
                else if (extension = extensions.get("WEBGL_compressed_texture_s3tc"), extension !== null) {
                  if (p === RGB_S3TC_DXT1_Format)
                    return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                  if (p === RGBA_S3TC_DXT1_Format)
                    return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                  if (p === RGBA_S3TC_DXT3_Format)
                    return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                  if (p === RGBA_S3TC_DXT5_Format)
                    return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                } else
                  return null;
              if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format)
                if (extension = extensions.get("WEBGL_compressed_texture_pvrtc"), extension !== null) {
                  if (p === RGB_PVRTC_4BPPV1_Format)
                    return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                  if (p === RGB_PVRTC_2BPPV1_Format)
                    return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                  if (p === RGBA_PVRTC_4BPPV1_Format)
                    return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                  if (p === RGBA_PVRTC_2BPPV1_Format)
                    return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                } else
                  return null;
              if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format)
                if (extension = extensions.get("WEBGL_compressed_texture_etc"), extension !== null) {
                  if (p === RGB_ETC1_Format || p === RGB_ETC2_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
                  if (p === RGBA_ETC2_EAC_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
                } else
                  return null;
              if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format)
                if (extension = extensions.get("WEBGL_compressed_texture_astc"), extension !== null) {
                  if (p === RGBA_ASTC_4x4_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
                  if (p === RGBA_ASTC_5x4_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
                  if (p === RGBA_ASTC_5x5_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
                  if (p === RGBA_ASTC_6x5_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
                  if (p === RGBA_ASTC_6x6_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
                  if (p === RGBA_ASTC_8x5_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
                  if (p === RGBA_ASTC_8x6_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
                  if (p === RGBA_ASTC_8x8_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
                  if (p === RGBA_ASTC_10x5_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
                  if (p === RGBA_ASTC_10x6_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
                  if (p === RGBA_ASTC_10x8_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
                  if (p === RGBA_ASTC_10x10_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
                  if (p === RGBA_ASTC_12x10_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
                  if (p === RGBA_ASTC_12x12_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
                } else
                  return null;
              if (p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format)
                if (extension = extensions.get("EXT_texture_compression_bptc"), extension !== null) {
                  if (p === RGBA_BPTC_Format)
                    return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                  if (p === RGB_BPTC_SIGNED_Format)
                    return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                  if (p === RGB_BPTC_UNSIGNED_Format)
                    return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
                } else
                  return null;
              if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format)
                if (extension = extensions.get("EXT_texture_compression_rgtc"), extension !== null) {
                  if (p === RGBA_BPTC_Format)
                    return extension.COMPRESSED_RED_RGTC1_EXT;
                  if (p === SIGNED_RED_RGTC1_Format)
                    return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                  if (p === RED_GREEN_RGTC2_Format)
                    return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
                  if (p === SIGNED_RED_GREEN_RGTC2_Format)
                    return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
                } else
                  return null;
              return p === UnsignedInt248Type ? gl.UNSIGNED_INT_24_8 : gl[p] !== void 0 ? gl[p] : null;
            }
            return { convert };
          }
          class Group extends Object3D {
            constructor() {
              super();
              this.isGroup = !0, this.type = "Group";
            }
          }
          class ArrayCamera extends PerspectiveCamera {
            constructor(array = []) {
              super();
              this.isArrayCamera = !0, this.cameras = array;
            }
          }
          var cameraLPos = new Vector3(), cameraRPos = new Vector3();
          function setProjectionFromUnion(camera, cameraL, cameraR) {
            cameraLPos.setFromMatrixPosition(cameraL.matrixWorld), cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
            var ipd = cameraLPos.distanceTo(cameraRPos), projL = cameraL.projectionMatrix.elements, projR = cameraR.projectionMatrix.elements, near = projL[14] / (projL[10] - 1), far = projL[14] / (projL[10] + 1), topFov = (projL[9] + 1) / projL[5], bottomFov = (projL[9] - 1) / projL[5], leftFov = (projL[8] - 1) / projL[0], rightFov = (projR[8] + 1) / projR[0], left = near * leftFov, right = near * rightFov, zOffset = ipd / (-leftFov + rightFov), xOffset = zOffset * -leftFov;
            cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale), camera.translateX(xOffset), camera.translateZ(zOffset), camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale), camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            var near2 = near + zOffset, far2 = far + zOffset, left2 = left - xOffset, right2 = right + (ipd - xOffset), top2 = topFov * far / far2 * near2, bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
          }
          function WebVRManager(renderer) {
            var renderWidth, renderHeight, scope = this, device = null, frameData = null, poseTarget = null, controllers = [], standingMatrix = new Matrix4(), standingMatrixInverse = new Matrix4(), framebufferScaleFactor = 1, referenceSpaceType = "local-floor";
            typeof window != "undefined" && "VRFrameData" in window && (frameData = new window.VRFrameData(), window.addEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, !1));
            var matrixWorldInverse = new Matrix4(), tempQuaternion = new Quaternion(), tempPosition = new Vector3(), cameraL = new PerspectiveCamera();
            cameraL.viewport = new Vector4(), cameraL.layers.enable(1);
            var cameraR = new PerspectiveCamera();
            cameraR.viewport = new Vector4(), cameraR.layers.enable(2);
            var cameraVR = new ArrayCamera([cameraL, cameraR]);
            cameraVR.layers.enable(1), cameraVR.layers.enable(2);
            var currentSize = new Vector2(), currentPixelRatio;
            function onVRDisplayPresentChange() {
              var isPresenting = scope.isPresenting = device !== null && device.isPresenting === !0;
              if (isPresenting) {
                var eyeParameters = device.getEyeParameters("left");
                renderWidth = 2 * eyeParameters.renderWidth * framebufferScaleFactor, renderHeight = eyeParameters.renderHeight * framebufferScaleFactor, currentPixelRatio = renderer.getPixelRatio(), renderer.getSize(currentSize), renderer.setDrawingBufferSize(renderWidth, renderHeight, 1), cameraL.viewport.set(0, 0, renderWidth / 2, renderHeight), cameraR.viewport.set(renderWidth / 2, 0, renderWidth / 2, renderHeight), animation.start(), scope.dispatchEvent({ type: "sessionstart" });
              } else
                scope.enabled && renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio), animation.stop(), scope.dispatchEvent({ type: "sessionend" });
            }
            var triggers = [], grips = [];
            function findGamepad(id) {
              for (var gamepads = navigator.getGamepads && navigator.getGamepads(), i = 0, l = gamepads.length; i < l; i++) {
                var gamepad = gamepads[i];
                if (gamepad && (gamepad.id === "Daydream Controller" || gamepad.id === "Gear VR Controller" || gamepad.id === "Oculus Go Controller" || gamepad.id === "OpenVR Gamepad" || gamepad.id.startsWith("Oculus Touch") || gamepad.id.startsWith("HTC Vive Focus") || gamepad.id.startsWith("Spatial Controller"))) {
                  var hand = gamepad.hand;
                  if (id === 0 && (hand === "" || hand === "right") || id === 1 && hand === "left")
                    return gamepad;
                }
              }
            }
            function updateControllers() {
              for (var i = 0; i < controllers.length; i++) {
                var controller = controllers[i], gamepad = findGamepad(i);
                if (gamepad !== void 0 && gamepad.pose !== void 0) {
                  if (gamepad.pose === null)
                    return;
                  var pose = gamepad.pose;
                  pose.hasPosition === !1 && controller.position.set(0.2, -0.6, -0.05), pose.position !== null && controller.position.fromArray(pose.position), pose.orientation !== null && controller.quaternion.fromArray(pose.orientation), controller.matrix.compose(controller.position, controller.quaternion, controller.scale), controller.matrix.premultiply(standingMatrix), controller.matrix.decompose(controller.position, controller.quaternion, controller.scale), controller.matrixWorldNeedsUpdate = !0, controller.visible = !0;
                  var buttonId = gamepad.id === "Daydream Controller" ? 0 : 1;
                  triggers[i] === void 0 && (triggers[i] = !1), triggers[i] !== gamepad.buttons[buttonId].pressed && (triggers[i] = gamepad.buttons[buttonId].pressed, triggers[i] === !0 ? controller.dispatchEvent({ type: "selectstart" }) : (controller.dispatchEvent({ type: "selectend" }), controller.dispatchEvent({ type: "select" }))), buttonId = 2, grips[i] === void 0 && (grips[i] = !1), gamepad.buttons[buttonId] !== void 0 && grips[i] !== gamepad.buttons[buttonId].pressed && (grips[i] = gamepad.buttons[buttonId].pressed, grips[i] === !0 ? controller.dispatchEvent({ type: "squeezestart" }) : (controller.dispatchEvent({ type: "squeezeend" }), controller.dispatchEvent({ type: "squeeze" })));
                } else
                  controller.visible = !1;
              }
            }
            function updateViewportFromBounds(viewport, bounds) {
              bounds !== null && bounds.length === 4 && viewport.set(bounds[0] * renderWidth, bounds[1] * renderHeight, bounds[2] * renderWidth, bounds[3] * renderHeight);
            }
            this.enabled = !1, this.getController = function(id) {
              var controller = controllers[id];
              return controller === void 0 && (controller = new Group(), controller.matrixAutoUpdate = !1, controller.visible = !1, controllers[id] = controller), controller;
            }, this.getDevice = function() {
              return device;
            }, this.setDevice = function(value) {
              value !== void 0 && (device = value), animation.setContext(value);
            }, this.setFramebufferScaleFactor = function(value) {
              framebufferScaleFactor = value;
            }, this.setReferenceSpaceType = function(value) {
              referenceSpaceType = value;
            }, this.setPoseTarget = function(object) {
              object !== void 0 && (poseTarget = object);
            }, this.cameraAutoUpdate = !0, this.updateCamera = function(camera) {
              var userHeight = referenceSpaceType === "local-floor" ? 1.6 : 0;
              if (device.depthNear = camera.near, device.depthFar = camera.far, device.getFrameData(frameData), referenceSpaceType === "local-floor") {
                var stageParameters = device.stageParameters;
                stageParameters ? standingMatrix.fromArray(stageParameters.sittingToStandingTransform) : standingMatrix.makeTranslation(0, userHeight, 0);
              }
              var pose = frameData.pose, poseObject = poseTarget !== null ? poseTarget : camera;
              poseObject.matrix.copy(standingMatrix), poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale), pose.orientation !== null && (tempQuaternion.fromArray(pose.orientation), poseObject.quaternion.multiply(tempQuaternion)), pose.position !== null && (tempQuaternion.setFromRotationMatrix(standingMatrix), tempPosition.fromArray(pose.position), tempPosition.applyQuaternion(tempQuaternion), poseObject.position.add(tempPosition)), poseObject.updateMatrixWorld();
              for (var children = poseObject.children, i = 0, l = children.length; i < l; i++)
                children[i].updateMatrixWorld(!0);
              cameraL.near = camera.near, cameraR.near = camera.near, cameraL.far = camera.far, cameraR.far = camera.far, cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix), cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix), standingMatrixInverse.copy(standingMatrix).invert(), referenceSpaceType === "local-floor" && (cameraL.matrixWorldInverse.multiply(standingMatrixInverse), cameraR.matrixWorldInverse.multiply(standingMatrixInverse));
              var parent = poseObject.parent;
              parent !== null && (matrixWorldInverse.copy(parent.matrixWorld).invert(), cameraL.matrixWorldInverse.multiply(matrixWorldInverse), cameraR.matrixWorldInverse.multiply(matrixWorldInverse)), cameraL.matrixWorld.copy(cameraL.matrixWorldInverse).invert(), cameraR.matrixWorld.copy(cameraR.matrixWorldInverse).invert(), cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix), cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix), setProjectionFromUnion(cameraVR, cameraL, cameraR);
              var layers = device.getLayers();
              if (layers.length) {
                var layer = layers[0];
                updateViewportFromBounds(cameraL.viewport, layer.leftBounds), updateViewportFromBounds(cameraR.viewport, layer.rightBounds);
              }
              return updateControllers(), cameraVR;
            }, this.getCamera = function() {
              return cameraVR;
            }, this.getFoveation = function() {
              return 1;
            }, this.setFoveation = function(foveation) {
              foveation !== 1 && console.warn("THREE.WebVRManager: setFoveation() not used in WebVR.");
            }, this.getEnvironmentBlendMode = function() {
              if (scope.isPresenting)
                return "opaque";
            }, this.getStandingMatrix = function() {
              return standingMatrix;
            }, this.isPresenting = !1;
            var animation = new WebGLAnimation();
            this.setAnimationLoop = function(callback) {
              animation.setAnimationLoop(callback), this.isPresenting && animation.start();
            }, this.submitFrame = function() {
              this.isPresenting && device.submitFrame();
            }, this.dispose = function() {
              typeof window != "undefined" && window.removeEventListener("vrdisplaypresentchange", onVRDisplayPresentChange);
            }, this.setFrameOfReferenceType = function() {
              console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.");
            };
          }
          Object.assign(WebVRManager.prototype, { addEventListener: EventDispatcher.prototype.addEventListener, hasEventListener: EventDispatcher.prototype.hasEventListener, removeEventListener: EventDispatcher.prototype.removeEventListener, dispatchEvent: EventDispatcher.prototype.dispatchEvent });
          class WebGLMultiviewRenderTarget extends WebGLRenderTarget {
            constructor(width, height, numViews, options = {}) {
              super(width, height, options);
              this.depthBuffer = !1, this.stencilBuffer = !1, this.numViews = numViews;
            }
            copy(source) {
              return super.copy(source), this.numViews = source.numViews, this;
            }
          }
          WebGLMultiviewRenderTarget.prototype.isWebGLMultiviewRenderTarget = !0;
          let _moveEvent = { type: "move" };
          class WebXRController {
            constructor() {
              this._targetRay = null, this._grip = null, this._hand = null;
            }
            getHandSpace() {
              return this._hand === null && (this._hand = new Group(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
            }
            getTargetRaySpace() {
              return this._targetRay === null && (this._targetRay = new Group(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Vector3(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Vector3()), this._targetRay;
            }
            getGripSpace() {
              return this._grip === null && (this._grip = new Group(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Vector3(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Vector3()), this._grip;
            }
            dispatchEvent(event) {
              return this._targetRay !== null && this._targetRay.dispatchEvent(event), this._grip !== null && this._grip.dispatchEvent(event), this._hand !== null && this._hand.dispatchEvent(event), this;
            }
            connect(inputSource) {
              if (inputSource && inputSource.hand) {
                let hand = this._hand;
                if (hand)
                  for (let inputjoint of inputSource.hand.values())
                    this._getHandJoint(hand, inputjoint);
              }
              return this.dispatchEvent({ type: "connected", data: inputSource }), this;
            }
            disconnect(inputSource) {
              return this.dispatchEvent({ type: "disconnected", data: inputSource }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
            }
            update(inputSource, frame, referenceSpace) {
              let inputPose = null, gripPose = null, handPose = null, targetRay = this._targetRay, grip = this._grip, hand = this._hand;
              if (inputSource && frame.session.visibilityState !== "visible-blurred") {
                if (hand && inputSource.hand) {
                  handPose = !0;
                  for (let inputjoint of inputSource.hand.values()) {
                    let jointPose = frame.getJointPose(inputjoint, referenceSpace), joint = this._getHandJoint(hand, inputjoint);
                    jointPose !== null && (joint.matrix.fromArray(jointPose.transform.matrix), joint.matrix.decompose(joint.position, joint.rotation, joint.scale), joint.matrixWorldNeedsUpdate = !0, joint.jointRadius = jointPose.radius), joint.visible = jointPose !== null;
                  }
                  let indexTip = hand.joints["index-finger-tip"], thumbTip = hand.joints["thumb-tip"], distance = indexTip.position.distanceTo(thumbTip.position), distanceToPinch = 0.02, threshold = 5e-3;
                  hand.inputState.pinching && distance > distanceToPinch + threshold ? (hand.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: inputSource.handedness, target: this })) : !hand.inputState.pinching && distance <= distanceToPinch - threshold && (hand.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: inputSource.handedness, target: this }));
                } else
                  grip !== null && inputSource.gripSpace && (gripPose = frame.getPose(inputSource.gripSpace, referenceSpace), gripPose !== null && (grip.matrix.fromArray(gripPose.transform.matrix), grip.matrix.decompose(grip.position, grip.rotation, grip.scale), grip.matrixWorldNeedsUpdate = !0, gripPose.linearVelocity ? (grip.hasLinearVelocity = !0, grip.linearVelocity.copy(gripPose.linearVelocity)) : grip.hasLinearVelocity = !1, gripPose.angularVelocity ? (grip.hasAngularVelocity = !0, grip.angularVelocity.copy(gripPose.angularVelocity)) : grip.hasAngularVelocity = !1));
                targetRay !== null && (inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace), inputPose === null && gripPose !== null && (inputPose = gripPose), inputPose !== null && (targetRay.matrix.fromArray(inputPose.transform.matrix), targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale), targetRay.matrixWorldNeedsUpdate = !0, inputPose.linearVelocity ? (targetRay.hasLinearVelocity = !0, targetRay.linearVelocity.copy(inputPose.linearVelocity)) : targetRay.hasLinearVelocity = !1, inputPose.angularVelocity ? (targetRay.hasAngularVelocity = !0, targetRay.angularVelocity.copy(inputPose.angularVelocity)) : targetRay.hasAngularVelocity = !1, this.dispatchEvent(_moveEvent)));
              }
              return targetRay !== null && (targetRay.visible = inputPose !== null), grip !== null && (grip.visible = gripPose !== null), hand !== null && (hand.visible = handPose !== null), this;
            }
            _getHandJoint(hand, inputjoint) {
              if (hand.joints[inputjoint.jointName] === void 0) {
                let joint = new Group();
                joint.matrixAutoUpdate = !1, joint.visible = !1, hand.joints[inputjoint.jointName] = joint, hand.add(joint);
              }
              return hand.joints[inputjoint.jointName];
            }
          }
          let _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
          class WebXRDepthSensing {
            constructor() {
              this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
            }
            init(renderer, depthData, renderState) {
              if (this.texture === null) {
                let texture = new Texture(), texProps = renderer.properties.get(texture);
                texProps.__webglTexture = depthData.texture, (depthData.depthNear != renderState.depthNear || depthData.depthFar != renderState.depthFar) && (this.depthNear = depthData.depthNear, this.depthFar = depthData.depthFar), this.texture = texture;
              }
            }
            render(renderer, cameraXR) {
              if (this.texture !== null) {
                if (this.mesh === null) {
                  let viewport = cameraXR.cameras[0].viewport, material = new ShaderMaterial({ vertexShader: _occlusion_vertex, fragmentShader: _occlusion_fragment, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: viewport.z }, depthHeight: { value: viewport.w } } });
                  this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
                }
                renderer.render(this.mesh, cameraXR);
              }
            }
            reset() {
              this.texture = null, this.mesh = null;
            }
          }
          class WebXRManager extends EventDispatcher {
            constructor(renderer, gl, extensions, useMultiview) {
              super();
              let scope = this, session = null, framebufferScaleFactor = 1;
              var poseTarget = null;
              let referenceSpace = null, referenceSpaceType = "local-floor", foveation = 1, customReferenceSpace = null, pose = null;
              var layers = [];
              let glBinding = null, glProjLayer = null, glBaseLayer = null, xrFrame = null, depthSensing = new WebXRDepthSensing(), attributes = gl.getContextAttributes(), initialRenderTarget = null, newRenderTarget = null, controllers = [], controllerInputSources = [], currentSize = new Vector2(), currentPixelRatio = null, cameraL = new PerspectiveCamera();
              cameraL.layers.enable(1), cameraL.viewport = new Vector4();
              let cameraR = new PerspectiveCamera();
              cameraR.layers.enable(2), cameraR.viewport = new Vector4();
              let cameras = [cameraL, cameraR], cameraXR = new ArrayCamera();
              cameraXR.layers.enable(1), cameraXR.layers.enable(2);
              let _currentDepthNear = null, _currentDepthFar = null;
              this.cameraAutoUpdate = !0, this.layersEnabled = !1, this.enabled = !1, this.isPresenting = !1, this.isMultiview = !1, this.getCameraPose = function() {
                return pose;
              }, this.getController = function(index) {
                let controller = controllers[index];
                return controller === void 0 && (controller = new WebXRController(), controllers[index] = controller), controller.getTargetRaySpace();
              }, this.getControllerGrip = function(index) {
                let controller = controllers[index];
                return controller === void 0 && (controller = new WebXRController(), controllers[index] = controller), controller.getGripSpace();
              }, this.getHand = function(index) {
                let controller = controllers[index];
                return controller === void 0 && (controller = new WebXRController(), controllers[index] = controller), controller.getHandSpace();
              };
              function onSessionEvent(event) {
                let controllerIndex = controllerInputSources.indexOf(event.inputSource);
                if (controllerIndex === -1)
                  return;
                let controller = controllers[controllerIndex];
                controller !== void 0 && (controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace), controller.dispatchEvent({ type: event.type, data: event.inputSource }));
              }
              function onSessionEnd() {
                session.removeEventListener("select", onSessionEvent), session.removeEventListener("selectstart", onSessionEvent), session.removeEventListener("selectend", onSessionEvent), session.removeEventListener("squeeze", onSessionEvent), session.removeEventListener("squeezestart", onSessionEvent), session.removeEventListener("squeezeend", onSessionEvent), session.removeEventListener("end", onSessionEnd), session.removeEventListener("inputsourceschange", onInputSourcesChange);
                for (let i = 0; i < controllers.length; i++) {
                  let inputSource = controllerInputSources[i];
                  inputSource !== null && (controllerInputSources[i] = null, controllers[i].disconnect(inputSource));
                }
                _currentDepthNear = null, _currentDepthFar = null, depthSensing.reset(), renderer.setRenderTarget(initialRenderTarget), glBaseLayer = null, glProjLayer = null, glBinding = null, session = null, newRenderTarget = null, animation.stop(), scope.isPresenting = !1, renderer.setPixelRatio(currentPixelRatio), renderer.setSize(currentSize.width, currentSize.height, !1), scope.dispatchEvent({ type: "sessionend" });
              }
              this.setFramebufferScaleFactor = function(value) {
                framebufferScaleFactor = value, scope.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
              }, this.setReferenceSpaceType = function(value) {
                referenceSpaceType = value, scope.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
              }, this.getReferenceSpace = function() {
                return customReferenceSpace || referenceSpace;
              }, this.setReferenceSpace = function(space) {
                customReferenceSpace = space;
              }, this.getBaseLayer = function() {
                return glProjLayer !== null ? glProjLayer : glBaseLayer;
              }, this.getBinding = function() {
                return glBinding;
              }, this.getFrame = function() {
                return xrFrame;
              }, this.getSession = function() {
                return session;
              }, this.setSession = async function(value) {
                if (session = value, session !== null) {
                  if (initialRenderTarget = renderer.getRenderTarget(), session.addEventListener("select", onSessionEvent), session.addEventListener("selectstart", onSessionEvent), session.addEventListener("selectend", onSessionEvent), session.addEventListener("squeeze", onSessionEvent), session.addEventListener("squeezestart", onSessionEvent), session.addEventListener("squeezeend", onSessionEvent), session.addEventListener("end", onSessionEnd), session.addEventListener("inputsourceschange", onInputSourcesChange), attributes.xrCompatible !== !0 && await gl.makeXRCompatible(), currentPixelRatio = renderer.getPixelRatio(), renderer.getSize(currentSize), session.renderState.layers === void 0) {
                    let layerInit = { antialias: attributes.antialias, alpha: !0, depth: attributes.depth, stencil: attributes.stencil, framebufferScaleFactor };
                    glBaseLayer = new XRWebGLLayer(session, gl, layerInit), session.updateRenderState({ baseLayer: glBaseLayer }), renderer.setPixelRatio(1), renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, !1), newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, { format: RGBAFormat, type: UnsignedByteType, colorSpace: renderer.outputColorSpace, stencilBuffer: attributes.stencil });
                  } else {
                    let depthFormat = null, depthType = null, glDepthFormat = null;
                    attributes.depth && (glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24, depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat, depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType), scope.isMultiview = useMultiview && extensions.has("OCULUS_multiview");
                    let projectionlayerInit = { colorFormat: gl.RGBA8, depthFormat: glDepthFormat, scaleFactor: framebufferScaleFactor };
                    scope.isMultiview && (projectionlayerInit.textureType = "texture-array"), glBinding = new XRWebGLBinding(session, gl), glProjLayer = glBinding.createProjectionLayer(projectionlayerInit), session.updateRenderState({ layers: [glProjLayer] }), renderer.setPixelRatio(1), renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, !1);
                    let renderTargetOptions = { format: RGBAFormat, type: UnsignedByteType, depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat), stencilBuffer: attributes.stencil, colorSpace: renderer.outputColorSpace, samples: attributes.antialias ? 4 : 0, resolveDepthBuffer: glProjLayer.ignoreDepthValues === !1 };
                    if (scope.isMultiview) {
                      let extension = extensions.get("OCULUS_multiview");
                      this.maxNumViews = gl.getParameter(extension.MAX_VIEWS_OVR), newRenderTarget = new WebGLMultiviewRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, 2, renderTargetOptions);
                    } else
                      newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, renderTargetOptions);
                  }
                  newRenderTarget.isXRRenderTarget = !0, this.setFoveation(foveation), customReferenceSpace = null, referenceSpace = await session.requestReferenceSpace(referenceSpaceType), animation.setContext(session), animation.start(), scope.isPresenting = !0, scope.dispatchEvent({ type: "sessionstart" });
                }
              }, this.getEnvironmentBlendMode = function() {
                if (session !== null)
                  return session.environmentBlendMode;
              }, this.addLayer = function(layer) {
                !window.XRWebGLBinding || !this.layersEnabled || !session || (layers.push(layer), this.updateLayers());
              }, this.removeLayer = function(layer) {
                layers.splice(layers.indexOf(layer), 1), !(!window.XRWebGLBinding || !this.layersEnabled || !session) && this.updateLayers();
              }, this.updateLayers = function() {
                var layersCopy = layers.map(function(x) {
                  return x;
                });
                layersCopy.unshift(session.renderState.layers[0]), session.updateRenderState({ layers: layersCopy });
              };
              function onInputSourcesChange(event) {
                for (let i = 0; i < event.removed.length; i++) {
                  let inputSource = event.removed[i], index = controllerInputSources.indexOf(inputSource);
                  index >= 0 && (controllerInputSources[index] = null, controllers[index].disconnect(inputSource));
                }
                for (let i = 0; i < event.added.length; i++) {
                  let inputSource = event.added[i], controllerIndex = controllerInputSources.indexOf(inputSource);
                  if (controllerIndex === -1) {
                    for (let i2 = 0; i2 < controllers.length; i2++)
                      if (i2 >= controllerInputSources.length) {
                        controllerInputSources.push(inputSource), controllerIndex = i2;
                        break;
                      } else if (controllerInputSources[i2] === null) {
                        controllerInputSources[i2] = inputSource, controllerIndex = i2;
                        break;
                      }
                    if (controllerIndex === -1)
                      break;
                  }
                  let controller = controllers[controllerIndex];
                  controller && controller.connect(inputSource);
                }
              }
              let cameraLPos2 = new Vector3(), cameraRPos2 = new Vector3();
              function setProjectionFromUnion2(camera, cameraL2, cameraR2) {
                cameraLPos2.setFromMatrixPosition(cameraL2.matrixWorld), cameraRPos2.setFromMatrixPosition(cameraR2.matrixWorld);
                let ipd = cameraLPos2.distanceTo(cameraRPos2), projL = cameraL2.projectionMatrix.elements, projR = cameraR2.projectionMatrix.elements, near = projL[14] / (projL[10] - 1), far = projL[14] / (projL[10] + 1), topFov = (projL[9] + 1) / projL[5], bottomFov = (projL[9] - 1) / projL[5], leftFov = (projL[8] - 1) / projL[0], rightFov = (projR[8] + 1) / projR[0], left = near * leftFov, right = near * rightFov, zOffset = ipd / (-leftFov + rightFov), xOffset = zOffset * -leftFov;
                cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale), camera.translateX(xOffset), camera.translateZ(zOffset), camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale), camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
                let near2 = near + zOffset, far2 = far + zOffset, left2 = left - xOffset, right2 = right + (ipd - xOffset), top2 = topFov * far / far2 * near2, bottom2 = bottomFov * far / far2 * near2;
                camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2), camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
              }
              function updateCamera(camera, parent) {
                parent === null ? camera.matrixWorld.copy(camera.matrix) : camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix), camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
              }
              this.setPoseTarget = function(object) {
                object !== void 0 && (poseTarget = object);
              }, this.updateCamera = function(camera) {
                if (session === null)
                  return;
                depthSensing.texture !== null && (camera.near = depthSensing.depthNear, camera.far = depthSensing.depthFar), cameraXR.near = cameraR.near = cameraL.near = camera.near, cameraXR.far = cameraR.far = cameraL.far = camera.far, (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) && (session.updateRenderState({ depthNear: cameraXR.near, depthFar: cameraXR.far }), _currentDepthNear = cameraXR.near, _currentDepthFar = cameraXR.far, cameraL.near = _currentDepthNear, cameraL.far = _currentDepthFar, cameraR.near = _currentDepthNear, cameraR.far = _currentDepthFar, cameraL.updateProjectionMatrix(), cameraR.updateProjectionMatrix(), camera.updateProjectionMatrix());
                let cameras2 = cameraXR.cameras;
                var object = poseTarget || camera;
                let parent = object.parent;
                updateCamera(cameraXR, parent);
                for (let i = 0; i < cameras2.length; i++)
                  updateCamera(cameras2[i], parent);
                cameras2.length === 2 ? setProjectionFromUnion2(cameraXR, cameraL, cameraR) : cameraXR.projectionMatrix.copy(cameraL.projectionMatrix), updateUserCamera(camera, cameraXR, object);
              };
              function updateUserCamera(camera, cameraXR2, object) {
                cameraXR2.matrixWorld.decompose(cameraXR2.position, cameraXR2.quaternion, cameraXR2.scale), object.parent === null ? object.matrix.copy(cameraXR2.matrixWorld) : (object.matrix.copy(object.parent.matrixWorld), object.matrix.invert(), object.matrix.multiply(cameraXR2.matrixWorld)), object.matrix.decompose(object.position, object.quaternion, object.scale), object.updateMatrixWorld(!0), camera.projectionMatrix.copy(cameraXR2.projectionMatrix), camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse), camera.isPerspectiveCamera && (camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]), camera.zoom = 1);
              }
              this.getCamera = function() {
                return cameraXR;
              }, this.getFoveation = function() {
                if (!(glProjLayer === null && glBaseLayer === null))
                  return foveation;
              }, this.setFoveation = function(value) {
                foveation = value, glProjLayer !== null && (glProjLayer.fixedFoveation = value), glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0 && (glBaseLayer.fixedFoveation = value);
              }, this.hasDepthSensing = function() {
                return depthSensing.texture !== null;
              };
              let onAnimationFrameCallback = null;
              function onAnimationFrame(time, frame) {
                if (pose = frame.getViewerPose(customReferenceSpace || referenceSpace), xrFrame = frame, pose !== null) {
                  let views = pose.views;
                  glBaseLayer !== null && (renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer), renderer.setRenderTarget(newRenderTarget));
                  let cameraXRNeedsUpdate = !1;
                  views.length !== cameraXR.cameras.length && (cameraXR.cameras.length = 0, cameraXRNeedsUpdate = !0);
                  for (let i = 0; i < views.length; i++) {
                    let view = views[i], viewport = null;
                    if (glBaseLayer !== null)
                      viewport = glBaseLayer.getViewport(view);
                    else {
                      let glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                      viewport = glSubImage.viewport, i === 0 && (renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture), renderer.setRenderTarget(newRenderTarget));
                    }
                    let camera = cameras[i];
                    camera === void 0 && (camera = new PerspectiveCamera(), camera.layers.enable(i), camera.viewport = new Vector4(), cameras[i] = camera), camera.matrix.fromArray(view.transform.matrix), camera.matrix.decompose(camera.position, camera.quaternion, camera.scale), camera.projectionMatrix.fromArray(view.projectionMatrix), camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert(), camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height), i === 0 && (cameraXR.matrix.copy(camera.matrix), cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale)), cameraXRNeedsUpdate === !0 && cameraXR.cameras.push(camera);
                  }
                  let enabledFeatures = session.enabledFeatures;
                  if (enabledFeatures && enabledFeatures.includes("depth-sensing")) {
                    let depthData = glBinding.getDepthInformation(views[0]);
                    depthData && depthData.isValid && depthData.texture && depthSensing.init(renderer, depthData, session.renderState);
                  }
                }
                for (let i = 0; i < controllers.length; i++) {
                  let inputSource = controllerInputSources[i], controller = controllers[i];
                  inputSource !== null && controller !== void 0 && controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
                }
                depthSensing.render(renderer, cameraXR), onAnimationFrameCallback && onAnimationFrameCallback(time, frame), frame.detectedPlanes && scope.dispatchEvent({ type: "planesdetected", data: frame }), xrFrame = null;
              }
              let animation = new WebGLAnimation();
              animation.setAnimationLoop(onAnimationFrame), this.setAnimationLoop = function(callback) {
                onAnimationFrameCallback = callback;
              }, this.dispose = function() {
              };
            }
          }
          let _e1 = /* @__PURE__ */ new Euler(), _m1 = /* @__PURE__ */ new Matrix4();
          function WebGLMaterials(renderer, properties) {
            function refreshTransformUniform(map, uniform) {
              map.matrixAutoUpdate === !0 && map.updateMatrix(), uniform.value.copy(map.matrix);
            }
            function refreshFogUniforms(uniforms, fog) {
              fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer)), fog.isFog ? (uniforms.fogNear.value = fog.near, uniforms.fogFar.value = fog.far) : fog.isFogExp2 && (uniforms.fogDensity.value = fog.density);
            }
            function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
              material.isMeshBasicMaterial || material.isMeshLambertMaterial ? refreshUniformsCommon(uniforms, material) : material.isMeshToonMaterial ? (refreshUniformsCommon(uniforms, material), refreshUniformsToon(uniforms, material)) : material.isMeshPhongMaterial ? (refreshUniformsCommon(uniforms, material), refreshUniformsPhong(uniforms, material)) : material.isMeshStandardMaterial ? (refreshUniformsCommon(uniforms, material), refreshUniformsStandard(uniforms, material), material.isMeshPhysicalMaterial && refreshUniformsPhysical(uniforms, material, transmissionRenderTarget)) : material.isMeshMatcapMaterial ? (refreshUniformsCommon(uniforms, material), refreshUniformsMatcap(uniforms, material)) : material.isMeshDepthMaterial ? refreshUniformsCommon(uniforms, material) : material.isMeshDistanceMaterial ? (refreshUniformsCommon(uniforms, material), refreshUniformsDistance(uniforms, material)) : material.isMeshNormalMaterial ? refreshUniformsCommon(uniforms, material) : material.isLineBasicMaterial ? (refreshUniformsLine(uniforms, material), material.isLineDashedMaterial && refreshUniformsDash(uniforms, material)) : material.isPointsMaterial ? refreshUniformsPoints(uniforms, material, pixelRatio, height) : material.isSpriteMaterial ? refreshUniformsSprites(uniforms, material) : material.isShadowMaterial ? (uniforms.color.value.copy(material.color), uniforms.opacity.value = material.opacity) : material.isShaderMaterial && (material.uniformsNeedUpdate = !1);
            }
            function refreshUniformsCommon(uniforms, material) {
              uniforms.opacity.value = material.opacity, material.color && uniforms.diffuse.value.copy(material.color), material.emissive && uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity), material.map && (uniforms.map.value = material.map, refreshTransformUniform(material.map, uniforms.mapTransform)), material.alphaMap && (uniforms.alphaMap.value = material.alphaMap, refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform)), material.bumpMap && (uniforms.bumpMap.value = material.bumpMap, refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform), uniforms.bumpScale.value = material.bumpScale, material.side === BackSide && (uniforms.bumpScale.value *= -1)), material.normalMap && (uniforms.normalMap.value = material.normalMap, refreshTransformUniform(material.normalMap, uniforms.normalMapTransform), uniforms.normalScale.value.copy(material.normalScale), material.side === BackSide && uniforms.normalScale.value.negate()), material.displacementMap && (uniforms.displacementMap.value = material.displacementMap, refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform), uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias), material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap, refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform)), material.specularMap && (uniforms.specularMap.value = material.specularMap, refreshTransformUniform(material.specularMap, uniforms.specularMapTransform)), material.alphaTest > 0 && (uniforms.alphaTest.value = material.alphaTest);
              let materialProperties = properties.get(material), envMap = materialProperties.envMap, envMapRotation = materialProperties.envMapRotation;
              if (envMap && (uniforms.envMap.value = envMap, _e1.copy(envMapRotation), _e1.x *= -1, _e1.y *= -1, _e1.z *= -1, envMap.isCubeTexture && envMap.isRenderTargetTexture === !1 && (_e1.y *= -1, _e1.z *= -1), uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)), uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === !1 ? -1 : 1, uniforms.reflectivity.value = material.reflectivity, uniforms.ior.value = material.ior, uniforms.refractionRatio.value = material.refractionRatio), material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                let scaleFactor = renderer._useLegacyLights === !0 ? Math.PI : 1;
                uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor, refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
              }
              material.aoMap && (uniforms.aoMap.value = material.aoMap, uniforms.aoMapIntensity.value = material.aoMapIntensity, refreshTransformUniform(material.aoMap, uniforms.aoMapTransform));
            }
            function refreshUniformsLine(uniforms, material) {
              uniforms.diffuse.value.copy(material.color), uniforms.opacity.value = material.opacity, material.map && (uniforms.map.value = material.map, refreshTransformUniform(material.map, uniforms.mapTransform));
            }
            function refreshUniformsDash(uniforms, material) {
              uniforms.dashSize.value = material.dashSize, uniforms.totalSize.value = material.dashSize + material.gapSize, uniforms.scale.value = material.scale;
            }
            function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
              uniforms.diffuse.value.copy(material.color), uniforms.opacity.value = material.opacity, uniforms.size.value = material.size * pixelRatio, uniforms.scale.value = height * 0.5, material.map && (uniforms.map.value = material.map, refreshTransformUniform(material.map, uniforms.uvTransform)), material.alphaMap && (uniforms.alphaMap.value = material.alphaMap, refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform)), material.alphaTest > 0 && (uniforms.alphaTest.value = material.alphaTest);
            }
            function refreshUniformsSprites(uniforms, material) {
              uniforms.diffuse.value.copy(material.color), uniforms.opacity.value = material.opacity, uniforms.rotation.value = material.rotation, material.map && (uniforms.map.value = material.map, refreshTransformUniform(material.map, uniforms.mapTransform)), material.alphaMap && (uniforms.alphaMap.value = material.alphaMap, refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform)), material.alphaTest > 0 && (uniforms.alphaTest.value = material.alphaTest);
            }
            function refreshUniformsPhong(uniforms, material) {
              uniforms.specular.value.copy(material.specular), uniforms.shininess.value = Math.max(material.shininess, 1e-4);
            }
            function refreshUniformsToon(uniforms, material) {
              material.gradientMap && (uniforms.gradientMap.value = material.gradientMap);
            }
            function refreshUniformsStandard(uniforms, material) {
              uniforms.metalness.value = material.metalness, material.metalnessMap && (uniforms.metalnessMap.value = material.metalnessMap, refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform)), uniforms.roughness.value = material.roughness, material.roughnessMap && (uniforms.roughnessMap.value = material.roughnessMap, refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform)), material.envMap && (uniforms.envMapIntensity.value = material.envMapIntensity);
            }
            function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
              uniforms.ior.value = material.ior, material.sheen > 0 && (uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen), uniforms.sheenRoughness.value = material.sheenRoughness, material.sheenColorMap && (uniforms.sheenColorMap.value = material.sheenColorMap, refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform)), material.sheenRoughnessMap && (uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap, refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform))), material.clearcoat > 0 && (uniforms.clearcoat.value = material.clearcoat, uniforms.clearcoatRoughness.value = material.clearcoatRoughness, material.clearcoatMap && (uniforms.clearcoatMap.value = material.clearcoatMap, refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform)), material.clearcoatRoughnessMap && (uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap, refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform)), material.clearcoatNormalMap && (uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap, refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform), uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale), material.side === BackSide && uniforms.clearcoatNormalScale.value.negate())), material.dispersion > 0 && (uniforms.dispersion.value = material.dispersion), material.iridescence > 0 && (uniforms.iridescence.value = material.iridescence, uniforms.iridescenceIOR.value = material.iridescenceIOR, uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0], uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1], material.iridescenceMap && (uniforms.iridescenceMap.value = material.iridescenceMap, refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform)), material.iridescenceThicknessMap && (uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap, refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform))), material.transmission > 0 && (uniforms.transmission.value = material.transmission, uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture, uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height), material.transmissionMap && (uniforms.transmissionMap.value = material.transmissionMap, refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform)), uniforms.thickness.value = material.thickness, material.thicknessMap && (uniforms.thicknessMap.value = material.thicknessMap, refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform)), uniforms.attenuationDistance.value = material.attenuationDistance, uniforms.attenuationColor.value.copy(material.attenuationColor)), material.anisotropy > 0 && (uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation)), material.anisotropyMap && (uniforms.anisotropyMap.value = material.anisotropyMap, refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform))), uniforms.specularIntensity.value = material.specularIntensity, uniforms.specularColor.value.copy(material.specularColor), material.specularColorMap && (uniforms.specularColorMap.value = material.specularColorMap, refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform)), material.specularIntensityMap && (uniforms.specularIntensityMap.value = material.specularIntensityMap, refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform));
            }
            function refreshUniformsMatcap(uniforms, material) {
              material.matcap && (uniforms.matcap.value = material.matcap);
            }
            function refreshUniformsDistance(uniforms, material) {
              let light = properties.get(material).light;
              uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld), uniforms.nearDistance.value = light.shadow.camera.near, uniforms.farDistance.value = light.shadow.camera.far;
            }
            return { refreshFogUniforms, refreshMaterialUniforms };
          }
          function WebGLUniformsGroups(gl, info, capabilities, state) {
            let buffers = {}, updateList = {}, allocatedBindingPoints = [], maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
            function bind(uniformsGroup, program) {
              let webglProgram = program.program;
              state.uniformBlockBinding(uniformsGroup, webglProgram);
            }
            function update(uniformsGroup, program) {
              let buffer = buffers[uniformsGroup.id];
              buffer === void 0 && (prepareUniformsGroup(uniformsGroup), buffer = createBuffer(uniformsGroup), buffers[uniformsGroup.id] = buffer, uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose));
              let webglProgram = program.program;
              state.updateUBOMapping(uniformsGroup, webglProgram);
              let frame = info.render.frame;
              updateList[uniformsGroup.id] !== frame && (updateBufferData(uniformsGroup), updateList[uniformsGroup.id] = frame);
            }
            function createBuffer(uniformsGroup) {
              let bindingPointIndex = allocateBindingPointIndex();
              uniformsGroup.__bindingPointIndex = bindingPointIndex;
              let buffer = gl.createBuffer(), size = uniformsGroup.__size, usage = uniformsGroup.usage;
              return gl.bindBuffer(gl.UNIFORM_BUFFER, buffer), gl.bufferData(gl.UNIFORM_BUFFER, size, usage), gl.bindBuffer(gl.UNIFORM_BUFFER, null), gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer), buffer;
            }
            function allocateBindingPointIndex() {
              for (let i = 0; i < maxBindingPoints; i++)
                if (allocatedBindingPoints.indexOf(i) === -1)
                  return allocatedBindingPoints.push(i), i;
              return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
            }
            function updateBufferData(uniformsGroup) {
              let buffer = buffers[uniformsGroup.id], uniforms = uniformsGroup.uniforms, cache = uniformsGroup.__cache;
              gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
              for (let i = 0, il = uniforms.length; i < il; i++) {
                let uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
                for (let j = 0, jl = uniformArray.length; j < jl; j++) {
                  let uniform = uniformArray[j];
                  if (hasUniformChanged(uniform, i, j, cache) === !0) {
                    let offset = uniform.__offset, values = Array.isArray(uniform.value) ? uniform.value : [uniform.value], arrayOffset = 0;
                    for (let k = 0; k < values.length; k++) {
                      let value = values[k], info2 = getUniformSize(value);
                      typeof value == "number" || typeof value == "boolean" ? (uniform.__data[0] = value, gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data)) : value.isMatrix3 ? (uniform.__data[0] = value.elements[0], uniform.__data[1] = value.elements[1], uniform.__data[2] = value.elements[2], uniform.__data[3] = 0, uniform.__data[4] = value.elements[3], uniform.__data[5] = value.elements[4], uniform.__data[6] = value.elements[5], uniform.__data[7] = 0, uniform.__data[8] = value.elements[6], uniform.__data[9] = value.elements[7], uniform.__data[10] = value.elements[8], uniform.__data[11] = 0) : (value.toArray(uniform.__data, arrayOffset), arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT);
                    }
                    gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
                  }
                }
              }
              gl.bindBuffer(gl.UNIFORM_BUFFER, null);
            }
            function hasUniformChanged(uniform, index, indexArray, cache) {
              let value = uniform.value, indexString = index + "_" + indexArray;
              if (cache[indexString] === void 0)
                return typeof value == "number" || typeof value == "boolean" ? cache[indexString] = value : cache[indexString] = value.clone(), !0;
              {
                let cachedObject = cache[indexString];
                if (typeof value == "number" || typeof value == "boolean") {
                  if (cachedObject !== value)
                    return cache[indexString] = value, !0;
                } else if (cachedObject.equals(value) === !1)
                  return cachedObject.copy(value), !0;
              }
              return !1;
            }
            function prepareUniformsGroup(uniformsGroup) {
              let uniforms = uniformsGroup.uniforms, offset = 0, chunkSize = 16;
              for (let i = 0, l = uniforms.length; i < l; i++) {
                let uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
                for (let j = 0, jl = uniformArray.length; j < jl; j++) {
                  let uniform = uniformArray[j], values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
                  for (let k = 0, kl = values.length; k < kl; k++) {
                    let value = values[k], info2 = getUniformSize(value), chunkOffsetUniform = offset % chunkSize;
                    chunkOffsetUniform !== 0 && chunkSize - chunkOffsetUniform < info2.boundary && (offset += chunkSize - chunkOffsetUniform), uniform.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT), uniform.__offset = offset, offset += info2.storage;
                  }
                }
              }
              let chunkOffset = offset % chunkSize;
              return chunkOffset > 0 && (offset += chunkSize - chunkOffset), uniformsGroup.__size = offset, uniformsGroup.__cache = {}, this;
            }
            function getUniformSize(value) {
              let info2 = {
                boundary: 0,
                storage: 0
              };
              return typeof value == "number" || typeof value == "boolean" ? (info2.boundary = 4, info2.storage = 4) : value.isVector2 ? (info2.boundary = 8, info2.storage = 8) : value.isVector3 || value.isColor ? (info2.boundary = 16, info2.storage = 12) : value.isVector4 ? (info2.boundary = 16, info2.storage = 16) : value.isMatrix3 ? (info2.boundary = 48, info2.storage = 48) : value.isMatrix4 ? (info2.boundary = 64, info2.storage = 64) : value.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value), info2;
            }
            function onUniformsGroupsDispose(event) {
              let uniformsGroup = event.target;
              uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
              let index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
              allocatedBindingPoints.splice(index, 1), gl.deleteBuffer(buffers[uniformsGroup.id]), delete buffers[uniformsGroup.id], delete updateList[uniformsGroup.id];
            }
            function dispose() {
              for (let id in buffers)
                gl.deleteBuffer(buffers[id]);
              allocatedBindingPoints = [], buffers = {}, updateList = {};
            }
            return { bind, update, dispose };
          }
          class WebGLRenderer {
            constructor(parameters = {}) {
              let { canvas = createCanvasElement(), context = null, depth = !0, stencil = !1, alpha = !1, antialias = !1, premultipliedAlpha = !0, preserveDrawingBuffer = !1, powerPreference = "default", failIfMajorPerformanceCaveat = !1, multiviewStereo = !1 } = parameters;
              this.isWebGLRenderer = !0;
              let _alpha;
              if (context !== null) {
                if (typeof WebGLRenderingContext != "undefined" && context instanceof WebGLRenderingContext)
                  throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                _alpha = context.getContextAttributes().alpha;
              } else
                _alpha = alpha;
              let uintClearColor = new Uint32Array(4), intClearColor = new Int32Array(4), currentRenderList = null, currentRenderState = null, renderListStack = [], renderStateStack = [];
              this.domElement = canvas, this.debug = {
                checkShaderErrors: !0,
                onShaderError: null
              }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = SRGBColorSpace, this._useLegacyLights = !1, this.toneMapping = NoToneMapping, this.toneMappingExposure = 1;
              let _this = this, _isContextLost = !1, _currentActiveCubeFace = 0, _currentActiveMipmapLevel = 0, _currentRenderTarget = null, _currentMaterialId = -1, _currentCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, _currentClearColor = new Color(0), _currentClearAlpha = 0, _width = canvas.width, _height = canvas.height, _pixelRatio = 1, _opaqueSort = null, _transparentSort = null, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = !1, _frustum2 = new Frustum(), _clippingEnabled = !1, _localClippingEnabled = !1, _projScreenMatrix2 = new Matrix4(), _vector32 = new Vector3(), _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
              function getTargetPixelRatio() {
                return _currentRenderTarget === null ? _pixelRatio : 1;
              }
              let _gl = context;
              function getContext(contextName, contextAttributes) {
                return canvas.getContext(contextName, contextAttributes);
              }
              try {
                let contextAttributes = { alpha: !0, depth, stencil, antialias, premultipliedAlpha, preserveDrawingBuffer, powerPreference, failIfMajorPerformanceCaveat };
                if ("setAttribute" in canvas && canvas.setAttribute("data-engine", `three.js r${REVISION}`), canvas.addEventListener("webglcontextlost", onContextLost, !1), canvas.addEventListener("webglcontextrestored", onContextRestore, !1), canvas.addEventListener("webglcontextcreationerror", onContextCreationError, !1), _gl === null) {
                  let contextName = "webgl2";
                  if (_gl = getContext(contextName, contextAttributes), _gl === null)
                    throw getContext(contextName) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                }
              } catch (error) {
                throw console.error("THREE.WebGLRenderer: " + error.message), error;
              }
              let extensions, capabilities, state, info, properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects, programCache, materials, renderLists, renderStates, clipping, shadowMap, multiview, background, morphtargets, bufferRenderer, indexedBufferRenderer, utils, bindingStates, uniformsGroups;
              function initGLContext() {
                extensions = new WebGLExtensions(_gl), extensions.init(), utils = new WebGLUtils(_gl, extensions), capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils), state = new WebGLState(_gl), info = new WebGLInfo(_gl), properties = new WebGLProperties(), textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info), cubemaps = new WebGLCubeMaps(_this), cubeuvmaps = new WebGLCubeUVMaps(_this), attributes = new WebGLAttributes(_gl), bindingStates = new WebGLBindingStates(_gl, attributes), geometries = new WebGLGeometries(_gl, attributes, info, bindingStates), objects = new WebGLObjects(_gl, geometries, attributes, info), morphtargets = new WebGLMorphtargets(_gl, capabilities, textures), clipping = new WebGLClipping(properties), programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping), materials = new WebGLMaterials(_this, properties), renderLists = new WebGLRenderLists(), renderStates = new WebGLRenderStates(extensions), background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha), multiview = new WebGLMultiview(_this, extensions, _gl), shadowMap = new WebGLShadowMap(_this, objects, capabilities), uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state), bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info), indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info), info.programs = programCache.programs, _this.capabilities = capabilities, _this.extensions = extensions, _this.properties = properties, _this.renderLists = renderLists, _this.shadowMap = shadowMap, _this.state = state, _this.info = info;
              }
              initGLContext();
              let xr = typeof navigator != "undefined" && "xr" in navigator ? new WebXRManager(_this, _gl, extensions, multiviewStereo) : new WebVRManager(_this);
              this.xr = xr, this.getContext = function() {
                return _gl;
              }, this.getContextAttributes = function() {
                return _gl.getContextAttributes();
              }, this.forceContextLoss = function() {
                let extension = extensions.get("WEBGL_lose_context");
                extension && extension.loseContext();
              }, this.forceContextRestore = function() {
                let extension = extensions.get("WEBGL_lose_context");
                extension && extension.restoreContext();
              }, this.getPixelRatio = function() {
                return _pixelRatio;
              }, this.setPixelRatio = function(value) {
                value !== void 0 && (_pixelRatio = value, this.setSize(_width, _height, !1));
              }, this.getSize = function(target) {
                return target.set(_width, _height);
              }, this.setSize = function(width, height, updateStyle = !0) {
                if (xr.isPresenting) {
                  console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                  return;
                }
                _width = width, _height = height, canvas.width = Math.floor(width * _pixelRatio), canvas.height = Math.floor(height * _pixelRatio), updateStyle === !0 && (canvas.style.width = width + "px", canvas.style.height = height + "px"), this.setViewport(0, 0, width, height);
              }, this.getDrawingBufferSize = function(target) {
                return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
              }, this.setDrawingBufferSize = function(width, height, pixelRatio) {
                _width = width, _height = height, _pixelRatio = pixelRatio, canvas.width = Math.floor(width * pixelRatio), canvas.height = Math.floor(height * pixelRatio), this.setViewport(0, 0, width, height);
              }, this.getCurrentViewport = function(target) {
                return target.copy(_currentViewport);
              }, this.getViewport = function(target) {
                return target.copy(_viewport);
              }, this.setViewport = function(x, y, width, height) {
                x.isVector4 ? _viewport.set(x.x, x.y, x.z, x.w) : _viewport.set(x, y, width, height), state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());
              }, this.getScissor = function(target) {
                return target.copy(_scissor);
              }, this.setScissor = function(x, y, width, height) {
                x.isVector4 ? _scissor.set(x.x, x.y, x.z, x.w) : _scissor.set(x, y, width, height), state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
              }, this.getScissorTest = function() {
                return _scissorTest;
              }, this.setScissorTest = function(boolean) {
                state.setScissorTest(_scissorTest = boolean);
              }, this.setOpaqueSort = function(method) {
                _opaqueSort = method;
              }, this.setTransparentSort = function(method) {
                _transparentSort = method;
              }, this.getClearColor = function(target) {
                return target.copy(background.getClearColor());
              }, this.setClearColor = function() {
                background.setClearColor.apply(background, arguments);
              }, this.getClearAlpha = function() {
                return background.getClearAlpha();
              }, this.setClearAlpha = function() {
                background.setClearAlpha.apply(background, arguments);
              }, this.clear = function(color = !0, depth2 = !0, stencil2 = !0) {
                let bits = 0;
                if (color) {
                  let isIntegerFormat = !1;
                  if (_currentRenderTarget !== null) {
                    let targetFormat = _currentRenderTarget.texture.format;
                    isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
                  }
                  if (isIntegerFormat) {
                    let targetType = _currentRenderTarget.texture.type, isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type, clearColor = background.getClearColor(), a = background.getClearAlpha(), r = clearColor.r, g = clearColor.g, b = clearColor.b;
                    isUnsignedType ? (uintClearColor[0] = r, uintClearColor[1] = g, uintClearColor[2] = b, uintClearColor[3] = a, _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor)) : (intClearColor[0] = r, intClearColor[1] = g, intClearColor[2] = b, intClearColor[3] = a, _gl.clearBufferiv(_gl.COLOR, 0, intClearColor));
                  } else
                    bits |= _gl.COLOR_BUFFER_BIT;
                }
                depth2 && (bits |= _gl.DEPTH_BUFFER_BIT), stencil2 && (bits |= _gl.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), _gl.clear(bits);
              }, this.clearColor = function() {
                this.clear(!0, !1, !1);
              }, this.clearDepth = function() {
                this.clear(!1, !0, !1);
              }, this.clearStencil = function() {
                this.clear(!1, !1, !0);
              }, this.dispose = function() {
                canvas.removeEventListener("webglcontextlost", onContextLost, !1), canvas.removeEventListener("webglcontextrestored", onContextRestore, !1), canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, !1), renderLists.dispose(), renderStates.dispose(), properties.dispose(), cubemaps.dispose(), cubeuvmaps.dispose(), objects.dispose(), bindingStates.dispose(), uniformsGroups.dispose(), programCache.dispose(), xr.dispose(), xr.removeEventListener("sessionstart", onXRSessionStart), xr.removeEventListener("sessionend", onXRSessionEnd), animation.stop();
              };
              function onContextLost(event) {
                event.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _isContextLost = !0;
              }
              function onContextRestore() {
                console.log("THREE.WebGLRenderer: Context Restored."), _isContextLost = !1;
                let infoAutoReset = info.autoReset, shadowMapEnabled = shadowMap.enabled, shadowMapAutoUpdate = shadowMap.autoUpdate, shadowMapNeedsUpdate = shadowMap.needsUpdate, shadowMapType = shadowMap.type;
                initGLContext(), info.autoReset = infoAutoReset, shadowMap.enabled = shadowMapEnabled, shadowMap.autoUpdate = shadowMapAutoUpdate, shadowMap.needsUpdate = shadowMapNeedsUpdate, shadowMap.type = shadowMapType;
              }
              function onContextCreationError(event) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
              }
              function onMaterialDispose(event) {
                let material = event.target;
                material.removeEventListener("dispose", onMaterialDispose), deallocateMaterial(material);
              }
              function deallocateMaterial(material) {
                releaseMaterialProgramReferences(material), properties.remove(material);
              }
              function releaseMaterialProgramReferences(material) {
                let programs = properties.get(material).programs;
                programs !== void 0 && (programs.forEach(function(program) {
                  programCache.releaseProgram(program);
                }), material.isShaderMaterial && programCache.releaseShaderCache(material));
              }
              this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
                scene === null && (scene = _emptyScene);
                let frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0, program = setProgram(camera, scene, geometry, material, object);
                state.setMaterial(material, frontFaceCW);
                let index = geometry.index, rangeFactor = 1;
                if (material.wireframe === !0) {
                  if (index = geometries.getWireframeAttribute(geometry), index === void 0)
                    return;
                  rangeFactor = 2;
                }
                let drawRange = geometry.drawRange, position = geometry.attributes.position, drawStart = drawRange.start * rangeFactor, drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
                group !== null && (drawStart = Math.max(drawStart, group.start * rangeFactor), drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor)), index !== null ? (drawStart = Math.max(drawStart, 0), drawEnd = Math.min(drawEnd, index.count)) : position != null && (drawStart = Math.max(drawStart, 0), drawEnd = Math.min(drawEnd, position.count));
                let drawCount = drawEnd - drawStart;
                if (drawCount < 0 || drawCount === 1 / 0)
                  return;
                bindingStates.setup(object, material, program, geometry, index);
                let attribute, renderer = bufferRenderer;
                if (index !== null && (attribute = attributes.get(index), renderer = indexedBufferRenderer, renderer.setIndex(attribute)), object.isMesh)
                  material.wireframe === !0 ? (state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio()), renderer.setMode(_gl.LINES)) : renderer.setMode(_gl.TRIANGLES);
                else if (object.isLine) {
                  let lineWidth = material.linewidth;
                  lineWidth === void 0 && (lineWidth = 1), state.setLineWidth(lineWidth * getTargetPixelRatio()), object.isLineSegments ? renderer.setMode(_gl.LINES) : object.isLineLoop ? renderer.setMode(_gl.LINE_LOOP) : renderer.setMode(_gl.LINE_STRIP);
                } else
                  object.isPoints ? renderer.setMode(_gl.POINTS) : object.isSprite && renderer.setMode(_gl.TRIANGLES);
                if (object.isBatchedMesh)
                  object._multiDrawInstances !== null ? renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances) : renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
                else if (object.isInstancedMesh)
                  renderer.renderInstances(drawStart, drawCount, object.count);
                else if (geometry.isInstancedBufferGeometry) {
                  let maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : 1 / 0, instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
                  renderer.renderInstances(drawStart, drawCount, instanceCount);
                } else
                  renderer.render(drawStart, drawCount);
              };
              function prepareMaterial(material, scene, object) {
                material.transparent === !0 && material.side === DoubleSide && material.forceSinglePass === !1 ? (material.side = BackSide, material.needsUpdate = !0, getProgram(material, scene, object), material.side = FrontSide, material.needsUpdate = !0, getProgram(material, scene, object), material.side = DoubleSide) : getProgram(material, scene, object);
              }
              this.compile = function(scene, camera, targetScene = null) {
                targetScene === null && (targetScene = scene), currentRenderState = renderStates.get(targetScene), currentRenderState.init(camera), renderStateStack.push(currentRenderState), targetScene.traverseVisible(function(object) {
                  object.isLight && object.layers.test(camera.layers) && (currentRenderState.pushLight(object), object.castShadow && currentRenderState.pushShadow(object));
                }), scene !== targetScene && scene.traverseVisible(function(object) {
                  object.isLight && object.layers.test(camera.layers) && (currentRenderState.pushLight(object), object.castShadow && currentRenderState.pushShadow(object));
                }), currentRenderState.setupLights(_this._useLegacyLights);
                let materials2 = new Set();
                return scene.traverse(function(object) {
                  let material = object.material;
                  if (material)
                    if (Array.isArray(material))
                      for (let i = 0; i < material.length; i++) {
                        let material2 = material[i];
                        prepareMaterial(material2, targetScene, object), materials2.add(material2);
                      }
                    else
                      prepareMaterial(material, targetScene, object), materials2.add(material);
                }), renderStateStack.pop(), currentRenderState = null, materials2;
              }, this.compileAsync = function(scene, camera, targetScene = null) {
                let materials2 = this.compile(scene, camera, targetScene);
                return new Promise((resolve) => {
                  function checkMaterialsReady() {
                    if (materials2.forEach(function(material) {
                      properties.get(material).currentProgram.isReady() && materials2.delete(material);
                    }), materials2.size === 0) {
                      resolve(scene);
                      return;
                    }
                    setTimeout(checkMaterialsReady, 10);
                  }
                  extensions.get("KHR_parallel_shader_compile") !== null ? checkMaterialsReady() : setTimeout(checkMaterialsReady, 10);
                });
              };
              let onAnimationFrameCallback = null;
              function onAnimationFrame(time) {
                onAnimationFrameCallback && onAnimationFrameCallback(time);
              }
              function onXRSessionStart() {
                animation.stop();
              }
              function onXRSessionEnd() {
                animation.start();
              }
              let animation = new WebGLAnimation();
              animation.setAnimationLoop(onAnimationFrame), typeof self != "undefined" && animation.setContext(self), this.setAnimationLoop = function(callback) {
                onAnimationFrameCallback = callback, xr.setAnimationLoop(callback), callback === null ? animation.stop() : animation.start();
              }, xr.addEventListener("sessionstart", onXRSessionStart), xr.addEventListener("sessionend", onXRSessionEnd), this.render = function(scene, camera) {
                if (camera !== void 0 && camera.isCamera !== !0) {
                  console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                  return;
                }
                if (_isContextLost === !0)
                  return;
                scene.matrixWorldAutoUpdate === !0 && scene.updateMatrixWorld(), camera.parent === null && camera.matrixWorldAutoUpdate === !0 && camera.updateMatrixWorld(), xr.enabled === !0 && xr.isPresenting === !0 && (xr.cameraAutoUpdate === !0 && xr.updateCamera(camera), camera = xr.getCamera()), scene.isScene === !0 && scene.onBeforeRender(_this, scene, camera, _currentRenderTarget), currentRenderState = renderStates.get(scene, renderStateStack.length), currentRenderState.init(camera), renderStateStack.push(currentRenderState), _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse), _frustum2.setFromProjectionMatrix(_projScreenMatrix2), _localClippingEnabled = this.localClippingEnabled, _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled), currentRenderList = renderLists.get(scene, renderListStack.length), currentRenderList.init(), renderListStack.push(currentRenderList), projectObject(scene, camera, 0, _this.sortObjects), currentRenderList.finish(), _this.sortObjects === !0 && currentRenderList.sort(_opaqueSort, _transparentSort);
                let renderBackground = xr.enabled === !1 || xr.isPresenting === !1 || xr.hasDepthSensing() === !1;
                renderBackground && background.addToRenderList(currentRenderList, scene), this.info.render.frame++, _clippingEnabled === !0 && clipping.beginShadows();
                let shadowsArray = currentRenderState.state.shadowsArray;
                shadowMap.render(shadowsArray, scene, camera), _clippingEnabled === !0 && clipping.endShadows(), this.info.autoReset === !0 && this.info.reset();
                let opaqueObjects = currentRenderList.opaque, transmissiveObjects = currentRenderList.transmissive;
                if (currentRenderState.setupLights(_this._useLegacyLights), camera.isArrayCamera) {
                  let cameras = camera.cameras;
                  if (transmissiveObjects.length > 0)
                    for (let i = 0, l = cameras.length; i < l; i++) {
                      let camera2 = cameras[i];
                      renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
                    }
                  if (renderBackground && background.render(scene), xr.enabled && xr.isMultiview)
                    textures.setDeferTextureUploads(!0), renderScene(currentRenderList, scene, camera, camera.cameras[0].viewport);
                  else
                    for (let i = 0, l = cameras.length; i < l; i++) {
                      let camera2 = cameras[i];
                      renderScene(currentRenderList, scene, camera2, camera2.viewport);
                    }
                } else
                  transmissiveObjects.length > 0 && renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera), renderBackground && background.render(scene), renderScene(currentRenderList, scene, camera);
                _currentRenderTarget !== null && (textures.updateMultisampleRenderTarget(_currentRenderTarget), textures.updateRenderTargetMipmap(_currentRenderTarget)), scene.isScene === !0 && scene.onAfterRender(_this, scene, camera), textures.runDeferredUploads(), xr.enabled && xr.submitFrame && xr.submitFrame(), bindingStates.resetDefaultState(), _currentMaterialId = -1, _currentCamera = null, renderStateStack.pop(), renderStateStack.length > 0 ? (currentRenderState = renderStateStack[renderStateStack.length - 1], _clippingEnabled === !0 && clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera)) : currentRenderState = null, renderListStack.pop(), renderListStack.length > 0 ? currentRenderList = renderListStack[renderListStack.length - 1] : currentRenderList = null;
              };
              function projectObject(object, camera, groupOrder, sortObjects) {
                if (object.visible === !1)
                  return;
                if (object.layers.test(camera.layers)) {
                  if (object.isGroup)
                    groupOrder = object.renderOrder;
                  else if (object.isLOD)
                    object.autoUpdate === !0 && object.update(camera);
                  else if (object.isLight)
                    currentRenderState.pushLight(object), object.castShadow && currentRenderState.pushShadow(object);
                  else if (object.isSprite) {
                    if (!object.frustumCulled || _frustum2.intersectsSprite(object)) {
                      sortObjects && _vector32.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
                      let geometry = objects.update(object), material = object.material;
                      material.visible && currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
                    }
                  } else if ((object.isMesh || object.isLine || object.isPoints) && (!object.frustumCulled || _frustum2.intersectsObject(object))) {
                    let geometry = objects.update(object), material = object.material;
                    if (sortObjects && (object.boundingSphere !== void 0 ? (object.boundingSphere === null && object.computeBoundingSphere(), _vector32.copy(object.boundingSphere.center)) : (geometry.boundingSphere === null && geometry.computeBoundingSphere(), _vector32.copy(geometry.boundingSphere.center)), _vector32.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2)), Array.isArray(material)) {
                      let groups = geometry.groups;
                      for (let i = 0, l = groups.length; i < l; i++) {
                        let group = groups[i], groupMaterial = material[group.materialIndex];
                        groupMaterial && groupMaterial.visible && currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector32.z, group);
                      }
                    } else
                      material.visible && currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
                  }
                }
                let children = object.children;
                for (let i = 0, l = children.length; i < l; i++)
                  projectObject(children[i], camera, groupOrder, sortObjects);
              }
              function renderScene(currentRenderList2, scene, camera, viewport) {
                let opaqueObjects = currentRenderList2.opaque, transmissiveObjects = currentRenderList2.transmissive, transparentObjects = currentRenderList2.transparent;
                currentRenderState.setupLightsView(camera), _clippingEnabled === !0 && clipping.setGlobalState(_this.clippingPlanes, camera), viewport && state.viewport(_currentViewport.copy(viewport)), opaqueObjects.length > 0 && renderObjects(opaqueObjects, scene, camera), transmissiveObjects.length > 0 && renderObjects(transmissiveObjects, scene, camera), transparentObjects.length > 0 && renderObjects(transparentObjects, scene, camera), state.buffers.depth.setTest(!0), state.buffers.depth.setMask(!0), state.buffers.color.setMask(!0), state.setPolygonOffset(!1);
              }
              function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
                if ((scene.isScene === !0 ? scene.overrideMaterial : null) !== null)
                  return;
                currentRenderState.state.transmissionRenderTarget[camera.id] === void 0 && (currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, { generateMipmaps: !0, type: extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType, minFilter: LinearMipmapLinearFilter, samples: 4, stencilBuffer: stencil, resolveDepthBuffer: !1, resolveStencilBuffer: !1 }));
                let transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id], activeViewport = camera.viewport || _currentViewport;
                transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);
                let currentRenderTarget = _this.getRenderTarget();
                _this.setRenderTarget(transmissionRenderTarget), _this.getClearColor(_currentClearColor), _currentClearAlpha = _this.getClearAlpha(), _currentClearAlpha < 1 && _this.setClearColor(16777215, 0.5), _this.clear();
                let currentToneMapping = _this.toneMapping;
                _this.toneMapping = NoToneMapping;
                let currentCameraViewport = camera.viewport;
                if (camera.viewport !== void 0 && (camera.viewport = void 0), currentRenderState.setupLightsView(camera), _clippingEnabled === !0 && clipping.setGlobalState(_this.clippingPlanes, camera), renderObjects(opaqueObjects, scene, camera), textures.updateMultisampleRenderTarget(transmissionRenderTarget), textures.updateRenderTargetMipmap(transmissionRenderTarget), extensions.has("WEBGL_multisampled_render_to_texture") === !1) {
                  let renderTargetNeedsUpdate = !1;
                  for (let i = 0, l = transmissiveObjects.length; i < l; i++) {
                    let renderItem = transmissiveObjects[i], object = renderItem.object, geometry = renderItem.geometry, material = renderItem.material, group = renderItem.group;
                    if (material.side === DoubleSide && object.layers.test(camera.layers)) {
                      let currentSide = material.side;
                      material.side = BackSide, material.needsUpdate = !0, renderObject(object, scene, camera, geometry, material, group), material.side = currentSide, material.needsUpdate = !0, renderTargetNeedsUpdate = !0;
                    }
                  }
                  renderTargetNeedsUpdate === !0 && (textures.updateMultisampleRenderTarget(transmissionRenderTarget), textures.updateRenderTargetMipmap(transmissionRenderTarget));
                }
                _this.setRenderTarget(currentRenderTarget), _this.setClearColor(_currentClearColor, _currentClearAlpha), currentCameraViewport !== void 0 && (camera.viewport = currentCameraViewport), _this.toneMapping = currentToneMapping;
              }
              function renderObjects(renderList, scene, camera) {
                let overrideMaterial = scene.isScene === !0 ? scene.overrideMaterial : null;
                for (let i = 0, l = renderList.length; i < l; i++) {
                  let renderItem = renderList[i], object = renderItem.object, geometry = renderItem.geometry, material = overrideMaterial === null ? renderItem.material : overrideMaterial, group = renderItem.group;
                  object.layers.test(camera.layers) && renderObject(object, scene, camera, geometry, material, group);
                }
              }
              function renderObject(object, scene, camera, geometry, material, group) {
                object.onBeforeRender(_this, scene, camera, geometry, material, group), object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld), object.normalMatrix.getNormalMatrix(object.modelViewMatrix), material.onBeforeRender(_this, scene, camera, geometry, object, group), material.transparent === !0 && material.side === DoubleSide && material.forceSinglePass === !1 ? (material.side = BackSide, material.needsUpdate = !0, _this.renderBufferDirect(camera, scene, geometry, material, object, group), material.side = FrontSide, material.needsUpdate = !0, _this.renderBufferDirect(camera, scene, geometry, material, object, group), material.side = DoubleSide) : _this.renderBufferDirect(camera, scene, geometry, material, object, group), object.onAfterRender(_this, scene, camera, geometry, material, group);
              }
              function getProgram(material, scene, object) {
                scene.isScene !== !0 && (scene = _emptyScene);
                let materialProperties = properties.get(material), lights = currentRenderState.state.lights, shadowsArray = currentRenderState.state.shadowsArray, lightsStateVersion = lights.state.version, parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object), programCacheKey = programCache.getProgramCacheKey(parameters2), programs = materialProperties.programs;
                materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null, materialProperties.fog = scene.fog, materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment), materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation, programs === void 0 && (material.addEventListener("dispose", onMaterialDispose), programs = new Map(), materialProperties.programs = programs);
                let program = programs.get(programCacheKey);
                if (program !== void 0) {
                  if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion)
                    return updateCommonMaterialProperties(material, parameters2), program;
                } else
                  parameters2.uniforms = programCache.getUniforms(material), material.onBuild(object, parameters2, _this), material.onBeforeCompile(parameters2, _this), program = programCache.acquireProgram(parameters2, programCacheKey), programs.set(programCacheKey, program), materialProperties.uniforms = parameters2.uniforms;
                let uniforms = materialProperties.uniforms;
                return (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === !0) && (uniforms.clippingPlanes = clipping.uniform), updateCommonMaterialProperties(material, parameters2), materialProperties.needsLights = materialNeedsLights(material), materialProperties.lightsStateVersion = lightsStateVersion, materialProperties.needsLights && (uniforms.ambientLightColor.value = lights.state.ambient, uniforms.lightProbe.value = lights.state.probe, uniforms.directionalLights.value = lights.state.directional, uniforms.directionalLightShadows.value = lights.state.directionalShadow, uniforms.spotLights.value = lights.state.spot, uniforms.spotLightShadows.value = lights.state.spotShadow, uniforms.rectAreaLights.value = lights.state.rectArea, uniforms.ltc_1.value = lights.state.rectAreaLTC1, uniforms.ltc_2.value = lights.state.rectAreaLTC2, uniforms.pointLights.value = lights.state.point, uniforms.pointLightShadows.value = lights.state.pointShadow, uniforms.hemisphereLights.value = lights.state.hemi, uniforms.directionalShadowMap.value = lights.state.directionalShadowMap, uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix, uniforms.spotShadowMap.value = lights.state.spotShadowMap, uniforms.spotLightMatrix.value = lights.state.spotLightMatrix, uniforms.spotLightMap.value = lights.state.spotLightMap, uniforms.pointShadowMap.value = lights.state.pointShadowMap, uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix), materialProperties.currentProgram = program, materialProperties.uniformsList = null, program;
              }
              function getUniformList(materialProperties) {
                if (materialProperties.uniformsList === null) {
                  let progUniforms = materialProperties.currentProgram.getUniforms();
                  materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
                }
                return materialProperties.uniformsList;
              }
              function updateCommonMaterialProperties(material, parameters2) {
                let materialProperties = properties.get(material);
                materialProperties.outputColorSpace = parameters2.outputColorSpace, materialProperties.batching = parameters2.batching, materialProperties.instancing = parameters2.instancing, materialProperties.instancingColor = parameters2.instancingColor, materialProperties.instancingMorph = parameters2.instancingMorph, materialProperties.skinning = parameters2.skinning, materialProperties.morphTargets = parameters2.morphTargets, materialProperties.morphNormals = parameters2.morphNormals, materialProperties.morphColors = parameters2.morphColors, materialProperties.morphTargetsCount = parameters2.morphTargetsCount, materialProperties.numClippingPlanes = parameters2.numClippingPlanes, materialProperties.numIntersection = parameters2.numClipIntersection, materialProperties.vertexAlphas = parameters2.vertexAlphas, materialProperties.vertexTangents = parameters2.vertexTangents, materialProperties.toneMapping = parameters2.toneMapping, materialProperties.numMultiviewViews = parameters2.numMultiviewViews;
              }
              function setProgram(camera, scene, geometry, material, object) {
                scene.isScene !== !0 && (scene = _emptyScene), textures.resetTextureUnits();
                let fog = scene.fog, environment = material.isMeshStandardMaterial ? scene.environment : null, colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === !0 ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace, envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment), vertexAlphas = material.vertexColors === !0 && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4, vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0), morphTargets = !!geometry.morphAttributes.position, morphNormals = !!geometry.morphAttributes.normal, morphColors = !!geometry.morphAttributes.color, toneMapping = NoToneMapping;
                material.toneMapped && (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === !0) && (toneMapping = _this.toneMapping);
                let numMultiviewViews = _currentRenderTarget && _currentRenderTarget.isWebGLMultiviewRenderTarget ? _currentRenderTarget.numViews : 0, morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color, morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0, materialProperties = properties.get(material), lights = currentRenderState.state.lights;
                if (_clippingEnabled === !0 && (_localClippingEnabled === !0 || camera !== _currentCamera)) {
                  let useCache = camera === _currentCamera && material.id === _currentMaterialId;
                  clipping.setState(material, camera, useCache);
                }
                let needsProgramChange = !1;
                material.version === materialProperties.__version ? (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version || materialProperties.outputColorSpace !== colorSpace || object.isBatchedMesh && materialProperties.batching === !1 || !object.isBatchedMesh && materialProperties.batching === !0 || object.isInstancedMesh && materialProperties.instancing === !1 || !object.isInstancedMesh && materialProperties.instancing === !0 || object.isSkinnedMesh && materialProperties.skinning === !1 || !object.isSkinnedMesh && materialProperties.skinning === !0 || object.isInstancedMesh && materialProperties.instancingColor === !0 && object.instanceColor === null || object.isInstancedMesh && materialProperties.instancingColor === !1 && object.instanceColor !== null || object.isInstancedMesh && materialProperties.instancingMorph === !0 && object.morphTexture === null || object.isInstancedMesh && materialProperties.instancingMorph === !1 && object.morphTexture !== null || materialProperties.envMap !== envMap || material.fog === !0 && materialProperties.fog !== fog || materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection) || materialProperties.vertexAlphas !== vertexAlphas || materialProperties.vertexTangents !== vertexTangents || materialProperties.morphTargets !== morphTargets || materialProperties.morphNormals !== morphNormals || materialProperties.morphColors !== morphColors || materialProperties.toneMapping !== toneMapping || materialProperties.morphTargetsCount !== morphTargetsCount || materialProperties.numMultiviewViews !== numMultiviewViews) && (needsProgramChange = !0) : (needsProgramChange = !0, materialProperties.__version = material.version);
                let program = materialProperties.currentProgram;
                needsProgramChange === !0 && (program = getProgram(material, scene, object));
                let refreshProgram = !1, refreshMaterial = !1, refreshLights = !1, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
                if (state.useProgram(program.program) && (refreshProgram = !0, refreshMaterial = !0, refreshLights = !0), material.id !== _currentMaterialId && (_currentMaterialId = material.id, refreshMaterial = !0), refreshProgram || _currentCamera !== camera) {
                  program.numMultiviewViews > 0 ? (multiview.updateCameraProjectionMatricesUniform(camera, p_uniforms), multiview.updateCameraViewMatricesUniform(camera, p_uniforms)) : (p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix), p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse));
                  let uCamPos = p_uniforms.map.cameraPosition;
                  uCamPos !== void 0 && uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld)), capabilities.logarithmicDepthBuffer && p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2)), (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) && p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === !0), _currentCamera !== camera && (_currentCamera = camera, refreshMaterial = !0, refreshLights = !0);
                }
                if (object.isSkinnedMesh) {
                  p_uniforms.setOptional(_gl, object, "bindMatrix"), p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
                  let skeleton = object.skeleton;
                  skeleton && (skeleton.boneTexture === null && skeleton.computeBoneTexture(), p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures));
                }
                object.isBatchedMesh && (p_uniforms.setOptional(_gl, object, "batchingTexture"), p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures));
                let morphAttributes = geometry.morphAttributes;
                if ((morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) && morphtargets.update(object, geometry, program), (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) && (materialProperties.receiveShadow = object.receiveShadow, p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow)), material.isMeshGouraudMaterial && material.envMap !== null && (m_uniforms.envMap.value = envMap, m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === !1 ? -1 : 1), material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null && (m_uniforms.envMapIntensity.value = scene.environmentIntensity), refreshMaterial && (p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure), materialProperties.needsLights && markUniformsLightsNeedsUpdate(m_uniforms, refreshLights), fog && material.fog === !0 && materials.refreshFogUniforms(m_uniforms, fog), materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]), WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures)), material.isShaderMaterial && material.uniformsNeedUpdate === !0 && (WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures), material.uniformsNeedUpdate = !1), material.isSpriteMaterial && p_uniforms.setValue(_gl, "center", object.center), program.numMultiviewViews > 0 ? multiview.updateObjectMatricesUniforms(object, camera, p_uniforms) : (p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix), p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix)), p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld), material.isShaderMaterial || material.isRawShaderMaterial) {
                  let groups = material.uniformsGroups;
                  for (let i = 0, l = groups.length; i < l; i++) {
                    let group = groups[i];
                    uniformsGroups.update(group, program), uniformsGroups.bind(group, program);
                  }
                }
                return program;
              }
              function markUniformsLightsNeedsUpdate(uniforms, value) {
                uniforms.ambientLightColor.needsUpdate = value, uniforms.lightProbe.needsUpdate = value, uniforms.directionalLights.needsUpdate = value, uniforms.directionalLightShadows.needsUpdate = value, uniforms.pointLights.needsUpdate = value, uniforms.pointLightShadows.needsUpdate = value, uniforms.spotLights.needsUpdate = value, uniforms.spotLightShadows.needsUpdate = value, uniforms.rectAreaLights.needsUpdate = value, uniforms.hemisphereLights.needsUpdate = value;
              }
              function materialNeedsLights(material) {
                return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === !0;
              }
              this.setTexture2D = function() {
                var warned = !1;
                return function(texture, slot) {
                  texture && texture.isWebGLRenderTarget && (warned || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), warned = !0), texture = texture.texture), textures.setTexture2D(texture, slot);
                };
              }(), this.getActiveCubeFace = function() {
                return _currentActiveCubeFace;
              }, this.getActiveMipmapLevel = function() {
                return _currentActiveMipmapLevel;
              }, this.getRenderTarget = function() {
                return _currentRenderTarget;
              }, this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
                properties.get(renderTarget.texture).__webglTexture = colorTexture, properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
                let renderTargetProperties = properties.get(renderTarget);
                renderTargetProperties.__hasExternalTextures = !0, renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0, !renderTargetProperties.__autoAllocateDepthBuffer && (!_currentRenderTarget || !_currentRenderTarget.isWebGLMultiviewRenderTarget) && extensions.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), renderTargetProperties.__useRenderToTexture = !1);
              }, this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
                let renderTargetProperties = properties.get(renderTarget);
                renderTargetProperties.__webglFramebuffer = defaultFramebuffer, renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
              }, this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
                _currentRenderTarget = renderTarget, _currentActiveCubeFace = activeCubeFace, _currentActiveMipmapLevel = activeMipmapLevel;
                let useDefaultFramebuffer = !0, framebuffer = null, isCube = !1, isRenderTarget3D = !1;
                if (renderTarget) {
                  let renderTargetProperties = properties.get(renderTarget);
                  renderTargetProperties.__useDefaultFramebuffer !== void 0 ? (state.bindFramebuffer(_gl.FRAMEBUFFER, null), useDefaultFramebuffer = !1) : renderTargetProperties.__webglFramebuffer === void 0 ? textures.setupRenderTarget(renderTarget) : renderTargetProperties.__hasExternalTextures && textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
                  let texture = renderTarget.texture;
                  (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) && (isRenderTarget3D = !0);
                  let __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                  renderTarget.isWebGLCubeRenderTarget ? (Array.isArray(__webglFramebuffer[activeCubeFace]) ? framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel] : framebuffer = __webglFramebuffer[activeCubeFace], isCube = !0) : renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === !1 ? framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer : Array.isArray(__webglFramebuffer) ? framebuffer = __webglFramebuffer[activeMipmapLevel] : framebuffer = __webglFramebuffer, _currentViewport.copy(renderTarget.viewport), _currentScissor.copy(renderTarget.scissor), _currentScissorTest = renderTarget.scissorTest;
                } else
                  _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor(), _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor(), _currentScissorTest = _scissorTest;
                if (state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer) && useDefaultFramebuffer && state.drawBuffers(renderTarget, framebuffer), state.viewport(_currentViewport), state.scissor(_currentScissor), state.setScissorTest(_currentScissorTest), isCube) {
                  let textureProperties = properties.get(renderTarget.texture);
                  _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
                } else if (isRenderTarget3D) {
                  let textureProperties = properties.get(renderTarget.texture), layer = activeCubeFace || 0;
                  _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
                }
                _currentMaterialId = -1;
              }, this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
                if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                  return;
                }
                let framebuffer = properties.get(renderTarget).__webglFramebuffer;
                if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0 && (framebuffer = framebuffer[activeCubeFaceIndex]), framebuffer) {
                  state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                  try {
                    let texture = renderTarget.texture, textureFormat = texture.format, textureType = texture.type;
                    if (!capabilities.textureFormatReadable(textureFormat)) {
                      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                      return;
                    }
                    if (!capabilities.textureTypeReadable(textureType)) {
                      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                      return;
                    }
                    x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height && _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                  } finally {
                    let framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
                  }
                }
              }, this.copyFramebufferToTexture = function(position, texture, level = 0) {
                let levelScale = Math.pow(2, -level), width = Math.floor(texture.image.width * levelScale), height = Math.floor(texture.image.height * levelScale);
                textures.setTexture2D(texture, 0), _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height), state.unbindTexture();
              }, this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
                let width = srcTexture.image.width, height = srcTexture.image.height, glFormat = utils.convert(dstTexture.format), glType = utils.convert(dstTexture.type);
                textures.setTexture2D(dstTexture, 0), _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha), _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment), srcTexture.isDataTexture ? _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data) : srcTexture.isCompressedTexture ? _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data) : _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image), level === 0 && dstTexture.generateMipmaps && _gl.generateMipmap(_gl.TEXTURE_2D), state.unbindTexture();
              }, this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
                let width = sourceBox.max.x - sourceBox.min.x, height = sourceBox.max.y - sourceBox.min.y, depth2 = sourceBox.max.z - sourceBox.min.z, glFormat = utils.convert(dstTexture.format), glType = utils.convert(dstTexture.type), glTarget;
                if (dstTexture.isData3DTexture)
                  textures.setTexture3D(dstTexture, 0), glTarget = _gl.TEXTURE_3D;
                else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture)
                  textures.setTexture2DArray(dstTexture, 0), glTarget = _gl.TEXTURE_2D_ARRAY;
                else {
                  console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                  return;
                }
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha), _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
                let unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH), unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT), unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS), unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS), unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES), image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
                _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width), _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height), _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x), _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y), _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z), srcTexture.isDataTexture || srcTexture.isData3DTexture ? _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image.data) : dstTexture.isCompressedArrayTexture ? _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, image.data) : _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image), _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen), _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight), _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels), _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows), _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages), level === 0 && dstTexture.generateMipmaps && _gl.generateMipmap(glTarget), state.unbindTexture();
              }, this.initTexture = function(texture) {
                texture.isCubeTexture ? textures.setTextureCube(texture, 0) : texture.isData3DTexture ? textures.setTexture3D(texture, 0) : texture.isDataArrayTexture || texture.isCompressedArrayTexture ? textures.setTexture2DArray(texture, 0) : textures.setTexture2D(texture, 0), state.unbindTexture();
              }, this.resetState = function() {
                _currentActiveCubeFace = 0, _currentActiveMipmapLevel = 0, _currentRenderTarget = null, state.reset(), bindingStates.reset();
              }, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
            }
            get coordinateSystem() {
              return WebGLCoordinateSystem;
            }
            get outputColorSpace() {
              return this._outputColorSpace;
            }
            set outputColorSpace(colorSpace) {
              this._outputColorSpace = colorSpace;
              let gl = this.getContext();
              gl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? "display-p3" : "srgb", gl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? "display-p3" : "srgb";
            }
            get useLegacyLights() {
              return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
            }
            set useLegacyLights(value) {
              console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = value;
            }
          }
          class FogExp2 {
            constructor(color, density = 25e-5) {
              this.isFogExp2 = !0, this.name = "", this.color = new Color(color), this.density = density;
            }
            clone() {
              return new FogExp2(this.color, this.density);
            }
            toJSON() {
              return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density };
            }
          }
          class Fog {
            constructor(color, near = 1, far = 1e3) {
              this.isFog = !0, this.name = "", this.color = new Color(color), this.near = near, this.far = far;
            }
            clone() {
              return new Fog(this.color, this.near, this.far);
            }
            toJSON() {
              return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far };
            }
          }
          class Scene extends Object3D {
            constructor() {
              super();
              this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Euler(), this.environmentIntensity = 1, this.environmentRotation = new Euler(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
            }
            copy(source, recursive) {
              return super.copy(source, recursive), source.background !== null && (this.background = source.background.clone()), source.environment !== null && (this.environment = source.environment.clone()), source.fog !== null && (this.fog = source.fog.clone()), this.backgroundBlurriness = source.backgroundBlurriness, this.backgroundIntensity = source.backgroundIntensity, this.backgroundRotation.copy(source.backgroundRotation), this.environmentIntensity = source.environmentIntensity, this.environmentRotation.copy(source.environmentRotation), source.overrideMaterial !== null && (this.overrideMaterial = source.overrideMaterial.clone()), this.matrixAutoUpdate = source.matrixAutoUpdate, this;
            }
            toJSON(meta) {
              let data = super.toJSON(meta);
              return this.fog !== null && (data.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (data.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (data.object.backgroundIntensity = this.backgroundIntensity), data.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (data.object.environmentIntensity = this.environmentIntensity), data.object.environmentRotation = this.environmentRotation.toArray(), data;
            }
          }
          class InterleavedBuffer {
            constructor(array, stride) {
              this.isInterleavedBuffer = !0, this.array = array, this.stride = stride, this.count = array !== void 0 ? array.length / stride : 0, this.usage = StaticDrawUsage, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = generateUUID();
            }
            onUploadCallback() {
            }
            set needsUpdate(value) {
              value === !0 && this.version++;
            }
            get updateRange() {
              return warnOnce("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
            }
            setUsage(value) {
              return this.usage = value, this;
            }
            addUpdateRange(start, count) {
              this.updateRanges.push({ start, count });
            }
            clearUpdateRanges() {
              this.updateRanges.length = 0;
            }
            copy(source) {
              return this.array = new source.array.constructor(source.array), this.count = source.count, this.stride = source.stride, this.usage = source.usage, this;
            }
            copyAt(index1, attribute, index2) {
              index1 *= this.stride, index2 *= attribute.stride;
              for (let i = 0, l = this.stride; i < l; i++)
                this.array[index1 + i] = attribute.array[index2 + i];
              return this;
            }
            set(value, offset = 0) {
              return this.array.set(value, offset), this;
            }
            clone(data) {
              data.arrayBuffers === void 0 && (data.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()), data.arrayBuffers[this.array.buffer._uuid] === void 0 && (data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
              let array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]), ib = new this.constructor(array, this.stride);
              return ib.setUsage(this.usage), ib;
            }
            onUpload(callback) {
              return this.onUploadCallback = callback, this;
            }
            toJSON(data) {
              return data.arrayBuffers === void 0 && (data.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = generateUUID()), data.arrayBuffers[this.array.buffer._uuid] === void 0 && (data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
            }
          }
          let _vector$6 = /* @__PURE__ */ new Vector3();
          class InterleavedBufferAttribute {
            constructor(interleavedBuffer, itemSize, offset, normalized = !1) {
              this.isInterleavedBufferAttribute = !0, this.name = "", this.data = interleavedBuffer, this.itemSize = itemSize, this.offset = offset, this.normalized = normalized;
            }
            get count() {
              return this.data.count;
            }
            get array() {
              return this.data.array;
            }
            set needsUpdate(value) {
              this.data.needsUpdate = value;
            }
            applyMatrix4(m) {
              for (let i = 0, l = this.data.count; i < l; i++)
                _vector$6.fromBufferAttribute(this, i), _vector$6.applyMatrix4(m), this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
              return this;
            }
            applyNormalMatrix(m) {
              for (let i = 0, l = this.count; i < l; i++)
                _vector$6.fromBufferAttribute(this, i), _vector$6.applyNormalMatrix(m), this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
              return this;
            }
            transformDirection(m) {
              for (let i = 0, l = this.count; i < l; i++)
                _vector$6.fromBufferAttribute(this, i), _vector$6.transformDirection(m), this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
              return this;
            }
            getComponent(index, component) {
              let value = this.array[index * this.data.stride + this.offset + component];
              return this.normalized && (value = denormalize(value, this.array)), value;
            }
            setComponent(index, component, value) {
              return this.normalized && (value = normalize(value, this.array)), this.data.array[index * this.data.stride + this.offset + component] = value, this;
            }
            setX(index, x) {
              return this.normalized && (x = normalize(x, this.array)), this.data.array[index * this.data.stride + this.offset] = x, this;
            }
            setY(index, y) {
              return this.normalized && (y = normalize(y, this.array)), this.data.array[index * this.data.stride + this.offset + 1] = y, this;
            }
            setZ(index, z) {
              return this.normalized && (z = normalize(z, this.array)), this.data.array[index * this.data.stride + this.offset + 2] = z, this;
            }
            setW(index, w) {
              return this.normalized && (w = normalize(w, this.array)), this.data.array[index * this.data.stride + this.offset + 3] = w, this;
            }
            getX(index) {
              let x = this.data.array[index * this.data.stride + this.offset];
              return this.normalized && (x = denormalize(x, this.array)), x;
            }
            getY(index) {
              let y = this.data.array[index * this.data.stride + this.offset + 1];
              return this.normalized && (y = denormalize(y, this.array)), y;
            }
            getZ(index) {
              let z = this.data.array[index * this.data.stride + this.offset + 2];
              return this.normalized && (z = denormalize(z, this.array)), z;
            }
            getW(index) {
              let w = this.data.array[index * this.data.stride + this.offset + 3];
              return this.normalized && (w = denormalize(w, this.array)), w;
            }
            setXY(index, x, y) {
              return index = index * this.data.stride + this.offset, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array)), this.data.array[index + 0] = x, this.data.array[index + 1] = y, this;
            }
            setXYZ(index, x, y, z) {
              return index = index * this.data.stride + this.offset, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array), z = normalize(z, this.array)), this.data.array[index + 0] = x, this.data.array[index + 1] = y, this.data.array[index + 2] = z, this;
            }
            setXYZW(index, x, y, z, w) {
              return index = index * this.data.stride + this.offset, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array), z = normalize(z, this.array), w = normalize(w, this.array)), this.data.array[index + 0] = x, this.data.array[index + 1] = y, this.data.array[index + 2] = z, this.data.array[index + 3] = w, this;
            }
            clone(data) {
              if (data === void 0) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                let array = [];
                for (let i = 0; i < this.count; i++) {
                  let index = i * this.data.stride + this.offset;
                  for (let j = 0; j < this.itemSize; j++)
                    array.push(this.data.array[index + j]);
                }
                return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
              } else
                return data.interleavedBuffers === void 0 && (data.interleavedBuffers = {}), data.interleavedBuffers[this.data.uuid] === void 0 && (data.interleavedBuffers[this.data.uuid] = this.data.clone(data)), new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
            }
            toJSON(data) {
              if (data === void 0) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                let array = [];
                for (let i = 0; i < this.count; i++) {
                  let index = i * this.data.stride + this.offset;
                  for (let j = 0; j < this.itemSize; j++)
                    array.push(this.data.array[index + j]);
                }
                return { itemSize: this.itemSize, type: this.array.constructor.name, array, normalized: this.normalized };
              } else
                return data.interleavedBuffers === void 0 && (data.interleavedBuffers = {}), data.interleavedBuffers[this.data.uuid] === void 0 && (data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
            }
          }
          class SpriteMaterial extends Material {
            constructor(parameters) {
              super();
              this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.color.copy(source.color), this.map = source.map, this.alphaMap = source.alphaMap, this.rotation = source.rotation, this.sizeAttenuation = source.sizeAttenuation, this.fog = source.fog, this;
            }
          }
          let _geometry, _intersectPoint = /* @__PURE__ */ new Vector3(), _worldScale = /* @__PURE__ */ new Vector3(), _mvPosition = /* @__PURE__ */ new Vector3(), _alignedPosition = /* @__PURE__ */ new Vector2(), _rotatedPosition = /* @__PURE__ */ new Vector2(), _viewWorldMatrix = /* @__PURE__ */ new Matrix4(), _vA = /* @__PURE__ */ new Vector3(), _vB = /* @__PURE__ */ new Vector3(), _vC = /* @__PURE__ */ new Vector3(), _uvA = /* @__PURE__ */ new Vector2(), _uvB = /* @__PURE__ */ new Vector2(), _uvC = /* @__PURE__ */ new Vector2();
          class Sprite extends Object3D {
            constructor(material = new SpriteMaterial()) {
              super();
              if (this.isSprite = !0, this.type = "Sprite", _geometry === void 0) {
                _geometry = new BufferGeometry();
                let float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), interleavedBuffer = new InterleavedBuffer(float32Array, 5);
                _geometry.setIndex([0, 1, 2, 0, 2, 3]), _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, !1)), _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, !1));
              }
              this.geometry = _geometry, this.material = material, this.center = new Vector2(0.5, 0.5);
            }
            raycast(raycaster, intersects2) {
              raycaster.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _worldScale.setFromMatrixScale(this.matrixWorld), _viewWorldMatrix.copy(raycaster.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld), _mvPosition.setFromMatrixPosition(this.modelViewMatrix), raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && _worldScale.multiplyScalar(-_mvPosition.z);
              let rotation = this.material.rotation, sin, cos;
              rotation !== 0 && (cos = Math.cos(rotation), sin = Math.sin(rotation));
              let center = this.center;
              transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos), transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos), transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos), _uvA.set(0, 0), _uvB.set(1, 0), _uvC.set(1, 1);
              let intersect2 = raycaster.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint);
              if (intersect2 === null && (transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos), _uvB.set(0, 1), intersect2 = raycaster.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint), intersect2 === null))
                return;
              let distance = raycaster.ray.origin.distanceTo(_intersectPoint);
              distance < raycaster.near || distance > raycaster.far || intersects2.push({ distance, point: _intersectPoint.clone(), uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()), face: null, object: this });
            }
            copy(source, recursive) {
              return super.copy(source, recursive), source.center !== void 0 && this.center.copy(source.center), this.material = source.material, this;
            }
          }
          function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
            _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale), sin !== void 0 ? (_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y, _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition), vertexPosition.copy(mvPosition), vertexPosition.x += _rotatedPosition.x, vertexPosition.y += _rotatedPosition.y, vertexPosition.applyMatrix4(_viewWorldMatrix);
          }
          let _v1$2 = /* @__PURE__ */ new Vector3(), _v2$1 = /* @__PURE__ */ new Vector3();
          class LOD extends Object3D {
            constructor() {
              super();
              this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0;
            }
            copy(source) {
              super.copy(source, !1);
              let levels = source.levels;
              for (let i = 0, l = levels.length; i < l; i++) {
                let level = levels[i];
                this.addLevel(level.object.clone(), level.distance, level.hysteresis);
              }
              return this.autoUpdate = source.autoUpdate, this;
            }
            addLevel(object, distance = 0, hysteresis = 0) {
              distance = Math.abs(distance);
              let levels = this.levels, l;
              for (l = 0; l < levels.length && !(distance < levels[l].distance); l++)
                ;
              return levels.splice(l, 0, { distance, hysteresis, object }), this.add(object), this;
            }
            getCurrentLevel() {
              return this._currentLevel;
            }
            getObjectForDistance(distance) {
              let levels = this.levels;
              if (levels.length > 0) {
                let i, l;
                for (i = 1, l = levels.length; i < l; i++) {
                  let levelDistance = levels[i].distance;
                  if (levels[i].object.visible && (levelDistance -= levelDistance * levels[i].hysteresis), distance < levelDistance)
                    break;
                }
                return levels[i - 1].object;
              }
              return null;
            }
            raycast(raycaster, intersects2) {
              if (this.levels.length > 0) {
                _v1$2.setFromMatrixPosition(this.matrixWorld);
                let distance = raycaster.ray.origin.distanceTo(_v1$2);
                this.getObjectForDistance(distance).raycast(raycaster, intersects2);
              }
            }
            update(camera) {
              let levels = this.levels;
              if (levels.length > 1) {
                _v1$2.setFromMatrixPosition(camera.matrixWorld), _v2$1.setFromMatrixPosition(this.matrixWorld);
                let distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
                levels[0].object.visible = !0;
                let i, l;
                for (i = 1, l = levels.length; i < l; i++) {
                  let levelDistance = levels[i].distance;
                  if (levels[i].object.visible && (levelDistance -= levelDistance * levels[i].hysteresis), distance >= levelDistance)
                    levels[i - 1].object.visible = !1, levels[i].object.visible = !0;
                  else
                    break;
                }
                for (this._currentLevel = i - 1; i < l; i++)
                  levels[i].object.visible = !1;
              }
            }
            toJSON(meta) {
              let data = super.toJSON(meta);
              this.autoUpdate === !1 && (data.object.autoUpdate = !1), data.object.levels = [];
              let levels = this.levels;
              for (let i = 0, l = levels.length; i < l; i++) {
                let level = levels[i];
                data.object.levels.push({ object: level.object.uuid, distance: level.distance, hysteresis: level.hysteresis });
              }
              return data;
            }
          }
          let _basePosition = /* @__PURE__ */ new Vector3(), _skinIndex = /* @__PURE__ */ new Vector4(), _skinWeight = /* @__PURE__ */ new Vector4(), _vector3 = /* @__PURE__ */ new Vector3(), _matrix4 = /* @__PURE__ */ new Matrix4(), _vertex = /* @__PURE__ */ new Vector3(), _sphere$4 = /* @__PURE__ */ new Sphere(), _inverseMatrix$2 = /* @__PURE__ */ new Matrix4(), _ray$2 = /* @__PURE__ */ new Ray();
          class SkinnedMesh extends Mesh {
            constructor(geometry, material) {
              super(geometry, material);
              this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = AttachedBindMode, this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4(), this.boundingBox = null, this.boundingSphere = null;
            }
            computeBoundingBox() {
              let geometry = this.geometry;
              this.boundingBox === null && (this.boundingBox = new Box3()), this.boundingBox.makeEmpty();
              let positionAttribute = geometry.getAttribute("position");
              for (let i = 0; i < positionAttribute.count; i++)
                this.getVertexPosition(i, _vertex), this.boundingBox.expandByPoint(_vertex);
            }
            computeBoundingSphere() {
              let geometry = this.geometry;
              this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingSphere.makeEmpty();
              let positionAttribute = geometry.getAttribute("position");
              for (let i = 0; i < positionAttribute.count; i++)
                this.getVertexPosition(i, _vertex), this.boundingSphere.expandByPoint(_vertex);
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.bindMode = source.bindMode, this.bindMatrix.copy(source.bindMatrix), this.bindMatrixInverse.copy(source.bindMatrixInverse), this.skeleton = source.skeleton, source.boundingBox !== null && (this.boundingBox = source.boundingBox.clone()), source.boundingSphere !== null && (this.boundingSphere = source.boundingSphere.clone()), this;
            }
            raycast(raycaster, intersects2) {
              let material = this.material, matrixWorld = this.matrixWorld;
              material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _sphere$4.copy(this.boundingSphere), _sphere$4.applyMatrix4(matrixWorld), raycaster.ray.intersectsSphere(_sphere$4) !== !1 && (_inverseMatrix$2.copy(matrixWorld).invert(), _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2), !(this.boundingBox !== null && _ray$2.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(raycaster, intersects2, _ray$2)));
            }
            getVertexPosition(index, target) {
              return super.getVertexPosition(index, target), this.applyBoneTransform(index, target), target;
            }
            bind(skeleton, bindMatrix) {
              this.skeleton = skeleton, bindMatrix === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), bindMatrix = this.matrixWorld), this.bindMatrix.copy(bindMatrix), this.bindMatrixInverse.copy(bindMatrix).invert();
            }
            pose() {
              this.skeleton.pose();
            }
            normalizeSkinWeights() {
              let vector = new Vector4(), skinWeight = this.geometry.attributes.skinWeight;
              for (let i = 0, l = skinWeight.count; i < l; i++) {
                vector.fromBufferAttribute(skinWeight, i);
                let scale = 1 / vector.manhattanLength();
                scale !== 1 / 0 ? vector.multiplyScalar(scale) : vector.set(1, 0, 0, 0), skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
              }
            }
            updateMatrixWorld(force) {
              super.updateMatrixWorld(force), this.bindMode === AttachedBindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === DetachedBindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
            }
            applyBoneTransform(index, vector) {
              let skeleton = this.skeleton, geometry = this.geometry;
              _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index), _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index), _basePosition.copy(vector).applyMatrix4(this.bindMatrix), vector.set(0, 0, 0);
              for (let i = 0; i < 4; i++) {
                let weight = _skinWeight.getComponent(i);
                if (weight !== 0) {
                  let boneIndex = _skinIndex.getComponent(i);
                  _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]), vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
                }
              }
              return vector.applyMatrix4(this.bindMatrixInverse);
            }
          }
          class Bone extends Object3D {
            constructor() {
              super();
              this.isBone = !0, this.type = "Bone";
            }
          }
          class DataTexture extends Texture {
            constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
              super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
              this.isDataTexture = !0, this.image = { data, width, height }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
            }
          }
          let _offsetMatrix = /* @__PURE__ */ new Matrix4(), _identityMatrix$1 = /* @__PURE__ */ new Matrix4();
          class Skeleton {
            constructor(bones = [], boneInverses = []) {
              this.uuid = generateUUID(), this.bones = bones.slice(0), this.boneInverses = boneInverses, this.boneMatrices = null, this.boneTexture = null, this.init();
            }
            init() {
              let bones = this.bones, boneInverses = this.boneInverses;
              if (this.boneMatrices = new Float32Array(bones.length * 16), boneInverses.length === 0)
                this.calculateInverses();
              else if (bones.length !== boneInverses.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                for (let i = 0, il = this.bones.length; i < il; i++)
                  this.boneInverses.push(new Matrix4());
              }
            }
            calculateInverses() {
              this.boneInverses.length = 0;
              for (let i = 0, il = this.bones.length; i < il; i++) {
                let inverse = new Matrix4();
                this.bones[i] && inverse.copy(this.bones[i].matrixWorld).invert(), this.boneInverses.push(inverse);
              }
            }
            pose() {
              for (let i = 0, il = this.bones.length; i < il; i++) {
                let bone = this.bones[i];
                bone && bone.matrixWorld.copy(this.boneInverses[i]).invert();
              }
              for (let i = 0, il = this.bones.length; i < il; i++) {
                let bone = this.bones[i];
                bone && (bone.parent && bone.parent.isBone ? (bone.matrix.copy(bone.parent.matrixWorld).invert(), bone.matrix.multiply(bone.matrixWorld)) : bone.matrix.copy(bone.matrixWorld), bone.matrix.decompose(bone.position, bone.quaternion, bone.scale));
              }
            }
            update() {
              let bones = this.bones, boneInverses = this.boneInverses, boneMatrices = this.boneMatrices, boneTexture = this.boneTexture;
              for (let i = 0, il = bones.length; i < il; i++) {
                let matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix$1;
                _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]), _offsetMatrix.toArray(boneMatrices, i * 16);
              }
              boneTexture !== null && (boneTexture.needsUpdate = !0);
            }
            clone() {
              return new Skeleton(this.bones, this.boneInverses);
            }
            computeBoneTexture() {
              let size = Math.sqrt(this.bones.length * 4);
              size = Math.ceil(size / 4) * 4, size = Math.max(size, 4);
              let boneMatrices = new Float32Array(size * size * 4);
              boneMatrices.set(this.boneMatrices);
              let boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
              return boneTexture.needsUpdate = !0, this.boneMatrices = boneMatrices, this.boneTexture = boneTexture, this;
            }
            getBoneByName(name) {
              for (let i = 0, il = this.bones.length; i < il; i++) {
                let bone = this.bones[i];
                if (bone.name === name)
                  return bone;
              }
            }
            dispose() {
              this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
            }
            fromJSON(json, bones) {
              this.uuid = json.uuid;
              for (let i = 0, l = json.bones.length; i < l; i++) {
                let uuid = json.bones[i], bone = bones[uuid];
                bone === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", uuid), bone = new Bone()), this.bones.push(bone), this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
              }
              return this.init(), this;
            }
            toJSON() {
              let data = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
              data.uuid = this.uuid;
              let bones = this.bones, boneInverses = this.boneInverses;
              for (let i = 0, l = bones.length; i < l; i++) {
                let bone = bones[i];
                data.bones.push(bone.uuid);
                let boneInverse = boneInverses[i];
                data.boneInverses.push(boneInverse.toArray());
              }
              return data;
            }
          }
          class InstancedBufferAttribute extends BufferAttribute {
            constructor(array, itemSize, normalized, meshPerAttribute = 1) {
              super(array, itemSize, normalized);
              this.isInstancedBufferAttribute = !0, this.meshPerAttribute = meshPerAttribute;
            }
            copy(source) {
              return super.copy(source), this.meshPerAttribute = source.meshPerAttribute, this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.meshPerAttribute = this.meshPerAttribute, data.isInstancedBufferAttribute = !0, data;
            }
          }
          let _instanceLocalMatrix = /* @__PURE__ */ new Matrix4(), _instanceWorldMatrix = /* @__PURE__ */ new Matrix4(), _instanceIntersects = [], _box3 = /* @__PURE__ */ new Box3(), _identity = /* @__PURE__ */ new Matrix4(), _mesh$1 = /* @__PURE__ */ new Mesh(), _sphere$3 = /* @__PURE__ */ new Sphere();
          class InstancedMesh extends Mesh {
            constructor(geometry, material, count) {
              super(geometry, material);
              this.isInstancedMesh = !0, this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = count, this.boundingBox = null, this.boundingSphere = null;
              for (let i = 0; i < count; i++)
                this.setMatrixAt(i, _identity);
            }
            computeBoundingBox() {
              let geometry = this.geometry, count = this.count;
              this.boundingBox === null && (this.boundingBox = new Box3()), geometry.boundingBox === null && geometry.computeBoundingBox(), this.boundingBox.makeEmpty();
              for (let i = 0; i < count; i++)
                this.getMatrixAt(i, _instanceLocalMatrix), _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix), this.boundingBox.union(_box3);
            }
            computeBoundingSphere() {
              let geometry = this.geometry, count = this.count;
              this.boundingSphere === null && (this.boundingSphere = new Sphere()), geometry.boundingSphere === null && geometry.computeBoundingSphere(), this.boundingSphere.makeEmpty();
              for (let i = 0; i < count; i++)
                this.getMatrixAt(i, _instanceLocalMatrix), _sphere$3.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix), this.boundingSphere.union(_sphere$3);
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.instanceMatrix.copy(source.instanceMatrix), source.morphTexture !== null && (this.morphTexture = source.morphTexture.clone()), source.instanceColor !== null && (this.instanceColor = source.instanceColor.clone()), this.count = source.count, source.boundingBox !== null && (this.boundingBox = source.boundingBox.clone()), source.boundingSphere !== null && (this.boundingSphere = source.boundingSphere.clone()), this;
            }
            getColorAt(index, color) {
              color.fromArray(this.instanceColor.array, index * 3);
            }
            getMatrixAt(index, matrix) {
              matrix.fromArray(this.instanceMatrix.array, index * 16);
            }
            getMorphAt(index, object) {
              let objectInfluences = object.morphTargetInfluences, array = this.morphTexture.source.data.data, len = objectInfluences.length + 1, dataIndex = index * len + 1;
              for (let i = 0; i < objectInfluences.length; i++)
                objectInfluences[i] = array[dataIndex + i];
            }
            raycast(raycaster, intersects2) {
              let matrixWorld = this.matrixWorld, raycastTimes = this.count;
              if (_mesh$1.geometry = this.geometry, _mesh$1.material = this.material, _mesh$1.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), _sphere$3.copy(this.boundingSphere), _sphere$3.applyMatrix4(matrixWorld), raycaster.ray.intersectsSphere(_sphere$3) !== !1))
                for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
                  this.getMatrixAt(instanceId, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix), _mesh$1.matrixWorld = _instanceWorldMatrix, _mesh$1.raycast(raycaster, _instanceIntersects);
                  for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
                    let intersect2 = _instanceIntersects[i];
                    intersect2.instanceId = instanceId, intersect2.object = this, intersects2.push(intersect2);
                  }
                  _instanceIntersects.length = 0;
                }
            }
            setColorAt(index, color) {
              this.instanceColor === null && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3)), color.toArray(this.instanceColor.array, index * 3);
            }
            setMatrixAt(index, matrix) {
              matrix.toArray(this.instanceMatrix.array, index * 16);
            }
            setMorphAt(index, object) {
              let objectInfluences = object.morphTargetInfluences, len = objectInfluences.length + 1;
              this.morphTexture === null && (this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType));
              let array = this.morphTexture.source.data.data, morphInfluencesSum = 0;
              for (let i = 0; i < objectInfluences.length; i++)
                morphInfluencesSum += objectInfluences[i];
              let morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum, dataIndex = len * index;
              array[dataIndex] = morphBaseInfluence, array.set(objectInfluences, dataIndex + 1);
            }
            updateMorphTargets() {
            }
            dispose() {
              return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
            }
          }
          function sortOpaque(a, b) {
            return a.z - b.z;
          }
          function sortTransparent(a, b) {
            return b.z - a.z;
          }
          class MultiDrawRenderList {
            constructor() {
              this.index = 0, this.pool = [], this.list = [];
            }
            push(drawRange, z) {
              let pool = this.pool, list = this.list;
              this.index >= pool.length && pool.push({ start: -1, count: -1, z: -1 });
              let item = pool[this.index];
              list.push(item), this.index++, item.start = drawRange.start, item.count = drawRange.count, item.z = z;
            }
            reset() {
              this.list.length = 0, this.index = 0;
            }
          }
          let ID_ATTR_NAME = "batchId", _matrix$1 = /* @__PURE__ */ new Matrix4(), _invMatrixWorld = /* @__PURE__ */ new Matrix4(), _identityMatrix = /* @__PURE__ */ new Matrix4(), _projScreenMatrix$2 = /* @__PURE__ */ new Matrix4(), _frustum = /* @__PURE__ */ new Frustum(), _box$1 = /* @__PURE__ */ new Box3(), _sphere$2 = /* @__PURE__ */ new Sphere(), _vector$5 = /* @__PURE__ */ new Vector3(), _renderList = /* @__PURE__ */ new MultiDrawRenderList(), _mesh = /* @__PURE__ */ new Mesh(), _batchIntersects = [];
          function copyAttributeData(src, target, targetOffset = 0) {
            let itemSize = target.itemSize;
            if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {
              let vertexCount = src.count;
              for (let i = 0; i < vertexCount; i++)
                for (let c = 0; c < itemSize; c++)
                  target.setComponent(i + targetOffset, c, src.getComponent(i, c));
            } else
              target.array.set(src.array, targetOffset * itemSize);
            target.needsUpdate = !0;
          }
          class BatchedMesh extends Mesh {
            get maxGeometryCount() {
              return this._maxGeometryCount;
            }
            constructor(maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {
              super(new BufferGeometry(), material);
              this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = maxGeometryCount, this._maxVertexCount = maxVertexCount, this._maxIndexCount = maxIndexCount, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(maxGeometryCount), this._multiDrawStarts = new Int32Array(maxGeometryCount), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture();
            }
            _initMatricesTexture() {
              let size = Math.sqrt(this._maxGeometryCount * 4);
              size = Math.ceil(size / 4) * 4, size = Math.max(size, 4);
              let matricesArray = new Float32Array(size * size * 4), matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);
              this._matricesTexture = matricesTexture;
            }
            _initializeGeometry(reference) {
              let geometry = this.geometry, maxVertexCount = this._maxVertexCount, maxGeometryCount = this._maxGeometryCount, maxIndexCount = this._maxIndexCount;
              if (this._geometryInitialized === !1) {
                for (let attributeName in reference.attributes) {
                  let srcAttribute = reference.getAttribute(attributeName), { array, itemSize, normalized } = srcAttribute, dstArray = new array.constructor(maxVertexCount * itemSize), dstAttribute = new BufferAttribute(dstArray, itemSize, normalized);
                  geometry.setAttribute(attributeName, dstAttribute);
                }
                if (reference.getIndex() !== null) {
                  let indexArray = maxVertexCount > 65536 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);
                  geometry.setIndex(new BufferAttribute(indexArray, 1));
                }
                let idArray = maxGeometryCount > 65536 ? new Uint32Array(maxVertexCount) : new Uint16Array(maxVertexCount);
                geometry.setAttribute(ID_ATTR_NAME, new BufferAttribute(idArray, 1)), this._geometryInitialized = !0;
              }
            }
            _validateGeometry(geometry) {
              if (geometry.getAttribute(ID_ATTR_NAME))
                throw new Error(`BatchedMesh: Geometry cannot use attribute "${ID_ATTR_NAME}"`);
              let batchGeometry = this.geometry;
              if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex()))
                throw new Error('BatchedMesh: All geometries must consistently have "index".');
              for (let attributeName in batchGeometry.attributes) {
                if (attributeName === ID_ATTR_NAME)
                  continue;
                if (!geometry.hasAttribute(attributeName))
                  throw new Error(`BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`);
                let srcAttribute = geometry.getAttribute(attributeName), dstAttribute = batchGeometry.getAttribute(attributeName);
                if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized)
                  throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
              }
            }
            setCustomSort(func) {
              return this.customSort = func, this;
            }
            computeBoundingBox() {
              this.boundingBox === null && (this.boundingBox = new Box3());
              let geometryCount = this._geometryCount, boundingBox = this.boundingBox, active = this._active;
              boundingBox.makeEmpty();
              for (let i = 0; i < geometryCount; i++)
                active[i] !== !1 && (this.getMatrixAt(i, _matrix$1), this.getBoundingBoxAt(i, _box$1).applyMatrix4(_matrix$1), boundingBox.union(_box$1));
            }
            computeBoundingSphere() {
              this.boundingSphere === null && (this.boundingSphere = new Sphere());
              let geometryCount = this._geometryCount, boundingSphere = this.boundingSphere, active = this._active;
              boundingSphere.makeEmpty();
              for (let i = 0; i < geometryCount; i++)
                active[i] !== !1 && (this.getMatrixAt(i, _matrix$1), this.getBoundingSphereAt(i, _sphere$2).applyMatrix4(_matrix$1), boundingSphere.union(_sphere$2));
            }
            addGeometry(geometry, vertexCount = -1, indexCount = -1) {
              if (this._initializeGeometry(geometry), this._validateGeometry(geometry), this._geometryCount >= this._maxGeometryCount)
                throw new Error("BatchedMesh: Maximum geometry count reached.");
              let reservedRange = { vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1 }, lastRange = null, reservedRanges = this._reservedRanges, drawRanges = this._drawRanges, bounds = this._bounds;
              this._geometryCount !== 0 && (lastRange = reservedRanges[reservedRanges.length - 1]), vertexCount === -1 ? reservedRange.vertexCount = geometry.getAttribute("position").count : reservedRange.vertexCount = vertexCount, lastRange === null ? reservedRange.vertexStart = 0 : reservedRange.vertexStart = lastRange.vertexStart + lastRange.vertexCount;
              let index = geometry.getIndex(), hasIndex = index !== null;
              if (hasIndex && (indexCount === -1 ? reservedRange.indexCount = index.count : reservedRange.indexCount = indexCount, lastRange === null ? reservedRange.indexStart = 0 : reservedRange.indexStart = lastRange.indexStart + lastRange.indexCount), reservedRange.indexStart !== -1 && reservedRange.indexStart + reservedRange.indexCount > this._maxIndexCount || reservedRange.vertexStart + reservedRange.vertexCount > this._maxVertexCount)
                throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
              let visibility = this._visibility, active = this._active, matricesTexture = this._matricesTexture, matricesArray = this._matricesTexture.image.data;
              visibility.push(!0), active.push(!0);
              let geometryId = this._geometryCount;
              this._geometryCount++, _identityMatrix.toArray(matricesArray, geometryId * 16), matricesTexture.needsUpdate = !0, reservedRanges.push(reservedRange), drawRanges.push({ start: hasIndex ? reservedRange.indexStart : reservedRange.vertexStart, count: -1 }), bounds.push({ boxInitialized: !1, box: new Box3(), sphereInitialized: !1, sphere: new Sphere() });
              let idAttribute = this.geometry.getAttribute(ID_ATTR_NAME);
              for (let i = 0; i < reservedRange.vertexCount; i++)
                idAttribute.setX(reservedRange.vertexStart + i, geometryId);
              return idAttribute.needsUpdate = !0, this.setGeometryAt(geometryId, geometry), geometryId;
            }
            setGeometryAt(id, geometry) {
              if (id >= this._geometryCount)
                throw new Error("BatchedMesh: Maximum geometry count reached.");
              this._validateGeometry(geometry);
              let batchGeometry = this.geometry, hasIndex = batchGeometry.getIndex() !== null, dstIndex = batchGeometry.getIndex(), srcIndex = geometry.getIndex(), reservedRange = this._reservedRanges[id];
              if (hasIndex && srcIndex.count > reservedRange.indexCount || geometry.attributes.position.count > reservedRange.vertexCount)
                throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
              let vertexStart = reservedRange.vertexStart, vertexCount = reservedRange.vertexCount;
              for (let attributeName in batchGeometry.attributes) {
                if (attributeName === ID_ATTR_NAME)
                  continue;
                let srcAttribute = geometry.getAttribute(attributeName), dstAttribute = batchGeometry.getAttribute(attributeName);
                copyAttributeData(srcAttribute, dstAttribute, vertexStart);
                let itemSize = srcAttribute.itemSize;
                for (let i = srcAttribute.count, l = vertexCount; i < l; i++) {
                  let index = vertexStart + i;
                  for (let c = 0; c < itemSize; c++)
                    dstAttribute.setComponent(index, c, 0);
                }
                dstAttribute.needsUpdate = !0, dstAttribute.addUpdateRange(vertexStart * itemSize, vertexCount * itemSize);
              }
              if (hasIndex) {
                let indexStart = reservedRange.indexStart;
                for (let i = 0; i < srcIndex.count; i++)
                  dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));
                for (let i = srcIndex.count, l = reservedRange.indexCount; i < l; i++)
                  dstIndex.setX(indexStart + i, vertexStart);
                dstIndex.needsUpdate = !0, dstIndex.addUpdateRange(indexStart, reservedRange.indexCount);
              }
              let bound = this._bounds[id];
              geometry.boundingBox !== null ? (bound.box.copy(geometry.boundingBox), bound.boxInitialized = !0) : bound.boxInitialized = !1, geometry.boundingSphere !== null ? (bound.sphere.copy(geometry.boundingSphere), bound.sphereInitialized = !0) : bound.sphereInitialized = !1;
              let drawRange = this._drawRanges[id], posAttr = geometry.getAttribute("position");
              return drawRange.count = hasIndex ? srcIndex.count : posAttr.count, this._visibilityChanged = !0, id;
            }
            deleteGeometry(geometryId) {
              let active = this._active;
              return geometryId >= active.length || active[geometryId] === !1 ? this : (active[geometryId] = !1, this._visibilityChanged = !0, this);
            }
            getInstanceCountAt(id) {
              return this._multiDrawInstances === null ? null : this._multiDrawInstances[id];
            }
            setInstanceCountAt(id, instanceCount) {
              return this._multiDrawInstances === null && (this._multiDrawInstances = new Int32Array(this._maxGeometryCount).fill(1)), this._multiDrawInstances[id] = instanceCount, id;
            }
            getBoundingBoxAt(id, target) {
              if (this._active[id] === !1)
                return null;
              let bound = this._bounds[id], box = bound.box, geometry = this.geometry;
              if (bound.boxInitialized === !1) {
                box.makeEmpty();
                let index = geometry.index, position = geometry.attributes.position, drawRange = this._drawRanges[id];
                for (let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i++) {
                  let iv = i;
                  index && (iv = index.getX(iv)), box.expandByPoint(_vector$5.fromBufferAttribute(position, iv));
                }
                bound.boxInitialized = !0;
              }
              return target.copy(box), target;
            }
            getBoundingSphereAt(id, target) {
              if (this._active[id] === !1)
                return null;
              let bound = this._bounds[id], sphere = bound.sphere, geometry = this.geometry;
              if (bound.sphereInitialized === !1) {
                sphere.makeEmpty(), this.getBoundingBoxAt(id, _box$1), _box$1.getCenter(sphere.center);
                let index = geometry.index, position = geometry.attributes.position, drawRange = this._drawRanges[id], maxRadiusSq = 0;
                for (let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i++) {
                  let iv = i;
                  index && (iv = index.getX(iv)), _vector$5.fromBufferAttribute(position, iv), maxRadiusSq = Math.max(maxRadiusSq, sphere.center.distanceToSquared(_vector$5));
                }
                sphere.radius = Math.sqrt(maxRadiusSq), bound.sphereInitialized = !0;
              }
              return target.copy(sphere), target;
            }
            setMatrixAt(geometryId, matrix) {
              let active = this._active, matricesTexture = this._matricesTexture, matricesArray = this._matricesTexture.image.data, geometryCount = this._geometryCount;
              return geometryId >= geometryCount || active[geometryId] === !1 ? this : (matrix.toArray(matricesArray, geometryId * 16), matricesTexture.needsUpdate = !0, this);
            }
            getMatrixAt(geometryId, matrix) {
              let active = this._active, matricesArray = this._matricesTexture.image.data, geometryCount = this._geometryCount;
              return geometryId >= geometryCount || active[geometryId] === !1 ? null : matrix.fromArray(matricesArray, geometryId * 16);
            }
            setVisibleAt(geometryId, value) {
              let visibility = this._visibility, active = this._active, geometryCount = this._geometryCount;
              return geometryId >= geometryCount || active[geometryId] === !1 || visibility[geometryId] === value ? this : (visibility[geometryId] = value, this._visibilityChanged = !0, this);
            }
            getVisibleAt(geometryId) {
              let visibility = this._visibility, active = this._active, geometryCount = this._geometryCount;
              return geometryId >= geometryCount || active[geometryId] === !1 ? !1 : visibility[geometryId];
            }
            raycast(raycaster, intersects2) {
              let visibility = this._visibility, active = this._active, drawRanges = this._drawRanges, geometryCount = this._geometryCount, matrixWorld = this.matrixWorld, batchGeometry = this.geometry;
              _mesh.material = this.material, _mesh.geometry.index = batchGeometry.index, _mesh.geometry.attributes = batchGeometry.attributes, _mesh.geometry.boundingBox === null && (_mesh.geometry.boundingBox = new Box3()), _mesh.geometry.boundingSphere === null && (_mesh.geometry.boundingSphere = new Sphere());
              for (let i = 0; i < geometryCount; i++) {
                if (!visibility[i] || !active[i])
                  continue;
                let drawRange = drawRanges[i];
                _mesh.geometry.setDrawRange(drawRange.start, drawRange.count), this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld), this.getBoundingBoxAt(i, _mesh.geometry.boundingBox), this.getBoundingSphereAt(i, _mesh.geometry.boundingSphere), _mesh.raycast(raycaster, _batchIntersects);
                for (let j = 0, l = _batchIntersects.length; j < l; j++) {
                  let intersect2 = _batchIntersects[j];
                  intersect2.object = this, intersect2.batchId = i, intersects2.push(intersect2);
                }
                _batchIntersects.length = 0;
              }
              _mesh.material = null, _mesh.geometry.index = null, _mesh.geometry.attributes = {}, _mesh.geometry.setDrawRange(0, 1 / 0);
            }
            copy(source) {
              return super.copy(source), this.geometry = source.geometry.clone(), this.perObjectFrustumCulled = source.perObjectFrustumCulled, this.sortObjects = source.sortObjects, this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null, this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null, this._drawRanges = source._drawRanges.map((range) => ({ ...range })), this._reservedRanges = source._reservedRanges.map((range) => ({ ...range })), this._visibility = source._visibility.slice(), this._active = source._active.slice(), this._bounds = source._bounds.map((bound) => ({ boxInitialized: bound.boxInitialized, box: bound.box.clone(), sphereInitialized: bound.sphereInitialized, sphere: bound.sphere.clone() })), this._maxGeometryCount = source._maxGeometryCount, this._maxVertexCount = source._maxVertexCount, this._maxIndexCount = source._maxIndexCount, this._geometryInitialized = source._geometryInitialized, this._geometryCount = source._geometryCount, this._multiDrawCounts = source._multiDrawCounts.slice(), this._multiDrawStarts = source._multiDrawStarts.slice(), this._matricesTexture = source._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
            }
            dispose() {
              return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
            }
            onBeforeRender(renderer, scene, camera, geometry, material) {
              if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
                return;
              let index = geometry.getIndex(), bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT, active = this._active, visibility = this._visibility, multiDrawStarts = this._multiDrawStarts, multiDrawCounts = this._multiDrawCounts, drawRanges = this._drawRanges, perObjectFrustumCulled = this.perObjectFrustumCulled;
              perObjectFrustumCulled && (_projScreenMatrix$2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse).multiply(this.matrixWorld), _frustum.setFromProjectionMatrix(_projScreenMatrix$2, renderer.coordinateSystem));
              let count = 0;
              if (this.sortObjects) {
                _invMatrixWorld.copy(this.matrixWorld).invert(), _vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_invMatrixWorld);
                for (let i = 0, l = visibility.length; i < l; i++)
                  if (visibility[i] && active[i]) {
                    this.getMatrixAt(i, _matrix$1), this.getBoundingSphereAt(i, _sphere$2).applyMatrix4(_matrix$1);
                    let culled = !1;
                    if (perObjectFrustumCulled && (culled = !_frustum.intersectsSphere(_sphere$2)), !culled) {
                      let z = _vector$5.distanceTo(_sphere$2.center);
                      _renderList.push(drawRanges[i], z);
                    }
                  }
                let list = _renderList.list, customSort = this.customSort;
                customSort === null ? list.sort(material.transparent ? sortTransparent : sortOpaque) : customSort.call(this, list, camera);
                for (let i = 0, l = list.length; i < l; i++) {
                  let item = list[i];
                  multiDrawStarts[count] = item.start * bytesPerElement, multiDrawCounts[count] = item.count, count++;
                }
                _renderList.reset();
              } else
                for (let i = 0, l = visibility.length; i < l; i++)
                  if (visibility[i] && active[i]) {
                    let culled = !1;
                    if (perObjectFrustumCulled && (this.getMatrixAt(i, _matrix$1), this.getBoundingSphereAt(i, _sphere$2).applyMatrix4(_matrix$1), culled = !_frustum.intersectsSphere(_sphere$2)), !culled) {
                      let range = drawRanges[i];
                      multiDrawStarts[count] = range.start * bytesPerElement, multiDrawCounts[count] = range.count, count++;
                    }
                  }
              this._multiDrawCount = count, this._visibilityChanged = !1;
            }
            onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial) {
              this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial);
            }
          }
          class LineBasicMaterial extends Material {
            constructor(parameters) {
              super();
              this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Color(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.color.copy(source.color), this.map = source.map, this.linewidth = source.linewidth, this.linecap = source.linecap, this.linejoin = source.linejoin, this.fog = source.fog, this;
            }
          }
          let _vStart = /* @__PURE__ */ new Vector3(), _vEnd = /* @__PURE__ */ new Vector3(), _inverseMatrix$1 = /* @__PURE__ */ new Matrix4(), _ray$1 = /* @__PURE__ */ new Ray(), _sphere$1 = /* @__PURE__ */ new Sphere(), _intersectPointOnRay = /* @__PURE__ */ new Vector3(), _intersectPointOnSegment = /* @__PURE__ */ new Vector3();
          class Line extends Object3D {
            constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
              super();
              this.isLine = !0, this.type = "Line", this.geometry = geometry, this.material = material, this.updateMorphTargets();
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.material = Array.isArray(source.material) ? source.material.slice() : source.material, this.geometry = source.geometry, this;
            }
            computeLineDistances() {
              let geometry = this.geometry;
              if (geometry.index === null) {
                let positionAttribute = geometry.attributes.position, lineDistances = [0];
                for (let i = 1, l = positionAttribute.count; i < l; i++)
                  _vStart.fromBufferAttribute(positionAttribute, i - 1), _vEnd.fromBufferAttribute(positionAttribute, i), lineDistances[i] = lineDistances[i - 1], lineDistances[i] += _vStart.distanceTo(_vEnd);
                geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
              } else
                console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
              return this;
            }
            raycast(raycaster, intersects2) {
              let geometry = this.geometry, matrixWorld = this.matrixWorld, threshold = raycaster.params.Line.threshold, drawRange = geometry.drawRange;
              if (geometry.boundingSphere === null && geometry.computeBoundingSphere(), _sphere$1.copy(geometry.boundingSphere), _sphere$1.applyMatrix4(matrixWorld), _sphere$1.radius += threshold, raycaster.ray.intersectsSphere(_sphere$1) === !1)
                return;
              _inverseMatrix$1.copy(matrixWorld).invert(), _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
              let localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3), localThresholdSq = localThreshold * localThreshold, step = this.isLineSegments ? 2 : 1, index = geometry.index, positionAttribute = geometry.attributes.position;
              if (index !== null) {
                let start = Math.max(0, drawRange.start), end = Math.min(index.count, drawRange.start + drawRange.count);
                for (let i = start, l = end - 1; i < l; i += step) {
                  let a = index.getX(i), b = index.getX(i + 1), intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
                  intersect2 && intersects2.push(intersect2);
                }
                if (this.isLineLoop) {
                  let a = index.getX(end - 1), b = index.getX(start), intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
                  intersect2 && intersects2.push(intersect2);
                }
              } else {
                let start = Math.max(0, drawRange.start), end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
                for (let i = start, l = end - 1; i < l; i += step) {
                  let intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i, i + 1);
                  intersect2 && intersects2.push(intersect2);
                }
                if (this.isLineLoop) {
                  let intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start);
                  intersect2 && intersects2.push(intersect2);
                }
              }
            }
            updateMorphTargets() {
              let morphAttributes = this.geometry.morphAttributes, keys = Object.keys(morphAttributes);
              if (keys.length > 0) {
                let morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== void 0) {
                  this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                  for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                    let name = morphAttribute[m].name || String(m);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[name] = m;
                  }
                }
              }
            }
          }
          function checkIntersection(object, raycaster, ray, thresholdSq, a, b) {
            let positionAttribute = object.geometry.attributes.position;
            if (_vStart.fromBufferAttribute(positionAttribute, a), _vEnd.fromBufferAttribute(positionAttribute, b), ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment) > thresholdSq)
              return;
            _intersectPointOnRay.applyMatrix4(object.matrixWorld);
            let distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
            if (!(distance < raycaster.near || distance > raycaster.far))
              return {
                distance,
                point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
                index: a,
                face: null,
                faceIndex: null,
                object
              };
          }
          let _start = /* @__PURE__ */ new Vector3(), _end = /* @__PURE__ */ new Vector3();
          class LineSegments extends Line {
            constructor(geometry, material) {
              super(geometry, material);
              this.isLineSegments = !0, this.type = "LineSegments";
            }
            computeLineDistances() {
              let geometry = this.geometry;
              if (geometry.index === null) {
                let positionAttribute = geometry.attributes.position, lineDistances = [];
                for (let i = 0, l = positionAttribute.count; i < l; i += 2)
                  _start.fromBufferAttribute(positionAttribute, i), _end.fromBufferAttribute(positionAttribute, i + 1), lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1], lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
                geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
              } else
                console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
              return this;
            }
          }
          class LineLoop extends Line {
            constructor(geometry, material) {
              super(geometry, material);
              this.isLineLoop = !0, this.type = "LineLoop";
            }
          }
          class PointsMaterial extends Material {
            constructor(parameters) {
              super();
              this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.color.copy(source.color), this.map = source.map, this.alphaMap = source.alphaMap, this.size = source.size, this.sizeAttenuation = source.sizeAttenuation, this.fog = source.fog, this;
            }
          }
          let _inverseMatrix = /* @__PURE__ */ new Matrix4(), _ray = /* @__PURE__ */ new Ray(), _sphere = /* @__PURE__ */ new Sphere(), _position$2 = /* @__PURE__ */ new Vector3();
          class Points extends Object3D {
            constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
              super();
              this.isPoints = !0, this.type = "Points", this.geometry = geometry, this.material = material, this.updateMorphTargets();
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.material = Array.isArray(source.material) ? source.material.slice() : source.material, this.geometry = source.geometry, this;
            }
            raycast(raycaster, intersects2) {
              let geometry = this.geometry, matrixWorld = this.matrixWorld, threshold = raycaster.params.Points.threshold, drawRange = geometry.drawRange;
              if (geometry.boundingSphere === null && geometry.computeBoundingSphere(), _sphere.copy(geometry.boundingSphere), _sphere.applyMatrix4(matrixWorld), _sphere.radius += threshold, raycaster.ray.intersectsSphere(_sphere) === !1)
                return;
              _inverseMatrix.copy(matrixWorld).invert(), _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
              let localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3), localThresholdSq = localThreshold * localThreshold, index = geometry.index, positionAttribute = geometry.attributes.position;
              if (index !== null) {
                let start = Math.max(0, drawRange.start), end = Math.min(index.count, drawRange.start + drawRange.count);
                for (let i = start, il = end; i < il; i++) {
                  let a = index.getX(i);
                  _position$2.fromBufferAttribute(positionAttribute, a), testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
                }
              } else {
                let start = Math.max(0, drawRange.start), end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
                for (let i = start, l = end; i < l; i++)
                  _position$2.fromBufferAttribute(positionAttribute, i), testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
              }
            }
            updateMorphTargets() {
              let morphAttributes = this.geometry.morphAttributes, keys = Object.keys(morphAttributes);
              if (keys.length > 0) {
                let morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== void 0) {
                  this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                  for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                    let name = morphAttribute[m].name || String(m);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[name] = m;
                  }
                }
              }
            }
          }
          function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
            let rayPointDistanceSq = _ray.distanceSqToPoint(point);
            if (rayPointDistanceSq < localThresholdSq) {
              let intersectPoint = new Vector3();
              _ray.closestPointToPoint(point, intersectPoint), intersectPoint.applyMatrix4(matrixWorld);
              let distance = raycaster.ray.origin.distanceTo(intersectPoint);
              if (distance < raycaster.near || distance > raycaster.far)
                return;
              intersects2.push({ distance, distanceToRay: Math.sqrt(rayPointDistanceSq), point: intersectPoint, index, face: null, object });
            }
          }
          class VideoTexture extends Texture {
            constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
              super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
              this.isVideoTexture = !0, this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter, this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter, this.generateMipmaps = !1;
              let scope = this;
              function updateVideo() {
                scope.needsUpdate = !0, video.requestVideoFrameCallback(updateVideo);
              }
              "requestVideoFrameCallback" in video && video.requestVideoFrameCallback(updateVideo);
            }
            clone() {
              return new this.constructor(this.image).copy(this);
            }
            update() {
              let video = this.image;
              "requestVideoFrameCallback" in video === !1 && video.readyState >= video.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
            }
          }
          class FramebufferTexture extends Texture {
            constructor(width, height) {
              super({ width, height });
              this.isFramebufferTexture = !0, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.generateMipmaps = !1, this.needsUpdate = !0;
            }
          }
          class CompressedTexture extends Texture {
            constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {
              super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
              this.isCompressedTexture = !0, this.image = { width, height }, this.mipmaps = mipmaps, this.flipY = !1, this.generateMipmaps = !1;
            }
          }
          class CompressedArrayTexture extends CompressedTexture {
            constructor(mipmaps, width, height, depth, format, type) {
              super(mipmaps, width, height, format, type);
              this.isCompressedArrayTexture = !0, this.image.depth = depth, this.wrapR = ClampToEdgeWrapping;
            }
          }
          class CompressedCubeTexture extends CompressedTexture {
            constructor(images, format, type) {
              super(void 0, images[0].width, images[0].height, format, type, CubeReflectionMapping);
              this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = images;
            }
          }
          class CanvasTexture extends Texture {
            constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
              super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
              this.isCanvasTexture = !0, this.needsUpdate = !0;
            }
          }
          class Curve {
            constructor() {
              this.type = "Curve", this.arcLengthDivisions = 200;
            }
            getPoint() {
              return console.warn("THREE.Curve: .getPoint() not implemented."), null;
            }
            getPointAt(u, optionalTarget) {
              let t = this.getUtoTmapping(u);
              return this.getPoint(t, optionalTarget);
            }
            getPoints(divisions = 5) {
              let points = [];
              for (let d = 0; d <= divisions; d++)
                points.push(this.getPoint(d / divisions));
              return points;
            }
            getSpacedPoints(divisions = 5) {
              let points = [];
              for (let d = 0; d <= divisions; d++)
                points.push(this.getPointAt(d / divisions));
              return points;
            }
            getLength() {
              let lengths = this.getLengths();
              return lengths[lengths.length - 1];
            }
            getLengths(divisions = this.arcLengthDivisions) {
              if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
              this.needsUpdate = !1;
              let cache = [], current, last = this.getPoint(0), sum = 0;
              cache.push(0);
              for (let p = 1; p <= divisions; p++)
                current = this.getPoint(p / divisions), sum += current.distanceTo(last), cache.push(sum), last = current;
              return this.cacheArcLengths = cache, cache;
            }
            updateArcLengths() {
              this.needsUpdate = !0, this.getLengths();
            }
            getUtoTmapping(u, distance) {
              let arcLengths = this.getLengths(), i = 0, il = arcLengths.length, targetArcLength;
              distance ? targetArcLength = distance : targetArcLength = u * arcLengths[il - 1];
              let low = 0, high = il - 1, comparison;
              for (; low <= high; )
                if (i = Math.floor(low + (high - low) / 2), comparison = arcLengths[i] - targetArcLength, comparison < 0)
                  low = i + 1;
                else if (comparison > 0)
                  high = i - 1;
                else {
                  high = i;
                  break;
                }
              if (i = high, arcLengths[i] === targetArcLength)
                return i / (il - 1);
              let lengthBefore = arcLengths[i], segmentLength = arcLengths[i + 1] - lengthBefore, segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
              return (i + segmentFraction) / (il - 1);
            }
            getTangent(t, optionalTarget) {
              let delta = 1e-4, t1 = t - delta, t2 = t + delta;
              t1 < 0 && (t1 = 0), t2 > 1 && (t2 = 1);
              let pt1 = this.getPoint(t1), pt2 = this.getPoint(t2), tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
              return tangent.copy(pt2).sub(pt1).normalize(), tangent;
            }
            getTangentAt(u, optionalTarget) {
              let t = this.getUtoTmapping(u);
              return this.getTangent(t, optionalTarget);
            }
            computeFrenetFrames(segments, closed) {
              let normal = new Vector3(), tangents = [], normals = [], binormals = [], vec = new Vector3(), mat = new Matrix4();
              for (let i = 0; i <= segments; i++) {
                let u = i / segments;
                tangents[i] = this.getTangentAt(u, new Vector3());
              }
              normals[0] = new Vector3(), binormals[0] = new Vector3();
              let min = Number.MAX_VALUE, tx = Math.abs(tangents[0].x), ty = Math.abs(tangents[0].y), tz = Math.abs(tangents[0].z);
              tx <= min && (min = tx, normal.set(1, 0, 0)), ty <= min && (min = ty, normal.set(0, 1, 0)), tz <= min && normal.set(0, 0, 1), vec.crossVectors(tangents[0], normal).normalize(), normals[0].crossVectors(tangents[0], vec), binormals[0].crossVectors(tangents[0], normals[0]);
              for (let i = 1; i <= segments; i++) {
                if (normals[i] = normals[i - 1].clone(), binormals[i] = binormals[i - 1].clone(), vec.crossVectors(tangents[i - 1], tangents[i]), vec.length() > Number.EPSILON) {
                  vec.normalize();
                  let theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
                  normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }
                binormals[i].crossVectors(tangents[i], normals[i]);
              }
              if (closed === !0) {
                let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
                theta /= segments, tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0 && (theta = -theta);
                for (let i = 1; i <= segments; i++)
                  normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i)), binormals[i].crossVectors(tangents[i], normals[i]);
              }
              return { tangents, normals, binormals };
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(source) {
              return this.arcLengthDivisions = source.arcLengthDivisions, this;
            }
            toJSON() {
              let data = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
              return data.arcLengthDivisions = this.arcLengthDivisions, data.type = this.type, data;
            }
            fromJSON(json) {
              return this.arcLengthDivisions = json.arcLengthDivisions, this;
            }
          }
          class EllipseCurve extends Curve {
            constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = !1, aRotation = 0) {
              super();
              this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = aX, this.aY = aY, this.xRadius = xRadius, this.yRadius = yRadius, this.aStartAngle = aStartAngle, this.aEndAngle = aEndAngle, this.aClockwise = aClockwise, this.aRotation = aRotation;
            }
            getPoint(t, optionalTarget = new Vector2()) {
              let point = optionalTarget, twoPi = Math.PI * 2, deltaAngle = this.aEndAngle - this.aStartAngle, samePoints = Math.abs(deltaAngle) < Number.EPSILON;
              for (; deltaAngle < 0; )
                deltaAngle += twoPi;
              for (; deltaAngle > twoPi; )
                deltaAngle -= twoPi;
              deltaAngle < Number.EPSILON && (samePoints ? deltaAngle = 0 : deltaAngle = twoPi), this.aClockwise === !0 && !samePoints && (deltaAngle === twoPi ? deltaAngle = -twoPi : deltaAngle = deltaAngle - twoPi);
              let angle = this.aStartAngle + t * deltaAngle, x = this.aX + this.xRadius * Math.cos(angle), y = this.aY + this.yRadius * Math.sin(angle);
              if (this.aRotation !== 0) {
                let cos = Math.cos(this.aRotation), sin = Math.sin(this.aRotation), tx = x - this.aX, ty = y - this.aY;
                x = tx * cos - ty * sin + this.aX, y = tx * sin + ty * cos + this.aY;
              }
              return point.set(x, y);
            }
            copy(source) {
              return super.copy(source), this.aX = source.aX, this.aY = source.aY, this.xRadius = source.xRadius, this.yRadius = source.yRadius, this.aStartAngle = source.aStartAngle, this.aEndAngle = source.aEndAngle, this.aClockwise = source.aClockwise, this.aRotation = source.aRotation, this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.aX = this.aX, data.aY = this.aY, data.xRadius = this.xRadius, data.yRadius = this.yRadius, data.aStartAngle = this.aStartAngle, data.aEndAngle = this.aEndAngle, data.aClockwise = this.aClockwise, data.aRotation = this.aRotation, data;
            }
            fromJSON(json) {
              return super.fromJSON(json), this.aX = json.aX, this.aY = json.aY, this.xRadius = json.xRadius, this.yRadius = json.yRadius, this.aStartAngle = json.aStartAngle, this.aEndAngle = json.aEndAngle, this.aClockwise = json.aClockwise, this.aRotation = json.aRotation, this;
            }
          }
          class ArcCurve extends EllipseCurve {
            constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
              super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
              this.isArcCurve = !0, this.type = "ArcCurve";
            }
          }
          function CubicPoly() {
            let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
            function init(x0, x1, t0, t1) {
              c0 = x0, c1 = t0, c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1, c3 = 2 * x0 - 2 * x1 + t0 + t1;
            }
            return { initCatmullRom: function(x0, x1, x2, x3, tension) {
              init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            }, initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
              let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1, t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
              t1 *= dt1, t2 *= dt1, init(x1, x2, t1, t2);
            }, calc: function(t) {
              let t2 = t * t, t3 = t2 * t;
              return c0 + c1 * t + c2 * t2 + c3 * t3;
            } };
          }
          let tmp = /* @__PURE__ */ new Vector3(), px = /* @__PURE__ */ new CubicPoly(), py = /* @__PURE__ */ new CubicPoly(), pz = /* @__PURE__ */ new CubicPoly();
          class CatmullRomCurve3 extends Curve {
            constructor(points = [], closed = !1, curveType = "centripetal", tension = 0.5) {
              super();
              this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = points, this.closed = closed, this.curveType = curveType, this.tension = tension;
            }
            getPoint(t, optionalTarget = new Vector3()) {
              let point = optionalTarget, points = this.points, l = points.length, p = (l - (this.closed ? 0 : 1)) * t, intPoint = Math.floor(p), weight = p - intPoint;
              this.closed ? intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l : weight === 0 && intPoint === l - 1 && (intPoint = l - 2, weight = 1);
              let p0, p3;
              this.closed || intPoint > 0 ? p0 = points[(intPoint - 1) % l] : (tmp.subVectors(points[0], points[1]).add(points[0]), p0 = tmp);
              let p1 = points[intPoint % l], p2 = points[(intPoint + 1) % l];
              if (this.closed || intPoint + 2 < l ? p3 = points[(intPoint + 2) % l] : (tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]), p3 = tmp), this.curveType === "centripetal" || this.curveType === "chordal") {
                let pow = this.curveType === "chordal" ? 0.5 : 0.25, dt0 = Math.pow(p0.distanceToSquared(p1), pow), dt1 = Math.pow(p1.distanceToSquared(p2), pow), dt2 = Math.pow(p2.distanceToSquared(p3), pow);
                dt1 < 1e-4 && (dt1 = 1), dt0 < 1e-4 && (dt0 = dt1), dt2 < 1e-4 && (dt2 = dt1), px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2), py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2), pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
              } else
                this.curveType === "catmullrom" && (px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension), py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension), pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension));
              return point.set(px.calc(weight), py.calc(weight), pz.calc(weight)), point;
            }
            copy(source) {
              super.copy(source), this.points = [];
              for (let i = 0, l = source.points.length; i < l; i++) {
                let point = source.points[i];
                this.points.push(point.clone());
              }
              return this.closed = source.closed, this.curveType = source.curveType, this.tension = source.tension, this;
            }
            toJSON() {
              let data = super.toJSON();
              data.points = [];
              for (let i = 0, l = this.points.length; i < l; i++) {
                let point = this.points[i];
                data.points.push(point.toArray());
              }
              return data.closed = this.closed, data.curveType = this.curveType, data.tension = this.tension, data;
            }
            fromJSON(json) {
              super.fromJSON(json), this.points = [];
              for (let i = 0, l = json.points.length; i < l; i++) {
                let point = json.points[i];
                this.points.push(new Vector3().fromArray(point));
              }
              return this.closed = json.closed, this.curveType = json.curveType, this.tension = json.tension, this;
            }
          }
          function CatmullRom(t, p0, p1, p2, p3) {
            let v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
          }
          function QuadraticBezierP0(t, p) {
            let k = 1 - t;
            return k * k * p;
          }
          function QuadraticBezierP1(t, p) {
            return 2 * (1 - t) * t * p;
          }
          function QuadraticBezierP2(t, p) {
            return t * t * p;
          }
          function QuadraticBezier(t, p0, p1, p2) {
            return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
          }
          function CubicBezierP0(t, p) {
            let k = 1 - t;
            return k * k * k * p;
          }
          function CubicBezierP1(t, p) {
            let k = 1 - t;
            return 3 * k * k * t * p;
          }
          function CubicBezierP2(t, p) {
            return 3 * (1 - t) * t * t * p;
          }
          function CubicBezierP3(t, p) {
            return t * t * t * p;
          }
          function CubicBezier(t, p0, p1, p2, p3) {
            return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
          }
          class CubicBezierCurve extends Curve {
            constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
              super();
              this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = v0, this.v1 = v1, this.v2 = v2, this.v3 = v3;
            }
            getPoint(t, optionalTarget = new Vector2()) {
              let point = optionalTarget, v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
              return point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y)), point;
            }
            copy(source) {
              return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this.v3.copy(source.v3), this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data.v3 = this.v3.toArray(), data;
            }
            fromJSON(json) {
              return super.fromJSON(json), this.v0.fromArray(json.v0), this.v1.fromArray(json.v1), this.v2.fromArray(json.v2), this.v3.fromArray(json.v3), this;
            }
          }
          class CubicBezierCurve3 extends Curve {
            constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
              super();
              this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = v0, this.v1 = v1, this.v2 = v2, this.v3 = v3;
            }
            getPoint(t, optionalTarget = new Vector3()) {
              let point = optionalTarget, v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
              return point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z)), point;
            }
            copy(source) {
              return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this.v3.copy(source.v3), this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data.v3 = this.v3.toArray(), data;
            }
            fromJSON(json) {
              return super.fromJSON(json), this.v0.fromArray(json.v0), this.v1.fromArray(json.v1), this.v2.fromArray(json.v2), this.v3.fromArray(json.v3), this;
            }
          }
          class LineCurve extends Curve {
            constructor(v1 = new Vector2(), v2 = new Vector2()) {
              super();
              this.isLineCurve = !0, this.type = "LineCurve", this.v1 = v1, this.v2 = v2;
            }
            getPoint(t, optionalTarget = new Vector2()) {
              let point = optionalTarget;
              return t === 1 ? point.copy(this.v2) : (point.copy(this.v2).sub(this.v1), point.multiplyScalar(t).add(this.v1)), point;
            }
            getPointAt(u, optionalTarget) {
              return this.getPoint(u, optionalTarget);
            }
            getTangent(t, optionalTarget = new Vector2()) {
              return optionalTarget.subVectors(this.v2, this.v1).normalize();
            }
            getTangentAt(u, optionalTarget) {
              return this.getTangent(u, optionalTarget);
            }
            copy(source) {
              return super.copy(source), this.v1.copy(source.v1), this.v2.copy(source.v2), this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data;
            }
            fromJSON(json) {
              return super.fromJSON(json), this.v1.fromArray(json.v1), this.v2.fromArray(json.v2), this;
            }
          }
          class LineCurve3 extends Curve {
            constructor(v1 = new Vector3(), v2 = new Vector3()) {
              super();
              this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = v1, this.v2 = v2;
            }
            getPoint(t, optionalTarget = new Vector3()) {
              let point = optionalTarget;
              return t === 1 ? point.copy(this.v2) : (point.copy(this.v2).sub(this.v1), point.multiplyScalar(t).add(this.v1)), point;
            }
            getPointAt(u, optionalTarget) {
              return this.getPoint(u, optionalTarget);
            }
            getTangent(t, optionalTarget = new Vector3()) {
              return optionalTarget.subVectors(this.v2, this.v1).normalize();
            }
            getTangentAt(u, optionalTarget) {
              return this.getTangent(u, optionalTarget);
            }
            copy(source) {
              return super.copy(source), this.v1.copy(source.v1), this.v2.copy(source.v2), this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data;
            }
            fromJSON(json) {
              return super.fromJSON(json), this.v1.fromArray(json.v1), this.v2.fromArray(json.v2), this;
            }
          }
          class QuadraticBezierCurve extends Curve {
            constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
              super();
              this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = v0, this.v1 = v1, this.v2 = v2;
            }
            getPoint(t, optionalTarget = new Vector2()) {
              let point = optionalTarget, v0 = this.v0, v1 = this.v1, v2 = this.v2;
              return point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y)), point;
            }
            copy(source) {
              return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data;
            }
            fromJSON(json) {
              return super.fromJSON(json), this.v0.fromArray(json.v0), this.v1.fromArray(json.v1), this.v2.fromArray(json.v2), this;
            }
          }
          class QuadraticBezierCurve3 extends Curve {
            constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
              super();
              this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = v0, this.v1 = v1, this.v2 = v2;
            }
            getPoint(t, optionalTarget = new Vector3()) {
              let point = optionalTarget, v0 = this.v0, v1 = this.v1, v2 = this.v2;
              return point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z)), point;
            }
            copy(source) {
              return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data;
            }
            fromJSON(json) {
              return super.fromJSON(json), this.v0.fromArray(json.v0), this.v1.fromArray(json.v1), this.v2.fromArray(json.v2), this;
            }
          }
          class SplineCurve extends Curve {
            constructor(points = []) {
              super();
              this.isSplineCurve = !0, this.type = "SplineCurve", this.points = points;
            }
            getPoint(t, optionalTarget = new Vector2()) {
              let point = optionalTarget, points = this.points, p = (points.length - 1) * t, intPoint = Math.floor(p), weight = p - intPoint, p0 = points[intPoint === 0 ? intPoint : intPoint - 1], p1 = points[intPoint], p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1], p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
              return point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)), point;
            }
            copy(source) {
              super.copy(source), this.points = [];
              for (let i = 0, l = source.points.length; i < l; i++) {
                let point = source.points[i];
                this.points.push(point.clone());
              }
              return this;
            }
            toJSON() {
              let data = super.toJSON();
              data.points = [];
              for (let i = 0, l = this.points.length; i < l; i++) {
                let point = this.points[i];
                data.points.push(point.toArray());
              }
              return data;
            }
            fromJSON(json) {
              super.fromJSON(json), this.points = [];
              for (let i = 0, l = json.points.length; i < l; i++) {
                let point = json.points[i];
                this.points.push(new Vector2().fromArray(point));
              }
              return this;
            }
          }
          var Curves = /* @__PURE__ */ Object.freeze({ __proto__: null, ArcCurve, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, EllipseCurve, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve });
          class CurvePath extends Curve {
            constructor() {
              super();
              this.type = "CurvePath", this.curves = [], this.autoClose = !1;
            }
            add(curve) {
              this.curves.push(curve);
            }
            closePath() {
              let startPoint = this.curves[0].getPoint(0), endPoint = this.curves[this.curves.length - 1].getPoint(1);
              if (!startPoint.equals(endPoint)) {
                let lineType = startPoint.isVector2 === !0 ? "LineCurve" : "LineCurve3";
                this.curves.push(new Curves[lineType](endPoint, startPoint));
              }
              return this;
            }
            getPoint(t, optionalTarget) {
              let d = t * this.getLength(), curveLengths = this.getCurveLengths(), i = 0;
              for (; i < curveLengths.length; ) {
                if (curveLengths[i] >= d) {
                  let diff = curveLengths[i] - d, curve = this.curves[i], segmentLength = curve.getLength(), u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                  return curve.getPointAt(u, optionalTarget);
                }
                i++;
              }
              return null;
            }
            getLength() {
              let lens = this.getCurveLengths();
              return lens[lens.length - 1];
            }
            updateArcLengths() {
              this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
            }
            getCurveLengths() {
              if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
              let lengths = [], sums = 0;
              for (let i = 0, l = this.curves.length; i < l; i++)
                sums += this.curves[i].getLength(), lengths.push(sums);
              return this.cacheLengths = lengths, lengths;
            }
            getSpacedPoints(divisions = 40) {
              let points = [];
              for (let i = 0; i <= divisions; i++)
                points.push(this.getPoint(i / divisions));
              return this.autoClose && points.push(points[0]), points;
            }
            getPoints(divisions = 12) {
              let points = [], last;
              for (let i = 0, curves = this.curves; i < curves.length; i++) {
                let curve = curves[i], resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions, pts = curve.getPoints(resolution);
                for (let j = 0; j < pts.length; j++) {
                  let point = pts[j];
                  last && last.equals(point) || (points.push(point), last = point);
                }
              }
              return this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0]) && points.push(points[0]), points;
            }
            copy(source) {
              super.copy(source), this.curves = [];
              for (let i = 0, l = source.curves.length; i < l; i++) {
                let curve = source.curves[i];
                this.curves.push(curve.clone());
              }
              return this.autoClose = source.autoClose, this;
            }
            toJSON() {
              let data = super.toJSON();
              data.autoClose = this.autoClose, data.curves = [];
              for (let i = 0, l = this.curves.length; i < l; i++) {
                let curve = this.curves[i];
                data.curves.push(curve.toJSON());
              }
              return data;
            }
            fromJSON(json) {
              super.fromJSON(json), this.autoClose = json.autoClose, this.curves = [];
              for (let i = 0, l = json.curves.length; i < l; i++) {
                let curve = json.curves[i];
                this.curves.push(new Curves[curve.type]().fromJSON(curve));
              }
              return this;
            }
          }
          class Path extends CurvePath {
            constructor(points) {
              super();
              this.type = "Path", this.currentPoint = new Vector2(), points && this.setFromPoints(points);
            }
            setFromPoints(points) {
              this.moveTo(points[0].x, points[0].y);
              for (let i = 1, l = points.length; i < l; i++)
                this.lineTo(points[i].x, points[i].y);
              return this;
            }
            moveTo(x, y) {
              return this.currentPoint.set(x, y), this;
            }
            lineTo(x, y) {
              let curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
              return this.curves.push(curve), this.currentPoint.set(x, y), this;
            }
            quadraticCurveTo(aCPx, aCPy, aX, aY) {
              let curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
              return this.curves.push(curve), this.currentPoint.set(aX, aY), this;
            }
            bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
              let curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
              return this.curves.push(curve), this.currentPoint.set(aX, aY), this;
            }
            splineThru(pts) {
              let npts = [this.currentPoint.clone()].concat(pts), curve = new SplineCurve(npts);
              return this.curves.push(curve), this.currentPoint.copy(pts[pts.length - 1]), this;
            }
            arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
              let x0 = this.currentPoint.x, y0 = this.currentPoint.y;
              return this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise), this;
            }
            absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
              return this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise), this;
            }
            ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
              let x0 = this.currentPoint.x, y0 = this.currentPoint.y;
              return this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation), this;
            }
            absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
              let curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
              if (this.curves.length > 0) {
                let firstPoint = curve.getPoint(0);
                firstPoint.equals(this.currentPoint) || this.lineTo(firstPoint.x, firstPoint.y);
              }
              this.curves.push(curve);
              let lastPoint = curve.getPoint(1);
              return this.currentPoint.copy(lastPoint), this;
            }
            copy(source) {
              return super.copy(source), this.currentPoint.copy(source.currentPoint), this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.currentPoint = this.currentPoint.toArray(), data;
            }
            fromJSON(json) {
              return super.fromJSON(json), this.currentPoint.fromArray(json.currentPoint), this;
            }
          }
          class LatheGeometry extends BufferGeometry {
            constructor(points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
              super();
              this.type = "LatheGeometry", this.parameters = { points, segments, phiStart, phiLength }, segments = Math.floor(segments), phiLength = clamp(phiLength, 0, Math.PI * 2);
              let indices = [], vertices = [], uvs = [], initNormals = [], normals = [], inverseSegments = 1 / segments, vertex2 = new Vector3(), uv = new Vector2(), normal = new Vector3(), curNormal = new Vector3(), prevNormal = new Vector3(), dx = 0, dy = 0;
              for (let j = 0; j <= points.length - 1; j++)
                switch (j) {
                  case 0:
                    dx = points[j + 1].x - points[j].x, dy = points[j + 1].y - points[j].y, normal.x = dy * 1, normal.y = -dx, normal.z = dy * 0, prevNormal.copy(normal), normal.normalize(), initNormals.push(normal.x, normal.y, normal.z);
                    break;
                  case points.length - 1:
                    initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
                    break;
                  default:
                    dx = points[j + 1].x - points[j].x, dy = points[j + 1].y - points[j].y, normal.x = dy * 1, normal.y = -dx, normal.z = dy * 0, curNormal.copy(normal), normal.x += prevNormal.x, normal.y += prevNormal.y, normal.z += prevNormal.z, normal.normalize(), initNormals.push(normal.x, normal.y, normal.z), prevNormal.copy(curNormal);
                }
              for (let i = 0; i <= segments; i++) {
                let phi = phiStart + i * inverseSegments * phiLength, sin = Math.sin(phi), cos = Math.cos(phi);
                for (let j = 0; j <= points.length - 1; j++) {
                  vertex2.x = points[j].x * sin, vertex2.y = points[j].y, vertex2.z = points[j].x * cos, vertices.push(vertex2.x, vertex2.y, vertex2.z), uv.x = i / segments, uv.y = j / (points.length - 1), uvs.push(uv.x, uv.y);
                  let x = initNormals[3 * j + 0] * sin, y = initNormals[3 * j + 1], z = initNormals[3 * j + 0] * cos;
                  normals.push(x, y, z);
                }
              }
              for (let i = 0; i < segments; i++)
                for (let j = 0; j < points.length - 1; j++) {
                  let base = j + i * points.length, a = base, b = base + points.length, c = base + points.length + 1, d = base + 1;
                  indices.push(a, b, d), indices.push(c, d, b);
                }
              this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            static fromJSON(data) {
              return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
            }
          }
          class CapsuleGeometry extends LatheGeometry {
            constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
              let path = new Path();
              path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0), path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
              super(path.getPoints(capSegments), radialSegments);
              this.type = "CapsuleGeometry", this.parameters = { radius, length, capSegments, radialSegments };
            }
            static fromJSON(data) {
              return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
            }
          }
          class CircleGeometry extends BufferGeometry {
            constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
              super();
              this.type = "CircleGeometry", this.parameters = { radius, segments, thetaStart, thetaLength }, segments = Math.max(3, segments);
              let indices = [], vertices = [], normals = [], uvs = [], vertex2 = new Vector3(), uv = new Vector2();
              vertices.push(0, 0, 0), normals.push(0, 0, 1), uvs.push(0.5, 0.5);
              for (let s = 0, i = 3; s <= segments; s++, i += 3) {
                let segment = thetaStart + s / segments * thetaLength;
                vertex2.x = radius * Math.cos(segment), vertex2.y = radius * Math.sin(segment), vertices.push(vertex2.x, vertex2.y, vertex2.z), normals.push(0, 0, 1), uv.x = (vertices[i] / radius + 1) / 2, uv.y = (vertices[i + 1] / radius + 1) / 2, uvs.push(uv.x, uv.y);
              }
              for (let i = 1; i <= segments; i++)
                indices.push(i, i + 1, 0);
              this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            static fromJSON(data) {
              return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
            }
          }
          class CylinderGeometry extends BufferGeometry {
            constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = !1, thetaStart = 0, thetaLength = Math.PI * 2) {
              super();
              this.type = "CylinderGeometry", this.parameters = { radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength };
              let scope = this;
              radialSegments = Math.floor(radialSegments), heightSegments = Math.floor(heightSegments);
              let indices = [], vertices = [], normals = [], uvs = [], index = 0, indexArray = [], halfHeight = height / 2, groupStart = 0;
              generateTorso(), openEnded === !1 && (radiusTop > 0 && generateCap(!0), radiusBottom > 0 && generateCap(!1)), this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
              function generateTorso() {
                let normal = new Vector3(), vertex2 = new Vector3(), groupCount = 0, slope = (radiusBottom - radiusTop) / height;
                for (let y = 0; y <= heightSegments; y++) {
                  let indexRow = [], v = y / heightSegments, radius = v * (radiusBottom - radiusTop) + radiusTop;
                  for (let x = 0; x <= radialSegments; x++) {
                    let u = x / radialSegments, theta = u * thetaLength + thetaStart, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                    vertex2.x = radius * sinTheta, vertex2.y = -v * height + halfHeight, vertex2.z = radius * cosTheta, vertices.push(vertex2.x, vertex2.y, vertex2.z), normal.set(sinTheta, slope, cosTheta).normalize(), normals.push(normal.x, normal.y, normal.z), uvs.push(u, 1 - v), indexRow.push(index++);
                  }
                  indexArray.push(indexRow);
                }
                for (let x = 0; x < radialSegments; x++)
                  for (let y = 0; y < heightSegments; y++) {
                    let a = indexArray[y][x], b = indexArray[y + 1][x], c = indexArray[y + 1][x + 1], d = indexArray[y][x + 1];
                    indices.push(a, b, d), indices.push(b, c, d), groupCount += 6;
                  }
                scope.addGroup(groupStart, groupCount, 0), groupStart += groupCount;
              }
              function generateCap(top) {
                let centerIndexStart = index, uv = new Vector2(), vertex2 = new Vector3(), groupCount = 0, radius = top === !0 ? radiusTop : radiusBottom, sign2 = top === !0 ? 1 : -1;
                for (let x = 1; x <= radialSegments; x++)
                  vertices.push(0, halfHeight * sign2, 0), normals.push(0, sign2, 0), uvs.push(0.5, 0.5), index++;
                let centerIndexEnd = index;
                for (let x = 0; x <= radialSegments; x++) {
                  let theta = x / radialSegments * thetaLength + thetaStart, cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
                  vertex2.x = radius * sinTheta, vertex2.y = halfHeight * sign2, vertex2.z = radius * cosTheta, vertices.push(vertex2.x, vertex2.y, vertex2.z), normals.push(0, sign2, 0), uv.x = cosTheta * 0.5 + 0.5, uv.y = sinTheta * 0.5 * sign2 + 0.5, uvs.push(uv.x, uv.y), index++;
                }
                for (let x = 0; x < radialSegments; x++) {
                  let c = centerIndexStart + x, i = centerIndexEnd + x;
                  top === !0 ? indices.push(i, i + 1, c) : indices.push(i + 1, i, c), groupCount += 3;
                }
                scope.addGroup(groupStart, groupCount, top === !0 ? 1 : 2), groupStart += groupCount;
              }
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            static fromJSON(data) {
              return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            }
          }
          class ConeGeometry extends CylinderGeometry {
            constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = !1, thetaStart = 0, thetaLength = Math.PI * 2) {
              super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
              this.type = "ConeGeometry", this.parameters = { radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength };
            }
            static fromJSON(data) {
              return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            }
          }
          class PolyhedronGeometry extends BufferGeometry {
            constructor(vertices = [], indices = [], radius = 1, detail = 0) {
              super();
              this.type = "PolyhedronGeometry", this.parameters = { vertices, indices, radius, detail };
              let vertexBuffer = [], uvBuffer = [];
              subdivide(detail), applyRadius(radius), generateUVs(), this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3)), this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3)), this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2)), detail === 0 ? this.computeVertexNormals() : this.normalizeNormals();
              function subdivide(detail2) {
                let a = new Vector3(), b = new Vector3(), c = new Vector3();
                for (let i = 0; i < indices.length; i += 3)
                  getVertexByIndex(indices[i + 0], a), getVertexByIndex(indices[i + 1], b), getVertexByIndex(indices[i + 2], c), subdivideFace(a, b, c, detail2);
              }
              function subdivideFace(a, b, c, detail2) {
                let cols = detail2 + 1, v = [];
                for (let i = 0; i <= cols; i++) {
                  v[i] = [];
                  let aj = a.clone().lerp(c, i / cols), bj = b.clone().lerp(c, i / cols), rows = cols - i;
                  for (let j = 0; j <= rows; j++)
                    j === 0 && i === cols ? v[i][j] = aj : v[i][j] = aj.clone().lerp(bj, j / rows);
                }
                for (let i = 0; i < cols; i++)
                  for (let j = 0; j < 2 * (cols - i) - 1; j++) {
                    let k = Math.floor(j / 2);
                    j % 2 == 0 ? (pushVertex(v[i][k + 1]), pushVertex(v[i + 1][k]), pushVertex(v[i][k])) : (pushVertex(v[i][k + 1]), pushVertex(v[i + 1][k + 1]), pushVertex(v[i + 1][k]));
                  }
              }
              function applyRadius(radius2) {
                let vertex2 = new Vector3();
                for (let i = 0; i < vertexBuffer.length; i += 3)
                  vertex2.x = vertexBuffer[i + 0], vertex2.y = vertexBuffer[i + 1], vertex2.z = vertexBuffer[i + 2], vertex2.normalize().multiplyScalar(radius2), vertexBuffer[i + 0] = vertex2.x, vertexBuffer[i + 1] = vertex2.y, vertexBuffer[i + 2] = vertex2.z;
              }
              function generateUVs() {
                let vertex2 = new Vector3();
                for (let i = 0; i < vertexBuffer.length; i += 3) {
                  vertex2.x = vertexBuffer[i + 0], vertex2.y = vertexBuffer[i + 1], vertex2.z = vertexBuffer[i + 2];
                  let u = azimuth(vertex2) / 2 / Math.PI + 0.5, v = inclination(vertex2) / Math.PI + 0.5;
                  uvBuffer.push(u, 1 - v);
                }
                correctUVs(), correctSeam();
              }
              function correctSeam() {
                for (let i = 0; i < uvBuffer.length; i += 6) {
                  let x0 = uvBuffer[i + 0], x1 = uvBuffer[i + 2], x2 = uvBuffer[i + 4], max = Math.max(x0, x1, x2), min = Math.min(x0, x1, x2);
                  max > 0.9 && min < 0.1 && (x0 < 0.2 && (uvBuffer[i + 0] += 1), x1 < 0.2 && (uvBuffer[i + 2] += 1), x2 < 0.2 && (uvBuffer[i + 4] += 1));
                }
              }
              function pushVertex(vertex2) {
                vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
              }
              function getVertexByIndex(index, vertex2) {
                let stride = index * 3;
                vertex2.x = vertices[stride + 0], vertex2.y = vertices[stride + 1], vertex2.z = vertices[stride + 2];
              }
              function correctUVs() {
                let a = new Vector3(), b = new Vector3(), c = new Vector3(), centroid = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2();
                for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                  a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]), b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]), c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]), uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]), uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]), uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]), centroid.copy(a).add(b).add(c).divideScalar(3);
                  let azi = azimuth(centroid);
                  correctUV(uvA, j + 0, a, azi), correctUV(uvB, j + 2, b, azi), correctUV(uvC, j + 4, c, azi);
                }
              }
              function correctUV(uv, stride, vector, azimuth2) {
                azimuth2 < 0 && uv.x === 1 && (uvBuffer[stride] = uv.x - 1), vector.x === 0 && vector.z === 0 && (uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5);
              }
              function azimuth(vector) {
                return Math.atan2(vector.z, -vector.x);
              }
              function inclination(vector) {
                return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
              }
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            static fromJSON(data) {
              return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
            }
          }
          class DodecahedronGeometry extends PolyhedronGeometry {
            constructor(radius = 1, detail = 0) {
              let t = (1 + Math.sqrt(5)) / 2, r = 1 / t, vertices = [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -r,
                -t,
                0,
                -r,
                t,
                0,
                r,
                -t,
                0,
                r,
                t,
                -r,
                -t,
                0,
                -r,
                t,
                0,
                r,
                -t,
                0,
                r,
                t,
                0,
                -t,
                0,
                -r,
                t,
                0,
                -r,
                -t,
                0,
                r,
                t,
                0,
                r
              ], indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
              super(vertices, indices, radius, detail);
              this.type = "DodecahedronGeometry", this.parameters = { radius, detail };
            }
            static fromJSON(data) {
              return new DodecahedronGeometry(data.radius, data.detail);
            }
          }
          let _v0 = /* @__PURE__ */ new Vector3(), _v1$1 = /* @__PURE__ */ new Vector3(), _normal = /* @__PURE__ */ new Vector3(), _triangle = /* @__PURE__ */ new Triangle();
          class EdgesGeometry extends BufferGeometry {
            constructor(geometry = null, thresholdAngle = 1) {
              super();
              if (this.type = "EdgesGeometry", this.parameters = { geometry, thresholdAngle }, geometry !== null) {
                let precision = Math.pow(10, 4), thresholdDot = Math.cos(DEG2RAD * thresholdAngle), indexAttr = geometry.getIndex(), positionAttr = geometry.getAttribute("position"), indexCount = indexAttr ? indexAttr.count : positionAttr.count, indexArr = [0, 0, 0], vertKeys = ["a", "b", "c"], hashes = new Array(3), edgeData = {}, vertices = [];
                for (let i = 0; i < indexCount; i += 3) {
                  indexAttr ? (indexArr[0] = indexAttr.getX(i), indexArr[1] = indexAttr.getX(i + 1), indexArr[2] = indexAttr.getX(i + 2)) : (indexArr[0] = i, indexArr[1] = i + 1, indexArr[2] = i + 2);
                  let { a, b, c } = _triangle;
                  if (a.fromBufferAttribute(positionAttr, indexArr[0]), b.fromBufferAttribute(positionAttr, indexArr[1]), c.fromBufferAttribute(positionAttr, indexArr[2]), _triangle.getNormal(_normal), hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`, hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`, hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`, !(hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]))
                    for (let j = 0; j < 3; j++) {
                      let jNext = (j + 1) % 3, vecHash0 = hashes[j], vecHash1 = hashes[jNext], v0 = _triangle[vertKeys[j]], v1 = _triangle[vertKeys[jNext]], hash = `${vecHash0}_${vecHash1}`, reverseHash = `${vecHash1}_${vecHash0}`;
                      reverseHash in edgeData && edgeData[reverseHash] ? (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot && (vertices.push(v0.x, v0.y, v0.z), vertices.push(v1.x, v1.y, v1.z)), edgeData[reverseHash] = null) : hash in edgeData || (edgeData[hash] = { index0: indexArr[j], index1: indexArr[jNext], normal: _normal.clone() });
                    }
                }
                for (let key in edgeData)
                  if (edgeData[key]) {
                    let { index0, index1 } = edgeData[key];
                    _v0.fromBufferAttribute(positionAttr, index0), _v1$1.fromBufferAttribute(positionAttr, index1), vertices.push(_v0.x, _v0.y, _v0.z), vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
                  }
                this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
              }
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
          }
          class Shape extends Path {
            constructor(points) {
              super(points);
              this.uuid = generateUUID(), this.type = "Shape", this.holes = [];
            }
            getPointsHoles(divisions) {
              let holesPts = [];
              for (let i = 0, l = this.holes.length; i < l; i++)
                holesPts[i] = this.holes[i].getPoints(divisions);
              return holesPts;
            }
            extractPoints(divisions) {
              return { shape: this.getPoints(divisions), holes: this.getPointsHoles(divisions) };
            }
            copy(source) {
              super.copy(source), this.holes = [];
              for (let i = 0, l = source.holes.length; i < l; i++) {
                let hole = source.holes[i];
                this.holes.push(hole.clone());
              }
              return this;
            }
            toJSON() {
              let data = super.toJSON();
              data.uuid = this.uuid, data.holes = [];
              for (let i = 0, l = this.holes.length; i < l; i++) {
                let hole = this.holes[i];
                data.holes.push(hole.toJSON());
              }
              return data;
            }
            fromJSON(json) {
              super.fromJSON(json), this.uuid = json.uuid, this.holes = [];
              for (let i = 0, l = json.holes.length; i < l; i++) {
                let hole = json.holes[i];
                this.holes.push(new Path().fromJSON(hole));
              }
              return this;
            }
          }
          let Earcut = { triangulate: function(data, holeIndices, dim = 2) {
            let hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, !0), triangles = [];
            if (!outerNode || outerNode.next === outerNode.prev)
              return triangles;
            let minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles && (outerNode = eliminateHoles(data, holeIndices, outerNode, dim)), data.length > 80 * dim) {
              minX = maxX = data[0], minY = maxY = data[1];
              for (let i = dim; i < outerLen; i += dim)
                x = data[i], y = data[i + 1], x < minX && (minX = x), y < minY && (minY = y), x > maxX && (maxX = x), y > maxY && (maxY = y);
              invSize = Math.max(maxX - minX, maxY - minY), invSize = invSize !== 0 ? 32767 / invSize : 0;
            }
            return earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0), triangles;
          } };
          function linkedList(data, start, end, dim, clockwise) {
            let i, last;
            if (clockwise === signedArea(data, start, end, dim) > 0)
              for (i = start; i < end; i += dim)
                last = insertNode(i, data[i], data[i + 1], last);
            else
              for (i = end - dim; i >= start; i -= dim)
                last = insertNode(i, data[i], data[i + 1], last);
            return last && equals(last, last.next) && (removeNode(last), last = last.next), last;
          }
          function filterPoints(start, end) {
            if (!start)
              return start;
            end || (end = start);
            let p = start, again;
            do
              if (again = !1, !p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                if (removeNode(p), p = end = p.prev, p === p.next)
                  break;
                again = !0;
              } else
                p = p.next;
            while (again || p !== end);
            return end;
          }
          function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
            if (!ear)
              return;
            !pass && invSize && indexCurve(ear, minX, minY, invSize);
            let stop = ear, prev, next;
            for (; ear.prev !== ear.next; ) {
              if (prev = ear.prev, next = ear.next, invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                triangles.push(prev.i / dim | 0), triangles.push(ear.i / dim | 0), triangles.push(next.i / dim | 0), removeNode(ear), ear = next.next, stop = next.next;
                continue;
              }
              if (ear = next, ear === stop) {
                pass ? pass === 1 ? (ear = cureLocalIntersections(filterPoints(ear), triangles, dim), earcutLinked(ear, triangles, dim, minX, minY, invSize, 2)) : pass === 2 && splitEarcut(ear, triangles, dim, minX, minY, invSize) : earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                break;
              }
            }
          }
          function isEar(ear) {
            let a = ear.prev, b = ear, c = ear.next;
            if (area(a, b, c) >= 0)
              return !1;
            let ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y, x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy, p = c.next;
            for (; p !== a; ) {
              if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
                return !1;
              p = p.next;
            }
            return !0;
          }
          function isEarHashed(ear, minX, minY, invSize) {
            let a = ear.prev, b = ear, c = ear.next;
            if (area(a, b, c) >= 0)
              return !1;
            let ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y, x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy, minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize), p = ear.prevZ, n = ear.nextZ;
            for (; p && p.z >= minZ && n && n.z <= maxZ; ) {
              if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0 || (p = p.prevZ, n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0))
                return !1;
              n = n.nextZ;
            }
            for (; p && p.z >= minZ; ) {
              if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
                return !1;
              p = p.prevZ;
            }
            for (; n && n.z <= maxZ; ) {
              if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
                return !1;
              n = n.nextZ;
            }
            return !0;
          }
          function cureLocalIntersections(start, triangles, dim) {
            let p = start;
            do {
              let a = p.prev, b = p.next.next;
              !equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a) && (triangles.push(a.i / dim | 0), triangles.push(p.i / dim | 0), triangles.push(b.i / dim | 0), removeNode(p), removeNode(p.next), p = start = b), p = p.next;
            } while (p !== start);
            return filterPoints(p);
          }
          function splitEarcut(start, triangles, dim, minX, minY, invSize) {
            let a = start;
            do {
              let b = a.next.next;
              for (; b !== a.prev; ) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                  let c = splitPolygon(a, b);
                  a = filterPoints(a, a.next), c = filterPoints(c, c.next), earcutLinked(a, triangles, dim, minX, minY, invSize, 0), earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                  return;
                }
                b = b.next;
              }
              a = a.next;
            } while (a !== start);
          }
          function eliminateHoles(data, holeIndices, outerNode, dim) {
            let queue = [], i, len, start, end, list;
            for (i = 0, len = holeIndices.length; i < len; i++)
              start = holeIndices[i] * dim, end = i < len - 1 ? holeIndices[i + 1] * dim : data.length, list = linkedList(data, start, end, dim, !1), list === list.next && (list.steiner = !0), queue.push(getLeftmost(list));
            for (queue.sort(compareX), i = 0; i < queue.length; i++)
              outerNode = eliminateHole(queue[i], outerNode);
            return outerNode;
          }
          function compareX(a, b) {
            return a.x - b.x;
          }
          function eliminateHole(hole, outerNode) {
            let bridge = findHoleBridge(hole, outerNode);
            if (!bridge)
              return outerNode;
            let bridgeReverse = splitPolygon(bridge, hole);
            return filterPoints(bridgeReverse, bridgeReverse.next), filterPoints(bridge, bridge.next);
          }
          function findHoleBridge(hole, outerNode) {
            let p = outerNode, qx = -1 / 0, m, hx = hole.x, hy = hole.y;
            do {
              if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                let x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx && (qx = x, m = p.x < p.next.x ? p : p.next, x === hx))
                  return m;
              }
              p = p.next;
            } while (p !== outerNode);
            if (!m)
              return null;
            let stop = m, mx = m.x, my = m.y, tanMin = 1 / 0, tan;
            p = m;
            do
              hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y) && (tan = Math.abs(hy - p.y) / (hx - p.x), locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p))) && (m = p, tanMin = tan)), p = p.next;
            while (p !== stop);
            return m;
          }
          function sectorContainsSector(m, p) {
            return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
          }
          function indexCurve(start, minX, minY, invSize) {
            let p = start;
            do
              p.z === 0 && (p.z = zOrder(p.x, p.y, minX, minY, invSize)), p.prevZ = p.prev, p.nextZ = p.next, p = p.next;
            while (p !== start);
            p.prevZ.nextZ = null, p.prevZ = null, sortLinked(p);
          }
          function sortLinked(list) {
            let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
            do {
              for (p = list, list = null, tail = null, numMerges = 0; p; ) {
                for (numMerges++, q = p, pSize = 0, i = 0; i < inSize && (pSize++, q = q.nextZ, !!q); i++)
                  ;
                for (qSize = inSize; pSize > 0 || qSize > 0 && q; )
                  pSize !== 0 && (qSize === 0 || !q || p.z <= q.z) ? (e = p, p = p.nextZ, pSize--) : (e = q, q = q.nextZ, qSize--), tail ? tail.nextZ = e : list = e, e.prevZ = tail, tail = e;
                p = q;
              }
              tail.nextZ = null, inSize *= 2;
            } while (numMerges > 1);
            return list;
          }
          function zOrder(x, y, minX, minY, invSize) {
            return x = (x - minX) * invSize | 0, y = (y - minY) * invSize | 0, x = (x | x << 8) & 16711935, x = (x | x << 4) & 252645135, x = (x | x << 2) & 858993459, x = (x | x << 1) & 1431655765, y = (y | y << 8) & 16711935, y = (y | y << 4) & 252645135, y = (y | y << 2) & 858993459, y = (y | y << 1) & 1431655765, x | y << 1;
          }
          function getLeftmost(start) {
            let p = start, leftmost = start;
            do
              (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) && (leftmost = p), p = p.next;
            while (p !== start);
            return leftmost;
          }
          function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
            return (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) && (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) && (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2);
          }
          function isValidDiagonal(a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
          }
          function area(p, q, r) {
            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
          }
          function equals(p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
          }
          function intersects(p1, q1, p2, q2) {
            let o1 = sign(area(p1, q1, p2)), o2 = sign(area(p1, q1, q2)), o3 = sign(area(p2, q2, p1)), o4 = sign(area(p2, q2, q1));
            return !!(o1 !== o2 && o3 !== o4 || o1 === 0 && onSegment(p1, p2, q1) || o2 === 0 && onSegment(p1, q2, q1) || o3 === 0 && onSegment(p2, p1, q2) || o4 === 0 && onSegment(p2, q1, q2));
          }
          function onSegment(p, q, r) {
            return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
          }
          function sign(num) {
            return num > 0 ? 1 : num < 0 ? -1 : 0;
          }
          function intersectsPolygon(a, b) {
            let p = a;
            do {
              if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
                return !0;
              p = p.next;
            } while (p !== a);
            return !1;
          }
          function locallyInside(a, b) {
            return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
          }
          function middleInside(a, b) {
            let p = a, inside = !1, px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
            do
              p.y > py2 != p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x && (inside = !inside), p = p.next;
            while (p !== a);
            return inside;
          }
          function splitPolygon(a, b) {
            let a2 = new Node2(a.i, a.x, a.y), b2 = new Node2(b.i, b.x, b.y), an = a.next, bp = b.prev;
            return a.next = b, b.prev = a, a2.next = an, an.prev = a2, b2.next = a2, a2.prev = b2, bp.next = b2, b2.prev = bp, b2;
          }
          function insertNode(i, x, y, last) {
            let p = new Node2(i, x, y);
            return last ? (p.next = last.next, p.prev = last, last.next.prev = p, last.next = p) : (p.prev = p, p.next = p), p;
          }
          function removeNode(p) {
            p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), p.nextZ && (p.nextZ.prevZ = p.prevZ);
          }
          function Node2(i, x, y) {
            this.i = i, this.x = x, this.y = y, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
          }
          function signedArea(data, start, end, dim) {
            let sum = 0;
            for (let i = start, j = end - dim; i < end; i += dim)
              sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]), j = i;
            return sum;
          }
          class ShapeUtils {
            static area(contour) {
              let n = contour.length, a = 0;
              for (let p = n - 1, q = 0; q < n; p = q++)
                a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
              return a * 0.5;
            }
            static isClockWise(pts) {
              return ShapeUtils.area(pts) < 0;
            }
            static triangulateShape(contour, holes) {
              let vertices = [], holeIndices = [], faces = [];
              removeDupEndPts(contour), addContour(vertices, contour);
              let holeIndex = contour.length;
              holes.forEach(removeDupEndPts);
              for (let i = 0; i < holes.length; i++)
                holeIndices.push(holeIndex), holeIndex += holes[i].length, addContour(vertices, holes[i]);
              let triangles = Earcut.triangulate(vertices, holeIndices);
              for (let i = 0; i < triangles.length; i += 3)
                faces.push(triangles.slice(i, i + 3));
              return faces;
            }
          }
          function removeDupEndPts(points) {
            let l = points.length;
            l > 2 && points[l - 1].equals(points[0]) && points.pop();
          }
          function addContour(vertices, contour) {
            for (let i = 0; i < contour.length; i++)
              vertices.push(contour[i].x), vertices.push(contour[i].y);
          }
          class ExtrudeGeometry extends BufferGeometry {
            constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
              super();
              this.type = "ExtrudeGeometry", this.parameters = { shapes, options }, shapes = Array.isArray(shapes) ? shapes : [shapes];
              let scope = this, verticesArray = [], uvArray = [];
              for (let i = 0, l = shapes.length; i < l; i++) {
                let shape = shapes[i];
                addShape(shape);
              }
              this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2)), this.computeVertexNormals();
              function addShape(shape) {
                let placeholder = [], curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12, steps = options.steps !== void 0 ? options.steps : 1, depth = options.depth !== void 0 ? options.depth : 1, bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : !0, bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2, bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1, bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0, bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3, extrudePath = options.extrudePath, uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator, extrudePts, extrudeByPath = !1, splineTube, binormal, normal, position2;
                extrudePath && (extrudePts = extrudePath.getSpacedPoints(steps), extrudeByPath = !0, bevelEnabled = !1, splineTube = extrudePath.computeFrenetFrames(steps, !1), binormal = new Vector3(), normal = new Vector3(), position2 = new Vector3()), bevelEnabled || (bevelSegments = 0, bevelThickness = 0, bevelSize = 0, bevelOffset = 0);
                let shapePoints = shape.extractPoints(curveSegments), vertices = shapePoints.shape, holes = shapePoints.holes;
                if (!ShapeUtils.isClockWise(vertices)) {
                  vertices = vertices.reverse();
                  for (let h = 0, hl = holes.length; h < hl; h++) {
                    let ahole = holes[h];
                    ShapeUtils.isClockWise(ahole) && (holes[h] = ahole.reverse());
                  }
                }
                let faces = ShapeUtils.triangulateShape(vertices, holes), contour = vertices;
                for (let h = 0, hl = holes.length; h < hl; h++) {
                  let ahole = holes[h];
                  vertices = vertices.concat(ahole);
                }
                function scalePt2(pt, vec, size) {
                  return vec || console.error("THREE.ExtrudeGeometry: vec does not exist"), pt.clone().addScaledVector(vec, size);
                }
                let vlen = vertices.length, flen = faces.length;
                function getBevelVec(inPt, inPrev, inNext) {
                  let v_trans_x, v_trans_y, shrink_by, v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y, v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y, v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y, collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
                  if (Math.abs(collinear0) > Number.EPSILON) {
                    let v_prev_len = Math.sqrt(v_prev_lensq), v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y), ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len, ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len, ptNextShift_x = inNext.x - v_next_y / v_next_len, ptNextShift_y = inNext.y + v_next_x / v_next_len, sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x, v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                    let v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                    if (v_trans_lensq <= 2)
                      return new Vector2(v_trans_x, v_trans_y);
                    shrink_by = Math.sqrt(v_trans_lensq / 2);
                  } else {
                    let direction_eq = !1;
                    v_prev_x > Number.EPSILON ? v_next_x > Number.EPSILON && (direction_eq = !0) : v_prev_x < -Number.EPSILON ? v_next_x < -Number.EPSILON && (direction_eq = !0) : Math.sign(v_prev_y) === Math.sign(v_next_y) && (direction_eq = !0), direction_eq ? (v_trans_x = -v_prev_y, v_trans_y = v_prev_x, shrink_by = Math.sqrt(v_prev_lensq)) : (v_trans_x = v_prev_x, v_trans_y = v_prev_y, shrink_by = Math.sqrt(v_prev_lensq / 2));
                  }
                  return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
                }
                let contourMovements = [];
                for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++)
                  j === il && (j = 0), k === il && (k = 0), contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
                let holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
                for (let h = 0, hl = holes.length; h < hl; h++) {
                  let ahole = holes[h];
                  oneHoleMovements = [];
                  for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++)
                    j === il && (j = 0), k === il && (k = 0), oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
                  holesMovements.push(oneHoleMovements), verticesMovements = verticesMovements.concat(oneHoleMovements);
                }
                for (let b = 0; b < bevelSegments; b++) {
                  let t = b / bevelSegments, z = bevelThickness * Math.cos(t * Math.PI / 2), bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                  for (let i = 0, il = contour.length; i < il; i++) {
                    let vert = scalePt2(contour[i], contourMovements[i], bs2);
                    v(vert.x, vert.y, -z);
                  }
                  for (let h = 0, hl = holes.length; h < hl; h++) {
                    let ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (let i = 0, il = ahole.length; i < il; i++) {
                      let vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
                      v(vert.x, vert.y, -z);
                    }
                  }
                }
                let bs = bevelSize + bevelOffset;
                for (let i = 0; i < vlen; i++) {
                  let vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                  extrudeByPath ? (normal.copy(splineTube.normals[0]).multiplyScalar(vert.x), binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y), position2.copy(extrudePts[0]).add(normal).add(binormal), v(position2.x, position2.y, position2.z)) : v(vert.x, vert.y, 0);
                }
                for (let s = 1; s <= steps; s++)
                  for (let i = 0; i < vlen; i++) {
                    let vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                    extrudeByPath ? (normal.copy(splineTube.normals[s]).multiplyScalar(vert.x), binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y), position2.copy(extrudePts[s]).add(normal).add(binormal), v(position2.x, position2.y, position2.z)) : v(vert.x, vert.y, depth / steps * s);
                  }
                for (let b = bevelSegments - 1; b >= 0; b--) {
                  let t = b / bevelSegments, z = bevelThickness * Math.cos(t * Math.PI / 2), bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                  for (let i = 0, il = contour.length; i < il; i++) {
                    let vert = scalePt2(contour[i], contourMovements[i], bs2);
                    v(vert.x, vert.y, depth + z);
                  }
                  for (let h = 0, hl = holes.length; h < hl; h++) {
                    let ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (let i = 0, il = ahole.length; i < il; i++) {
                      let vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
                      extrudeByPath ? v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z) : v(vert.x, vert.y, depth + z);
                    }
                  }
                }
                buildLidFaces(), buildSideFaces();
                function buildLidFaces() {
                  let start = verticesArray.length / 3;
                  if (bevelEnabled) {
                    let layer = 0, offset = vlen * layer;
                    for (let i = 0; i < flen; i++) {
                      let face = faces[i];
                      f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    }
                    layer = steps + bevelSegments * 2, offset = vlen * layer;
                    for (let i = 0; i < flen; i++) {
                      let face = faces[i];
                      f3(face[0] + offset, face[1] + offset, face[2] + offset);
                    }
                  } else {
                    for (let i = 0; i < flen; i++) {
                      let face = faces[i];
                      f3(face[2], face[1], face[0]);
                    }
                    for (let i = 0; i < flen; i++) {
                      let face = faces[i];
                      f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                    }
                  }
                  scope.addGroup(start, verticesArray.length / 3 - start, 0);
                }
                function buildSideFaces() {
                  let start = verticesArray.length / 3, layeroffset = 0;
                  sidewalls(contour, layeroffset), layeroffset += contour.length;
                  for (let h = 0, hl = holes.length; h < hl; h++) {
                    let ahole = holes[h];
                    sidewalls(ahole, layeroffset), layeroffset += ahole.length;
                  }
                  scope.addGroup(start, verticesArray.length / 3 - start, 1);
                }
                function sidewalls(contour2, layeroffset) {
                  let i = contour2.length;
                  for (; --i >= 0; ) {
                    let j = i, k = i - 1;
                    k < 0 && (k = contour2.length - 1);
                    for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
                      let slen1 = vlen * s, slen2 = vlen * (s + 1), a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                      f4(a, b, c, d);
                    }
                  }
                }
                function v(x, y, z) {
                  placeholder.push(x), placeholder.push(y), placeholder.push(z);
                }
                function f3(a, b, c) {
                  addVertex(a), addVertex(b), addVertex(c);
                  let nextIndex = verticesArray.length / 3, uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                  addUV(uvs[0]), addUV(uvs[1]), addUV(uvs[2]);
                }
                function f4(a, b, c, d) {
                  addVertex(a), addVertex(b), addVertex(d), addVertex(b), addVertex(c), addVertex(d);
                  let nextIndex = verticesArray.length / 3, uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                  addUV(uvs[0]), addUV(uvs[1]), addUV(uvs[3]), addUV(uvs[1]), addUV(uvs[2]), addUV(uvs[3]);
                }
                function addVertex(index) {
                  verticesArray.push(placeholder[index * 3 + 0]), verticesArray.push(placeholder[index * 3 + 1]), verticesArray.push(placeholder[index * 3 + 2]);
                }
                function addUV(vector2) {
                  uvArray.push(vector2.x), uvArray.push(vector2.y);
                }
              }
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            toJSON() {
              let data = super.toJSON(), shapes = this.parameters.shapes, options = this.parameters.options;
              return toJSON$1(shapes, options, data);
            }
            static fromJSON(data, shapes) {
              let geometryShapes = [];
              for (let j = 0, jl = data.shapes.length; j < jl; j++) {
                let shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
              }
              let extrudePath = data.options.extrudePath;
              return extrudePath !== void 0 && (data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath)), new ExtrudeGeometry(geometryShapes, data.options);
            }
          }
          let WorldUVGenerator = { generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
            let a_x = vertices[indexA * 3], a_y = vertices[indexA * 3 + 1], b_x = vertices[indexB * 3], b_y = vertices[indexB * 3 + 1], c_x = vertices[indexC * 3], c_y = vertices[indexC * 3 + 1];
            return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
          }, generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
            let a_x = vertices[indexA * 3], a_y = vertices[indexA * 3 + 1], a_z = vertices[indexA * 3 + 2], b_x = vertices[indexB * 3], b_y = vertices[indexB * 3 + 1], b_z = vertices[indexB * 3 + 2], c_x = vertices[indexC * 3], c_y = vertices[indexC * 3 + 1], c_z = vertices[indexC * 3 + 2], d_x = vertices[indexD * 3], d_y = vertices[indexD * 3 + 1], d_z = vertices[indexD * 3 + 2];
            return Math.abs(a_y - b_y) < Math.abs(a_x - b_x) ? [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)] : [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
          } };
          function toJSON$1(shapes, options, data) {
            if (data.shapes = [], Array.isArray(shapes))
              for (let i = 0, l = shapes.length; i < l; i++) {
                let shape = shapes[i];
                data.shapes.push(shape.uuid);
              }
            else
              data.shapes.push(shapes.uuid);
            return data.options = Object.assign({}, options), options.extrudePath !== void 0 && (data.options.extrudePath = options.extrudePath.toJSON()), data;
          }
          class IcosahedronGeometry extends PolyhedronGeometry {
            constructor(radius = 1, detail = 0) {
              let t = (1 + Math.sqrt(5)) / 2, vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1], indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
              super(vertices, indices, radius, detail);
              this.type = "IcosahedronGeometry", this.parameters = { radius, detail };
            }
            static fromJSON(data) {
              return new IcosahedronGeometry(data.radius, data.detail);
            }
          }
          class OctahedronGeometry extends PolyhedronGeometry {
            constructor(radius = 1, detail = 0) {
              let vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
              super(vertices, indices, radius, detail);
              this.type = "OctahedronGeometry", this.parameters = { radius, detail };
            }
            static fromJSON(data) {
              return new OctahedronGeometry(data.radius, data.detail);
            }
          }
          class RingGeometry extends BufferGeometry {
            constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
              super();
              this.type = "RingGeometry", this.parameters = { innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength }, thetaSegments = Math.max(3, thetaSegments), phiSegments = Math.max(1, phiSegments);
              let indices = [], vertices = [], normals = [], uvs = [], radius = innerRadius, radiusStep = (outerRadius - innerRadius) / phiSegments, vertex2 = new Vector3(), uv = new Vector2();
              for (let j = 0; j <= phiSegments; j++) {
                for (let i = 0; i <= thetaSegments; i++) {
                  let segment = thetaStart + i / thetaSegments * thetaLength;
                  vertex2.x = radius * Math.cos(segment), vertex2.y = radius * Math.sin(segment), vertices.push(vertex2.x, vertex2.y, vertex2.z), normals.push(0, 0, 1), uv.x = (vertex2.x / outerRadius + 1) / 2, uv.y = (vertex2.y / outerRadius + 1) / 2, uvs.push(uv.x, uv.y);
                }
                radius += radiusStep;
              }
              for (let j = 0; j < phiSegments; j++) {
                let thetaSegmentLevel = j * (thetaSegments + 1);
                for (let i = 0; i < thetaSegments; i++) {
                  let segment = i + thetaSegmentLevel, a = segment, b = segment + thetaSegments + 1, c = segment + thetaSegments + 2, d = segment + 1;
                  indices.push(a, b, d), indices.push(b, c, d);
                }
              }
              this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            static fromJSON(data) {
              return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            }
          }
          class ShapeGeometry extends BufferGeometry {
            constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
              super();
              this.type = "ShapeGeometry", this.parameters = { shapes, curveSegments };
              let indices = [], vertices = [], normals = [], uvs = [], groupStart = 0, groupCount = 0;
              if (Array.isArray(shapes) === !1)
                addShape(shapes);
              else
                for (let i = 0; i < shapes.length; i++)
                  addShape(shapes[i]), this.addGroup(groupStart, groupCount, i), groupStart += groupCount, groupCount = 0;
              this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
              function addShape(shape) {
                let indexOffset = vertices.length / 3, points = shape.extractPoints(curveSegments), shapeVertices = points.shape, shapeHoles = points.holes;
                ShapeUtils.isClockWise(shapeVertices) === !1 && (shapeVertices = shapeVertices.reverse());
                for (let i = 0, l = shapeHoles.length; i < l; i++) {
                  let shapeHole = shapeHoles[i];
                  ShapeUtils.isClockWise(shapeHole) === !0 && (shapeHoles[i] = shapeHole.reverse());
                }
                let faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
                for (let i = 0, l = shapeHoles.length; i < l; i++) {
                  let shapeHole = shapeHoles[i];
                  shapeVertices = shapeVertices.concat(shapeHole);
                }
                for (let i = 0, l = shapeVertices.length; i < l; i++) {
                  let vertex2 = shapeVertices[i];
                  vertices.push(vertex2.x, vertex2.y, 0), normals.push(0, 0, 1), uvs.push(vertex2.x, vertex2.y);
                }
                for (let i = 0, l = faces.length; i < l; i++) {
                  let face = faces[i], a = face[0] + indexOffset, b = face[1] + indexOffset, c = face[2] + indexOffset;
                  indices.push(a, b, c), groupCount += 3;
                }
              }
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            toJSON() {
              let data = super.toJSON(), shapes = this.parameters.shapes;
              return toJSON(shapes, data);
            }
            static fromJSON(data, shapes) {
              let geometryShapes = [];
              for (let j = 0, jl = data.shapes.length; j < jl; j++) {
                let shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
              }
              return new ShapeGeometry(geometryShapes, data.curveSegments);
            }
          }
          function toJSON(shapes, data) {
            if (data.shapes = [], Array.isArray(shapes))
              for (let i = 0, l = shapes.length; i < l; i++) {
                let shape = shapes[i];
                data.shapes.push(shape.uuid);
              }
            else
              data.shapes.push(shapes.uuid);
            return data;
          }
          class SphereGeometry extends BufferGeometry {
            constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
              super();
              this.type = "SphereGeometry", this.parameters = { radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength }, widthSegments = Math.max(3, Math.floor(widthSegments)), heightSegments = Math.max(2, Math.floor(heightSegments));
              let thetaEnd = Math.min(thetaStart + thetaLength, Math.PI), index = 0, grid = [], vertex2 = new Vector3(), normal = new Vector3(), indices = [], vertices = [], normals = [], uvs = [];
              for (let iy = 0; iy <= heightSegments; iy++) {
                let verticesRow = [], v = iy / heightSegments, uOffset = 0;
                iy === 0 && thetaStart === 0 ? uOffset = 0.5 / widthSegments : iy === heightSegments && thetaEnd === Math.PI && (uOffset = -0.5 / widthSegments);
                for (let ix = 0; ix <= widthSegments; ix++) {
                  let u = ix / widthSegments;
                  vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), vertex2.y = radius * Math.cos(thetaStart + v * thetaLength), vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), vertices.push(vertex2.x, vertex2.y, vertex2.z), normal.copy(vertex2).normalize(), normals.push(normal.x, normal.y, normal.z), uvs.push(u + uOffset, 1 - v), verticesRow.push(index++);
                }
                grid.push(verticesRow);
              }
              for (let iy = 0; iy < heightSegments; iy++)
                for (let ix = 0; ix < widthSegments; ix++) {
                  let a = grid[iy][ix + 1], b = grid[iy][ix], c = grid[iy + 1][ix], d = grid[iy + 1][ix + 1];
                  (iy !== 0 || thetaStart > 0) && indices.push(a, b, d), (iy !== heightSegments - 1 || thetaEnd < Math.PI) && indices.push(b, c, d);
                }
              this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            static fromJSON(data) {
              return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            }
          }
          class TetrahedronGeometry extends PolyhedronGeometry {
            constructor(radius = 1, detail = 0) {
              let vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
              super(vertices, indices, radius, detail);
              this.type = "TetrahedronGeometry", this.parameters = { radius, detail };
            }
            static fromJSON(data) {
              return new TetrahedronGeometry(data.radius, data.detail);
            }
          }
          class TorusGeometry extends BufferGeometry {
            constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
              super();
              this.type = "TorusGeometry", this.parameters = { radius, tube, radialSegments, tubularSegments, arc }, radialSegments = Math.floor(radialSegments), tubularSegments = Math.floor(tubularSegments);
              let indices = [], vertices = [], normals = [], uvs = [], center = new Vector3(), vertex2 = new Vector3(), normal = new Vector3();
              for (let j = 0; j <= radialSegments; j++)
                for (let i = 0; i <= tubularSegments; i++) {
                  let u = i / tubularSegments * arc, v = j / radialSegments * Math.PI * 2;
                  vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u), vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u), vertex2.z = tube * Math.sin(v), vertices.push(vertex2.x, vertex2.y, vertex2.z), center.x = radius * Math.cos(u), center.y = radius * Math.sin(u), normal.subVectors(vertex2, center).normalize(), normals.push(normal.x, normal.y, normal.z), uvs.push(i / tubularSegments), uvs.push(j / radialSegments);
                }
              for (let j = 1; j <= radialSegments; j++)
                for (let i = 1; i <= tubularSegments; i++) {
                  let a = (tubularSegments + 1) * j + i - 1, b = (tubularSegments + 1) * (j - 1) + i - 1, c = (tubularSegments + 1) * (j - 1) + i, d = (tubularSegments + 1) * j + i;
                  indices.push(a, b, d), indices.push(b, c, d);
                }
              this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            static fromJSON(data) {
              return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            }
          }
          class TorusKnotGeometry extends BufferGeometry {
            constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
              super();
              this.type = "TorusKnotGeometry", this.parameters = { radius, tube, tubularSegments, radialSegments, p, q }, tubularSegments = Math.floor(tubularSegments), radialSegments = Math.floor(radialSegments);
              let indices = [], vertices = [], normals = [], uvs = [], vertex2 = new Vector3(), normal = new Vector3(), P1 = new Vector3(), P2 = new Vector3(), B = new Vector3(), T = new Vector3(), N = new Vector3();
              for (let i = 0; i <= tubularSegments; ++i) {
                let u = i / tubularSegments * p * Math.PI * 2;
                calculatePositionOnCurve(u, p, q, radius, P1), calculatePositionOnCurve(u + 0.01, p, q, radius, P2), T.subVectors(P2, P1), N.addVectors(P2, P1), B.crossVectors(T, N), N.crossVectors(B, T), B.normalize(), N.normalize();
                for (let j = 0; j <= radialSegments; ++j) {
                  let v = j / radialSegments * Math.PI * 2, cx = -tube * Math.cos(v), cy = tube * Math.sin(v);
                  vertex2.x = P1.x + (cx * N.x + cy * B.x), vertex2.y = P1.y + (cx * N.y + cy * B.y), vertex2.z = P1.z + (cx * N.z + cy * B.z), vertices.push(vertex2.x, vertex2.y, vertex2.z), normal.subVectors(vertex2, P1).normalize(), normals.push(normal.x, normal.y, normal.z), uvs.push(i / tubularSegments), uvs.push(j / radialSegments);
                }
              }
              for (let j = 1; j <= tubularSegments; j++)
                for (let i = 1; i <= radialSegments; i++) {
                  let a = (radialSegments + 1) * (j - 1) + (i - 1), b = (radialSegments + 1) * j + (i - 1), c = (radialSegments + 1) * j + i, d = (radialSegments + 1) * (j - 1) + i;
                  indices.push(a, b, d), indices.push(b, c, d);
                }
              this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
              function calculatePositionOnCurve(u, p2, q2, radius2, position) {
                let cu = Math.cos(u), su = Math.sin(u), quOverP = q2 / p2 * u, cs = Math.cos(quOverP);
                position.x = radius2 * (2 + cs) * 0.5 * cu, position.y = radius2 * (2 + cs) * su * 0.5, position.z = radius2 * Math.sin(quOverP) * 0.5;
              }
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            static fromJSON(data) {
              return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            }
          }
          class TubeGeometry extends BufferGeometry {
            constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = !1) {
              super();
              this.type = "TubeGeometry", this.parameters = { path, tubularSegments, radius, radialSegments, closed };
              let frames = path.computeFrenetFrames(tubularSegments, closed);
              this.tangents = frames.tangents, this.normals = frames.normals, this.binormals = frames.binormals;
              let vertex2 = new Vector3(), normal = new Vector3(), uv = new Vector2(), P = new Vector3(), vertices = [], normals = [], uvs = [], indices = [];
              generateBufferData(), this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
              function generateBufferData() {
                for (let i = 0; i < tubularSegments; i++)
                  generateSegment(i);
                generateSegment(closed === !1 ? tubularSegments : 0), generateUVs(), generateIndices();
              }
              function generateSegment(i) {
                P = path.getPointAt(i / tubularSegments, P);
                let N = frames.normals[i], B = frames.binormals[i];
                for (let j = 0; j <= radialSegments; j++) {
                  let v = j / radialSegments * Math.PI * 2, sin = Math.sin(v), cos = -Math.cos(v);
                  normal.x = cos * N.x + sin * B.x, normal.y = cos * N.y + sin * B.y, normal.z = cos * N.z + sin * B.z, normal.normalize(), normals.push(normal.x, normal.y, normal.z), vertex2.x = P.x + radius * normal.x, vertex2.y = P.y + radius * normal.y, vertex2.z = P.z + radius * normal.z, vertices.push(vertex2.x, vertex2.y, vertex2.z);
                }
              }
              function generateIndices() {
                for (let j = 1; j <= tubularSegments; j++)
                  for (let i = 1; i <= radialSegments; i++) {
                    let a = (radialSegments + 1) * (j - 1) + (i - 1), b = (radialSegments + 1) * j + (i - 1), c = (radialSegments + 1) * j + i, d = (radialSegments + 1) * (j - 1) + i;
                    indices.push(a, b, d), indices.push(b, c, d);
                  }
              }
              function generateUVs() {
                for (let i = 0; i <= tubularSegments; i++)
                  for (let j = 0; j <= radialSegments; j++)
                    uv.x = i / tubularSegments, uv.y = j / radialSegments, uvs.push(uv.x, uv.y);
              }
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.path = this.parameters.path.toJSON(), data;
            }
            static fromJSON(data) {
              return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
            }
          }
          class WireframeGeometry extends BufferGeometry {
            constructor(geometry = null) {
              super();
              if (this.type = "WireframeGeometry", this.parameters = { geometry }, geometry !== null) {
                let vertices = [], edges = new Set(), start = new Vector3(), end = new Vector3();
                if (geometry.index !== null) {
                  let position = geometry.attributes.position, indices = geometry.index, groups = geometry.groups;
                  groups.length === 0 && (groups = [{ start: 0, count: indices.count, materialIndex: 0 }]);
                  for (let o = 0, ol = groups.length; o < ol; ++o) {
                    let group = groups[o], groupStart = group.start, groupCount = group.count;
                    for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3)
                      for (let j = 0; j < 3; j++) {
                        let index1 = indices.getX(i + j), index2 = indices.getX(i + (j + 1) % 3);
                        start.fromBufferAttribute(position, index1), end.fromBufferAttribute(position, index2), isUniqueEdge(start, end, edges) === !0 && (vertices.push(start.x, start.y, start.z), vertices.push(end.x, end.y, end.z));
                      }
                  }
                } else {
                  let position = geometry.attributes.position;
                  for (let i = 0, l = position.count / 3; i < l; i++)
                    for (let j = 0; j < 3; j++) {
                      let index1 = 3 * i + j, index2 = 3 * i + (j + 1) % 3;
                      start.fromBufferAttribute(position, index1), end.fromBufferAttribute(position, index2), isUniqueEdge(start, end, edges) === !0 && (vertices.push(start.x, start.y, start.z), vertices.push(end.x, end.y, end.z));
                    }
                }
                this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
              }
            }
            copy(source) {
              return super.copy(source), this.parameters = Object.assign({}, source.parameters), this;
            }
          }
          function isUniqueEdge(start, end, edges) {
            let hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`, hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
            return edges.has(hash1) === !0 || edges.has(hash2) === !0 ? !1 : (edges.add(hash1), edges.add(hash2), !0);
          }
          var Geometries = /* @__PURE__ */ Object.freeze({ __proto__: null, BoxGeometry, CapsuleGeometry, CircleGeometry, ConeGeometry, CylinderGeometry, DodecahedronGeometry, EdgesGeometry, ExtrudeGeometry, IcosahedronGeometry, LatheGeometry, OctahedronGeometry, PlaneGeometry, PolyhedronGeometry, RingGeometry, ShapeGeometry, SphereGeometry, TetrahedronGeometry, TorusGeometry, TorusKnotGeometry, TubeGeometry, WireframeGeometry });
          class ShadowMaterial extends Material {
            constructor(parameters) {
              super();
              this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Color(0), this.transparent = !0, this.fog = !0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.color.copy(source.color), this.fog = source.fog, this;
            }
          }
          class RawShaderMaterial extends ShaderMaterial {
            constructor(parameters) {
              super(parameters);
              this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
            }
          }
          class MeshStandardMaterial extends Material {
            constructor(parameters) {
              super();
              this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.defines = { STANDARD: "" }, this.color.copy(source.color), this.roughness = source.roughness, this.metalness = source.metalness, this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.roughnessMap = source.roughnessMap, this.metalnessMap = source.metalnessMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapRotation.copy(source.envMapRotation), this.envMapIntensity = source.envMapIntensity, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.flatShading = source.flatShading, this.fog = source.fog, this;
            }
          }
          class MeshPhysicalMaterial extends MeshStandardMaterial {
            constructor(parameters) {
              super();
              this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
                return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
              }, set: function(reflectivity) {
                this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
              } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Color(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Color(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Color(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(parameters);
            }
            get anisotropy() {
              return this._anisotropy;
            }
            set anisotropy(value) {
              this._anisotropy > 0 != value > 0 && this.version++, this._anisotropy = value;
            }
            get clearcoat() {
              return this._clearcoat;
            }
            set clearcoat(value) {
              this._clearcoat > 0 != value > 0 && this.version++, this._clearcoat = value;
            }
            get iridescence() {
              return this._iridescence;
            }
            set iridescence(value) {
              this._iridescence > 0 != value > 0 && this.version++, this._iridescence = value;
            }
            get dispersion() {
              return this._dispersion;
            }
            set dispersion(value) {
              this._dispersion > 0 != value > 0 && this.version++, this._dispersion = value;
            }
            get sheen() {
              return this._sheen;
            }
            set sheen(value) {
              this._sheen > 0 != value > 0 && this.version++, this._sheen = value;
            }
            get transmission() {
              return this._transmission;
            }
            set transmission(value) {
              this._transmission > 0 != value > 0 && this.version++, this._transmission = value;
            }
            copy(source) {
              return super.copy(source), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = source.anisotropy, this.anisotropyRotation = source.anisotropyRotation, this.anisotropyMap = source.anisotropyMap, this.clearcoat = source.clearcoat, this.clearcoatMap = source.clearcoatMap, this.clearcoatRoughness = source.clearcoatRoughness, this.clearcoatRoughnessMap = source.clearcoatRoughnessMap, this.clearcoatNormalMap = source.clearcoatNormalMap, this.clearcoatNormalScale.copy(source.clearcoatNormalScale), this.dispersion = source.dispersion, this.ior = source.ior, this.iridescence = source.iridescence, this.iridescenceMap = source.iridescenceMap, this.iridescenceIOR = source.iridescenceIOR, this.iridescenceThicknessRange = [...source.iridescenceThicknessRange], this.iridescenceThicknessMap = source.iridescenceThicknessMap, this.sheen = source.sheen, this.sheenColor.copy(source.sheenColor), this.sheenColorMap = source.sheenColorMap, this.sheenRoughness = source.sheenRoughness, this.sheenRoughnessMap = source.sheenRoughnessMap, this.transmission = source.transmission, this.transmissionMap = source.transmissionMap, this.thickness = source.thickness, this.thicknessMap = source.thicknessMap, this.attenuationDistance = source.attenuationDistance, this.attenuationColor.copy(source.attenuationColor), this.specularIntensity = source.specularIntensity, this.specularIntensityMap = source.specularIntensityMap, this.specularColor.copy(source.specularColor), this.specularColorMap = source.specularColorMap, this;
            }
          }
          class MeshPhongMaterial extends Material {
            constructor(parameters) {
              super();
              this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Color(16777215), this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler(), this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.color.copy(source.color), this.specular.copy(source.specular), this.shininess = source.shininess, this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapRotation.copy(source.envMapRotation), this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.flatShading = source.flatShading, this.fog = source.fog, this;
            }
          }
          class MeshToonMaterial extends Material {
            constructor(parameters) {
              super();
              this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Color(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.color.copy(source.color), this.map = source.map, this.gradientMap = source.gradientMap, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.alphaMap = source.alphaMap, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.fog = source.fog, this;
            }
          }
          class MeshNormalMaterial extends Material {
            constructor(parameters) {
              super();
              this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.flatShading = source.flatShading, this;
            }
          }
          class MeshLambertMaterial extends Material {
            constructor(parameters) {
              super();
              this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Euler(), this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.color.copy(source.color), this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapRotation.copy(source.envMapRotation), this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.flatShading = source.flatShading, this.fog = source.fog, this;
            }
          }
          class MeshMatcapMaterial extends Material {
            constructor(parameters) {
              super();
              this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Color(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.defines = { MATCAP: "" }, this.color.copy(source.color), this.matcap = source.matcap, this.map = source.map, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.alphaMap = source.alphaMap, this.flatShading = source.flatShading, this.fog = source.fog, this;
            }
          }
          class LineDashedMaterial extends LineBasicMaterial {
            constructor(parameters) {
              super();
              this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(parameters);
            }
            copy(source) {
              return super.copy(source), this.scale = source.scale, this.dashSize = source.dashSize, this.gapSize = source.gapSize, this;
            }
          }
          function convertArray(array, type, forceClone) {
            return !array || !forceClone && array.constructor === type ? array : typeof type.BYTES_PER_ELEMENT == "number" ? new type(array) : Array.prototype.slice.call(array);
          }
          function isTypedArray(object) {
            return ArrayBuffer.isView(object) && !(object instanceof DataView);
          }
          function getKeyframeOrder(times) {
            function compareTime(i, j) {
              return times[i] - times[j];
            }
            let n = times.length, result = new Array(n);
            for (let i = 0; i !== n; ++i)
              result[i] = i;
            return result.sort(compareTime), result;
          }
          function sortedArray(values, stride, order) {
            let nValues = values.length, result = new values.constructor(nValues);
            for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
              let srcOffset = order[i] * stride;
              for (let j = 0; j !== stride; ++j)
                result[dstOffset++] = values[srcOffset + j];
            }
            return result;
          }
          function flattenJSON(jsonKeys, times, values, valuePropertyName) {
            let i = 1, key = jsonKeys[0];
            for (; key !== void 0 && key[valuePropertyName] === void 0; )
              key = jsonKeys[i++];
            if (key === void 0)
              return;
            let value = key[valuePropertyName];
            if (value !== void 0)
              if (Array.isArray(value))
                do
                  value = key[valuePropertyName], value !== void 0 && (times.push(key.time), values.push.apply(values, value)), key = jsonKeys[i++];
                while (key !== void 0);
              else if (value.toArray !== void 0)
                do
                  value = key[valuePropertyName], value !== void 0 && (times.push(key.time), value.toArray(values, values.length)), key = jsonKeys[i++];
                while (key !== void 0);
              else
                do
                  value = key[valuePropertyName], value !== void 0 && (times.push(key.time), values.push(value)), key = jsonKeys[i++];
                while (key !== void 0);
          }
          function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
            let clip = sourceClip.clone();
            clip.name = name;
            let tracks = [];
            for (let i = 0; i < clip.tracks.length; ++i) {
              let track = clip.tracks[i], valueSize = track.getValueSize(), times = [], values = [];
              for (let j = 0; j < track.times.length; ++j) {
                let frame = track.times[j] * fps;
                if (!(frame < startFrame || frame >= endFrame)) {
                  times.push(track.times[j]);
                  for (let k = 0; k < valueSize; ++k)
                    values.push(track.values[j * valueSize + k]);
                }
              }
              times.length !== 0 && (track.times = convertArray(times, track.times.constructor), track.values = convertArray(values, track.values.constructor), tracks.push(track));
            }
            clip.tracks = tracks;
            let minStartTime = 1 / 0;
            for (let i = 0; i < clip.tracks.length; ++i)
              minStartTime > clip.tracks[i].times[0] && (minStartTime = clip.tracks[i].times[0]);
            for (let i = 0; i < clip.tracks.length; ++i)
              clip.tracks[i].shift(-1 * minStartTime);
            return clip.resetDuration(), clip;
          }
          function makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
            fps <= 0 && (fps = 30);
            let numTracks = referenceClip.tracks.length, referenceTime = referenceFrame / fps;
            for (let i = 0; i < numTracks; ++i) {
              let referenceTrack = referenceClip.tracks[i], referenceTrackType = referenceTrack.ValueTypeName;
              if (referenceTrackType === "bool" || referenceTrackType === "string")
                continue;
              let targetTrack = targetClip.tracks.find(function(track) {
                return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
              });
              if (targetTrack === void 0)
                continue;
              let referenceOffset = 0, referenceValueSize = referenceTrack.getValueSize();
              referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (referenceOffset = referenceValueSize / 3);
              let targetOffset = 0, targetValueSize = targetTrack.getValueSize();
              targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (targetOffset = targetValueSize / 3);
              let lastIndex = referenceTrack.times.length - 1, referenceValue;
              if (referenceTime <= referenceTrack.times[0]) {
                let startIndex = referenceOffset, endIndex = referenceValueSize - referenceOffset;
                referenceValue = referenceTrack.values.slice(startIndex, endIndex);
              } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                let startIndex = lastIndex * referenceValueSize + referenceOffset, endIndex = startIndex + referenceValueSize - referenceOffset;
                referenceValue = referenceTrack.values.slice(startIndex, endIndex);
              } else {
                let interpolant = referenceTrack.createInterpolant(), startIndex = referenceOffset, endIndex = referenceValueSize - referenceOffset;
                interpolant.evaluate(referenceTime), referenceValue = interpolant.resultBuffer.slice(startIndex, endIndex);
              }
              referenceTrackType === "quaternion" && new Quaternion().fromArray(referenceValue).normalize().conjugate().toArray(referenceValue);
              let numTimes = targetTrack.times.length;
              for (let j = 0; j < numTimes; ++j) {
                let valueStart = j * targetValueSize + targetOffset;
                if (referenceTrackType === "quaternion")
                  Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                else {
                  let valueEnd = targetValueSize - targetOffset * 2;
                  for (let k = 0; k < valueEnd; ++k)
                    targetTrack.values[valueStart + k] -= referenceValue[k];
                }
              }
            }
            return targetClip.blendMode = AdditiveAnimationBlendMode, targetClip;
          }
          let AnimationUtils = { convertArray, isTypedArray, getKeyframeOrder, sortedArray, flattenJSON, subclip, makeClipAdditive };
          class Interpolant {
            constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
              this.parameterPositions = parameterPositions, this._cachedIndex = 0, this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize), this.sampleValues = sampleValues, this.valueSize = sampleSize, this.settings = null, this.DefaultSettings_ = {};
            }
            evaluate(t) {
              let pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
              validate_interval: {
                seek: {
                  let right;
                  linear_scan: {
                    forward_scan:
                      if (!(t < t1)) {
                        for (let giveUpAt = i1 + 2; ; ) {
                          if (t1 === void 0) {
                            if (t < t0)
                              break forward_scan;
                            return i1 = pp.length, this._cachedIndex = i1, this.copySampleValue_(i1 - 1);
                          }
                          if (i1 === giveUpAt)
                            break;
                          if (t0 = t1, t1 = pp[++i1], t < t1)
                            break seek;
                        }
                        right = pp.length;
                        break linear_scan;
                      }
                    if (!(t >= t0)) {
                      let t1global = pp[1];
                      t < t1global && (i1 = 2, t0 = t1global);
                      for (let giveUpAt = i1 - 2; ; ) {
                        if (t0 === void 0)
                          return this._cachedIndex = 0, this.copySampleValue_(0);
                        if (i1 === giveUpAt)
                          break;
                        if (t1 = t0, t0 = pp[--i1 - 1], t >= t0)
                          break seek;
                      }
                      right = i1, i1 = 0;
                      break linear_scan;
                    }
                    break validate_interval;
                  }
                  for (; i1 < right; ) {
                    let mid = i1 + right >>> 1;
                    t < pp[mid] ? right = mid : i1 = mid + 1;
                  }
                  if (t1 = pp[i1], t0 = pp[i1 - 1], t0 === void 0)
                    return this._cachedIndex = 0, this.copySampleValue_(0);
                  if (t1 === void 0)
                    return i1 = pp.length, this._cachedIndex = i1, this.copySampleValue_(i1 - 1);
                }
                this._cachedIndex = i1, this.intervalChanged_(i1, t0, t1);
              }
              return this.interpolate_(i1, t0, t, t1);
            }
            getSettings_() {
              return this.settings || this.DefaultSettings_;
            }
            copySampleValue_(index) {
              let result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
              for (let i = 0; i !== stride; ++i)
                result[i] = values[offset + i];
              return result;
            }
            interpolate_() {
              throw new Error("call to abstract method");
            }
            intervalChanged_() {
            }
          }
          class CubicInterpolant extends Interpolant {
            constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
              super(parameterPositions, sampleValues, sampleSize, resultBuffer);
              this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding };
            }
            intervalChanged_(i1, t0, t1) {
              let pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
              if (tPrev === void 0)
                switch (this.getSettings_().endingStart) {
                  case ZeroSlopeEnding:
                    iPrev = i1, tPrev = 2 * t0 - t1;
                    break;
                  case WrapAroundEnding:
                    iPrev = pp.length - 2, tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                    break;
                  default:
                    iPrev = i1, tPrev = t1;
                }
              if (tNext === void 0)
                switch (this.getSettings_().endingEnd) {
                  case ZeroSlopeEnding:
                    iNext = i1, tNext = 2 * t1 - t0;
                    break;
                  case WrapAroundEnding:
                    iNext = 1, tNext = t1 + pp[1] - pp[0];
                    break;
                  default:
                    iNext = i1 - 1, tNext = t0;
                }
              let halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
              this._weightPrev = halfDt / (t0 - tPrev), this._weightNext = halfDt / (tNext - t1), this._offsetPrev = iPrev * stride, this._offsetNext = iNext * stride;
            }
            interpolate_(i1, t0, t, t1) {
              let result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p, sP = -wP * ppp + 2 * wP * pp - wP * p, s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1, s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p, sN = wN * ppp - wN * pp;
              for (let i = 0; i !== stride; ++i)
                result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
              return result;
            }
          }
          class LinearInterpolant extends Interpolant {
            constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
              super(parameterPositions, sampleValues, sampleSize, resultBuffer);
            }
            interpolate_(i1, t0, t, t1) {
              let result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
              for (let i = 0; i !== stride; ++i)
                result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
              return result;
            }
          }
          class DiscreteInterpolant extends Interpolant {
            constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
              super(parameterPositions, sampleValues, sampleSize, resultBuffer);
            }
            interpolate_(i1) {
              return this.copySampleValue_(i1 - 1);
            }
          }
          class KeyframeTrack {
            constructor(name, times, values, interpolation) {
              if (name === void 0)
                throw new Error("THREE.KeyframeTrack: track name is undefined");
              if (times === void 0 || times.length === 0)
                throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
              this.name = name, this.times = convertArray(times, this.TimeBufferType), this.values = convertArray(values, this.ValueBufferType), this.setInterpolation(interpolation || this.DefaultInterpolation);
            }
            static toJSON(track) {
              let trackType = track.constructor, json;
              if (trackType.toJSON !== this.toJSON)
                json = trackType.toJSON(track);
              else {
                json = { name: track.name, times: convertArray(track.times, Array), values: convertArray(track.values, Array) };
                let interpolation = track.getInterpolation();
                interpolation !== track.DefaultInterpolation && (json.interpolation = interpolation);
              }
              return json.type = track.ValueTypeName, json;
            }
            InterpolantFactoryMethodDiscrete(result) {
              return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
            }
            InterpolantFactoryMethodLinear(result) {
              return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
            }
            InterpolantFactoryMethodSmooth(result) {
              return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
            }
            setInterpolation(interpolation) {
              let factoryMethod;
              switch (interpolation) {
                case InterpolateDiscrete:
                  factoryMethod = this.InterpolantFactoryMethodDiscrete;
                  break;
                case InterpolateLinear:
                  factoryMethod = this.InterpolantFactoryMethodLinear;
                  break;
                case InterpolateSmooth:
                  factoryMethod = this.InterpolantFactoryMethodSmooth;
                  break;
              }
              if (factoryMethod === void 0) {
                let message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === void 0)
                  if (interpolation !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                  else
                    throw new Error(message);
                return console.warn("THREE.KeyframeTrack:", message), this;
              }
              return this.createInterpolant = factoryMethod, this;
            }
            getInterpolation() {
              switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                  return InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                  return InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                  return InterpolateSmooth;
              }
            }
            getValueSize() {
              return this.values.length / this.times.length;
            }
            shift(timeOffset) {
              if (timeOffset !== 0) {
                let times = this.times;
                for (let i = 0, n = times.length; i !== n; ++i)
                  times[i] += timeOffset;
              }
              return this;
            }
            scale(timeScale) {
              if (timeScale !== 1) {
                let times = this.times;
                for (let i = 0, n = times.length; i !== n; ++i)
                  times[i] *= timeScale;
              }
              return this;
            }
            trim(startTime, endTime) {
              let times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
              for (; from !== nKeys && times[from] < startTime; )
                ++from;
              for (; to !== -1 && times[to] > endTime; )
                --to;
              if (++to, from !== 0 || to !== nKeys) {
                from >= to && (to = Math.max(to, 1), from = to - 1);
                let stride = this.getValueSize();
                this.times = times.slice(from, to), this.values = this.values.slice(from * stride, to * stride);
              }
              return this;
            }
            validate() {
              let valid = !0, valueSize = this.getValueSize();
              valueSize - Math.floor(valueSize) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), valid = !1);
              let times = this.times, values = this.values, nKeys = times.length;
              nKeys === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), valid = !1);
              let prevTime = null;
              for (let i = 0; i !== nKeys; i++) {
                let currTime = times[i];
                if (typeof currTime == "number" && isNaN(currTime)) {
                  console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime), valid = !1;
                  break;
                }
                if (prevTime !== null && prevTime > currTime) {
                  console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime), valid = !1;
                  break;
                }
                prevTime = currTime;
              }
              if (values !== void 0 && isTypedArray(values))
                for (let i = 0, n = values.length; i !== n; ++i) {
                  let value = values[i];
                  if (isNaN(value)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value), valid = !1;
                    break;
                  }
                }
              return valid;
            }
            optimize() {
              let times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1, writeIndex = 1;
              for (let i = 1; i < lastIndex; ++i) {
                let keep = !1, time = times[i], timeNext = times[i + 1];
                if (time !== timeNext && (i !== 1 || time !== times[0]))
                  if (smoothInterpolation)
                    keep = !0;
                  else {
                    let offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for (let j = 0; j !== stride; ++j) {
                      let value = values[offset + j];
                      if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                        keep = !0;
                        break;
                      }
                    }
                  }
                if (keep) {
                  if (i !== writeIndex) {
                    times[writeIndex] = times[i];
                    let readOffset = i * stride, writeOffset = writeIndex * stride;
                    for (let j = 0; j !== stride; ++j)
                      values[writeOffset + j] = values[readOffset + j];
                  }
                  ++writeIndex;
                }
              }
              if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j)
                  values[writeOffset + j] = values[readOffset + j];
                ++writeIndex;
              }
              return writeIndex !== times.length ? (this.times = times.slice(0, writeIndex), this.values = values.slice(0, writeIndex * stride)) : (this.times = times, this.values = values), this;
            }
            clone() {
              let times = this.times.slice(), values = this.values.slice(), TypedKeyframeTrack = this.constructor, track = new TypedKeyframeTrack(this.name, times, values);
              return track.createInterpolant = this.createInterpolant, track;
            }
          }
          KeyframeTrack.prototype.TimeBufferType = Float32Array, KeyframeTrack.prototype.ValueBufferType = Float32Array, KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
          class BooleanKeyframeTrack extends KeyframeTrack {
          }
          BooleanKeyframeTrack.prototype.ValueTypeName = "bool", BooleanKeyframeTrack.prototype.ValueBufferType = Array, BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
          class ColorKeyframeTrack extends KeyframeTrack {
          }
          ColorKeyframeTrack.prototype.ValueTypeName = "color";
          class NumberKeyframeTrack extends KeyframeTrack {
          }
          NumberKeyframeTrack.prototype.ValueTypeName = "number";
          class QuaternionLinearInterpolant extends Interpolant {
            constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
              super(parameterPositions, sampleValues, sampleSize, resultBuffer);
            }
            interpolate_(i1, t0, t, t1) {
              let result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0), offset = i1 * stride;
              for (let end = offset + stride; offset !== end; offset += 4)
                Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
              return result;
            }
          }
          class QuaternionKeyframeTrack extends KeyframeTrack {
            InterpolantFactoryMethodLinear(result) {
              return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
            }
          }
          QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion", QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear, QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
          class StringKeyframeTrack extends KeyframeTrack {
          }
          StringKeyframeTrack.prototype.ValueTypeName = "string", StringKeyframeTrack.prototype.ValueBufferType = Array, StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete, StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
          class VectorKeyframeTrack extends KeyframeTrack {
          }
          VectorKeyframeTrack.prototype.ValueTypeName = "vector";
          class AnimationClip {
            constructor(name = "", duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {
              this.name = name, this.tracks = tracks, this.duration = duration, this.blendMode = blendMode, this.uuid = generateUUID(), this.duration < 0 && this.resetDuration();
            }
            static parse(json) {
              let tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
              for (let i = 0, n = jsonTracks.length; i !== n; ++i)
                tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
              let clip = new this(json.name, json.duration, tracks, json.blendMode);
              return clip.uuid = json.uuid, clip;
            }
            static toJSON(clip) {
              let tracks = [], clipTracks = clip.tracks, json = { name: clip.name, duration: clip.duration, tracks, uuid: clip.uuid, blendMode: clip.blendMode };
              for (let i = 0, n = clipTracks.length; i !== n; ++i)
                tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
              return json;
            }
            static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
              let numMorphTargets = morphTargetSequence.length, tracks = [];
              for (let i = 0; i < numMorphTargets; i++) {
                let times = [], values = [];
                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets), values.push(0, 1, 0);
                let order = getKeyframeOrder(times);
                times = sortedArray(times, 1, order), values = sortedArray(values, 1, order), !noLoop && times[0] === 0 && (times.push(numMorphTargets), values.push(values[0])), tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
              }
              return new this(name, -1, tracks);
            }
            static findByName(objectOrClipArray, name) {
              let clipArray = objectOrClipArray;
              if (!Array.isArray(objectOrClipArray)) {
                let o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
              }
              for (let i = 0; i < clipArray.length; i++)
                if (clipArray[i].name === name)
                  return clipArray[i];
              return null;
            }
            static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
              let animationToMorphTargets = {}, pattern = /^([\w-]*?)([\d]+)$/;
              for (let i = 0, il = morphTargets.length; i < il; i++) {
                let morphTarget = morphTargets[i], parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                  let name = parts[1], animationMorphTargets = animationToMorphTargets[name];
                  animationMorphTargets || (animationToMorphTargets[name] = animationMorphTargets = []), animationMorphTargets.push(morphTarget);
                }
              }
              let clips = [];
              for (let name in animationToMorphTargets)
                clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
              return clips;
            }
            static parseAnimation(animation, bones) {
              if (!animation)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
              let addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
                if (animationKeys.length !== 0) {
                  let times = [], values = [];
                  flattenJSON(animationKeys, times, values, propertyName), times.length !== 0 && destTracks.push(new trackType(trackName, times, values));
                }
              }, tracks = [], clipName = animation.name || "default", fps = animation.fps || 30, blendMode = animation.blendMode, duration = animation.length || -1, hierarchyTracks = animation.hierarchy || [];
              for (let h = 0; h < hierarchyTracks.length; h++) {
                let animationKeys = hierarchyTracks[h].keys;
                if (!(!animationKeys || animationKeys.length === 0))
                  if (animationKeys[0].morphTargets) {
                    let morphTargetNames = {}, k;
                    for (k = 0; k < animationKeys.length; k++)
                      if (animationKeys[k].morphTargets)
                        for (let m = 0; m < animationKeys[k].morphTargets.length; m++)
                          morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                    for (let morphTargetName in morphTargetNames) {
                      let times = [], values = [];
                      for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                        let animationKey = animationKeys[k];
                        times.push(animationKey.time), values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                      }
                      tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
                    }
                    duration = morphTargetNames.length * fps;
                  } else {
                    let boneName = ".bones[" + bones[h].name + "]";
                    addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks), addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks), addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
                  }
              }
              return tracks.length === 0 ? null : new this(clipName, duration, tracks, blendMode);
            }
            resetDuration() {
              let tracks = this.tracks, duration = 0;
              for (let i = 0, n = tracks.length; i !== n; ++i) {
                let track = this.tracks[i];
                duration = Math.max(duration, track.times[track.times.length - 1]);
              }
              return this.duration = duration, this;
            }
            trim() {
              for (let i = 0; i < this.tracks.length; i++)
                this.tracks[i].trim(0, this.duration);
              return this;
            }
            validate() {
              let valid = !0;
              for (let i = 0; i < this.tracks.length; i++)
                valid = valid && this.tracks[i].validate();
              return valid;
            }
            optimize() {
              for (let i = 0; i < this.tracks.length; i++)
                this.tracks[i].optimize();
              return this;
            }
            clone() {
              let tracks = [];
              for (let i = 0; i < this.tracks.length; i++)
                tracks.push(this.tracks[i].clone());
              return new this.constructor(this.name, this.duration, tracks, this.blendMode);
            }
            toJSON() {
              return this.constructor.toJSON(this);
            }
          }
          function getTrackTypeForValueTypeName(typeName) {
            switch (typeName.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return NumberKeyframeTrack;
              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return VectorKeyframeTrack;
              case "color":
                return ColorKeyframeTrack;
              case "quaternion":
                return QuaternionKeyframeTrack;
              case "bool":
              case "boolean":
                return BooleanKeyframeTrack;
              case "string":
                return StringKeyframeTrack;
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
          }
          function parseKeyframeTrack(json) {
            if (json.type === void 0)
              throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            let trackType = getTrackTypeForValueTypeName(json.type);
            if (json.times === void 0) {
              let times = [], values = [];
              flattenJSON(json.keys, times, values, "value"), json.times = times, json.values = values;
            }
            return trackType.parse !== void 0 ? trackType.parse(json) : new trackType(json.name, json.times, json.values, json.interpolation);
          }
          let Cache = { enabled: !1, files: {}, add: function(key, file) {
            this.enabled !== !1 && (this.files[key] = file);
          }, get: function(key) {
            if (this.enabled !== !1)
              return this.files[key];
          }, remove: function(key) {
            delete this.files[key];
          }, clear: function() {
            this.files = {};
          } };
          class LoadingManager {
            constructor(onLoad, onProgress, onError) {
              let scope = this, isLoading = !1, itemsLoaded = 0, itemsTotal = 0, urlModifier, handlers = [];
              this.onStart = void 0, this.onLoad = onLoad, this.onProgress = onProgress, this.onError = onError, this.itemStart = function(url) {
                itemsTotal++, isLoading === !1 && scope.onStart !== void 0 && scope.onStart(url, itemsLoaded, itemsTotal), isLoading = !0;
              }, this.itemEnd = function(url) {
                itemsLoaded++, scope.onProgress !== void 0 && scope.onProgress(url, itemsLoaded, itemsTotal), itemsLoaded === itemsTotal && (isLoading = !1, scope.onLoad !== void 0 && scope.onLoad());
              }, this.itemError = function(url) {
                scope.onError !== void 0 && scope.onError(url);
              }, this.resolveURL = function(url) {
                return urlModifier ? urlModifier(url) : url;
              }, this.setURLModifier = function(transform) {
                return urlModifier = transform, this;
              }, this.addHandler = function(regex, loader) {
                return handlers.push(regex, loader), this;
              }, this.removeHandler = function(regex) {
                let index = handlers.indexOf(regex);
                return index !== -1 && handlers.splice(index, 2), this;
              }, this.getHandler = function(file) {
                for (let i = 0, l = handlers.length; i < l; i += 2) {
                  let regex = handlers[i], loader = handlers[i + 1];
                  if (regex.global && (regex.lastIndex = 0), regex.test(file))
                    return loader;
                }
                return null;
              };
            }
          }
          let DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
          class Loader {
            constructor(manager) {
              this.manager = manager !== void 0 ? manager : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
            }
            load() {
            }
            loadAsync(url, onProgress) {
              let scope = this;
              return new Promise(function(resolve, reject) {
                scope.load(url, resolve, onProgress, reject);
              });
            }
            parse() {
            }
            setCrossOrigin(crossOrigin) {
              return this.crossOrigin = crossOrigin, this;
            }
            setWithCredentials(value) {
              return this.withCredentials = value, this;
            }
            setPath(path) {
              return this.path = path, this;
            }
            setResourcePath(resourcePath) {
              return this.resourcePath = resourcePath, this;
            }
            setRequestHeader(requestHeader) {
              return this.requestHeader = requestHeader, this;
            }
          }
          Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
          let loading = {};
          class HttpError extends Error {
            constructor(message, response) {
              super(message);
              this.response = response;
            }
          }
          class FileLoader extends Loader {
            constructor(manager) {
              super(manager);
            }
            load(url, onLoad, onProgress, onError) {
              url === void 0 && (url = ""), this.path !== void 0 && (url = this.path + url), url = this.manager.resolveURL(url);
              let cached = Cache.get(url);
              if (cached !== void 0)
                return this.manager.itemStart(url), setTimeout(() => {
                  onLoad && onLoad(cached), this.manager.itemEnd(url);
                }, 0), cached;
              if (loading[url] !== void 0) {
                loading[url].push({ onLoad, onProgress, onError });
                return;
              }
              loading[url] = [], loading[url].push({ onLoad, onProgress, onError });
              let req = new Request(url, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
              }), mimeType = this.mimeType, responseType = this.responseType;
              fetch(req).then((response) => {
                if (response.status === 200 || response.status === 0) {
                  if (response.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream == "undefined" || response.body === void 0 || response.body.getReader === void 0)
                    return response;
                  let callbacks = loading[url], reader = response.body.getReader(), contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length"), total = contentLength ? parseInt(contentLength) : 0, lengthComputable = total !== 0, loaded = 0, stream = new ReadableStream({ start(controller) {
                    readData();
                    function readData() {
                      reader.read().then(({ done, value }) => {
                        if (done)
                          controller.close();
                        else {
                          loaded += value.byteLength;
                          let event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                          for (let i = 0, il = callbacks.length; i < il; i++) {
                            let callback = callbacks[i];
                            callback.onProgress && callback.onProgress(event);
                          }
                          controller.enqueue(value), readData();
                        }
                      });
                    }
                  } });
                  return new Response(stream);
                } else
                  throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
              }).then((response) => {
                switch (responseType) {
                  case "arraybuffer":
                    return response.arrayBuffer();
                  case "blob":
                    return response.blob();
                  case "document":
                    return response.text().then((text) => new DOMParser().parseFromString(text, mimeType));
                  case "json":
                    return response.json();
                  default:
                    if (mimeType === void 0)
                      return response.text();
                    {
                      let exec = /charset="?([^;"\s]*)"?/i.exec(mimeType), label = exec && exec[1] ? exec[1].toLowerCase() : void 0, decoder = new TextDecoder(label);
                      return response.arrayBuffer().then((ab) => decoder.decode(ab));
                    }
                }
              }).then((data) => {
                Cache.add(url, data);
                let callbacks = loading[url];
                delete loading[url];
                for (let i = 0, il = callbacks.length; i < il; i++) {
                  let callback = callbacks[i];
                  callback.onLoad && callback.onLoad(data);
                }
              }).catch((err) => {
                let callbacks = loading[url];
                if (callbacks === void 0)
                  throw this.manager.itemError(url), err;
                delete loading[url];
                for (let i = 0, il = callbacks.length; i < il; i++) {
                  let callback = callbacks[i];
                  callback.onError && callback.onError(err);
                }
                this.manager.itemError(url);
              }).finally(() => {
                this.manager.itemEnd(url);
              }), this.manager.itemStart(url);
            }
            setResponseType(value) {
              return this.responseType = value, this;
            }
            setMimeType(value) {
              return this.mimeType = value, this;
            }
          }
          class AnimationLoader extends Loader {
            constructor(manager) {
              super(manager);
            }
            load(url, onLoad, onProgress, onError) {
              let scope = this, loader = new FileLoader(this.manager);
              loader.setPath(this.path), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(this.withCredentials), loader.load(url, function(text) {
                try {
                  onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                  onError ? onError(e) : console.error(e), scope.manager.itemError(url);
                }
              }, onProgress, onError);
            }
            parse(json) {
              let animations = [];
              for (let i = 0; i < json.length; i++) {
                let clip = AnimationClip.parse(json[i]);
                animations.push(clip);
              }
              return animations;
            }
          }
          class CompressedTextureLoader extends Loader {
            constructor(manager) {
              super(manager);
            }
            load(url, onLoad, onProgress, onError) {
              let scope = this, images = [], texture = new CompressedTexture(), loader = new FileLoader(this.manager);
              loader.setPath(this.path), loader.setResponseType("arraybuffer"), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(scope.withCredentials);
              let loaded = 0;
              function loadTexture(i) {
                loader.load(url[i], function(buffer) {
                  let texDatas = scope.parse(buffer, !0);
                  images[i] = { width: texDatas.width, height: texDatas.height, format: texDatas.format, mipmaps: texDatas.mipmaps }, loaded += 1, loaded === 6 && (texDatas.mipmapCount === 1 && (texture.minFilter = LinearFilter), texture.image = images, texture.format = texDatas.format, texture.needsUpdate = !0, onLoad && onLoad(texture));
                }, onProgress, onError);
              }
              if (Array.isArray(url))
                for (let i = 0, il = url.length; i < il; ++i)
                  loadTexture(i);
              else
                loader.load(url, function(buffer) {
                  let texDatas = scope.parse(buffer, !0);
                  if (texDatas.isCubemap) {
                    let faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                    for (let f = 0; f < faces; f++) {
                      images[f] = { mipmaps: [] };
                      for (let i = 0; i < texDatas.mipmapCount; i++)
                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]), images[f].format = texDatas.format, images[f].width = texDatas.width, images[f].height = texDatas.height;
                    }
                    texture.image = images;
                  } else
                    texture.image.width = texDatas.width, texture.image.height = texDatas.height, texture.mipmaps = texDatas.mipmaps;
                  texDatas.mipmapCount === 1 && (texture.minFilter = LinearFilter), texture.format = texDatas.format, texture.needsUpdate = !0, onLoad && onLoad(texture);
                }, onProgress, onError);
              return texture;
            }
          }
          class ImageLoader extends Loader {
            constructor(manager) {
              super(manager);
            }
            load(url, onLoad, onProgress, onError) {
              this.path !== void 0 && (url = this.path + url), url = this.manager.resolveURL(url);
              let scope = this, cached = Cache.get(url);
              if (cached !== void 0)
                return scope.manager.itemStart(url), setTimeout(function() {
                  onLoad && onLoad(cached), scope.manager.itemEnd(url);
                }, 0), cached;
              let image = createElementNS("img");
              function onImageLoad() {
                removeEventListeners(), Cache.add(url, this), onLoad && onLoad(this), scope.manager.itemEnd(url);
              }
              function onImageError(event) {
                removeEventListeners(), onError && onError(event), scope.manager.itemError(url), scope.manager.itemEnd(url);
              }
              function removeEventListeners() {
                image.removeEventListener("load", onImageLoad, !1), image.removeEventListener("error", onImageError, !1);
              }
              return image.addEventListener("load", onImageLoad, !1), image.addEventListener("error", onImageError, !1), url.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (image.crossOrigin = this.crossOrigin), scope.manager.itemStart(url), image.src = url, image;
            }
          }
          class CubeTextureLoader extends Loader {
            constructor(manager) {
              super(manager);
            }
            load(urls, onLoad, onProgress, onError) {
              let texture = new CubeTexture();
              texture.colorSpace = SRGBColorSpace;
              let loader = new ImageLoader(this.manager);
              loader.setCrossOrigin(this.crossOrigin), loader.setPath(this.path);
              let loaded = 0;
              function loadTexture(i) {
                loader.load(urls[i], function(image) {
                  texture.images[i] = image, loaded++, loaded === 6 && (texture.needsUpdate = !0, onLoad && onLoad(texture));
                }, void 0, onError);
              }
              for (let i = 0; i < urls.length; ++i)
                loadTexture(i);
              return texture;
            }
          }
          class DataTextureLoader extends Loader {
            constructor(manager) {
              super(manager);
            }
            load(url, onLoad, onProgress, onError) {
              let scope = this, texture = new DataTexture(), loader = new FileLoader(this.manager);
              return loader.setResponseType("arraybuffer"), loader.setRequestHeader(this.requestHeader), loader.setPath(this.path), loader.setWithCredentials(scope.withCredentials), loader.load(url, function(buffer) {
                let texData;
                try {
                  texData = scope.parse(buffer);
                } catch (error) {
                  if (onError !== void 0)
                    onError(error);
                  else {
                    console.error(error);
                    return;
                  }
                }
                texData.image !== void 0 ? texture.image = texData.image : texData.data !== void 0 && (texture.image.width = texData.width, texture.image.height = texData.height, texture.image.data = texData.data), texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping, texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping, texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter, texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter, texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1, texData.colorSpace !== void 0 && (texture.colorSpace = texData.colorSpace), texData.flipY !== void 0 && (texture.flipY = texData.flipY), texData.format !== void 0 && (texture.format = texData.format), texData.type !== void 0 && (texture.type = texData.type), texData.mipmaps !== void 0 && (texture.mipmaps = texData.mipmaps, texture.minFilter = LinearMipmapLinearFilter), texData.mipmapCount === 1 && (texture.minFilter = LinearFilter), texData.generateMipmaps !== void 0 && (texture.generateMipmaps = texData.generateMipmaps), texture.needsUpdate = !0, onLoad && onLoad(texture, texData);
              }, onProgress, onError), texture;
            }
          }
          class TextureLoader extends Loader {
            constructor(manager) {
              super(manager);
            }
            load(url, onLoad, onProgress, onError) {
              let texture = new Texture(), loader = new ImageLoader(this.manager);
              return loader.setCrossOrigin(this.crossOrigin), loader.setPath(this.path), loader.load(url, function(image) {
                texture.image = image, texture.needsUpdate = !0, onLoad !== void 0 && onLoad(texture);
              }, onProgress, onError), texture;
            }
          }
          class Light extends Object3D {
            constructor(color, intensity = 1) {
              super();
              this.isLight = !0, this.type = "Light", this.color = new Color(color), this.intensity = intensity;
            }
            dispose() {
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.color.copy(source.color), this.intensity = source.intensity, this;
            }
            toJSON(meta) {
              let data = super.toJSON(meta);
              return data.object.color = this.color.getHex(), data.object.intensity = this.intensity, this.groundColor !== void 0 && (data.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (data.object.distance = this.distance), this.angle !== void 0 && (data.object.angle = this.angle), this.decay !== void 0 && (data.object.decay = this.decay), this.penumbra !== void 0 && (data.object.penumbra = this.penumbra), this.shadow !== void 0 && (data.object.shadow = this.shadow.toJSON()), data;
            }
          }
          class HemisphereLight extends Light {
            constructor(skyColor, groundColor, intensity) {
              super(skyColor, intensity);
              this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Color(groundColor);
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.groundColor.copy(source.groundColor), this;
            }
          }
          let _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4(), _lightPositionWorld$1 = /* @__PURE__ */ new Vector3(), _lookTarget$1 = /* @__PURE__ */ new Vector3();
          class LightShadow {
            constructor(camera) {
              this.camera = camera, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Frustum(), this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)];
            }
            getViewportCount() {
              return this._viewportCount;
            }
            getFrustum() {
              return this._frustum;
            }
            updateMatrices(light) {
              let shadowCamera = this.camera, shadowMatrix = this.matrix;
              _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld), shadowCamera.position.copy(_lightPositionWorld$1), _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld), shadowCamera.lookAt(_lookTarget$1), shadowCamera.updateMatrixWorld(), _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1), shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), shadowMatrix.multiply(_projScreenMatrix$1);
            }
            getViewport(viewportIndex) {
              return this._viewports[viewportIndex];
            }
            getFrameExtents() {
              return this._frameExtents;
            }
            dispose() {
              this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
            }
            copy(source) {
              return this.camera = source.camera.clone(), this.bias = source.bias, this.radius = source.radius, this.mapSize.copy(source.mapSize), this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            toJSON() {
              let object = {};
              return this.bias !== 0 && (object.bias = this.bias), this.normalBias !== 0 && (object.normalBias = this.normalBias), this.radius !== 1 && (object.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (object.mapSize = this.mapSize.toArray()), object.camera = this.camera.toJSON(!1).object, delete object.camera.matrix, object;
            }
          }
          class SpotLightShadow extends LightShadow {
            constructor() {
              super(new PerspectiveCamera(50, 1, 0.5, 500));
              this.isSpotLightShadow = !0, this.focus = 1;
            }
            updateMatrices(light) {
              let camera = this.camera, fov2 = RAD2DEG * 2 * light.angle * this.focus, aspect2 = this.mapSize.width / this.mapSize.height, far = light.distance || camera.far;
              (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) && (camera.fov = fov2, camera.aspect = aspect2, camera.far = far, camera.updateProjectionMatrix()), super.updateMatrices(light);
            }
            copy(source) {
              return super.copy(source), this.focus = source.focus, this;
            }
          }
          class SpotLight extends Light {
            constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
              super(color, intensity);
              this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D(), this.distance = distance, this.angle = angle, this.penumbra = penumbra, this.decay = decay, this.map = null, this.shadow = new SpotLightShadow();
            }
            get power() {
              return this.intensity * Math.PI;
            }
            set power(power) {
              this.intensity = power / Math.PI;
            }
            dispose() {
              this.shadow.dispose();
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.distance = source.distance, this.angle = source.angle, this.penumbra = source.penumbra, this.decay = source.decay, this.target = source.target.clone(), this.shadow = source.shadow.clone(), this;
            }
          }
          let _projScreenMatrix = /* @__PURE__ */ new Matrix4(), _lightPositionWorld = /* @__PURE__ */ new Vector3(), _lookTarget = /* @__PURE__ */ new Vector3();
          class PointLightShadow extends LightShadow {
            constructor() {
              super(new PerspectiveCamera(90, 1, 0.5, 500));
              this.isPointLightShadow = !0, this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [
                new Vector4(2, 1, 1, 1),
                new Vector4(0, 1, 1, 1),
                new Vector4(3, 1, 1, 1),
                new Vector4(1, 1, 1, 1),
                new Vector4(3, 0, 1, 1),
                new Vector4(1, 0, 1, 1)
              ], this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)], this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
            }
            updateMatrices(light, viewportIndex = 0) {
              let camera = this.camera, shadowMatrix = this.matrix, far = light.distance || camera.far;
              far !== camera.far && (camera.far = far, camera.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(light.matrixWorld), camera.position.copy(_lightPositionWorld), _lookTarget.copy(camera.position), _lookTarget.add(this._cubeDirections[viewportIndex]), camera.up.copy(this._cubeUps[viewportIndex]), camera.lookAt(_lookTarget), camera.updateMatrixWorld(), shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z), _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix);
            }
          }
          class PointLight extends Light {
            constructor(color, intensity, distance = 0, decay = 2) {
              super(color, intensity);
              this.isPointLight = !0, this.type = "PointLight", this.distance = distance, this.decay = decay, this.shadow = new PointLightShadow();
            }
            get power() {
              return this.intensity * 4 * Math.PI;
            }
            set power(power) {
              this.intensity = power / (4 * Math.PI);
            }
            dispose() {
              this.shadow.dispose();
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.distance = source.distance, this.decay = source.decay, this.shadow = source.shadow.clone(), this;
            }
          }
          class DirectionalLightShadow extends LightShadow {
            constructor() {
              super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
              this.isDirectionalLightShadow = !0;
            }
          }
          class DirectionalLight extends Light {
            constructor(color, intensity) {
              super(color, intensity);
              this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D(), this.shadow = new DirectionalLightShadow();
            }
            dispose() {
              this.shadow.dispose();
            }
            copy(source) {
              return super.copy(source), this.target = source.target.clone(), this.shadow = source.shadow.clone(), this;
            }
          }
          class AmbientLight extends Light {
            constructor(color, intensity) {
              super(color, intensity);
              this.isAmbientLight = !0, this.type = "AmbientLight";
            }
          }
          class RectAreaLight extends Light {
            constructor(color, intensity, width = 10, height = 10) {
              super(color, intensity);
              this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = width, this.height = height;
            }
            get power() {
              return this.intensity * this.width * this.height * Math.PI;
            }
            set power(power) {
              this.intensity = power / (this.width * this.height * Math.PI);
            }
            copy(source) {
              return super.copy(source), this.width = source.width, this.height = source.height, this;
            }
            toJSON(meta) {
              let data = super.toJSON(meta);
              return data.object.width = this.width, data.object.height = this.height, data;
            }
          }
          class SphericalHarmonics3 {
            constructor() {
              this.isSphericalHarmonics3 = !0, this.coefficients = [];
              for (let i = 0; i < 9; i++)
                this.coefficients.push(new Vector3());
            }
            set(coefficients) {
              for (let i = 0; i < 9; i++)
                this.coefficients[i].copy(coefficients[i]);
              return this;
            }
            zero() {
              for (let i = 0; i < 9; i++)
                this.coefficients[i].set(0, 0, 0);
              return this;
            }
            getAt(normal, target) {
              let x = normal.x, y = normal.y, z = normal.z, coeff = this.coefficients;
              return target.copy(coeff[0]).multiplyScalar(0.282095), target.addScaledVector(coeff[1], 0.488603 * y), target.addScaledVector(coeff[2], 0.488603 * z), target.addScaledVector(coeff[3], 0.488603 * x), target.addScaledVector(coeff[4], 1.092548 * (x * y)), target.addScaledVector(coeff[5], 1.092548 * (y * z)), target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1)), target.addScaledVector(coeff[7], 1.092548 * (x * z)), target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y)), target;
            }
            getIrradianceAt(normal, target) {
              let x = normal.x, y = normal.y, z = normal.z, coeff = this.coefficients;
              return target.copy(coeff[0]).multiplyScalar(0.886227), target.addScaledVector(coeff[1], 2 * 0.511664 * y), target.addScaledVector(coeff[2], 2 * 0.511664 * z), target.addScaledVector(coeff[3], 2 * 0.511664 * x), target.addScaledVector(coeff[4], 2 * 0.429043 * x * y), target.addScaledVector(coeff[5], 2 * 0.429043 * y * z), target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708), target.addScaledVector(coeff[7], 2 * 0.429043 * x * z), target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)), target;
            }
            add(sh) {
              for (let i = 0; i < 9; i++)
                this.coefficients[i].add(sh.coefficients[i]);
              return this;
            }
            addScaledSH(sh, s) {
              for (let i = 0; i < 9; i++)
                this.coefficients[i].addScaledVector(sh.coefficients[i], s);
              return this;
            }
            scale(s) {
              for (let i = 0; i < 9; i++)
                this.coefficients[i].multiplyScalar(s);
              return this;
            }
            lerp(sh, alpha) {
              for (let i = 0; i < 9; i++)
                this.coefficients[i].lerp(sh.coefficients[i], alpha);
              return this;
            }
            equals(sh) {
              for (let i = 0; i < 9; i++)
                if (!this.coefficients[i].equals(sh.coefficients[i]))
                  return !1;
              return !0;
            }
            copy(sh) {
              return this.set(sh.coefficients);
            }
            clone() {
              return new this.constructor().copy(this);
            }
            fromArray(array, offset = 0) {
              let coefficients = this.coefficients;
              for (let i = 0; i < 9; i++)
                coefficients[i].fromArray(array, offset + i * 3);
              return this;
            }
            toArray(array = [], offset = 0) {
              let coefficients = this.coefficients;
              for (let i = 0; i < 9; i++)
                coefficients[i].toArray(array, offset + i * 3);
              return array;
            }
            static getBasisAt(normal, shBasis) {
              let x = normal.x, y = normal.y, z = normal.z;
              shBasis[0] = 0.282095, shBasis[1] = 0.488603 * y, shBasis[2] = 0.488603 * z, shBasis[3] = 0.488603 * x, shBasis[4] = 1.092548 * x * y, shBasis[5] = 1.092548 * y * z, shBasis[6] = 0.315392 * (3 * z * z - 1), shBasis[7] = 1.092548 * x * z, shBasis[8] = 0.546274 * (x * x - y * y);
            }
          }
          class LightProbe extends Light {
            constructor(sh = new SphericalHarmonics3(), intensity = 1) {
              super(void 0, intensity);
              this.isLightProbe = !0, this.sh = sh;
            }
            copy(source) {
              return super.copy(source), this.sh.copy(source.sh), this;
            }
            fromJSON(json) {
              return this.intensity = json.intensity, this.sh.fromArray(json.sh), this;
            }
            toJSON(meta) {
              let data = super.toJSON(meta);
              return data.object.sh = this.sh.toArray(), data;
            }
          }
          class MaterialLoader extends Loader {
            constructor(manager) {
              super(manager);
              this.textures = {};
            }
            load(url, onLoad, onProgress, onError) {
              let scope = this, loader = new FileLoader(scope.manager);
              loader.setPath(scope.path), loader.setRequestHeader(scope.requestHeader), loader.setWithCredentials(scope.withCredentials), loader.load(url, function(text) {
                try {
                  onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                  onError ? onError(e) : console.error(e), scope.manager.itemError(url);
                }
              }, onProgress, onError);
            }
            parse(json) {
              let textures = this.textures;
              function getTexture(name) {
                return textures[name] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", name), textures[name];
              }
              let material = MaterialLoader.createMaterialFromType(json.type);
              if (json.uuid !== void 0 && (material.uuid = json.uuid), json.name !== void 0 && (material.name = json.name), json.color !== void 0 && material.color !== void 0 && material.color.setHex(json.color), json.roughness !== void 0 && (material.roughness = json.roughness), json.metalness !== void 0 && (material.metalness = json.metalness), json.sheen !== void 0 && (material.sheen = json.sheen), json.sheenColor !== void 0 && (material.sheenColor = new Color().setHex(json.sheenColor)), json.sheenRoughness !== void 0 && (material.sheenRoughness = json.sheenRoughness), json.emissive !== void 0 && material.emissive !== void 0 && material.emissive.setHex(json.emissive), json.specular !== void 0 && material.specular !== void 0 && material.specular.setHex(json.specular), json.specularIntensity !== void 0 && (material.specularIntensity = json.specularIntensity), json.specularColor !== void 0 && material.specularColor !== void 0 && material.specularColor.setHex(json.specularColor), json.shininess !== void 0 && (material.shininess = json.shininess), json.clearcoat !== void 0 && (material.clearcoat = json.clearcoat), json.clearcoatRoughness !== void 0 && (material.clearcoatRoughness = json.clearcoatRoughness), json.dispersion !== void 0 && (material.dispersion = json.dispersion), json.iridescence !== void 0 && (material.iridescence = json.iridescence), json.iridescenceIOR !== void 0 && (material.iridescenceIOR = json.iridescenceIOR), json.iridescenceThicknessRange !== void 0 && (material.iridescenceThicknessRange = json.iridescenceThicknessRange), json.transmission !== void 0 && (material.transmission = json.transmission), json.thickness !== void 0 && (material.thickness = json.thickness), json.attenuationDistance !== void 0 && (material.attenuationDistance = json.attenuationDistance), json.attenuationColor !== void 0 && material.attenuationColor !== void 0 && material.attenuationColor.setHex(json.attenuationColor), json.anisotropy !== void 0 && (material.anisotropy = json.anisotropy), json.anisotropyRotation !== void 0 && (material.anisotropyRotation = json.anisotropyRotation), json.fog !== void 0 && (material.fog = json.fog), json.flatShading !== void 0 && (material.flatShading = json.flatShading), json.blending !== void 0 && (material.blending = json.blending), json.combine !== void 0 && (material.combine = json.combine), json.side !== void 0 && (material.side = json.side), json.shadowSide !== void 0 && (material.shadowSide = json.shadowSide), json.opacity !== void 0 && (material.opacity = json.opacity), json.transparent !== void 0 && (material.transparent = json.transparent), json.alphaTest !== void 0 && (material.alphaTest = json.alphaTest), json.alphaHash !== void 0 && (material.alphaHash = json.alphaHash), json.depthFunc !== void 0 && (material.depthFunc = json.depthFunc), json.depthTest !== void 0 && (material.depthTest = json.depthTest), json.depthWrite !== void 0 && (material.depthWrite = json.depthWrite), json.colorWrite !== void 0 && (material.colorWrite = json.colorWrite), json.blendSrc !== void 0 && (material.blendSrc = json.blendSrc), json.blendDst !== void 0 && (material.blendDst = json.blendDst), json.blendEquation !== void 0 && (material.blendEquation = json.blendEquation), json.blendSrcAlpha !== void 0 && (material.blendSrcAlpha = json.blendSrcAlpha), json.blendDstAlpha !== void 0 && (material.blendDstAlpha = json.blendDstAlpha), json.blendEquationAlpha !== void 0 && (material.blendEquationAlpha = json.blendEquationAlpha), json.blendColor !== void 0 && material.blendColor !== void 0 && material.blendColor.setHex(json.blendColor), json.blendAlpha !== void 0 && (material.blendAlpha = json.blendAlpha), json.stencilWriteMask !== void 0 && (material.stencilWriteMask = json.stencilWriteMask), json.stencilFunc !== void 0 && (material.stencilFunc = json.stencilFunc), json.stencilRef !== void 0 && (material.stencilRef = json.stencilRef), json.stencilFuncMask !== void 0 && (material.stencilFuncMask = json.stencilFuncMask), json.stencilFail !== void 0 && (material.stencilFail = json.stencilFail), json.stencilZFail !== void 0 && (material.stencilZFail = json.stencilZFail), json.stencilZPass !== void 0 && (material.stencilZPass = json.stencilZPass), json.stencilWrite !== void 0 && (material.stencilWrite = json.stencilWrite), json.wireframe !== void 0 && (material.wireframe = json.wireframe), json.wireframeLinewidth !== void 0 && (material.wireframeLinewidth = json.wireframeLinewidth), json.wireframeLinecap !== void 0 && (material.wireframeLinecap = json.wireframeLinecap), json.wireframeLinejoin !== void 0 && (material.wireframeLinejoin = json.wireframeLinejoin), json.rotation !== void 0 && (material.rotation = json.rotation), json.linewidth !== void 0 && (material.linewidth = json.linewidth), json.dashSize !== void 0 && (material.dashSize = json.dashSize), json.gapSize !== void 0 && (material.gapSize = json.gapSize), json.scale !== void 0 && (material.scale = json.scale), json.polygonOffset !== void 0 && (material.polygonOffset = json.polygonOffset), json.polygonOffsetFactor !== void 0 && (material.polygonOffsetFactor = json.polygonOffsetFactor), json.polygonOffsetUnits !== void 0 && (material.polygonOffsetUnits = json.polygonOffsetUnits), json.dithering !== void 0 && (material.dithering = json.dithering), json.alphaToCoverage !== void 0 && (material.alphaToCoverage = json.alphaToCoverage), json.premultipliedAlpha !== void 0 && (material.premultipliedAlpha = json.premultipliedAlpha), json.forceSinglePass !== void 0 && (material.forceSinglePass = json.forceSinglePass), json.visible !== void 0 && (material.visible = json.visible), json.toneMapped !== void 0 && (material.toneMapped = json.toneMapped), json.userData !== void 0 && (material.userData = json.userData), json.vertexColors !== void 0 && (typeof json.vertexColors == "number" ? material.vertexColors = json.vertexColors > 0 : material.vertexColors = json.vertexColors), json.uniforms !== void 0)
                for (let name in json.uniforms) {
                  let uniform = json.uniforms[name];
                  switch (material.uniforms[name] = {}, uniform.type) {
                    case "t":
                      material.uniforms[name].value = getTexture(uniform.value);
                      break;
                    case "c":
                      material.uniforms[name].value = new Color().setHex(uniform.value);
                      break;
                    case "v2":
                      material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                      break;
                    case "v3":
                      material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                      break;
                    case "v4":
                      material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                      break;
                    case "m3":
                      material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                      break;
                    case "m4":
                      material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                      break;
                    default:
                      material.uniforms[name].value = uniform.value;
                  }
                }
              if (json.defines !== void 0 && (material.defines = json.defines), json.vertexShader !== void 0 && (material.vertexShader = json.vertexShader), json.fragmentShader !== void 0 && (material.fragmentShader = json.fragmentShader), json.glslVersion !== void 0 && (material.glslVersion = json.glslVersion), json.extensions !== void 0)
                for (let key in json.extensions)
                  material.extensions[key] = json.extensions[key];
              if (json.lights !== void 0 && (material.lights = json.lights), json.clipping !== void 0 && (material.clipping = json.clipping), json.size !== void 0 && (material.size = json.size), json.sizeAttenuation !== void 0 && (material.sizeAttenuation = json.sizeAttenuation), json.map !== void 0 && (material.map = getTexture(json.map)), json.matcap !== void 0 && (material.matcap = getTexture(json.matcap)), json.alphaMap !== void 0 && (material.alphaMap = getTexture(json.alphaMap)), json.bumpMap !== void 0 && (material.bumpMap = getTexture(json.bumpMap)), json.bumpScale !== void 0 && (material.bumpScale = json.bumpScale), json.normalMap !== void 0 && (material.normalMap = getTexture(json.normalMap)), json.normalMapType !== void 0 && (material.normalMapType = json.normalMapType), json.normalScale !== void 0) {
                let normalScale = json.normalScale;
                Array.isArray(normalScale) === !1 && (normalScale = [normalScale, normalScale]), material.normalScale = new Vector2().fromArray(normalScale);
              }
              return json.displacementMap !== void 0 && (material.displacementMap = getTexture(json.displacementMap)), json.displacementScale !== void 0 && (material.displacementScale = json.displacementScale), json.displacementBias !== void 0 && (material.displacementBias = json.displacementBias), json.roughnessMap !== void 0 && (material.roughnessMap = getTexture(json.roughnessMap)), json.metalnessMap !== void 0 && (material.metalnessMap = getTexture(json.metalnessMap)), json.emissiveMap !== void 0 && (material.emissiveMap = getTexture(json.emissiveMap)), json.emissiveIntensity !== void 0 && (material.emissiveIntensity = json.emissiveIntensity), json.specularMap !== void 0 && (material.specularMap = getTexture(json.specularMap)), json.specularIntensityMap !== void 0 && (material.specularIntensityMap = getTexture(json.specularIntensityMap)), json.specularColorMap !== void 0 && (material.specularColorMap = getTexture(json.specularColorMap)), json.envMap !== void 0 && (material.envMap = getTexture(json.envMap)), json.envMapRotation !== void 0 && material.envMapRotation.fromArray(json.envMapRotation), json.envMapIntensity !== void 0 && (material.envMapIntensity = json.envMapIntensity), json.reflectivity !== void 0 && (material.reflectivity = json.reflectivity), json.refractionRatio !== void 0 && (material.refractionRatio = json.refractionRatio), json.lightMap !== void 0 && (material.lightMap = getTexture(json.lightMap)), json.lightMapIntensity !== void 0 && (material.lightMapIntensity = json.lightMapIntensity), json.aoMap !== void 0 && (material.aoMap = getTexture(json.aoMap)), json.aoMapIntensity !== void 0 && (material.aoMapIntensity = json.aoMapIntensity), json.gradientMap !== void 0 && (material.gradientMap = getTexture(json.gradientMap)), json.clearcoatMap !== void 0 && (material.clearcoatMap = getTexture(json.clearcoatMap)), json.clearcoatRoughnessMap !== void 0 && (material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap)), json.clearcoatNormalMap !== void 0 && (material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap)), json.clearcoatNormalScale !== void 0 && (material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale)), json.iridescenceMap !== void 0 && (material.iridescenceMap = getTexture(json.iridescenceMap)), json.iridescenceThicknessMap !== void 0 && (material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap)), json.transmissionMap !== void 0 && (material.transmissionMap = getTexture(json.transmissionMap)), json.thicknessMap !== void 0 && (material.thicknessMap = getTexture(json.thicknessMap)), json.anisotropyMap !== void 0 && (material.anisotropyMap = getTexture(json.anisotropyMap)), json.sheenColorMap !== void 0 && (material.sheenColorMap = getTexture(json.sheenColorMap)), json.sheenRoughnessMap !== void 0 && (material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap)), material;
            }
            setTextures(value) {
              return this.textures = value, this;
            }
            static createMaterialFromType(type) {
              let materialLib = { ShadowMaterial, SpriteMaterial, RawShaderMaterial, ShaderMaterial, PointsMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshPhongMaterial, MeshToonMaterial, MeshNormalMaterial, MeshLambertMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshBasicMaterial, MeshMatcapMaterial, LineDashedMaterial, LineBasicMaterial, Material };
              return new materialLib[type]();
            }
          }
          class LoaderUtils {
            static decodeText(array) {
              if (typeof TextDecoder != "undefined")
                return new TextDecoder().decode(array);
              let s = "";
              for (let i = 0, il = array.length; i < il; i++)
                s += String.fromCharCode(array[i]);
              try {
                return decodeURIComponent(escape(s));
              } catch (e) {
                return s;
              }
            }
            static extractUrlBase(url) {
              let index = url.lastIndexOf("/");
              return index === -1 ? "./" : url.slice(0, index + 1);
            }
            static resolveURL(url, path) {
              return typeof url != "string" || url === "" ? "" : (/^https?:\/\//i.test(path) && /^\//.test(url) && (path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(url) || /^data:.*,.*$/i.test(url) || /^blob:.*$/i.test(url) ? url : path + url);
            }
          }
          class InstancedBufferGeometry extends BufferGeometry {
            constructor() {
              super();
              this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
            }
            copy(source) {
              return super.copy(source), this.instanceCount = source.instanceCount, this;
            }
            toJSON() {
              let data = super.toJSON();
              return data.instanceCount = this.instanceCount, data.isInstancedBufferGeometry = !0, data;
            }
          }
          class BufferGeometryLoader extends Loader {
            constructor(manager) {
              super(manager);
            }
            load(url, onLoad, onProgress, onError) {
              let scope = this, loader = new FileLoader(scope.manager);
              loader.setPath(scope.path), loader.setRequestHeader(scope.requestHeader), loader.setWithCredentials(scope.withCredentials), loader.load(url, function(text) {
                try {
                  onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                  onError ? onError(e) : console.error(e), scope.manager.itemError(url);
                }
              }, onProgress, onError);
            }
            parse(json) {
              let interleavedBufferMap = {}, arrayBufferMap = {};
              function getInterleavedBuffer(json2, uuid) {
                if (interleavedBufferMap[uuid] !== void 0)
                  return interleavedBufferMap[uuid];
                let interleavedBuffer = json2.interleavedBuffers[uuid], buffer = getArrayBuffer(json2, interleavedBuffer.buffer), array = getTypedArray(interleavedBuffer.type, buffer), ib = new InterleavedBuffer(array, interleavedBuffer.stride);
                return ib.uuid = interleavedBuffer.uuid, interleavedBufferMap[uuid] = ib, ib;
              }
              function getArrayBuffer(json2, uuid) {
                if (arrayBufferMap[uuid] !== void 0)
                  return arrayBufferMap[uuid];
                let arrayBuffer = json2.arrayBuffers[uuid], ab = new Uint32Array(arrayBuffer).buffer;
                return arrayBufferMap[uuid] = ab, ab;
              }
              let geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry(), index = json.data.index;
              if (index !== void 0) {
                let typedArray = getTypedArray(index.type, index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
              }
              let attributes = json.data.attributes;
              for (let key in attributes) {
                let attribute = attributes[key], bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                  let interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                  bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                  let typedArray = getTypedArray(attribute.type, attribute.array), bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                  bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
                }
                attribute.name !== void 0 && (bufferAttribute.name = attribute.name), attribute.usage !== void 0 && bufferAttribute.setUsage(attribute.usage), geometry.setAttribute(key, bufferAttribute);
              }
              let morphAttributes = json.data.morphAttributes;
              if (morphAttributes)
                for (let key in morphAttributes) {
                  let attributeArray = morphAttributes[key], array = [];
                  for (let i = 0, il = attributeArray.length; i < il; i++) {
                    let attribute = attributeArray[i], bufferAttribute;
                    if (attribute.isInterleavedBufferAttribute) {
                      let interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                      bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                    } else {
                      let typedArray = getTypedArray(attribute.type, attribute.array);
                      bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                    }
                    attribute.name !== void 0 && (bufferAttribute.name = attribute.name), array.push(bufferAttribute);
                  }
                  geometry.morphAttributes[key] = array;
                }
              json.data.morphTargetsRelative && (geometry.morphTargetsRelative = !0);
              let groups = json.data.groups || json.data.drawcalls || json.data.offsets;
              if (groups !== void 0)
                for (let i = 0, n = groups.length; i !== n; ++i) {
                  let group = groups[i];
                  geometry.addGroup(group.start, group.count, group.materialIndex);
                }
              let boundingSphere = json.data.boundingSphere;
              if (boundingSphere !== void 0) {
                let center = new Vector3();
                boundingSphere.center !== void 0 && center.fromArray(boundingSphere.center), geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
              }
              return json.name && (geometry.name = json.name), json.userData && (geometry.userData = json.userData), geometry;
            }
          }
          class ObjectLoader extends Loader {
            constructor(manager) {
              super(manager);
            }
            load(url, onLoad, onProgress, onError) {
              let scope = this, path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
              this.resourcePath = this.resourcePath || path;
              let loader = new FileLoader(this.manager);
              loader.setPath(this.path), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(this.withCredentials), loader.load(url, function(text) {
                let json = null;
                try {
                  json = JSON.parse(text);
                } catch (error) {
                  onError !== void 0 && onError(error), console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
                  return;
                }
                let metadata = json.metadata;
                if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
                  onError !== void 0 && onError(new Error("THREE.ObjectLoader: Can't load " + url)), console.error("THREE.ObjectLoader: Can't load " + url);
                  return;
                }
                scope.parse(json, onLoad);
              }, onProgress, onError);
            }
            async loadAsync(url, onProgress) {
              let scope = this, path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
              this.resourcePath = this.resourcePath || path;
              let loader = new FileLoader(this.manager);
              loader.setPath(this.path), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(this.withCredentials);
              let text = await loader.loadAsync(url, onProgress), json = JSON.parse(text), metadata = json.metadata;
              if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry")
                throw new Error("THREE.ObjectLoader: Can't load " + url);
              return await scope.parseAsync(json);
            }
            parse(json, onLoad) {
              let animations = this.parseAnimations(json.animations), shapes = this.parseShapes(json.shapes), geometries = this.parseGeometries(json.geometries, shapes), images = this.parseImages(json.images, function() {
                onLoad !== void 0 && onLoad(object);
              }), textures = this.parseTextures(json.textures, images), materials = this.parseMaterials(json.materials, textures), object = this.parseObject(json.object, geometries, materials, textures, animations), skeletons = this.parseSkeletons(json.skeletons, object);
              if (this.bindSkeletons(object, skeletons), onLoad !== void 0) {
                let hasImages = !1;
                for (let uuid in images)
                  if (images[uuid].data instanceof HTMLImageElement) {
                    hasImages = !0;
                    break;
                  }
                hasImages === !1 && onLoad(object);
              }
              return object;
            }
            async parseAsync(json) {
              let animations = this.parseAnimations(json.animations), shapes = this.parseShapes(json.shapes), geometries = this.parseGeometries(json.geometries, shapes), images = await this.parseImagesAsync(json.images), textures = this.parseTextures(json.textures, images), materials = this.parseMaterials(json.materials, textures), object = this.parseObject(json.object, geometries, materials, textures, animations), skeletons = this.parseSkeletons(json.skeletons, object);
              return this.bindSkeletons(object, skeletons), object;
            }
            parseShapes(json) {
              let shapes = {};
              if (json !== void 0)
                for (let i = 0, l = json.length; i < l; i++) {
                  let shape = new Shape().fromJSON(json[i]);
                  shapes[shape.uuid] = shape;
                }
              return shapes;
            }
            parseSkeletons(json, object) {
              let skeletons = {}, bones = {};
              if (object.traverse(function(child) {
                child.isBone && (bones[child.uuid] = child);
              }), json !== void 0)
                for (let i = 0, l = json.length; i < l; i++) {
                  let skeleton = new Skeleton().fromJSON(json[i], bones);
                  skeletons[skeleton.uuid] = skeleton;
                }
              return skeletons;
            }
            parseGeometries(json, shapes) {
              let geometries = {};
              if (json !== void 0) {
                let bufferGeometryLoader = new BufferGeometryLoader();
                for (let i = 0, l = json.length; i < l; i++) {
                  let geometry, data = json[i];
                  switch (data.type) {
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                      geometry = bufferGeometryLoader.parse(data);
                      break;
                    case "Geometry":
                      if ("THREE" in window && "LegacyJSONLoader" in THREE) {
                        var geometryLoader = new THREE.LegacyJSONLoader();
                        geometry = geometryLoader.parse(data, this.resourcePath).geometry;
                      } else
                        console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                      break;
                    default:
                      data.type in Geometries ? geometry = Geometries[data.type].fromJSON(data, shapes) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                  }
                  geometry.uuid = data.uuid, data.name !== void 0 && (geometry.name = data.name), data.userData !== void 0 && (geometry.userData = data.userData), geometries[data.uuid] = geometry;
                }
              }
              return geometries;
            }
            parseMaterials(json, textures) {
              let cache = {}, materials = {};
              if (json !== void 0) {
                let loader = new MaterialLoader();
                loader.setTextures(textures);
                for (let i = 0, l = json.length; i < l; i++) {
                  let data = json[i];
                  cache[data.uuid] === void 0 && (cache[data.uuid] = loader.parse(data)), materials[data.uuid] = cache[data.uuid];
                }
              }
              return materials;
            }
            parseAnimations(json) {
              let animations = {};
              if (json !== void 0)
                for (let i = 0; i < json.length; i++) {
                  let data = json[i], clip = AnimationClip.parse(data);
                  animations[clip.uuid] = clip;
                }
              return animations;
            }
            parseImages(json, onLoad) {
              let scope = this, images = {}, loader;
              function loadImage(url) {
                return scope.manager.itemStart(url), loader.load(url, function() {
                  scope.manager.itemEnd(url);
                }, void 0, function() {
                  scope.manager.itemError(url), scope.manager.itemEnd(url);
                });
              }
              function deserializeImage(image) {
                if (typeof image == "string") {
                  let url = image, path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                  return loadImage(path);
                } else
                  return image.data ? { data: getTypedArray(image.type, image.data), width: image.width, height: image.height } : null;
              }
              if (json !== void 0 && json.length > 0) {
                let manager = new LoadingManager(onLoad);
                loader = new ImageLoader(manager), loader.setCrossOrigin(this.crossOrigin);
                for (let i = 0, il = json.length; i < il; i++) {
                  let image = json[i], url = image.url;
                  if (Array.isArray(url)) {
                    let imageArray = [];
                    for (let j = 0, jl = url.length; j < jl; j++) {
                      let currentUrl = url[j], deserializedImage = deserializeImage(currentUrl);
                      deserializedImage !== null && (deserializedImage instanceof HTMLImageElement ? imageArray.push(deserializedImage) : imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height)));
                    }
                    images[image.uuid] = new Source(imageArray);
                  } else {
                    let deserializedImage = deserializeImage(image.url);
                    images[image.uuid] = new Source(deserializedImage);
                  }
                }
              }
              return images;
            }
            async parseImagesAsync(json) {
              let scope = this, images = {}, loader;
              async function deserializeImage(image) {
                if (typeof image == "string") {
                  let url = image, path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                  return await loader.loadAsync(path);
                } else
                  return image.data ? { data: getTypedArray(image.type, image.data), width: image.width, height: image.height } : null;
              }
              if (json !== void 0 && json.length > 0) {
                loader = new ImageLoader(this.manager), loader.setCrossOrigin(this.crossOrigin);
                for (let i = 0, il = json.length; i < il; i++) {
                  let image = json[i], url = image.url;
                  if (Array.isArray(url)) {
                    let imageArray = [];
                    for (let j = 0, jl = url.length; j < jl; j++) {
                      let currentUrl = url[j], deserializedImage = await deserializeImage(currentUrl);
                      deserializedImage !== null && (deserializedImage instanceof HTMLImageElement ? imageArray.push(deserializedImage) : imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height)));
                    }
                    images[image.uuid] = new Source(imageArray);
                  } else {
                    let deserializedImage = await deserializeImage(image.url);
                    images[image.uuid] = new Source(deserializedImage);
                  }
                }
              }
              return images;
            }
            parseTextures(json, images) {
              function parseConstant(value, type) {
                return typeof value == "number" ? value : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value), type[value]);
              }
              let textures = {};
              if (json !== void 0)
                for (let i = 0, l = json.length; i < l; i++) {
                  let data = json[i];
                  data.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid), images[data.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", data.image);
                  let source = images[data.image], image = source.data, texture;
                  Array.isArray(image) ? (texture = new CubeTexture(), image.length === 6 && (texture.needsUpdate = !0)) : (image && image.data ? texture = new DataTexture() : texture = new Texture(), image && (texture.needsUpdate = !0)), texture.source = source, texture.uuid = data.uuid, data.name !== void 0 && (texture.name = data.name), data.mapping !== void 0 && (texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING)), data.channel !== void 0 && (texture.channel = data.channel), data.offset !== void 0 && texture.offset.fromArray(data.offset), data.repeat !== void 0 && texture.repeat.fromArray(data.repeat), data.center !== void 0 && texture.center.fromArray(data.center), data.rotation !== void 0 && (texture.rotation = data.rotation), data.wrap !== void 0 && (texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING), texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING)), data.format !== void 0 && (texture.format = data.format), data.internalFormat !== void 0 && (texture.internalFormat = data.internalFormat), data.type !== void 0 && (texture.type = data.type), data.colorSpace !== void 0 && (texture.colorSpace = data.colorSpace), data.minFilter !== void 0 && (texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER)), data.magFilter !== void 0 && (texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER)), data.anisotropy !== void 0 && (texture.anisotropy = data.anisotropy), data.flipY !== void 0 && (texture.flipY = data.flipY), data.generateMipmaps !== void 0 && (texture.generateMipmaps = data.generateMipmaps), data.premultiplyAlpha !== void 0 && (texture.premultiplyAlpha = data.premultiplyAlpha), data.unpackAlignment !== void 0 && (texture.unpackAlignment = data.unpackAlignment), data.compareFunction !== void 0 && (texture.compareFunction = data.compareFunction), data.userData !== void 0 && (texture.userData = data.userData), textures[data.uuid] = texture;
                }
              return textures;
            }
            parseObject(data, geometries, materials, textures, animations) {
              let object;
              function getGeometry(name) {
                return geometries[name] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", name), geometries[name];
              }
              function getMaterial(name) {
                if (name !== void 0) {
                  if (Array.isArray(name)) {
                    let array = [];
                    for (let i = 0, l = name.length; i < l; i++) {
                      let uuid = name[i];
                      materials[uuid] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", uuid), array.push(materials[uuid]);
                    }
                    return array;
                  }
                  return materials[name] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", name), materials[name];
                }
              }
              function getTexture(uuid) {
                return textures[uuid] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", uuid), textures[uuid];
              }
              let geometry, material;
              switch (data.type) {
                case "Scene":
                  object = new Scene(), data.background !== void 0 && (Number.isInteger(data.background) ? object.background = new Color(data.background) : object.background = getTexture(data.background)), data.environment !== void 0 && (object.environment = getTexture(data.environment)), data.fog !== void 0 && (data.fog.type === "Fog" ? object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far) : data.fog.type === "FogExp2" && (object.fog = new FogExp2(data.fog.color, data.fog.density)), data.fog.name !== "" && (object.fog.name = data.fog.name)), data.backgroundBlurriness !== void 0 && (object.backgroundBlurriness = data.backgroundBlurriness), data.backgroundIntensity !== void 0 && (object.backgroundIntensity = data.backgroundIntensity), data.backgroundRotation !== void 0 && object.backgroundRotation.fromArray(data.backgroundRotation), data.environmentIntensity !== void 0 && (object.environmentIntensity = data.environmentIntensity), data.environmentRotation !== void 0 && object.environmentRotation.fromArray(data.environmentRotation);
                  break;
                case "PerspectiveCamera":
                  object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far), data.focus !== void 0 && (object.focus = data.focus), data.zoom !== void 0 && (object.zoom = data.zoom), data.filmGauge !== void 0 && (object.filmGauge = data.filmGauge), data.filmOffset !== void 0 && (object.filmOffset = data.filmOffset), data.view !== void 0 && (object.view = Object.assign({}, data.view));
                  break;
                case "OrthographicCamera":
                  object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far), data.zoom !== void 0 && (object.zoom = data.zoom), data.view !== void 0 && (object.view = Object.assign({}, data.view));
                  break;
                case "AmbientLight":
                  object = new AmbientLight(data.color, data.intensity);
                  break;
                case "DirectionalLight":
                  object = new DirectionalLight(data.color, data.intensity);
                  break;
                case "PointLight":
                  object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                  break;
                case "RectAreaLight":
                  object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                  break;
                case "SpotLight":
                  object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                  break;
                case "HemisphereLight":
                  object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                  break;
                case "LightProbe":
                  object = new LightProbe().fromJSON(data);
                  break;
                case "SkinnedMesh":
                  geometry = getGeometry(data.geometry), material = getMaterial(data.material), object = new SkinnedMesh(geometry, material), data.bindMode !== void 0 && (object.bindMode = data.bindMode), data.bindMatrix !== void 0 && object.bindMatrix.fromArray(data.bindMatrix), data.skeleton !== void 0 && (object.skeleton = data.skeleton);
                  break;
                case "Mesh":
                  geometry = getGeometry(data.geometry), material = getMaterial(data.material), object = new Mesh(geometry, material);
                  break;
                case "InstancedMesh":
                  geometry = getGeometry(data.geometry), material = getMaterial(data.material);
                  let count = data.count, instanceMatrix = data.instanceMatrix, instanceColor = data.instanceColor;
                  object = new InstancedMesh(geometry, material, count), object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16), instanceColor !== void 0 && (object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize));
                  break;
                case "BatchedMesh":
                  geometry = getGeometry(data.geometry), material = getMaterial(data.material), object = new BatchedMesh(data.maxGeometryCount, data.maxVertexCount, data.maxIndexCount, material), object.geometry = geometry, object.perObjectFrustumCulled = data.perObjectFrustumCulled, object.sortObjects = data.sortObjects, object._drawRanges = data.drawRanges, object._reservedRanges = data.reservedRanges, object._visibility = data.visibility, object._active = data.active, object._bounds = data.bounds.map((bound) => {
                    let box = new Box3();
                    box.min.fromArray(bound.boxMin), box.max.fromArray(bound.boxMax);
                    let sphere = new Sphere();
                    return sphere.radius = bound.sphereRadius, sphere.center.fromArray(bound.sphereCenter), { boxInitialized: bound.boxInitialized, box, sphereInitialized: bound.sphereInitialized, sphere };
                  }), object._maxGeometryCount = data.maxGeometryCount, object._maxVertexCount = data.maxVertexCount, object._maxIndexCount = data.maxIndexCount, object._geometryInitialized = data.geometryInitialized, object._geometryCount = data.geometryCount, object._matricesTexture = getTexture(data.matricesTexture.uuid);
                  break;
                case "LOD":
                  object = new LOD();
                  break;
                case "Line":
                  object = new Line(getGeometry(data.geometry), getMaterial(data.material));
                  break;
                case "LineLoop":
                  object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                  break;
                case "LineSegments":
                  object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                  break;
                case "PointCloud":
                case "Points":
                  object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                  break;
                case "Sprite":
                  object = new Sprite(getMaterial(data.material));
                  break;
                case "Group":
                  object = new Group();
                  break;
                case "Bone":
                  object = new Bone();
                  break;
                default:
                  object = new Object3D();
              }
              if (object.uuid = data.uuid, data.name !== void 0 && (object.name = data.name), data.matrix !== void 0 ? (object.matrix.fromArray(data.matrix), data.matrixAutoUpdate !== void 0 && (object.matrixAutoUpdate = data.matrixAutoUpdate), object.matrixAutoUpdate && object.matrix.decompose(object.position, object.quaternion, object.scale)) : (data.position !== void 0 && object.position.fromArray(data.position), data.rotation !== void 0 && object.rotation.fromArray(data.rotation), data.quaternion !== void 0 && object.quaternion.fromArray(data.quaternion), data.scale !== void 0 && object.scale.fromArray(data.scale)), data.up !== void 0 && object.up.fromArray(data.up), data.castShadow !== void 0 && (object.castShadow = data.castShadow), data.receiveShadow !== void 0 && (object.receiveShadow = data.receiveShadow), data.shadow && (data.shadow.bias !== void 0 && (object.shadow.bias = data.shadow.bias), data.shadow.normalBias !== void 0 && (object.shadow.normalBias = data.shadow.normalBias), data.shadow.radius !== void 0 && (object.shadow.radius = data.shadow.radius), data.shadow.mapSize !== void 0 && object.shadow.mapSize.fromArray(data.shadow.mapSize), data.shadow.camera !== void 0 && (object.shadow.camera = this.parseObject(data.shadow.camera))), data.visible !== void 0 && (object.visible = data.visible), data.frustumCulled !== void 0 && (object.frustumCulled = data.frustumCulled), data.renderOrder !== void 0 && (object.renderOrder = data.renderOrder), data.userData !== void 0 && (object.userData = data.userData), data.layers !== void 0 && (object.layers.mask = data.layers), data.children !== void 0) {
                let children = data.children;
                for (let i = 0; i < children.length; i++)
                  object.add(this.parseObject(children[i], geometries, materials, textures, animations));
              }
              if (data.animations !== void 0) {
                let objectAnimations = data.animations;
                for (let i = 0; i < objectAnimations.length; i++) {
                  let uuid = objectAnimations[i];
                  object.animations.push(animations[uuid]);
                }
              }
              if (data.type === "LOD") {
                data.autoUpdate !== void 0 && (object.autoUpdate = data.autoUpdate);
                let levels = data.levels;
                for (let l = 0; l < levels.length; l++) {
                  let level = levels[l], child = object.getObjectByProperty("uuid", level.object);
                  child !== void 0 && object.addLevel(child, level.distance, level.hysteresis);
                }
              }
              return object;
            }
            bindSkeletons(object, skeletons) {
              Object.keys(skeletons).length !== 0 && object.traverse(function(child) {
                if (child.isSkinnedMesh === !0 && child.skeleton !== void 0) {
                  let skeleton = skeletons[child.skeleton];
                  skeleton === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton) : child.bind(skeleton, child.bindMatrix);
                }
              });
            }
          }
          let TEXTURE_MAPPING = { UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping }, TEXTURE_WRAPPING = { RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping }, TEXTURE_FILTER = { NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter };
          class ImageBitmapLoader extends Loader {
            constructor(manager) {
              super(manager);
              this.isImageBitmapLoader = !0, typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
            }
            setOptions(options) {
              return this.options = options, this;
            }
            load(url, onLoad, onProgress, onError) {
              url === void 0 && (url = ""), this.path !== void 0 && (url = this.path + url), url = this.manager.resolveURL(url);
              let scope = this, cached = Cache.get(url);
              if (cached !== void 0) {
                if (scope.manager.itemStart(url), cached.then) {
                  cached.then((imageBitmap) => {
                    onLoad && onLoad(imageBitmap), scope.manager.itemEnd(url);
                  }).catch((e) => {
                    onError && onError(e);
                  });
                  return;
                }
                return setTimeout(function() {
                  onLoad && onLoad(cached), scope.manager.itemEnd(url);
                }, 0), cached;
              }
              let fetchOptions = {};
              fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", fetchOptions.headers = this.requestHeader;
              let promise = fetch(url, fetchOptions).then(function(res) {
                return res.blob();
              }).then(function(blob) {
                return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
              }).then(function(imageBitmap) {
                return Cache.add(url, imageBitmap), onLoad && onLoad(imageBitmap), scope.manager.itemEnd(url), imageBitmap;
              }).catch(function(e) {
                onError && onError(e), Cache.remove(url), scope.manager.itemError(url), scope.manager.itemEnd(url);
              });
              Cache.add(url, promise), scope.manager.itemStart(url);
            }
          }
          let _context;
          class AudioContext {
            static getContext() {
              return _context === void 0 && (_context = new (window.AudioContext || window.webkitAudioContext)()), _context;
            }
            static setContext(value) {
              _context = value;
            }
          }
          class AudioLoader extends Loader {
            constructor(manager) {
              super(manager);
            }
            load(url, onLoad, onProgress, onError) {
              let scope = this, loader = new FileLoader(this.manager);
              loader.setResponseType("arraybuffer"), loader.setPath(this.path), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(this.withCredentials), loader.load(url, function(buffer) {
                try {
                  let bufferCopy = buffer.slice(0);
                  AudioContext.getContext().decodeAudioData(bufferCopy, function(audioBuffer) {
                    onLoad(audioBuffer);
                  }).catch(handleError);
                } catch (e) {
                  handleError(e);
                }
              }, onProgress, onError);
              function handleError(e) {
                onError ? onError(e) : console.error(e), scope.manager.itemError(url);
              }
            }
          }
          let _eyeRight = /* @__PURE__ */ new Matrix4(), _eyeLeft = /* @__PURE__ */ new Matrix4(), _projectionMatrix = /* @__PURE__ */ new Matrix4();
          class StereoCamera {
            constructor() {
              this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new PerspectiveCamera(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new PerspectiveCamera(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
            }
            update(camera) {
              let cache = this._cache;
              if (cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep) {
                cache.focus = camera.focus, cache.fov = camera.fov, cache.aspect = camera.aspect * this.aspect, cache.near = camera.near, cache.far = camera.far, cache.zoom = camera.zoom, cache.eyeSep = this.eyeSep, _projectionMatrix.copy(camera.projectionMatrix);
                let eyeSepHalf = cache.eyeSep / 2, eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus, ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom, xmin, xmax;
                _eyeLeft.elements[12] = -eyeSepHalf, _eyeRight.elements[12] = eyeSepHalf, xmin = -ymax * cache.aspect + eyeSepOnProjection, xmax = ymax * cache.aspect + eyeSepOnProjection, _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin), _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin), this.cameraL.projectionMatrix.copy(_projectionMatrix), xmin = -ymax * cache.aspect - eyeSepOnProjection, xmax = ymax * cache.aspect - eyeSepOnProjection, _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin), _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin), this.cameraR.projectionMatrix.copy(_projectionMatrix);
              }
              this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft), this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
            }
          }
          class Clock {
            constructor(autoStart = !0) {
              this.autoStart = autoStart, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
            }
            start() {
              this.startTime = now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
            }
            stop() {
              this.getElapsedTime(), this.running = !1, this.autoStart = !1;
            }
            getElapsedTime() {
              return this.getDelta(), this.elapsedTime;
            }
            getDelta() {
              let diff = 0;
              if (this.autoStart && !this.running)
                return this.start(), 0;
              if (this.running) {
                let newTime = now();
                diff = (newTime - this.oldTime) / 1e3, this.oldTime = newTime, this.elapsedTime += diff;
              }
              return diff;
            }
          }
          function now() {
            return (typeof performance == "undefined" ? Date : performance).now();
          }
          let _position$1 = /* @__PURE__ */ new Vector3(), _quaternion$1 = /* @__PURE__ */ new Quaternion(), _scale$1 = /* @__PURE__ */ new Vector3(), _orientation$1 = /* @__PURE__ */ new Vector3();
          class AudioListener extends Object3D {
            constructor() {
              super();
              this.type = "AudioListener", this.context = AudioContext.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Clock();
            }
            getInput() {
              return this.gain;
            }
            removeFilter() {
              return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
            }
            getFilter() {
              return this.filter;
            }
            setFilter(value) {
              return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = value, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
            }
            getMasterVolume() {
              return this.gain.gain.value;
            }
            setMasterVolume(value) {
              return this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01), this;
            }
            updateMatrixWorld(force) {
              super.updateMatrixWorld(force);
              let listener = this.context.listener, up = this.up;
              if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1), _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1), listener.positionX) {
                let endTime = this.context.currentTime + this.timeDelta;
                listener.positionX.linearRampToValueAtTime(_position$1.x, endTime), listener.positionY.linearRampToValueAtTime(_position$1.y, endTime), listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime), listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime), listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime), listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime), listener.upX.linearRampToValueAtTime(up.x, endTime), listener.upY.linearRampToValueAtTime(up.y, endTime), listener.upZ.linearRampToValueAtTime(up.z, endTime);
              } else
                listener.setPosition(_position$1.x, _position$1.y, _position$1.z), listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
            }
          }
          class Audio extends Object3D {
            constructor(listener) {
              super();
              this.type = "Audio", this.listener = listener, this.context = listener.context, this.gain = this.context.createGain(), this.gain.connect(listener.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
            }
            getOutput() {
              return this.gain;
            }
            setNodeSource(audioNode) {
              return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = audioNode, this.connect(), this;
            }
            setMediaElementSource(mediaElement) {
              return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(mediaElement), this.connect(), this;
            }
            setMediaStreamSource(mediaStream) {
              return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(mediaStream), this.connect(), this;
            }
            setBuffer(audioBuffer) {
              return this.buffer = audioBuffer, this.sourceType = "buffer", this.autoplay && this.play(), this;
            }
            play(delay = 0) {
              if (this.isPlaying === !0) {
                console.warn("THREE.Audio: Audio is already playing.");
                return;
              }
              if (this.hasPlaybackControl === !1) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
              }
              this._startedAt = this.context.currentTime + delay;
              let source = this.context.createBufferSource();
              return source.buffer = this.buffer, source.loop = this.loop, source.loopStart = this.loopStart, source.loopEnd = this.loopEnd, source.onended = this.onEnded.bind(this), source.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = source, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
            }
            pause() {
              if (this.hasPlaybackControl === !1) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
              }
              return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
            }
            stop() {
              if (this.hasPlaybackControl === !1) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
              }
              return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
            }
            connect() {
              if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (let i = 1, l = this.filters.length; i < l; i++)
                  this.filters[i - 1].connect(this.filters[i]);
                this.filters[this.filters.length - 1].connect(this.getOutput());
              } else
                this.source.connect(this.getOutput());
              return this._connected = !0, this;
            }
            disconnect() {
              if (this._connected !== !1) {
                if (this.filters.length > 0) {
                  this.source.disconnect(this.filters[0]);
                  for (let i = 1, l = this.filters.length; i < l; i++)
                    this.filters[i - 1].disconnect(this.filters[i]);
                  this.filters[this.filters.length - 1].disconnect(this.getOutput());
                } else
                  this.source.disconnect(this.getOutput());
                return this._connected = !1, this;
              }
            }
            getFilters() {
              return this.filters;
            }
            setFilters(value) {
              return value || (value = []), this._connected === !0 ? (this.disconnect(), this.filters = value.slice(), this.connect()) : this.filters = value.slice(), this;
            }
            setDetune(value) {
              return this.detune = value, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
            }
            getDetune() {
              return this.detune;
            }
            getFilter() {
              return this.getFilters()[0];
            }
            setFilter(filter) {
              return this.setFilters(filter ? [filter] : []);
            }
            setPlaybackRate(value) {
              if (this.hasPlaybackControl === !1) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
              }
              return this.playbackRate = value, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
            }
            getPlaybackRate() {
              return this.playbackRate;
            }
            onEnded() {
              this.isPlaying = !1;
            }
            getLoop() {
              return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
            }
            setLoop(value) {
              if (this.hasPlaybackControl === !1) {
                console.warn("THREE.Audio: this Audio has no playback control.");
                return;
              }
              return this.loop = value, this.isPlaying === !0 && (this.source.loop = this.loop), this;
            }
            setLoopStart(value) {
              return this.loopStart = value, this;
            }
            setLoopEnd(value) {
              return this.loopEnd = value, this;
            }
            getVolume() {
              return this.gain.gain.value;
            }
            setVolume(value) {
              return this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01), this;
            }
          }
          let _position = /* @__PURE__ */ new Vector3(), _quaternion = /* @__PURE__ */ new Quaternion(), _scale = /* @__PURE__ */ new Vector3(), _orientation = /* @__PURE__ */ new Vector3();
          class PositionalAudio extends Audio {
            constructor(listener) {
              super(listener);
              this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
            }
            connect() {
              super.connect(), this.panner.connect(this.gain);
            }
            disconnect() {
              super.disconnect(), this.panner.disconnect(this.gain);
            }
            getOutput() {
              return this.panner;
            }
            getRefDistance() {
              return this.panner.refDistance;
            }
            setRefDistance(value) {
              return this.panner.refDistance = value, this;
            }
            getRolloffFactor() {
              return this.panner.rolloffFactor;
            }
            setRolloffFactor(value) {
              return this.panner.rolloffFactor = value, this;
            }
            getDistanceModel() {
              return this.panner.distanceModel;
            }
            setDistanceModel(value) {
              return this.panner.distanceModel = value, this;
            }
            getMaxDistance() {
              return this.panner.maxDistance;
            }
            setMaxDistance(value) {
              return this.panner.maxDistance = value, this;
            }
            setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
              return this.panner.coneInnerAngle = coneInnerAngle, this.panner.coneOuterAngle = coneOuterAngle, this.panner.coneOuterGain = coneOuterGain, this;
            }
            updateMatrixWorld(force) {
              if (super.updateMatrixWorld(force), this.hasPlaybackControl === !0 && this.isPlaying === !1)
                return;
              this.matrixWorld.decompose(_position, _quaternion, _scale), _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
              let panner = this.panner;
              if (panner.positionX) {
                let endTime = this.context.currentTime + this.listener.timeDelta;
                panner.positionX.linearRampToValueAtTime(_position.x, endTime), panner.positionY.linearRampToValueAtTime(_position.y, endTime), panner.positionZ.linearRampToValueAtTime(_position.z, endTime), panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime), panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime), panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
              } else
                panner.setPosition(_position.x, _position.y, _position.z), panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
            }
          }
          class AudioAnalyser {
            constructor(audio, fftSize = 2048) {
              this.analyser = audio.context.createAnalyser(), this.analyser.fftSize = fftSize, this.data = new Uint8Array(this.analyser.frequencyBinCount), audio.getOutput().connect(this.analyser);
            }
            getFrequencyData() {
              return this.analyser.getByteFrequencyData(this.data), this.data;
            }
            getAverageFrequency() {
              let value = 0, data = this.getFrequencyData();
              for (let i = 0; i < data.length; i++)
                value += data[i];
              return value / data.length;
            }
          }
          class PropertyMixer {
            constructor(binding, typeName, valueSize) {
              this.binding = binding, this.valueSize = valueSize;
              let mixFunction, mixFunctionAdditive, setIdentity;
              switch (typeName) {
                case "quaternion":
                  mixFunction = this._slerp, mixFunctionAdditive = this._slerpAdditive, setIdentity = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(valueSize * 6), this._workIndex = 5;
                  break;
                case "string":
                case "bool":
                  mixFunction = this._select, mixFunctionAdditive = this._select, setIdentity = this._setAdditiveIdentityOther, this.buffer = new Array(valueSize * 5);
                  break;
                default:
                  mixFunction = this._lerp, mixFunctionAdditive = this._lerpAdditive, setIdentity = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(valueSize * 5);
              }
              this._mixBufferRegion = mixFunction, this._mixBufferRegionAdditive = mixFunctionAdditive, this._setIdentity = setIdentity, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
            }
            accumulate(accuIndex, weight) {
              let buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
              if (currentWeight === 0) {
                for (let i = 0; i !== stride; ++i)
                  buffer[offset + i] = buffer[i];
                currentWeight = weight;
              } else {
                currentWeight += weight;
                let mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
              }
              this.cumulativeWeight = currentWeight;
            }
            accumulateAdditive(weight) {
              let buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
              this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride), this.cumulativeWeightAdditive += weight;
            }
            apply(accuIndex) {
              let stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
              if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, weight < 1) {
                let originalValueOffset = stride * this._origIndex;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
              }
              weightAdditive > 0 && this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
              for (let i = stride, e = stride + stride; i !== e; ++i)
                if (buffer[i] !== buffer[i + stride]) {
                  binding.setValue(buffer, offset);
                  break;
                }
            }
            saveOriginalState() {
              let binding = this.binding, buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
              binding.getValue(buffer, originalValueOffset);
              for (let i = stride, e = originalValueOffset; i !== e; ++i)
                buffer[i] = buffer[originalValueOffset + i % stride];
              this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
            }
            restoreOriginalState() {
              let originalValueOffset = this.valueSize * 3;
              this.binding.setValue(this.buffer, originalValueOffset);
            }
            _setAdditiveIdentityNumeric() {
              let startIndex = this._addIndex * this.valueSize, endIndex = startIndex + this.valueSize;
              for (let i = startIndex; i < endIndex; i++)
                this.buffer[i] = 0;
            }
            _setAdditiveIdentityQuaternion() {
              this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
            }
            _setAdditiveIdentityOther() {
              let startIndex = this._origIndex * this.valueSize, targetIndex = this._addIndex * this.valueSize;
              for (let i = 0; i < this.valueSize; i++)
                this.buffer[targetIndex + i] = this.buffer[startIndex + i];
            }
            _select(buffer, dstOffset, srcOffset, t, stride) {
              if (t >= 0.5)
                for (let i = 0; i !== stride; ++i)
                  buffer[dstOffset + i] = buffer[srcOffset + i];
            }
            _slerp(buffer, dstOffset, srcOffset, t) {
              Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
            }
            _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
              let workOffset = this._workIndex * stride;
              Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset), Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
            }
            _lerp(buffer, dstOffset, srcOffset, t, stride) {
              let s = 1 - t;
              for (let i = 0; i !== stride; ++i) {
                let j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
              }
            }
            _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
              for (let i = 0; i !== stride; ++i) {
                let j = dstOffset + i;
                buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
              }
            }
          }
          let _RESERVED_CHARS_RE = "\\[\\]\\.:\\/", _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"), _wordChar = "[^" + _RESERVED_CHARS_RE + "]", _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]", _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar), _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot), _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar), _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar), _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"), _supportedObjectNames = ["material", "materials", "bones", "map"];
          class Composite {
            constructor(targetGroup, path, optionalParsedPath) {
              let parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
              this._targetGroup = targetGroup, this._bindings = targetGroup.subscribe_(path, parsedPath);
            }
            getValue(array, offset) {
              this.bind();
              let firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
              binding !== void 0 && binding.getValue(array, offset);
            }
            setValue(array, offset) {
              let bindings = this._bindings;
              for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i)
                bindings[i].setValue(array, offset);
            }
            bind() {
              let bindings = this._bindings;
              for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i)
                bindings[i].bind();
            }
            unbind() {
              let bindings = this._bindings;
              for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i)
                bindings[i].unbind();
            }
          }
          class PropertyBinding {
            constructor(rootNode, path, parsedPath) {
              this.path = path, this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path), this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName), this.rootNode = rootNode, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
            }
            static create(root, path, parsedPath) {
              return root && root.isAnimationObjectGroup ? new PropertyBinding.Composite(root, path, parsedPath) : new PropertyBinding(root, path, parsedPath);
            }
            static sanitizeNodeName(name) {
              return name.replace(/\s/g, "_").replace(_reservedRe, "");
            }
            static parseTrackName(trackName) {
              let matches = _trackRe.exec(trackName);
              if (matches === null)
                throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
              let results = {
                nodeName: matches[2],
                objectName: matches[3],
                objectIndex: matches[4],
                propertyName: matches[5],
                propertyIndex: matches[6]
              }, lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
              if (lastDot !== void 0 && lastDot !== -1) {
                let objectName = results.nodeName.substring(lastDot + 1);
                _supportedObjectNames.indexOf(objectName) !== -1 && (results.nodeName = results.nodeName.substring(0, lastDot), results.objectName = objectName);
              }
              if (results.propertyName === null || results.propertyName.length === 0)
                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
              return results;
            }
            static findNode(root, nodeName) {
              if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid)
                return root;
              if (root.skeleton) {
                let bone = root.skeleton.getBoneByName(nodeName);
                if (bone !== void 0)
                  return bone;
              }
              if (root.children) {
                let searchNodeSubtree = function(children) {
                  for (let i = 0; i < children.length; i++) {
                    let childNode = children[i];
                    if (childNode.name === nodeName || childNode.uuid === nodeName)
                      return childNode;
                    let result = searchNodeSubtree(childNode.children);
                    if (result)
                      return result;
                  }
                  return null;
                }, subTreeNode = searchNodeSubtree(root.children);
                if (subTreeNode)
                  return subTreeNode;
              }
              return null;
            }
            _getValue_unavailable() {
            }
            _setValue_unavailable() {
            }
            _getValue_direct(buffer, offset) {
              buffer[offset] = this.targetObject[this.propertyName];
            }
            _getValue_array(buffer, offset) {
              let source = this.resolvedProperty;
              for (let i = 0, n = source.length; i !== n; ++i)
                buffer[offset++] = source[i];
            }
            _getValue_arrayElement(buffer, offset) {
              buffer[offset] = this.resolvedProperty[this.propertyIndex];
            }
            _getValue_toArray(buffer, offset) {
              this.resolvedProperty.toArray(buffer, offset);
            }
            _setValue_direct(buffer, offset) {
              this.targetObject[this.propertyName] = buffer[offset];
            }
            _setValue_direct_setNeedsUpdate(buffer, offset) {
              this.targetObject[this.propertyName] = buffer[offset], this.targetObject.needsUpdate = !0;
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
              this.targetObject[this.propertyName] = buffer[offset], this.targetObject.matrixWorldNeedsUpdate = !0;
            }
            _setValue_array(buffer, offset) {
              let dest = this.resolvedProperty;
              for (let i = 0, n = dest.length; i !== n; ++i)
                dest[i] = buffer[offset++];
            }
            _setValue_array_setNeedsUpdate(buffer, offset) {
              let dest = this.resolvedProperty;
              for (let i = 0, n = dest.length; i !== n; ++i)
                dest[i] = buffer[offset++];
              this.targetObject.needsUpdate = !0;
            }
            _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
              let dest = this.resolvedProperty;
              for (let i = 0, n = dest.length; i !== n; ++i)
                dest[i] = buffer[offset++];
              this.targetObject.matrixWorldNeedsUpdate = !0;
            }
            _setValue_arrayElement(buffer, offset) {
              this.resolvedProperty[this.propertyIndex] = buffer[offset];
            }
            _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
              this.resolvedProperty[this.propertyIndex] = buffer[offset], this.targetObject.needsUpdate = !0;
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
              this.resolvedProperty[this.propertyIndex] = buffer[offset], this.targetObject.matrixWorldNeedsUpdate = !0;
            }
            _setValue_fromArray(buffer, offset) {
              this.resolvedProperty.fromArray(buffer, offset);
            }
            _setValue_fromArray_setNeedsUpdate(buffer, offset) {
              this.resolvedProperty.fromArray(buffer, offset), this.targetObject.needsUpdate = !0;
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
              this.resolvedProperty.fromArray(buffer, offset), this.targetObject.matrixWorldNeedsUpdate = !0;
            }
            _getValue_unbound(targetArray, offset) {
              this.bind(), this.getValue(targetArray, offset);
            }
            _setValue_unbound(sourceArray, offset) {
              this.bind(), this.setValue(sourceArray, offset);
            }
            bind() {
              let targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
              if (targetObject || (targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName), this.node = targetObject), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !targetObject) {
                console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                return;
              }
              if (objectName) {
                let objectIndex = parsedPath.objectIndex;
                switch (objectName) {
                  case "materials":
                    if (!targetObject.material) {
                      console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                      return;
                    }
                    if (!targetObject.material.materials) {
                      console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                      return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                  case "bones":
                    if (!targetObject.skeleton) {
                      console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                      return;
                    }
                    targetObject = targetObject.skeleton.bones;
                    for (let i = 0; i < targetObject.length; i++)
                      if (targetObject[i].name === objectIndex) {
                        objectIndex = i;
                        break;
                      }
                    break;
                  case "map":
                    if ("map" in targetObject) {
                      targetObject = targetObject.map;
                      break;
                    }
                    if (!targetObject.material) {
                      console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                      return;
                    }
                    if (!targetObject.material.map) {
                      console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                      return;
                    }
                    targetObject = targetObject.material.map;
                    break;
                  default:
                    if (targetObject[objectName] === void 0) {
                      console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                      return;
                    }
                    targetObject = targetObject[objectName];
                }
                if (objectIndex !== void 0) {
                  if (targetObject[objectIndex] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                    return;
                  }
                  targetObject = targetObject[objectIndex];
                }
              }
              let nodeProperty = targetObject[propertyName];
              if (nodeProperty === void 0) {
                let nodeName = parsedPath.nodeName;
                console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
                return;
              }
              let versioning = this.Versioning.None;
              this.targetObject = targetObject, targetObject.needsUpdate !== void 0 ? versioning = this.Versioning.NeedsUpdate : targetObject.matrixWorldNeedsUpdate !== void 0 && (versioning = this.Versioning.MatrixWorldNeedsUpdate);
              let bindingType = this.BindingType.Direct;
              if (propertyIndex !== void 0) {
                if (propertyName === "morphTargetInfluences") {
                  if (!targetObject.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return;
                  }
                  if (!targetObject.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return;
                  }
                  targetObject.morphTargetDictionary[propertyIndex] !== void 0 && (propertyIndex = targetObject.morphTargetDictionary[propertyIndex]);
                }
                bindingType = this.BindingType.ArrayElement, this.resolvedProperty = nodeProperty, this.propertyIndex = propertyIndex;
              } else
                nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0 ? (bindingType = this.BindingType.HasFromToArray, this.resolvedProperty = nodeProperty) : Array.isArray(nodeProperty) ? (bindingType = this.BindingType.EntireArray, this.resolvedProperty = nodeProperty) : this.propertyName = propertyName;
              this.getValue = this.GetterByBindingType[bindingType], this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
            }
            unbind() {
              this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
            }
          }
          PropertyBinding.Composite = Composite, PropertyBinding.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, PropertyBinding.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray], PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[
            PropertyBinding.prototype._setValue_direct,
            PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
            PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
          ], [
            PropertyBinding.prototype._setValue_array,
            PropertyBinding.prototype._setValue_array_setNeedsUpdate,
            PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
          ], [
            PropertyBinding.prototype._setValue_arrayElement,
            PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
            PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
          ], [
            PropertyBinding.prototype._setValue_fromArray,
            PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
            PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
          ]];
          class AnimationObjectGroup {
            constructor() {
              this.isAnimationObjectGroup = !0, this.uuid = generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
              let indices = {};
              this._indicesByUUID = indices;
              for (let i = 0, n = arguments.length; i !== n; ++i)
                indices[arguments[i].uuid] = i;
              this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
              let scope = this;
              this.stats = { objects: { get total() {
                return scope._objects.length;
              }, get inUse() {
                return this.total - scope.nCachedObjects_;
              } }, get bindingsPerObject() {
                return scope._bindings.length;
              } };
            }
            add() {
              let objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
              for (let i = 0, n = arguments.length; i !== n; ++i) {
                let object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index === void 0) {
                  index = nObjects++, indicesByUUID[uuid] = index, objects.push(object);
                  for (let j = 0, m = nBindings; j !== m; ++j)
                    bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                } else if (index < nCachedObjects) {
                  knownObject = objects[index];
                  let firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                  indicesByUUID[lastCachedObject.uuid] = index, objects[index] = lastCachedObject, indicesByUUID[uuid] = firstActiveIndex, objects[firstActiveIndex] = object;
                  for (let j = 0, m = nBindings; j !== m; ++j) {
                    let bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = lastCached, binding === void 0 && (binding = new PropertyBinding(object, paths[j], parsedPaths[j])), bindingsForPath[firstActiveIndex] = binding;
                  }
                } else
                  objects[index] !== knownObject && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
              }
              this.nCachedObjects_ = nCachedObjects;
            }
            remove() {
              let objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length, nCachedObjects = this.nCachedObjects_;
              for (let i = 0, n = arguments.length; i !== n; ++i) {
                let object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== void 0 && index >= nCachedObjects) {
                  let lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                  indicesByUUID[firstActiveObject.uuid] = index, objects[index] = firstActiveObject, indicesByUUID[uuid] = lastCachedIndex, objects[lastCachedIndex] = object;
                  for (let j = 0, m = nBindings; j !== m; ++j) {
                    let bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = firstActive, bindingsForPath[lastCachedIndex] = binding;
                  }
                }
              }
              this.nCachedObjects_ = nCachedObjects;
            }
            uncache() {
              let objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length, nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
              for (let i = 0, n = arguments.length; i !== n; ++i) {
                let object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== void 0)
                  if (delete indicesByUUID[uuid], index < nCachedObjects) {
                    let firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastCachedObject.uuid] = index, objects[index] = lastCachedObject, indicesByUUID[lastObject.uuid] = firstActiveIndex, objects[firstActiveIndex] = lastObject, objects.pop();
                    for (let j = 0, m = nBindings; j !== m; ++j) {
                      let bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                      bindingsForPath[index] = lastCached, bindingsForPath[firstActiveIndex] = last, bindingsForPath.pop();
                    }
                  } else {
                    let lastIndex = --nObjects, lastObject = objects[lastIndex];
                    lastIndex > 0 && (indicesByUUID[lastObject.uuid] = index), objects[index] = lastObject, objects.pop();
                    for (let j = 0, m = nBindings; j !== m; ++j) {
                      let bindingsForPath = bindings[j];
                      bindingsForPath[index] = bindingsForPath[lastIndex], bindingsForPath.pop();
                    }
                  }
              }
              this.nCachedObjects_ = nCachedObjects;
            }
            subscribe_(path, parsedPath) {
              let indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
              if (index !== void 0)
                return bindings[index];
              let paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
              index = bindings.length, indicesByPath[path] = index, paths.push(path), parsedPaths.push(parsedPath), bindings.push(bindingsForPath);
              for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
                let object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
              }
              return bindingsForPath;
            }
            unsubscribe_(path) {
              let indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
              if (index !== void 0) {
                let paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index, bindings[index] = lastBindings, bindings.pop(), parsedPaths[index] = parsedPaths[lastBindingsIndex], parsedPaths.pop(), paths[index] = paths[lastBindingsIndex], paths.pop();
              }
            }
          }
          class AnimationAction {
            constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
              this._mixer = mixer, this._clip = clip, this._localRoot = localRoot, this.blendMode = blendMode;
              let tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks), interpolantSettings = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding };
              for (let i = 0; i !== nTracks; ++i) {
                let interpolant = tracks[i].createInterpolant(null);
                interpolants[i] = interpolant, interpolant.settings = interpolantSettings;
              }
              this._interpolantSettings = interpolantSettings, this._interpolants = interpolants, this._propertyBindings = new Array(nTracks), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
            }
            play() {
              return this._mixer._activateAction(this), this;
            }
            stop() {
              return this._mixer._deactivateAction(this), this.reset();
            }
            reset() {
              return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
            }
            isRunning() {
              return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
            }
            isScheduled() {
              return this._mixer._isActiveAction(this);
            }
            startAt(time) {
              return this._startTime = time, this;
            }
            setLoop(mode, repetitions) {
              return this.loop = mode, this.repetitions = repetitions, this;
            }
            setEffectiveWeight(weight) {
              return this.weight = weight, this._effectiveWeight = this.enabled ? weight : 0, this.stopFading();
            }
            getEffectiveWeight() {
              return this._effectiveWeight;
            }
            fadeIn(duration) {
              return this._scheduleFading(duration, 0, 1);
            }
            fadeOut(duration) {
              return this._scheduleFading(duration, 1, 0);
            }
            crossFadeFrom(fadeOutAction, duration, warp) {
              if (fadeOutAction.fadeOut(duration), this.fadeIn(duration), warp) {
                let fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1, startEndRatio, duration), this.warp(endStartRatio, 1, duration);
              }
              return this;
            }
            crossFadeTo(fadeInAction, duration, warp) {
              return fadeInAction.crossFadeFrom(this, duration, warp);
            }
            stopFading() {
              let weightInterpolant = this._weightInterpolant;
              return weightInterpolant !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(weightInterpolant)), this;
            }
            setEffectiveTimeScale(timeScale) {
              return this.timeScale = timeScale, this._effectiveTimeScale = this.paused ? 0 : timeScale, this.stopWarping();
            }
            getEffectiveTimeScale() {
              return this._effectiveTimeScale;
            }
            setDuration(duration) {
              return this.timeScale = this._clip.duration / duration, this.stopWarping();
            }
            syncWith(action) {
              return this.time = action.time, this.timeScale = action.timeScale, this.stopWarping();
            }
            halt(duration) {
              return this.warp(this._effectiveTimeScale, 0, duration);
            }
            warp(startTimeScale, endTimeScale, duration) {
              let mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale, interpolant = this._timeScaleInterpolant;
              interpolant === null && (interpolant = mixer._lendControlInterpolant(), this._timeScaleInterpolant = interpolant);
              let times = interpolant.parameterPositions, values = interpolant.sampleValues;
              return times[0] = now2, times[1] = now2 + duration, values[0] = startTimeScale / timeScale, values[1] = endTimeScale / timeScale, this;
            }
            stopWarping() {
              let timeScaleInterpolant = this._timeScaleInterpolant;
              return timeScaleInterpolant !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(timeScaleInterpolant)), this;
            }
            getMixer() {
              return this._mixer;
            }
            getClip() {
              return this._clip;
            }
            getRoot() {
              return this._localRoot || this._mixer._root;
            }
            _update(time, deltaTime, timeDirection, accuIndex) {
              if (!this.enabled) {
                this._updateWeight(time);
                return;
              }
              let startTime = this._startTime;
              if (startTime !== null) {
                let timeRunning = (time - startTime) * timeDirection;
                timeRunning < 0 || timeDirection === 0 ? deltaTime = 0 : (this._startTime = null, deltaTime = timeDirection * timeRunning);
              }
              deltaTime *= this._updateTimeScale(time);
              let clipTime = this._updateTime(deltaTime), weight = this._updateWeight(time);
              if (weight > 0) {
                let interpolants = this._interpolants, propertyMixers = this._propertyBindings;
                switch (this.blendMode) {
                  case AdditiveAnimationBlendMode:
                    for (let j = 0, m = interpolants.length; j !== m; ++j)
                      interpolants[j].evaluate(clipTime), propertyMixers[j].accumulateAdditive(weight);
                    break;
                  case NormalAnimationBlendMode:
                  default:
                    for (let j = 0, m = interpolants.length; j !== m; ++j)
                      interpolants[j].evaluate(clipTime), propertyMixers[j].accumulate(accuIndex, weight);
                }
              }
            }
            _updateWeight(time) {
              let weight = 0;
              if (this.enabled) {
                weight = this.weight;
                let interpolant = this._weightInterpolant;
                if (interpolant !== null) {
                  let interpolantValue = interpolant.evaluate(time)[0];
                  weight *= interpolantValue, time > interpolant.parameterPositions[1] && (this.stopFading(), interpolantValue === 0 && (this.enabled = !1));
                }
              }
              return this._effectiveWeight = weight, weight;
            }
            _updateTimeScale(time) {
              let timeScale = 0;
              if (!this.paused) {
                timeScale = this.timeScale;
                let interpolant = this._timeScaleInterpolant;
                interpolant !== null && (timeScale *= interpolant.evaluate(time)[0], time > interpolant.parameterPositions[1] && (this.stopWarping(), timeScale === 0 ? this.paused = !0 : this.timeScale = timeScale));
              }
              return this._effectiveTimeScale = timeScale, timeScale;
            }
            _updateTime(deltaTime) {
              let duration = this._clip.duration, loop = this.loop, time = this.time + deltaTime, loopCount = this._loopCount, pingPong = loop === LoopPingPong;
              if (deltaTime === 0)
                return loopCount === -1 ? time : pingPong && (loopCount & 1) == 1 ? duration - time : time;
              if (loop === LoopOnce) {
                loopCount === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                handle_stop: {
                  if (time >= duration)
                    time = duration;
                  else if (time < 0)
                    time = 0;
                  else {
                    this.time = time;
                    break handle_stop;
                  }
                  this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = time, this._mixer.dispatchEvent({ type: "finished", action: this, direction: deltaTime < 0 ? -1 : 1 });
                }
              } else {
                if (loopCount === -1 && (deltaTime >= 0 ? (loopCount = 0, this._setEndings(!0, this.repetitions === 0, pingPong)) : this._setEndings(this.repetitions === 0, !0, pingPong)), time >= duration || time < 0) {
                  let loopDelta = Math.floor(time / duration);
                  time -= duration * loopDelta, loopCount += Math.abs(loopDelta);
                  let pending = this.repetitions - loopCount;
                  if (pending <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, time = deltaTime > 0 ? duration : 0, this.time = time, this._mixer.dispatchEvent({ type: "finished", action: this, direction: deltaTime > 0 ? 1 : -1 });
                  else {
                    if (pending === 1) {
                      let atStart = deltaTime < 0;
                      this._setEndings(atStart, !atStart, pingPong);
                    } else
                      this._setEndings(!1, !1, pingPong);
                    this._loopCount = loopCount, this.time = time, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta });
                  }
                } else
                  this.time = time;
                if (pingPong && (loopCount & 1) == 1)
                  return duration - time;
              }
              return time;
            }
            _setEndings(atStart, atEnd, pingPong) {
              let settings = this._interpolantSettings;
              pingPong ? (settings.endingStart = ZeroSlopeEnding, settings.endingEnd = ZeroSlopeEnding) : (atStart ? settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : settings.endingStart = WrapAroundEnding, atEnd ? settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : settings.endingEnd = WrapAroundEnding);
            }
            _scheduleFading(duration, weightNow, weightThen) {
              let mixer = this._mixer, now2 = mixer.time, interpolant = this._weightInterpolant;
              interpolant === null && (interpolant = mixer._lendControlInterpolant(), this._weightInterpolant = interpolant);
              let times = interpolant.parameterPositions, values = interpolant.sampleValues;
              return times[0] = now2, values[0] = weightNow, times[1] = now2 + duration, values[1] = weightThen, this;
            }
          }
          let _controlInterpolantsResultBuffer = new Float32Array(1);
          class AnimationMixer extends EventDispatcher {
            constructor(root) {
              super();
              this._root = root, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
            }
            _bindAction(action, prototypeAction) {
              let root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
              bindingsByName === void 0 && (bindingsByName = {}, bindingsByRoot[rootUuid] = bindingsByName);
              for (let i = 0; i !== nTracks; ++i) {
                let track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
                if (binding !== void 0)
                  ++binding.referenceCount, bindings[i] = binding;
                else {
                  if (binding = bindings[i], binding !== void 0) {
                    binding._cacheIndex === null && (++binding.referenceCount, this._addInactiveBinding(binding, rootUuid, trackName));
                    continue;
                  }
                  let path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                  binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize()), ++binding.referenceCount, this._addInactiveBinding(binding, rootUuid, trackName), bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
              }
            }
            _activateAction(action) {
              if (!this._isActiveAction(action)) {
                if (action._cacheIndex === null) {
                  let rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                  this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]), this._addInactiveAction(action, clipUuid, rootUuid);
                }
                let bindings = action._propertyBindings;
                for (let i = 0, n = bindings.length; i !== n; ++i) {
                  let binding = bindings[i];
                  binding.useCount++ == 0 && (this._lendBinding(binding), binding.saveOriginalState());
                }
                this._lendAction(action);
              }
            }
            _deactivateAction(action) {
              if (this._isActiveAction(action)) {
                let bindings = action._propertyBindings;
                for (let i = 0, n = bindings.length; i !== n; ++i) {
                  let binding = bindings[i];
                  --binding.useCount == 0 && (binding.restoreOriginalState(), this._takeBackBinding(binding));
                }
                this._takeBackAction(action);
              }
            }
            _initMemoryManager() {
              this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
              let scope = this;
              this.stats = { actions: { get total() {
                return scope._actions.length;
              }, get inUse() {
                return scope._nActiveActions;
              } }, bindings: { get total() {
                return scope._bindings.length;
              }, get inUse() {
                return scope._nActiveBindings;
              } }, controlInterpolants: { get total() {
                return scope._controlInterpolants.length;
              }, get inUse() {
                return scope._nActiveControlInterpolants;
              } } };
            }
            _isActiveAction(action) {
              let index = action._cacheIndex;
              return index !== null && index < this._nActiveActions;
            }
            _addInactiveAction(action, clipUuid, rootUuid) {
              let actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
              if (actionsForClip === void 0)
                actionsForClip = { knownActions: [action], actionByRoot: {} }, action._byClipCacheIndex = 0, actionsByClip[clipUuid] = actionsForClip;
              else {
                let knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length, knownActions.push(action);
              }
              action._cacheIndex = actions.length, actions.push(action), actionsForClip.actionByRoot[rootUuid] = action;
            }
            _removeInactiveAction(action) {
              let actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
              lastInactiveAction._cacheIndex = cacheIndex, actions[cacheIndex] = lastInactiveAction, actions.pop(), action._cacheIndex = null;
              let clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
              lastKnownAction._byClipCacheIndex = byClipCacheIndex, knownActionsForClip[byClipCacheIndex] = lastKnownAction, knownActionsForClip.pop(), action._byClipCacheIndex = null;
              let actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
              delete actionByRoot[rootUuid], knownActionsForClip.length === 0 && delete actionsByClip[clipUuid], this._removeInactiveBindingsForAction(action);
            }
            _removeInactiveBindingsForAction(action) {
              let bindings = action._propertyBindings;
              for (let i = 0, n = bindings.length; i !== n; ++i) {
                let binding = bindings[i];
                --binding.referenceCount == 0 && this._removeInactiveBinding(binding);
              }
            }
            _lendAction(action) {
              let actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
              action._cacheIndex = lastActiveIndex, actions[lastActiveIndex] = action, firstInactiveAction._cacheIndex = prevIndex, actions[prevIndex] = firstInactiveAction;
            }
            _takeBackAction(action) {
              let actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
              action._cacheIndex = firstInactiveIndex, actions[firstInactiveIndex] = action, lastActiveAction._cacheIndex = prevIndex, actions[prevIndex] = lastActiveAction;
            }
            _addInactiveBinding(binding, rootUuid, trackName) {
              let bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings, bindingByName = bindingsByRoot[rootUuid];
              bindingByName === void 0 && (bindingByName = {}, bindingsByRoot[rootUuid] = bindingByName), bindingByName[trackName] = binding, binding._cacheIndex = bindings.length, bindings.push(binding);
            }
            _removeInactiveBinding(binding) {
              let bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
              lastInactiveBinding._cacheIndex = cacheIndex, bindings[cacheIndex] = lastInactiveBinding, bindings.pop(), delete bindingByName[trackName], Object.keys(bindingByName).length === 0 && delete bindingsByRoot[rootUuid];
            }
            _lendBinding(binding) {
              let bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
              binding._cacheIndex = lastActiveIndex, bindings[lastActiveIndex] = binding, firstInactiveBinding._cacheIndex = prevIndex, bindings[prevIndex] = firstInactiveBinding;
            }
            _takeBackBinding(binding) {
              let bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
              binding._cacheIndex = firstInactiveIndex, bindings[firstInactiveIndex] = binding, lastActiveBinding._cacheIndex = prevIndex, bindings[prevIndex] = lastActiveBinding;
            }
            _lendControlInterpolant() {
              let interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
              return interpolant === void 0 && (interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer), interpolant.__cacheIndex = lastActiveIndex, interpolants[lastActiveIndex] = interpolant), interpolant;
            }
            _takeBackControlInterpolant(interpolant) {
              let interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
              interpolant.__cacheIndex = firstInactiveIndex, interpolants[firstInactiveIndex] = interpolant, lastActiveInterpolant.__cacheIndex = prevIndex, interpolants[prevIndex] = lastActiveInterpolant;
            }
            clipAction(clip, optionalRoot, blendMode) {
              let root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip == "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
              if (blendMode === void 0 && (clipObject !== null ? blendMode = clipObject.blendMode : blendMode = NormalAnimationBlendMode), actionsForClip !== void 0) {
                let existingAction = actionsForClip.actionByRoot[rootUuid];
                if (existingAction !== void 0 && existingAction.blendMode === blendMode)
                  return existingAction;
                prototypeAction = actionsForClip.knownActions[0], clipObject === null && (clipObject = prototypeAction._clip);
              }
              if (clipObject === null)
                return null;
              let newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
              return this._bindAction(newAction, prototypeAction), this._addInactiveAction(newAction, clipUuid, rootUuid), newAction;
            }
            existingAction(clip, optionalRoot) {
              let root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip == "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
              return actionsForClip !== void 0 && actionsForClip.actionByRoot[rootUuid] || null;
            }
            stopAllAction() {
              let actions = this._actions, nActions = this._nActiveActions;
              for (let i = nActions - 1; i >= 0; --i)
                actions[i].stop();
              return this;
            }
            update(deltaTime) {
              deltaTime *= this.timeScale;
              let actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
              for (let i = 0; i !== nActions; ++i)
                actions[i]._update(time, deltaTime, timeDirection, accuIndex);
              let bindings = this._bindings, nBindings = this._nActiveBindings;
              for (let i = 0; i !== nBindings; ++i)
                bindings[i].apply(accuIndex);
              return this;
            }
            setTime(timeInSeconds) {
              this.time = 0;
              for (let i = 0; i < this._actions.length; i++)
                this._actions[i].time = 0;
              return this.update(timeInSeconds);
            }
            getRoot() {
              return this._root;
            }
            uncacheClip(clip) {
              let actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
              if (actionsForClip !== void 0) {
                let actionsToRemove = actionsForClip.knownActions;
                for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
                  let action = actionsToRemove[i];
                  this._deactivateAction(action);
                  let cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                  action._cacheIndex = null, action._byClipCacheIndex = null, lastInactiveAction._cacheIndex = cacheIndex, actions[cacheIndex] = lastInactiveAction, actions.pop(), this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
              }
            }
            uncacheRoot(root) {
              let rootUuid = root.uuid, actionsByClip = this._actionsByClip;
              for (let clipUuid in actionsByClip) {
                let actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
                action !== void 0 && (this._deactivateAction(action), this._removeInactiveAction(action));
              }
              let bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
              if (bindingByName !== void 0)
                for (let trackName in bindingByName) {
                  let binding = bindingByName[trackName];
                  binding.restoreOriginalState(), this._removeInactiveBinding(binding);
                }
            }
            uncacheAction(clip, optionalRoot) {
              let action = this.existingAction(clip, optionalRoot);
              action !== null && (this._deactivateAction(action), this._removeInactiveAction(action));
            }
          }
          class Uniform {
            constructor(value) {
              this.value = value;
            }
            clone() {
              return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
            }
          }
          let _id = 0;
          class UniformsGroup extends EventDispatcher {
            constructor() {
              super();
              this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: _id++ }), this.name = "", this.usage = StaticDrawUsage, this.uniforms = [];
            }
            add(uniform) {
              return this.uniforms.push(uniform), this;
            }
            remove(uniform) {
              let index = this.uniforms.indexOf(uniform);
              return index !== -1 && this.uniforms.splice(index, 1), this;
            }
            setName(name) {
              return this.name = name, this;
            }
            setUsage(value) {
              return this.usage = value, this;
            }
            dispose() {
              return this.dispatchEvent({ type: "dispose" }), this;
            }
            copy(source) {
              this.name = source.name, this.usage = source.usage;
              let uniformsSource = source.uniforms;
              this.uniforms.length = 0;
              for (let i = 0, l = uniformsSource.length; i < l; i++) {
                let uniforms = Array.isArray(uniformsSource[i]) ? uniformsSource[i] : [uniformsSource[i]];
                for (let j = 0; j < uniforms.length; j++)
                  this.uniforms.push(uniforms[j].clone());
              }
              return this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }
          class InstancedInterleavedBuffer extends InterleavedBuffer {
            constructor(array, stride, meshPerAttribute = 1) {
              super(array, stride);
              this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = meshPerAttribute;
            }
            copy(source) {
              return super.copy(source), this.meshPerAttribute = source.meshPerAttribute, this;
            }
            clone(data) {
              let ib = super.clone(data);
              return ib.meshPerAttribute = this.meshPerAttribute, ib;
            }
            toJSON(data) {
              let json = super.toJSON(data);
              return json.isInstancedInterleavedBuffer = !0, json.meshPerAttribute = this.meshPerAttribute, json;
            }
          }
          class GLBufferAttribute {
            constructor(buffer, type, itemSize, elementSize, count) {
              this.isGLBufferAttribute = !0, this.name = "", this.buffer = buffer, this.type = type, this.itemSize = itemSize, this.elementSize = elementSize, this.count = count, this.version = 0;
            }
            set needsUpdate(value) {
              value === !0 && this.version++;
            }
            setBuffer(buffer) {
              return this.buffer = buffer, this;
            }
            setType(type, elementSize) {
              return this.type = type, this.elementSize = elementSize, this;
            }
            setItemSize(itemSize) {
              return this.itemSize = itemSize, this;
            }
            setCount(count) {
              return this.count = count, this;
            }
          }
          let _matrix = /* @__PURE__ */ new Matrix4();
          class Raycaster {
            constructor(origin, direction, near = 0, far = 1 / 0) {
              this.ray = new Ray(origin, direction), this.near = near, this.far = far, this.camera = null, this.layers = new Layers(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
            }
            set(origin, direction) {
              this.ray.set(origin, direction);
            }
            setFromCamera(coords, camera) {
              camera.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(camera.matrixWorld), this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize(), this.camera = camera) : camera.isOrthographicCamera ? (this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera), this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld), this.camera = camera) : console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
            }
            setFromXRController(controller) {
              return _matrix.identity().extractRotation(controller.matrixWorld), this.ray.origin.setFromMatrixPosition(controller.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix), this;
            }
            intersectObject(object, recursive = !0, intersects2 = []) {
              return intersect(object, this, intersects2, recursive), intersects2.sort(ascSort), intersects2;
            }
            intersectObjects(objects, recursive = !0, intersects2 = []) {
              for (let i = 0, l = objects.length; i < l; i++)
                intersect(objects[i], this, intersects2, recursive);
              return intersects2.sort(ascSort), intersects2;
            }
          }
          function ascSort(a, b) {
            return a.distance - b.distance;
          }
          function intersect(object, raycaster, intersects2, recursive) {
            if (object.layers.test(raycaster.layers) && object.raycast(raycaster, intersects2), recursive === !0) {
              let children = object.children;
              for (let i = 0, l = children.length; i < l; i++)
                intersect(children[i], raycaster, intersects2, !0);
            }
          }
          class Spherical {
            constructor(radius = 1, phi = 0, theta = 0) {
              return this.radius = radius, this.phi = phi, this.theta = theta, this;
            }
            set(radius, phi, theta) {
              return this.radius = radius, this.phi = phi, this.theta = theta, this;
            }
            copy(other) {
              return this.radius = other.radius, this.phi = other.phi, this.theta = other.theta, this;
            }
            makeSafe() {
              let EPS = 1e-6;
              return this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi)), this;
            }
            setFromVector3(v) {
              return this.setFromCartesianCoords(v.x, v.y, v.z);
            }
            setFromCartesianCoords(x, y, z) {
              return this.radius = Math.sqrt(x * x + y * y + z * z), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(x, z), this.phi = Math.acos(clamp(y / this.radius, -1, 1))), this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }
          class Cylindrical {
            constructor(radius = 1, theta = 0, y = 0) {
              return this.radius = radius, this.theta = theta, this.y = y, this;
            }
            set(radius, theta, y) {
              return this.radius = radius, this.theta = theta, this.y = y, this;
            }
            copy(other) {
              return this.radius = other.radius, this.theta = other.theta, this.y = other.y, this;
            }
            setFromVector3(v) {
              return this.setFromCartesianCoords(v.x, v.y, v.z);
            }
            setFromCartesianCoords(x, y, z) {
              return this.radius = Math.sqrt(x * x + z * z), this.theta = Math.atan2(x, z), this.y = y, this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }
          let _vector$4 = /* @__PURE__ */ new Vector2();
          class Box2 {
            constructor(min = new Vector2(1 / 0, 1 / 0), max = new Vector2(-1 / 0, -1 / 0)) {
              this.isBox2 = !0, this.min = min, this.max = max;
            }
            set(min, max) {
              return this.min.copy(min), this.max.copy(max), this;
            }
            setFromPoints(points) {
              this.makeEmpty();
              for (let i = 0, il = points.length; i < il; i++)
                this.expandByPoint(points[i]);
              return this;
            }
            setFromCenterAndSize(center, size) {
              let halfSize = _vector$4.copy(size).multiplyScalar(0.5);
              return this.min.copy(center).sub(halfSize), this.max.copy(center).add(halfSize), this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(box) {
              return this.min.copy(box.min), this.max.copy(box.max), this;
            }
            makeEmpty() {
              return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
            }
            isEmpty() {
              return this.max.x < this.min.x || this.max.y < this.min.y;
            }
            getCenter(target) {
              return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
            }
            getSize(target) {
              return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
            }
            expandByPoint(point) {
              return this.min.min(point), this.max.max(point), this;
            }
            expandByVector(vector) {
              return this.min.sub(vector), this.max.add(vector), this;
            }
            expandByScalar(scalar) {
              return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
            }
            containsPoint(point) {
              return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y);
            }
            containsBox(box) {
              return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
            }
            getParameter(point, target) {
              return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
            }
            intersectsBox(box) {
              return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y);
            }
            clampPoint(point, target) {
              return target.copy(point).clamp(this.min, this.max);
            }
            distanceToPoint(point) {
              return this.clampPoint(point, _vector$4).distanceTo(point);
            }
            intersect(box) {
              return this.min.max(box.min), this.max.min(box.max), this.isEmpty() && this.makeEmpty(), this;
            }
            union(box) {
              return this.min.min(box.min), this.max.max(box.max), this;
            }
            translate(offset) {
              return this.min.add(offset), this.max.add(offset), this;
            }
            equals(box) {
              return box.min.equals(this.min) && box.max.equals(this.max);
            }
          }
          let _startP = /* @__PURE__ */ new Vector3(), _startEnd = /* @__PURE__ */ new Vector3();
          class Line3 {
            constructor(start = new Vector3(), end = new Vector3()) {
              this.start = start, this.end = end;
            }
            set(start, end) {
              return this.start.copy(start), this.end.copy(end), this;
            }
            copy(line) {
              return this.start.copy(line.start), this.end.copy(line.end), this;
            }
            getCenter(target) {
              return target.addVectors(this.start, this.end).multiplyScalar(0.5);
            }
            delta(target) {
              return target.subVectors(this.end, this.start);
            }
            distanceSq() {
              return this.start.distanceToSquared(this.end);
            }
            distance() {
              return this.start.distanceTo(this.end);
            }
            at(t, target) {
              return this.delta(target).multiplyScalar(t).add(this.start);
            }
            closestPointToPointParameter(point, clampToLine) {
              _startP.subVectors(point, this.start), _startEnd.subVectors(this.end, this.start);
              let startEnd2 = _startEnd.dot(_startEnd), t = _startEnd.dot(_startP) / startEnd2;
              return clampToLine && (t = clamp(t, 0, 1)), t;
            }
            closestPointToPoint(point, clampToLine, target) {
              let t = this.closestPointToPointParameter(point, clampToLine);
              return this.delta(target).multiplyScalar(t).add(this.start);
            }
            applyMatrix4(matrix) {
              return this.start.applyMatrix4(matrix), this.end.applyMatrix4(matrix), this;
            }
            equals(line) {
              return line.start.equals(this.start) && line.end.equals(this.end);
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }
          let _vector$3 = /* @__PURE__ */ new Vector3();
          class SpotLightHelper extends Object3D {
            constructor(light, color) {
              super();
              this.light = light, this.matrixAutoUpdate = !1, this.color = color, this.type = "SpotLightHelper";
              let geometry = new BufferGeometry(), positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
              for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
                let p1 = i / l * Math.PI * 2, p2 = j / l * Math.PI * 2;
                positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
              }
              geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
              let material = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
              this.cone = new LineSegments(geometry, material), this.add(this.cone), this.update();
            }
            dispose() {
              this.cone.geometry.dispose(), this.cone.material.dispose();
            }
            update() {
              this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
              let coneLength = this.light.distance ? this.light.distance : 1e3, coneWidth = coneLength * Math.tan(this.light.angle);
              this.cone.scale.set(coneWidth, coneWidth, coneLength), _vector$3.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(_vector$3), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
            }
          }
          let _vector$2 = /* @__PURE__ */ new Vector3(), _boneMatrix = /* @__PURE__ */ new Matrix4(), _matrixWorldInv = /* @__PURE__ */ new Matrix4();
          class SkeletonHelper extends LineSegments {
            constructor(object) {
              let bones = getBoneList(object), geometry = new BufferGeometry(), vertices = [], colors = [], color1 = new Color(0, 0, 1), color2 = new Color(0, 1, 0);
              for (let i = 0; i < bones.length; i++) {
                let bone = bones[i];
                bone.parent && bone.parent.isBone && (vertices.push(0, 0, 0), vertices.push(0, 0, 0), colors.push(color1.r, color1.g, color1.b), colors.push(color2.r, color2.g, color2.b));
              }
              geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
              let material = new LineBasicMaterial({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
              super(geometry, material);
              this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = object, this.bones = bones, this.matrix = object.matrixWorld, this.matrixAutoUpdate = !1;
            }
            updateMatrixWorld(force) {
              let bones = this.bones, geometry = this.geometry, position = geometry.getAttribute("position");
              _matrixWorldInv.copy(this.root.matrixWorld).invert();
              for (let i = 0, j = 0; i < bones.length; i++) {
                let bone = bones[i];
                bone.parent && bone.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z), _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld), _vector$2.setFromMatrixPosition(_boneMatrix), position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z), j += 2);
              }
              geometry.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(force);
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }
          function getBoneList(object) {
            let boneList = [];
            object.isBone === !0 && boneList.push(object);
            for (let i = 0; i < object.children.length; i++)
              boneList.push.apply(boneList, getBoneList(object.children[i]));
            return boneList;
          }
          class PointLightHelper extends Mesh {
            constructor(light, sphereSize, color) {
              let geometry = new SphereGeometry(sphereSize, 4, 2), material = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 });
              super(geometry, material);
              this.light = light, this.color = color, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
            update() {
              this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
            }
          }
          let _vector$1 = /* @__PURE__ */ new Vector3(), _color1 = /* @__PURE__ */ new Color(), _color2 = /* @__PURE__ */ new Color();
          class HemisphereLightHelper extends Object3D {
            constructor(light, size, color) {
              super();
              this.light = light, this.matrix = light.matrixWorld, this.matrixAutoUpdate = !1, this.color = color, this.type = "HemisphereLightHelper";
              let geometry = new OctahedronGeometry(size);
              geometry.rotateY(Math.PI * 0.5), this.material = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
              let position = geometry.getAttribute("position"), colors = new Float32Array(position.count * 3);
              geometry.setAttribute("color", new BufferAttribute(colors, 3)), this.add(new Mesh(geometry, this.material)), this.update();
            }
            dispose() {
              this.children[0].geometry.dispose(), this.children[0].material.dispose();
            }
            update() {
              let mesh = this.children[0];
              if (this.color !== void 0)
                this.material.color.set(this.color);
              else {
                let colors = mesh.geometry.getAttribute("color");
                _color1.copy(this.light.color), _color2.copy(this.light.groundColor);
                for (let i = 0, l = colors.count; i < l; i++) {
                  let color = i < l / 2 ? _color1 : _color2;
                  colors.setXYZ(i, color.r, color.g, color.b);
                }
                colors.needsUpdate = !0;
              }
              this.light.updateWorldMatrix(!0, !1), mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
            }
          }
          class GridHelper extends LineSegments {
            constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
              color1 = new Color(color1), color2 = new Color(color2);
              let center = divisions / 2, step = size / divisions, halfSize = size / 2, vertices = [], colors = [];
              for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
                vertices.push(-halfSize, 0, k, halfSize, 0, k), vertices.push(k, 0, -halfSize, k, 0, halfSize);
                let color = i === center ? color1 : color2;
                color.toArray(colors, j), j += 3, color.toArray(colors, j), j += 3, color.toArray(colors, j), j += 3, color.toArray(colors, j), j += 3;
              }
              let geometry = new BufferGeometry();
              geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
              let material = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
              super(geometry, material);
              this.type = "GridHelper";
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }
          class PolarGridHelper extends LineSegments {
            constructor(radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
              color1 = new Color(color1), color2 = new Color(color2);
              let vertices = [], colors = [];
              if (sectors > 1)
                for (let i = 0; i < sectors; i++) {
                  let v = i / sectors * (Math.PI * 2), x = Math.sin(v) * radius, z = Math.cos(v) * radius;
                  vertices.push(0, 0, 0), vertices.push(x, 0, z);
                  let color = i & 1 ? color1 : color2;
                  colors.push(color.r, color.g, color.b), colors.push(color.r, color.g, color.b);
                }
              for (let i = 0; i < rings; i++) {
                let color = i & 1 ? color1 : color2, r = radius - radius / rings * i;
                for (let j = 0; j < divisions; j++) {
                  let v = j / divisions * (Math.PI * 2), x = Math.sin(v) * r, z = Math.cos(v) * r;
                  vertices.push(x, 0, z), colors.push(color.r, color.g, color.b), v = (j + 1) / divisions * (Math.PI * 2), x = Math.sin(v) * r, z = Math.cos(v) * r, vertices.push(x, 0, z), colors.push(color.r, color.g, color.b);
                }
              }
              let geometry = new BufferGeometry();
              geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
              let material = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
              super(geometry, material);
              this.type = "PolarGridHelper";
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }
          let _v1 = /* @__PURE__ */ new Vector3(), _v2 = /* @__PURE__ */ new Vector3(), _v3 = /* @__PURE__ */ new Vector3();
          class DirectionalLightHelper extends Object3D {
            constructor(light, size, color) {
              super();
              this.light = light, this.matrix = light.matrixWorld, this.matrixAutoUpdate = !1, this.color = color, this.type = "DirectionalLightHelper", size === void 0 && (size = 1);
              let geometry = new BufferGeometry();
              geometry.setAttribute("position", new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
              let material = new LineBasicMaterial({ fog: !1, toneMapped: !1 });
              this.lightPlane = new Line(geometry, material), this.add(this.lightPlane), geometry = new BufferGeometry(), geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Line(geometry, material), this.add(this.targetLine), this.update();
            }
            dispose() {
              this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
            }
            update() {
              this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), _v1.setFromMatrixPosition(this.light.matrixWorld), _v2.setFromMatrixPosition(this.light.target.matrixWorld), _v3.subVectors(_v2, _v1), this.lightPlane.lookAt(_v2), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(_v2), this.targetLine.scale.z = _v3.length();
            }
          }
          let _vector = /* @__PURE__ */ new Vector3(), _camera = /* @__PURE__ */ new Camera();
          class CameraHelper extends LineSegments {
            constructor(camera) {
              let geometry = new BufferGeometry(), material = new LineBasicMaterial({ color: 16777215, vertexColors: !0, toneMapped: !1 }), vertices = [], colors = [], pointMap = {};
              addLine("n1", "n2"), addLine("n2", "n4"), addLine("n4", "n3"), addLine("n3", "n1"), addLine("f1", "f2"), addLine("f2", "f4"), addLine("f4", "f3"), addLine("f3", "f1"), addLine("n1", "f1"), addLine("n2", "f2"), addLine("n3", "f3"), addLine("n4", "f4"), addLine("p", "n1"), addLine("p", "n2"), addLine("p", "n3"), addLine("p", "n4"), addLine("u1", "u2"), addLine("u2", "u3"), addLine("u3", "u1"), addLine("c", "t"), addLine("p", "c"), addLine("cn1", "cn2"), addLine("cn3", "cn4"), addLine("cf1", "cf2"), addLine("cf3", "cf4");
              function addLine(a, b) {
                addPoint(a), addPoint(b);
              }
              function addPoint(id) {
                vertices.push(0, 0, 0), colors.push(0, 0, 0), pointMap[id] === void 0 && (pointMap[id] = []), pointMap[id].push(vertices.length / 3 - 1);
              }
              geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
              super(geometry, material);
              this.type = "CameraHelper", this.camera = camera, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = camera.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = pointMap, this.update();
              let colorFrustum = new Color(16755200), colorCone = new Color(16711680), colorUp = new Color(43775), colorTarget = new Color(16777215), colorCross = new Color(3355443);
              this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
            }
            setColors(frustum, cone, up, target, cross) {
              let colorAttribute = this.geometry.getAttribute("color");
              colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b), colorAttribute.setXYZ(24, cone.r, cone.g, cone.b), colorAttribute.setXYZ(25, cone.r, cone.g, cone.b), colorAttribute.setXYZ(26, cone.r, cone.g, cone.b), colorAttribute.setXYZ(27, cone.r, cone.g, cone.b), colorAttribute.setXYZ(28, cone.r, cone.g, cone.b), colorAttribute.setXYZ(29, cone.r, cone.g, cone.b), colorAttribute.setXYZ(30, cone.r, cone.g, cone.b), colorAttribute.setXYZ(31, cone.r, cone.g, cone.b), colorAttribute.setXYZ(32, up.r, up.g, up.b), colorAttribute.setXYZ(33, up.r, up.g, up.b), colorAttribute.setXYZ(34, up.r, up.g, up.b), colorAttribute.setXYZ(35, up.r, up.g, up.b), colorAttribute.setXYZ(36, up.r, up.g, up.b), colorAttribute.setXYZ(37, up.r, up.g, up.b), colorAttribute.setXYZ(38, target.r, target.g, target.b), colorAttribute.setXYZ(39, target.r, target.g, target.b), colorAttribute.setXYZ(40, cross.r, cross.g, cross.b), colorAttribute.setXYZ(41, cross.r, cross.g, cross.b), colorAttribute.setXYZ(42, cross.r, cross.g, cross.b), colorAttribute.setXYZ(43, cross.r, cross.g, cross.b), colorAttribute.setXYZ(44, cross.r, cross.g, cross.b), colorAttribute.setXYZ(45, cross.r, cross.g, cross.b), colorAttribute.setXYZ(46, cross.r, cross.g, cross.b), colorAttribute.setXYZ(47, cross.r, cross.g, cross.b), colorAttribute.setXYZ(48, cross.r, cross.g, cross.b), colorAttribute.setXYZ(49, cross.r, cross.g, cross.b), colorAttribute.needsUpdate = !0;
            }
            update() {
              let geometry = this.geometry, pointMap = this.pointMap, w = 1, h = 1;
              _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), setPoint("c", pointMap, geometry, _camera, 0, 0, -1), setPoint("t", pointMap, geometry, _camera, 0, 0, 1), setPoint("n1", pointMap, geometry, _camera, -w, -h, -1), setPoint("n2", pointMap, geometry, _camera, w, -h, -1), setPoint("n3", pointMap, geometry, _camera, -w, h, -1), setPoint("n4", pointMap, geometry, _camera, w, h, -1), setPoint("f1", pointMap, geometry, _camera, -w, -h, 1), setPoint("f2", pointMap, geometry, _camera, w, -h, 1), setPoint("f3", pointMap, geometry, _camera, -w, h, 1), setPoint("f4", pointMap, geometry, _camera, w, h, 1), setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1), setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1), setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1), setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1), setPoint("cf2", pointMap, geometry, _camera, w, 0, 1), setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1), setPoint("cf4", pointMap, geometry, _camera, 0, h, 1), setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1), setPoint("cn2", pointMap, geometry, _camera, w, 0, -1), setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1), setPoint("cn4", pointMap, geometry, _camera, 0, h, -1), geometry.getAttribute("position").needsUpdate = !0;
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }
          function setPoint(point, pointMap, geometry, camera, x, y, z) {
            _vector.set(x, y, z).unproject(camera);
            let points = pointMap[point];
            if (points !== void 0) {
              let position = geometry.getAttribute("position");
              for (let i = 0, l = points.length; i < l; i++)
                position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
            }
          }
          let _box = /* @__PURE__ */ new Box3();
          class BoxHelper extends LineSegments {
            constructor(object, color = 16776960) {
              let indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), positions = new Float32Array(8 * 3), geometry = new BufferGeometry();
              geometry.setIndex(new BufferAttribute(indices, 1)), geometry.setAttribute("position", new BufferAttribute(positions, 3));
              super(geometry, new LineBasicMaterial({ color, toneMapped: !1 }));
              this.object = object, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
            }
            update(object) {
              if (object !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && _box.setFromObject(this.object), _box.isEmpty())
                return;
              let min = _box.min, max = _box.max, position = this.geometry.attributes.position, array = position.array;
              array[0] = max.x, array[1] = max.y, array[2] = max.z, array[3] = min.x, array[4] = max.y, array[5] = max.z, array[6] = min.x, array[7] = min.y, array[8] = max.z, array[9] = max.x, array[10] = min.y, array[11] = max.z, array[12] = max.x, array[13] = max.y, array[14] = min.z, array[15] = min.x, array[16] = max.y, array[17] = min.z, array[18] = min.x, array[19] = min.y, array[20] = min.z, array[21] = max.x, array[22] = min.y, array[23] = min.z, position.needsUpdate = !0, this.geometry.computeBoundingSphere();
            }
            setFromObject(object) {
              return this.object = object, this.update(), this;
            }
            copy(source, recursive) {
              return super.copy(source, recursive), this.object = source.object, this;
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }
          class Box3Helper extends LineSegments {
            constructor(box, color = 16776960) {
              let indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], geometry = new BufferGeometry();
              geometry.setIndex(new BufferAttribute(indices, 1)), geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
              super(geometry, new LineBasicMaterial({ color, toneMapped: !1 }));
              this.box = box, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
            }
            updateMatrixWorld(force) {
              let box = this.box;
              box.isEmpty() || (box.getCenter(this.position), box.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(force));
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }
          class PlaneHelper extends Line {
            constructor(plane, size = 1, hex = 16776960) {
              let color = hex, positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], geometry = new BufferGeometry();
              geometry.setAttribute("position", new Float32BufferAttribute(positions, 3)), geometry.computeBoundingSphere();
              super(geometry, new LineBasicMaterial({ color, toneMapped: !1 }));
              this.type = "PlaneHelper", this.plane = plane, this.size = size;
              let positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], geometry2 = new BufferGeometry();
              geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3)), geometry2.computeBoundingSphere(), this.add(new Mesh(geometry2, new MeshBasicMaterial({ color, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
            }
            updateMatrixWorld(force) {
              this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(force);
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
            }
          }
          let _axis = /* @__PURE__ */ new Vector3(), _lineGeometry, _coneGeometry;
          class ArrowHelper extends Object3D {
            constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
              super();
              this.type = "ArrowHelper", _lineGeometry === void 0 && (_lineGeometry = new BufferGeometry(), _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)), _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1), _coneGeometry.translate(0, -0.5, 0)), this.position.copy(origin), this.line = new Line(_lineGeometry, new LineBasicMaterial({ color, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(dir), this.setLength(length, headLength, headWidth);
            }
            setDirection(dir) {
              if (dir.y > 0.99999)
                this.quaternion.set(0, 0, 0, 1);
              else if (dir.y < -0.99999)
                this.quaternion.set(1, 0, 0, 0);
              else {
                _axis.set(dir.z, 0, -dir.x).normalize();
                let radians = Math.acos(dir.y);
                this.quaternion.setFromAxisAngle(_axis, radians);
              }
            }
            setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
              this.line.scale.set(1, Math.max(1e-4, length - headLength), 1), this.line.updateMatrix(), this.cone.scale.set(headWidth, headLength, headWidth), this.cone.position.y = length, this.cone.updateMatrix();
            }
            setColor(color) {
              this.line.material.color.set(color), this.cone.material.color.set(color);
            }
            copy(source) {
              return super.copy(source, !1), this.line.copy(source.line), this.cone.copy(source.cone), this;
            }
            dispose() {
              this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
            }
          }
          class AxesHelper extends LineSegments {
            constructor(size = 1) {
              let vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size], colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], geometry = new BufferGeometry();
              geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
              let material = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 });
              super(geometry, material);
              this.type = "AxesHelper";
            }
            setColors(xAxisColor, yAxisColor, zAxisColor) {
              let color = new Color(), array = this.geometry.attributes.color.array;
              return color.set(xAxisColor), color.toArray(array, 0), color.toArray(array, 3), color.set(yAxisColor), color.toArray(array, 6), color.toArray(array, 9), color.set(zAxisColor), color.toArray(array, 12), color.toArray(array, 15), this.geometry.attributes.color.needsUpdate = !0, this;
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }
          class ShapePath {
            constructor() {
              this.type = "ShapePath", this.color = new Color(), this.subPaths = [], this.currentPath = null;
            }
            moveTo(x, y) {
              return this.currentPath = new Path(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(x, y), this;
            }
            lineTo(x, y) {
              return this.currentPath.lineTo(x, y), this;
            }
            quadraticCurveTo(aCPx, aCPy, aX, aY) {
              return this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
            }
            bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
              return this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
            }
            splineThru(pts) {
              return this.currentPath.splineThru(pts), this;
            }
            toShapes(isCCW) {
              function toShapesNoHoles(inSubpaths) {
                let shapes2 = [];
                for (let i = 0, l = inSubpaths.length; i < l; i++) {
                  let tmpPath2 = inSubpaths[i], tmpShape2 = new Shape();
                  tmpShape2.curves = tmpPath2.curves, shapes2.push(tmpShape2);
                }
                return shapes2;
              }
              function isPointInsidePolygon(inPt, inPolygon) {
                let polyLen = inPolygon.length, inside = !1;
                for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                  let edgeLowPt = inPolygon[p], edgeHighPt = inPolygon[q], edgeDx = edgeHighPt.x - edgeLowPt.x, edgeDy = edgeHighPt.y - edgeLowPt.y;
                  if (Math.abs(edgeDy) > Number.EPSILON) {
                    if (edgeDy < 0 && (edgeLowPt = inPolygon[q], edgeDx = -edgeDx, edgeHighPt = inPolygon[p], edgeDy = -edgeDy), inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                      continue;
                    if (inPt.y === edgeLowPt.y) {
                      if (inPt.x === edgeLowPt.x)
                        return !0;
                    } else {
                      let perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                      if (perpEdge === 0)
                        return !0;
                      if (perpEdge < 0)
                        continue;
                      inside = !inside;
                    }
                  } else {
                    if (inPt.y !== edgeLowPt.y)
                      continue;
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                      return !0;
                  }
                }
                return inside;
              }
              let isClockWise = ShapeUtils.isClockWise, subPaths = this.subPaths;
              if (subPaths.length === 0)
                return [];
              let solid, tmpPath, tmpShape, shapes = [];
              if (subPaths.length === 1)
                return tmpPath = subPaths[0], tmpShape = new Shape(), tmpShape.curves = tmpPath.curves, shapes.push(tmpShape), shapes;
              let holesFirst = !isClockWise(subPaths[0].getPoints());
              holesFirst = isCCW ? !holesFirst : holesFirst;
              let betterShapeHoles = [], newShapes = [], newShapeHoles = [], mainIdx = 0, tmpPoints;
              newShapes[mainIdx] = void 0, newShapeHoles[mainIdx] = [];
              for (let i = 0, l = subPaths.length; i < l; i++)
                tmpPath = subPaths[i], tmpPoints = tmpPath.getPoints(), solid = isClockWise(tmpPoints), solid = isCCW ? !solid : solid, solid ? (!holesFirst && newShapes[mainIdx] && mainIdx++, newShapes[mainIdx] = { s: new Shape(), p: tmpPoints }, newShapes[mainIdx].s.curves = tmpPath.curves, holesFirst && mainIdx++, newShapeHoles[mainIdx] = []) : newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
              if (!newShapes[0])
                return toShapesNoHoles(subPaths);
              if (newShapes.length > 1) {
                let ambiguous = !1, toChange = 0;
                for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)
                  betterShapeHoles[sIdx] = [];
                for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                  let sho = newShapeHoles[sIdx];
                  for (let hIdx = 0; hIdx < sho.length; hIdx++) {
                    let ho = sho[hIdx], hole_unassigned = !0;
                    for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++)
                      isPointInsidePolygon(ho.p, newShapes[s2Idx].p) && (sIdx !== s2Idx && toChange++, hole_unassigned ? (hole_unassigned = !1, betterShapeHoles[s2Idx].push(ho)) : ambiguous = !0);
                    hole_unassigned && betterShapeHoles[sIdx].push(ho);
                  }
                }
                toChange > 0 && ambiguous === !1 && (newShapeHoles = betterShapeHoles);
              }
              let tmpHoles;
              for (let i = 0, il = newShapes.length; i < il; i++) {
                tmpShape = newShapes[i].s, shapes.push(tmpShape), tmpHoles = newShapeHoles[i];
                for (let j = 0, jl = tmpHoles.length; j < jl; j++)
                  tmpShape.holes.push(tmpHoles[j].h);
              }
              return shapes;
            }
          }
          class WebGLMultipleRenderTargets extends WebGLRenderTarget {
            constructor(width = 1, height = 1, count = 1, options = {}) {
              console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.');
              super(width, height, { ...options, count });
              this.isWebGLMultipleRenderTargets = !0;
            }
            get texture() {
              return this.textures;
            }
          }
          typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: REVISION } })), typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);
        },
        "./node_modules/three/examples/jsm/libs/ktx-parse.module.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            KHR_DF_CHANNEL_RGBSDA_ALPHA: () => Q,
            KHR_DF_CHANNEL_RGBSDA_BLUE: () => q,
            KHR_DF_CHANNEL_RGBSDA_DEPTH: () => J,
            KHR_DF_CHANNEL_RGBSDA_GREEN: () => Y,
            KHR_DF_CHANNEL_RGBSDA_RED: () => R,
            KHR_DF_CHANNEL_RGBSDA_STENCIL: () => G,
            KHR_DF_FLAG_ALPHA_PREMULTIPLIED: () => p,
            KHR_DF_FLAG_ALPHA_STRAIGHT: () => _,
            KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT: () => s,
            KHR_DF_MODEL_ASTC: () => c,
            KHR_DF_MODEL_ETC1: () => f,
            KHR_DF_MODEL_ETC1S: () => h,
            KHR_DF_MODEL_ETC2: () => U,
            KHR_DF_MODEL_RGBSDA: () => l,
            KHR_DF_MODEL_UNSPECIFIED: () => o,
            KHR_DF_PRIMARIES_ACES: () => W,
            KHR_DF_PRIMARIES_ACESCC: () => N,
            KHR_DF_PRIMARIES_ADOBERGB: () => j,
            KHR_DF_PRIMARIES_BT2020: () => z,
            KHR_DF_PRIMARIES_BT601_EBU: () => P,
            KHR_DF_PRIMARIES_BT601_SMPTE: () => C,
            KHR_DF_PRIMARIES_BT709: () => F,
            KHR_DF_PRIMARIES_CIEXYZ: () => M,
            KHR_DF_PRIMARIES_DISPLAYP3: () => X,
            KHR_DF_PRIMARIES_NTSC1953: () => H,
            KHR_DF_PRIMARIES_PAL525: () => K,
            KHR_DF_PRIMARIES_UNSPECIFIED: () => E,
            KHR_DF_SAMPLE_DATATYPE_EXPONENT: () => tt,
            KHR_DF_SAMPLE_DATATYPE_FLOAT: () => Z,
            KHR_DF_SAMPLE_DATATYPE_LINEAR: () => et,
            KHR_DF_SAMPLE_DATATYPE_SIGNED: () => $,
            KHR_DF_TRANSFER_ACESCC: () => O,
            KHR_DF_TRANSFER_ACESCCT: () => T,
            KHR_DF_TRANSFER_ADOBERGB: () => V,
            KHR_DF_TRANSFER_BT1886: () => w,
            KHR_DF_TRANSFER_DCIP3: () => k,
            KHR_DF_TRANSFER_HLG_EOTF: () => B,
            KHR_DF_TRANSFER_HLG_OETF: () => D,
            KHR_DF_TRANSFER_ITU: () => u,
            KHR_DF_TRANSFER_LINEAR: () => y,
            KHR_DF_TRANSFER_NTSC: () => b,
            KHR_DF_TRANSFER_PAL625_EOTF: () => S,
            KHR_DF_TRANSFER_PAL_OETF: () => v,
            KHR_DF_TRANSFER_PQ_EOTF: () => L,
            KHR_DF_TRANSFER_PQ_OETF: () => A,
            KHR_DF_TRANSFER_SLOG: () => d,
            KHR_DF_TRANSFER_SLOG2: () => m,
            KHR_DF_TRANSFER_SRGB: () => x,
            KHR_DF_TRANSFER_ST240: () => I,
            KHR_DF_TRANSFER_UNSPECIFIED: () => g,
            KHR_DF_VENDORID_KHRONOS: () => a,
            KHR_DF_VERSION: () => r,
            KHR_SUPERCOMPRESSION_BASISLZ: () => e,
            KHR_SUPERCOMPRESSION_NONE: () => t,
            KHR_SUPERCOMPRESSION_ZLIB: () => i,
            KHR_SUPERCOMPRESSION_ZSTD: () => n,
            KTX2Container: () => Si,
            VK_FORMAT_A1R5G5B5_UNORM_PACK16: () => Ut,
            VK_FORMAT_A2B10G10R10_SINT_PACK32: () => qt,
            VK_FORMAT_A2B10G10R10_SNORM_PACK32: () => Rt,
            VK_FORMAT_A2B10G10R10_UINT_PACK32: () => Yt,
            VK_FORMAT_A2B10G10R10_UNORM_PACK32: () => jt,
            VK_FORMAT_A2R10G10B10_SINT_PACK32: () => Xt,
            VK_FORMAT_A2R10G10B10_SNORM_PACK32: () => Ht,
            VK_FORMAT_A2R10G10B10_UINT_PACK32: () => Kt,
            VK_FORMAT_A2R10G10B10_UNORM_PACK32: () => Nt,
            VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: () => vi,
            VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: () => ki,
            VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: () => Bi,
            VK_FORMAT_ASTC_10x10_SRGB_BLOCK: () => Xn,
            VK_FORMAT_ASTC_10x10_UNORM_BLOCK: () => Kn,
            VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: () => mi,
            VK_FORMAT_ASTC_10x5_SRGB_BLOCK: () => zn,
            VK_FORMAT_ASTC_10x5_UNORM_BLOCK: () => Cn,
            VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: () => wi,
            VK_FORMAT_ASTC_10x6_SRGB_BLOCK: () => Wn,
            VK_FORMAT_ASTC_10x6_UNORM_BLOCK: () => Mn,
            VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: () => Di,
            VK_FORMAT_ASTC_10x8_SRGB_BLOCK: () => Hn,
            VK_FORMAT_ASTC_10x8_UNORM_BLOCK: () => Nn,
            VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: () => Li,
            VK_FORMAT_ASTC_12x10_SRGB_BLOCK: () => Rn,
            VK_FORMAT_ASTC_12x10_UNORM_BLOCK: () => jn,
            VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: () => Ai,
            VK_FORMAT_ASTC_12x12_SRGB_BLOCK: () => qn,
            VK_FORMAT_ASTC_12x12_UNORM_BLOCK: () => Yn,
            VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: () => _i,
            VK_FORMAT_ASTC_4x4_SRGB_BLOCK: () => wn,
            VK_FORMAT_ASTC_4x4_UNORM_BLOCK: () => mn,
            VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: () => pi,
            VK_FORMAT_ASTC_5x4_SRGB_BLOCK: () => Bn,
            VK_FORMAT_ASTC_5x4_UNORM_BLOCK: () => Dn,
            VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: () => gi,
            VK_FORMAT_ASTC_5x5_SRGB_BLOCK: () => An,
            VK_FORMAT_ASTC_5x5_UNORM_BLOCK: () => Ln,
            VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: () => yi,
            VK_FORMAT_ASTC_6x5_SRGB_BLOCK: () => vn,
            VK_FORMAT_ASTC_6x5_UNORM_BLOCK: () => kn,
            VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: () => xi,
            VK_FORMAT_ASTC_6x6_SRGB_BLOCK: () => In,
            VK_FORMAT_ASTC_6x6_UNORM_BLOCK: () => Sn,
            VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: () => ui,
            VK_FORMAT_ASTC_8x5_SRGB_BLOCK: () => Tn,
            VK_FORMAT_ASTC_8x5_UNORM_BLOCK: () => On,
            VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: () => bi,
            VK_FORMAT_ASTC_8x6_SRGB_BLOCK: () => En,
            VK_FORMAT_ASTC_8x6_UNORM_BLOCK: () => Vn,
            VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: () => di,
            VK_FORMAT_ASTC_8x8_SRGB_BLOCK: () => Pn,
            VK_FORMAT_ASTC_8x8_UNORM_BLOCK: () => Fn,
            VK_FORMAT_B10G11R11_UFLOAT_PACK32: () => Me,
            VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: () => $n,
            VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: () => si,
            VK_FORMAT_B4G4R4A4_UNORM_PACK16: () => at,
            VK_FORMAT_B5G5R5A1_UNORM_PACK16: () => ft,
            VK_FORMAT_B5G6R5_UNORM_PACK16: () => ot,
            VK_FORMAT_B8G8R8A8_SINT: () => Mt,
            VK_FORMAT_B8G8R8A8_SNORM: () => Ct,
            VK_FORMAT_B8G8R8A8_SRGB: () => Wt,
            VK_FORMAT_B8G8R8A8_UINT: () => zt,
            VK_FORMAT_B8G8R8A8_UNORM: () => Pt,
            VK_FORMAT_B8G8R8_SINT: () => St,
            VK_FORMAT_B8G8R8_SNORM: () => kt,
            VK_FORMAT_B8G8R8_SRGB: () => It,
            VK_FORMAT_B8G8R8_UINT: () => vt,
            VK_FORMAT_B8G8R8_UNORM: () => At,
            VK_FORMAT_BC1_RGBA_SRGB_BLOCK: () => Qe,
            VK_FORMAT_BC1_RGBA_UNORM_BLOCK: () => Je,
            VK_FORMAT_BC1_RGB_SRGB_BLOCK: () => Ge,
            VK_FORMAT_BC1_RGB_UNORM_BLOCK: () => qe,
            VK_FORMAT_BC2_SRGB_BLOCK: () => $e,
            VK_FORMAT_BC2_UNORM_BLOCK: () => Ze,
            VK_FORMAT_BC3_SRGB_BLOCK: () => en,
            VK_FORMAT_BC3_UNORM_BLOCK: () => tn,
            VK_FORMAT_BC4_SNORM_BLOCK: () => sn,
            VK_FORMAT_BC4_UNORM_BLOCK: () => nn,
            VK_FORMAT_BC5_SNORM_BLOCK: () => rn,
            VK_FORMAT_BC5_UNORM_BLOCK: () => an,
            VK_FORMAT_BC6H_SFLOAT_BLOCK: () => ln,
            VK_FORMAT_BC6H_UFLOAT_BLOCK: () => on,
            VK_FORMAT_BC7_SRGB_BLOCK: () => Un,
            VK_FORMAT_BC7_UNORM_BLOCK: () => fn,
            VK_FORMAT_D16_UNORM: () => Ne,
            VK_FORMAT_D16_UNORM_S8_UINT: () => je,
            VK_FORMAT_D24_UNORM_S8_UINT: () => Re,
            VK_FORMAT_D32_SFLOAT: () => Ke,
            VK_FORMAT_D32_SFLOAT_S8_UINT: () => Ye,
            VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: () => We,
            VK_FORMAT_EAC_R11G11_SNORM_BLOCK: () => dn,
            VK_FORMAT_EAC_R11G11_UNORM_BLOCK: () => bn,
            VK_FORMAT_EAC_R11_SNORM_BLOCK: () => un,
            VK_FORMAT_EAC_R11_UNORM_BLOCK: () => xn,
            VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: () => pn,
            VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: () => _n,
            VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: () => yn,
            VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: () => gn,
            VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: () => hn,
            VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: () => cn,
            VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: () => Zn,
            VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: () => ii,
            VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: () => fi,
            VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: () => ai,
            VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: () => Ui,
            VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: () => ri,
            VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: () => ci,
            VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: () => oi,
            VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: () => hi,
            VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: () => li,
            VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: () => Qn,
            VK_FORMAT_R10X6G10X6_UNORM_2PACK16: () => Jn,
            VK_FORMAT_R10X6_UNORM_PACK16: () => Gn,
            VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: () => ni,
            VK_FORMAT_R12X4G12X4_UNORM_2PACK16: () => ei,
            VK_FORMAT_R12X4_UNORM_PACK16: () => ti,
            VK_FORMAT_R16G16B16A16_SFLOAT: () => pe,
            VK_FORMAT_R16G16B16A16_SINT: () => _e,
            VK_FORMAT_R16G16B16A16_SNORM: () => ce,
            VK_FORMAT_R16G16B16A16_UINT: () => he,
            VK_FORMAT_R16G16B16A16_UNORM: () => Ue,
            VK_FORMAT_R16G16B16_SFLOAT: () => fe,
            VK_FORMAT_R16G16B16_SINT: () => le,
            VK_FORMAT_R16G16B16_SNORM: () => re,
            VK_FORMAT_R16G16B16_UINT: () => oe,
            VK_FORMAT_R16G16B16_UNORM: () => ae,
            VK_FORMAT_R16G16_SFLOAT: () => se,
            VK_FORMAT_R16G16_SINT: () => ie,
            VK_FORMAT_R16G16_SNORM: () => ee,
            VK_FORMAT_R16G16_UINT: () => ne,
            VK_FORMAT_R16G16_UNORM: () => te,
            VK_FORMAT_R16_SFLOAT: () => $t,
            VK_FORMAT_R16_SINT: () => Zt,
            VK_FORMAT_R16_SNORM: () => Jt,
            VK_FORMAT_R16_UINT: () => Qt,
            VK_FORMAT_R16_UNORM: () => Gt,
            VK_FORMAT_R32G32B32A32_SFLOAT: () => Ae,
            VK_FORMAT_R32G32B32A32_SINT: () => Le,
            VK_FORMAT_R32G32B32A32_UINT: () => Be,
            VK_FORMAT_R32G32B32_SFLOAT: () => De,
            VK_FORMAT_R32G32B32_SINT: () => we,
            VK_FORMAT_R32G32B32_UINT: () => me,
            VK_FORMAT_R32G32_SFLOAT: () => de,
            VK_FORMAT_R32G32_SINT: () => be,
            VK_FORMAT_R32G32_UINT: () => ue,
            VK_FORMAT_R32_SFLOAT: () => xe,
            VK_FORMAT_R32_SINT: () => ye,
            VK_FORMAT_R32_UINT: () => ge,
            VK_FORMAT_R4G4B4A4_UNORM_PACK16: () => st,
            VK_FORMAT_R4G4_UNORM_PACK8: () => it,
            VK_FORMAT_R5G5B5A1_UNORM_PACK16: () => lt,
            VK_FORMAT_R5G6B5_UNORM_PACK16: () => rt,
            VK_FORMAT_R64G64B64A64_SFLOAT: () => ze,
            VK_FORMAT_R64G64B64A64_SINT: () => Ce,
            VK_FORMAT_R64G64B64A64_UINT: () => Pe,
            VK_FORMAT_R64G64B64_SFLOAT: () => Fe,
            VK_FORMAT_R64G64B64_SINT: () => Ee,
            VK_FORMAT_R64G64B64_UINT: () => Ve,
            VK_FORMAT_R64G64_SFLOAT: () => Te,
            VK_FORMAT_R64G64_SINT: () => Oe,
            VK_FORMAT_R64G64_UINT: () => Ie,
            VK_FORMAT_R64_SFLOAT: () => Se,
            VK_FORMAT_R64_SINT: () => ve,
            VK_FORMAT_R64_UINT: () => ke,
            VK_FORMAT_R8G8B8A8_SINT: () => Et,
            VK_FORMAT_R8G8B8A8_SNORM: () => Tt,
            VK_FORMAT_R8G8B8A8_SRGB: () => Ft,
            VK_FORMAT_R8G8B8A8_UINT: () => Vt,
            VK_FORMAT_R8G8B8A8_UNORM: () => Ot,
            VK_FORMAT_R8G8B8_SINT: () => Bt,
            VK_FORMAT_R8G8B8_SNORM: () => wt,
            VK_FORMAT_R8G8B8_SRGB: () => Lt,
            VK_FORMAT_R8G8B8_UINT: () => Dt,
            VK_FORMAT_R8G8B8_UNORM: () => mt,
            VK_FORMAT_R8G8_SINT: () => bt,
            VK_FORMAT_R8G8_SNORM: () => xt,
            VK_FORMAT_R8G8_SRGB: () => dt,
            VK_FORMAT_R8G8_UINT: () => ut,
            VK_FORMAT_R8G8_UNORM: () => yt,
            VK_FORMAT_R8_SINT: () => pt,
            VK_FORMAT_R8_SNORM: () => ht,
            VK_FORMAT_R8_SRGB: () => gt,
            VK_FORMAT_R8_UINT: () => _t,
            VK_FORMAT_R8_UNORM: () => ct,
            VK_FORMAT_S8_UINT: () => Xe,
            VK_FORMAT_UNDEFINED: () => nt,
            VK_FORMAT_X8_D24_UNORM_PACK32: () => He,
            read: () => Pi,
            write: () => Mi
          });
          var Buffer2 = __webpack_require__2("./node_modules/buffer/index.js").Buffer;
          let t = 0, e = 1, n = 2, i = 3, s = 0, a = 0, r = 2, o = 0, l = 1, f = 160, U = 161, c = 162, h = 163, _ = 0, p = 1, g = 0, y = 1, x = 2, u = 3, b = 4, d = 5, m = 6, w = 7, D = 8, B = 9, L = 10, A = 11, k = 12, v = 13, S = 14, I = 15, O = 16, T = 17, V = 18, E = 0, F = 1, P = 2, C = 3, z = 4, M = 5, W = 6, N = 7, H = 8, K = 9, X = 10, j = 11, R = 0, Y = 1, q = 2, G = 13, J = 14, Q = 15, Z = 128, $ = 64, tt = 32, et = 16, nt = 0, it = 1, st = 2, at = 3, rt = 4, ot = 5, lt = 6, ft = 7, Ut = 8, ct = 9, ht = 10, _t = 13, pt = 14, gt = 15, yt = 16, xt = 17, ut = 20, bt = 21, dt = 22, mt = 23, wt = 24, Dt = 27, Bt = 28, Lt = 29, At = 30, kt = 31, vt = 34, St = 35, It = 36, Ot = 37, Tt = 38, Vt = 41, Et = 42, Ft = 43, Pt = 44, Ct = 45, zt = 48, Mt = 49, Wt = 50, Nt = 58, Ht = 59, Kt = 62, Xt = 63, jt = 64, Rt = 65, Yt = 68, qt = 69, Gt = 70, Jt = 71, Qt = 74, Zt = 75, $t = 76, te = 77, ee = 78, ne = 81, ie = 82, se = 83, ae = 84, re = 85, oe = 88, le = 89, fe = 90, Ue = 91, ce = 92, he = 95, _e = 96, pe = 97, ge = 98, ye = 99, xe = 100, ue = 101, be = 102, de = 103, me = 104, we = 105, De = 106, Be = 107, Le = 108, Ae = 109, ke = 110, ve = 111, Se = 112, Ie = 113, Oe = 114, Te = 115, Ve = 116, Ee = 117, Fe = 118, Pe = 119, Ce = 120, ze = 121, Me = 122, We = 123, Ne = 124, He = 125, Ke = 126, Xe = 127, je = 128, Re = 129, Ye = 130, qe = 131, Ge = 132, Je = 133, Qe = 134, Ze = 135, $e = 136, tn = 137, en = 138, nn = 139, sn = 140, an = 141, rn = 142, on = 143, ln = 144, fn = 145, Un = 146, cn = 147, hn = 148, _n = 149, pn = 150, gn = 151, yn = 152, xn = 153, un = 154, bn = 155, dn = 156, mn = 157, wn = 158, Dn = 159, Bn = 160, Ln = 161, An = 162, kn = 163, vn = 164, Sn = 165, In = 166, On = 167, Tn = 168, Vn = 169, En = 170, Fn = 171, Pn = 172, Cn = 173, zn = 174, Mn = 175, Wn = 176, Nn = 177, Hn = 178, Kn = 179, Xn = 180, jn = 181, Rn = 182, Yn = 183, qn = 184, Gn = 1000156007, Jn = 1000156008, Qn = 1000156009, Zn = 1000156010, $n = 1000156011, ti = 1000156017, ei = 1000156018, ni = 1000156019, ii = 1000156020, si = 1000156021, ai = 1000054e3, ri = 1000054001, oi = 1000054002, li = 1000054003, fi = 1000054004, Ui = 1000054005, ci = 1000054006, hi = 1000054007, _i = 1000066e3, pi = 1000066001, gi = 1000066002, yi = 1000066003, xi = 1000066004, ui = 1000066005, bi = 1000066006, di = 1000066007, mi = 1000066008, wi = 1000066009, Di = 1000066010, Bi = 1000066011, Li = 1000066012, Ai = 1000066013, ki = 100034e4, vi = 1000340001;
          class Si {
            constructor() {
              this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
                vendorId: 0,
                descriptorType: 0,
                descriptorBlockSize: 0,
                versionNumber: 2,
                colorModel: 0,
                colorPrimaries: 1,
                transferFunction: 2,
                flags: 0,
                texelBlockDimension: [0, 0, 0, 0],
                bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                samples: []
              }], this.keyValue = {}, this.globalData = null;
            }
          }
          class Ii {
            constructor(t2, e2, n2, i2) {
              this._dataView = new DataView(t2.buffer, t2.byteOffset + e2, n2), this._littleEndian = i2, this._offset = 0;
            }
            _nextUint8() {
              let t2 = this._dataView.getUint8(this._offset);
              return this._offset += 1, t2;
            }
            _nextUint16() {
              let t2 = this._dataView.getUint16(this._offset, this._littleEndian);
              return this._offset += 2, t2;
            }
            _nextUint32() {
              let t2 = this._dataView.getUint32(this._offset, this._littleEndian);
              return this._offset += 4, t2;
            }
            _nextUint64() {
              let t2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
              return this._offset += 8, t2;
            }
            _nextInt32() {
              let t2 = this._dataView.getInt32(this._offset, this._littleEndian);
              return this._offset += 4, t2;
            }
            _skip(t2) {
              return this._offset += t2, this;
            }
            _scan(t2, e2 = 0) {
              let n2 = this._offset, i2 = 0;
              for (; this._dataView.getUint8(this._offset) !== e2 && i2 < t2; )
                i2++, this._offset++;
              return i2 < t2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i2);
            }
          }
          let Oi = new Uint8Array([0]), Ti = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
          function Vi(t2) {
            return typeof TextEncoder != "undefined" ? new TextEncoder().encode(t2) : Buffer2.from(t2);
          }
          function Ei(t2) {
            return typeof TextDecoder != "undefined" ? new TextDecoder().decode(t2) : Buffer2.from(t2).toString("utf8");
          }
          function Fi(t2) {
            let e2 = 0;
            for (let n3 of t2)
              e2 += n3.byteLength;
            let n2 = new Uint8Array(e2), i2 = 0;
            for (let e3 of t2)
              n2.set(new Uint8Array(e3), i2), i2 += e3.byteLength;
            return n2;
          }
          function Pi(t2) {
            let e2 = new Uint8Array(t2.buffer, t2.byteOffset, Ti.length);
            if (e2[0] !== Ti[0] || e2[1] !== Ti[1] || e2[2] !== Ti[2] || e2[3] !== Ti[3] || e2[4] !== Ti[4] || e2[5] !== Ti[5] || e2[6] !== Ti[6] || e2[7] !== Ti[7] || e2[8] !== Ti[8] || e2[9] !== Ti[9] || e2[10] !== Ti[10] || e2[11] !== Ti[11])
              throw new Error("Missing KTX 2.0 identifier.");
            let n2 = new Si(), i2 = 17 * Uint32Array.BYTES_PER_ELEMENT, s2 = new Ii(t2, Ti.length, i2, !0);
            n2.vkFormat = s2._nextUint32(), n2.typeSize = s2._nextUint32(), n2.pixelWidth = s2._nextUint32(), n2.pixelHeight = s2._nextUint32(), n2.pixelDepth = s2._nextUint32(), n2.layerCount = s2._nextUint32(), n2.faceCount = s2._nextUint32();
            let a2 = s2._nextUint32();
            n2.supercompressionScheme = s2._nextUint32();
            let r2 = s2._nextUint32(), o2 = s2._nextUint32(), l2 = s2._nextUint32(), f2 = s2._nextUint32(), U2 = s2._nextUint64(), c2 = s2._nextUint64(), h2 = new Ii(t2, Ti.length + i2, 3 * a2 * 8, !0);
            for (let e3 = 0; e3 < a2; e3++)
              n2.levels.push({
                levelData: new Uint8Array(t2.buffer, t2.byteOffset + h2._nextUint64(), h2._nextUint64()),
                uncompressedByteLength: h2._nextUint64()
              });
            let _2 = new Ii(t2, r2, o2, !0), p2 = {
              vendorId: _2._skip(4)._nextUint16(),
              descriptorType: _2._nextUint16(),
              versionNumber: _2._nextUint16(),
              descriptorBlockSize: _2._nextUint16(),
              colorModel: _2._nextUint8(),
              colorPrimaries: _2._nextUint8(),
              transferFunction: _2._nextUint8(),
              flags: _2._nextUint8(),
              texelBlockDimension: [_2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8()],
              bytesPlane: [_2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8()],
              samples: []
            }, g2 = (p2.descriptorBlockSize / 4 - 6) / 4;
            for (let t3 = 0; t3 < g2; t3++) {
              let e3 = {
                bitOffset: _2._nextUint16(),
                bitLength: _2._nextUint8(),
                channelType: _2._nextUint8(),
                samplePosition: [_2._nextUint8(), _2._nextUint8(), _2._nextUint8(), _2._nextUint8()],
                sampleLower: -1 / 0,
                sampleUpper: 1 / 0
              };
              64 & e3.channelType ? (e3.sampleLower = _2._nextInt32(), e3.sampleUpper = _2._nextInt32()) : (e3.sampleLower = _2._nextUint32(), e3.sampleUpper = _2._nextUint32()), p2.samples[t3] = e3;
            }
            n2.dataFormatDescriptor.length = 0, n2.dataFormatDescriptor.push(p2);
            let y2 = new Ii(t2, l2, f2, !0);
            for (; y2._offset < f2; ) {
              let t3 = y2._nextUint32(), e3 = y2._scan(t3), i3 = Ei(e3), s3 = y2._scan(t3 - e3.byteLength);
              n2.keyValue[i3] = i3.match(/^ktx/i) ? Ei(s3) : s3, y2._offset % 4 && y2._skip(4 - y2._offset % 4);
            }
            if (c2 <= 0)
              return n2;
            let x2 = new Ii(t2, U2, c2, !0), u2 = x2._nextUint16(), b2 = x2._nextUint16(), d2 = x2._nextUint32(), m2 = x2._nextUint32(), w2 = x2._nextUint32(), D2 = x2._nextUint32(), B2 = [];
            for (let t3 = 0; t3 < a2; t3++)
              B2.push({
                imageFlags: x2._nextUint32(),
                rgbSliceByteOffset: x2._nextUint32(),
                rgbSliceByteLength: x2._nextUint32(),
                alphaSliceByteOffset: x2._nextUint32(),
                alphaSliceByteLength: x2._nextUint32()
              });
            let L2 = U2 + x2._offset, A2 = L2 + d2, k2 = A2 + m2, v2 = k2 + w2, S2 = new Uint8Array(t2.buffer, t2.byteOffset + L2, d2), I2 = new Uint8Array(t2.buffer, t2.byteOffset + A2, m2), O2 = new Uint8Array(t2.buffer, t2.byteOffset + k2, w2), T2 = new Uint8Array(t2.buffer, t2.byteOffset + v2, D2);
            return n2.globalData = {
              endpointCount: u2,
              selectorCount: b2,
              imageDescs: B2,
              endpointsData: S2,
              selectorsData: I2,
              tablesData: O2,
              extendedData: T2
            }, n2;
          }
          function Ci() {
            return (Ci = Object.assign || function(t2) {
              for (var e2 = 1; e2 < arguments.length; e2++) {
                var n2 = arguments[e2];
                for (var i2 in n2)
                  Object.prototype.hasOwnProperty.call(n2, i2) && (t2[i2] = n2[i2]);
              }
              return t2;
            }).apply(this, arguments);
          }
          let zi = {
            keepWriter: !1
          };
          function Mi(t2, e2 = {}) {
            e2 = Ci({}, zi, e2);
            let n2 = new ArrayBuffer(0);
            if (t2.globalData) {
              let e3 = new ArrayBuffer(20 + 5 * t2.globalData.imageDescs.length * 4), i3 = new DataView(e3);
              i3.setUint16(0, t2.globalData.endpointCount, !0), i3.setUint16(2, t2.globalData.selectorCount, !0), i3.setUint32(4, t2.globalData.endpointsData.byteLength, !0), i3.setUint32(8, t2.globalData.selectorsData.byteLength, !0), i3.setUint32(12, t2.globalData.tablesData.byteLength, !0), i3.setUint32(16, t2.globalData.extendedData.byteLength, !0);
              for (let e4 = 0; e4 < t2.globalData.imageDescs.length; e4++) {
                let n3 = t2.globalData.imageDescs[e4];
                i3.setUint32(20 + 5 * e4 * 4 + 0, n3.imageFlags, !0), i3.setUint32(20 + 5 * e4 * 4 + 4, n3.rgbSliceByteOffset, !0), i3.setUint32(20 + 5 * e4 * 4 + 8, n3.rgbSliceByteLength, !0), i3.setUint32(20 + 5 * e4 * 4 + 12, n3.alphaSliceByteOffset, !0), i3.setUint32(20 + 5 * e4 * 4 + 16, n3.alphaSliceByteLength, !0);
              }
              n2 = Fi([e3, t2.globalData.endpointsData, t2.globalData.selectorsData, t2.globalData.tablesData, t2.globalData.extendedData]);
            }
            let i2 = [], s2 = t2.keyValue;
            e2.keepWriter || (s2 = Ci({}, t2.keyValue, {
              KTXwriter: "KTX-Parse v0.3.1"
            }));
            for (let t3 in s2) {
              let e3 = s2[t3], n3 = Vi(t3), a3 = typeof e3 == "string" ? Vi(e3) : e3, r3 = n3.byteLength + 1 + a3.byteLength + 1, o3 = r3 % 4 ? 4 - r3 % 4 : 0;
              i2.push(Fi([new Uint32Array([r3]), n3, Oi, a3, Oi, new Uint8Array(o3).fill(0)]));
            }
            let a2 = Fi(i2);
            if (t2.dataFormatDescriptor.length !== 1 || t2.dataFormatDescriptor[0].descriptorType !== 0)
              throw new Error("Only BASICFORMAT Data Format Descriptor output supported.");
            let r2 = t2.dataFormatDescriptor[0], o2 = new ArrayBuffer(28 + 16 * r2.samples.length), l2 = new DataView(o2), f2 = 24 + 16 * r2.samples.length;
            if (l2.setUint32(0, o2.byteLength, !0), l2.setUint16(4, r2.vendorId, !0), l2.setUint16(6, r2.descriptorType, !0), l2.setUint16(8, r2.versionNumber, !0), l2.setUint16(10, f2, !0), l2.setUint8(12, r2.colorModel), l2.setUint8(13, r2.colorPrimaries), l2.setUint8(14, r2.transferFunction), l2.setUint8(15, r2.flags), !Array.isArray(r2.texelBlockDimension))
              throw new Error("texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.");
            l2.setUint8(16, r2.texelBlockDimension[0]), l2.setUint8(17, r2.texelBlockDimension[1]), l2.setUint8(18, r2.texelBlockDimension[2]), l2.setUint8(19, r2.texelBlockDimension[3]);
            for (let t3 = 0; t3 < 8; t3++)
              l2.setUint8(20 + t3, r2.bytesPlane[t3]);
            for (let t3 = 0; t3 < r2.samples.length; t3++) {
              let e3 = r2.samples[t3], n3 = 28 + 16 * t3;
              if (e3.channelID)
                throw new Error("channelID has been renamed to channelType.");
              l2.setUint16(n3 + 0, e3.bitOffset, !0), l2.setUint8(n3 + 2, e3.bitLength), l2.setUint8(n3 + 3, e3.channelType), l2.setUint8(n3 + 4, e3.samplePosition[0]), l2.setUint8(n3 + 5, e3.samplePosition[1]), l2.setUint8(n3 + 6, e3.samplePosition[2]), l2.setUint8(n3 + 7, e3.samplePosition[3]), 64 & e3.channelType ? (l2.setInt32(n3 + 8, e3.sampleLower, !0), l2.setInt32(n3 + 12, e3.sampleUpper, !0)) : (l2.setUint32(n3 + 8, e3.sampleLower, !0), l2.setUint32(n3 + 12, e3.sampleUpper, !0));
            }
            let U2 = Ti.length + 68 + 3 * t2.levels.length * 8, c2 = U2 + o2.byteLength, h2 = n2.byteLength > 0 ? c2 + a2.byteLength : 0;
            h2 % 8 && (h2 += 8 - h2 % 8);
            let _2 = [], p2 = new DataView(new ArrayBuffer(3 * t2.levels.length * 8)), g2 = (h2 || c2 + a2.byteLength) + n2.byteLength;
            for (let e3 = 0; e3 < t2.levels.length; e3++) {
              let n3 = t2.levels[e3];
              _2.push(n3.levelData), p2.setBigUint64(24 * e3 + 0, BigInt(g2), !0), p2.setBigUint64(24 * e3 + 8, BigInt(n3.levelData.byteLength), !0), p2.setBigUint64(24 * e3 + 16, BigInt(n3.uncompressedByteLength), !0), g2 += n3.levelData.byteLength;
            }
            let y2 = new ArrayBuffer(68), x2 = new DataView(y2);
            return x2.setUint32(0, t2.vkFormat, !0), x2.setUint32(4, t2.typeSize, !0), x2.setUint32(8, t2.pixelWidth, !0), x2.setUint32(12, t2.pixelHeight, !0), x2.setUint32(16, t2.pixelDepth, !0), x2.setUint32(20, t2.layerCount, !0), x2.setUint32(24, t2.faceCount, !0), x2.setUint32(28, t2.levels.length, !0), x2.setUint32(32, t2.supercompressionScheme, !0), x2.setUint32(36, U2, !0), x2.setUint32(40, o2.byteLength, !0), x2.setUint32(44, c2, !0), x2.setUint32(48, a2.byteLength, !0), x2.setBigUint64(52, BigInt(n2.byteLength > 0 ? h2 : 0), !0), x2.setBigUint64(60, BigInt(n2.byteLength), !0), new Uint8Array(Fi([new Uint8Array(Ti).buffer, y2, p2.buffer, o2, a2, h2 > 0 ? new ArrayBuffer(h2 - (c2 + a2.byteLength)) : new ArrayBuffer(0), n2, ..._2]));
          }
        },
        "./node_modules/three/examples/jsm/libs/zstddec.module.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            ZSTDDecoder: () => Q
          });
          var Buffer2 = __webpack_require__2("./node_modules/buffer/index.js").Buffer;
          let A, I, B, g = {
            env: {
              emscripten_notify_memory_growth: function(A2) {
                B = new Uint8Array(I.exports.memory.buffer);
              }
            }
          };
          class Q {
            init() {
              return A || (A = typeof fetch != "undefined" ? fetch("data:application/wasm;base64," + C).then((A2) => A2.arrayBuffer()).then((A2) => WebAssembly.instantiate(A2, g)).then(this._init) : WebAssembly.instantiate(Buffer2.from(C, "base64"), g).then(this._init), A);
            }
            _init(A2) {
              I = A2.instance, g.env.emscripten_notify_memory_growth(0);
            }
            decode(A2, g2 = 0) {
              if (!I)
                throw new Error("ZSTDDecoder: Await .init() before decoding.");
              let Q2 = A2.byteLength, C2 = I.exports.malloc(Q2);
              B.set(A2, C2), g2 = g2 || Number(I.exports.ZSTD_findDecompressedSize(C2, Q2));
              let E = I.exports.malloc(g2), i = I.exports.ZSTD_decompress(E, g2, C2, Q2), D = B.slice(E, E + i);
              return I.exports.free(C2), I.exports.free(E), D;
            }
          }
          let C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";
        },
        "./node_modules/three/examples/jsm/lights/LightProbeGenerator.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            LightProbeGenerator: () => LightProbeGenerator
          });
          var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/three/build/three.module.js");
          class LightProbeGenerator {
            static fromCubeTexture(cubeTexture) {
              let totalWeight = 0, coord = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), dir = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(), shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0], sh = new three__WEBPACK_IMPORTED_MODULE_0__.SphericalHarmonics3(), shCoefficients = sh.coefficients;
              for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
                let image = cubeTexture.image[faceIndex], width = image.width, height = image.height, canvas = document.createElement("canvas");
                canvas.width = width, canvas.height = height;
                let context = canvas.getContext("2d");
                context.drawImage(image, 0, 0, width, height);
                let imageData = context.getImageData(0, 0, width, height), data = imageData.data, imageWidth = imageData.width, pixelSize = 2 / imageWidth;
                for (let i = 0, il = data.length; i < il; i += 4) {
                  color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255), convertColorToLinear(color, cubeTexture.colorSpace);
                  let pixelIndex = i / 4, col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize, row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;
                  switch (faceIndex) {
                    case 0:
                      coord.set(-1, row, -col);
                      break;
                    case 1:
                      coord.set(1, row, col);
                      break;
                    case 2:
                      coord.set(-col, 1, -row);
                      break;
                    case 3:
                      coord.set(-col, -1, row);
                      break;
                    case 4:
                      coord.set(-col, row, 1);
                      break;
                    case 5:
                      coord.set(col, row, -1);
                      break;
                  }
                  let lengthSq = coord.lengthSq(), weight = 4 / (Math.sqrt(lengthSq) * lengthSq);
                  totalWeight += weight, dir.copy(coord).normalize(), three__WEBPACK_IMPORTED_MODULE_0__.SphericalHarmonics3.getBasisAt(dir, shBasis);
                  for (let j = 0; j < 9; j++)
                    shCoefficients[j].x += shBasis[j] * color.r * weight, shCoefficients[j].y += shBasis[j] * color.g * weight, shCoefficients[j].z += shBasis[j] * color.b * weight;
                }
              }
              let norm = 4 * Math.PI / totalWeight;
              for (let j = 0; j < 9; j++)
                shCoefficients[j].x *= norm, shCoefficients[j].y *= norm, shCoefficients[j].z *= norm;
              return new three__WEBPACK_IMPORTED_MODULE_0__.LightProbe(sh);
            }
            static fromCubeRenderTarget(renderer, cubeRenderTarget) {
              let totalWeight = 0, coord = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), dir = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(), shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0], sh = new three__WEBPACK_IMPORTED_MODULE_0__.SphericalHarmonics3(), shCoefficients = sh.coefficients, dataType = cubeRenderTarget.texture.type;
              for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
                let imageWidth = cubeRenderTarget.width, data;
                dataType === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType ? data = new Uint16Array(imageWidth * imageWidth * 4) : data = new Uint8Array(imageWidth * imageWidth * 4), renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);
                let pixelSize = 2 / imageWidth;
                for (let i = 0, il = data.length; i < il; i += 4) {
                  let r, g, b;
                  dataType === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType ? (r = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.fromHalfFloat(data[i]), g = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.fromHalfFloat(data[i + 1]), b = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.fromHalfFloat(data[i + 2])) : (r = data[i] / 255, g = data[i + 1] / 255, b = data[i + 2] / 255), color.setRGB(r, g, b), convertColorToLinear(color, cubeRenderTarget.texture.colorSpace);
                  let pixelIndex = i / 4, col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize, row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;
                  switch (faceIndex) {
                    case 0:
                      coord.set(1, row, -col);
                      break;
                    case 1:
                      coord.set(-1, row, col);
                      break;
                    case 2:
                      coord.set(col, 1, -row);
                      break;
                    case 3:
                      coord.set(col, -1, row);
                      break;
                    case 4:
                      coord.set(col, row, 1);
                      break;
                    case 5:
                      coord.set(-col, row, -1);
                      break;
                  }
                  let lengthSq = coord.lengthSq(), weight = 4 / (Math.sqrt(lengthSq) * lengthSq);
                  totalWeight += weight, dir.copy(coord).normalize(), three__WEBPACK_IMPORTED_MODULE_0__.SphericalHarmonics3.getBasisAt(dir, shBasis);
                  for (let j = 0; j < 9; j++)
                    shCoefficients[j].x += shBasis[j] * color.r * weight, shCoefficients[j].y += shBasis[j] * color.g * weight, shCoefficients[j].z += shBasis[j] * color.b * weight;
                }
              }
              let norm = 4 * Math.PI / totalWeight;
              for (let j = 0; j < 9; j++)
                shCoefficients[j].x *= norm, shCoefficients[j].y *= norm, shCoefficients[j].z *= norm;
              return new three__WEBPACK_IMPORTED_MODULE_0__.LightProbe(sh);
            }
          }
          function convertColorToLinear(color, colorSpace) {
            switch (colorSpace) {
              case three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace:
                color.convertSRGBToLinear();
                break;
              case three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace:
              case three__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace:
                break;
              default:
                console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.");
                break;
            }
            return color;
          }
        },
        "./node_modules/three/examples/jsm/loaders/DRACOLoader.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            DRACOLoader: () => DRACOLoader
          });
          var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/three/build/three.module.js");
          let _taskCache = new WeakMap();
          class DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {
            constructor(manager) {
              super(manager);
              this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD"
              }, this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array"
              };
            }
            setDecoderPath(path) {
              return this.decoderPath = path, this;
            }
            setDecoderConfig(config) {
              return this.decoderConfig = config, this;
            }
            setWorkerLimit(workerLimit) {
              return this.workerLimit = workerLimit, this;
            }
            load(url, onLoad, onProgress, onError) {
              let loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
              loader.setPath(this.path), loader.setResponseType("arraybuffer"), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(this.withCredentials), loader.load(url, (buffer) => {
                this.parse(buffer, onLoad, onError);
              }, onProgress, onError);
            }
            parse(buffer, onLoad, onError = () => {
            }) {
              this.decodeDracoFile(buffer, onLoad, null, null, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace).catch(onError);
            }
            decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace, onError = () => {
            }) {
              let taskConfig = {
                attributeIDs: attributeIDs || this.defaultAttributeIDs,
                attributeTypes: attributeTypes || this.defaultAttributeTypes,
                useUniqueIDs: !!attributeIDs,
                vertexColorSpace
              };
              return this.decodeGeometry(buffer, taskConfig).then(callback).catch(onError);
            }
            decodeGeometry(buffer, taskConfig) {
              let taskKey = JSON.stringify(taskConfig);
              if (_taskCache.has(buffer)) {
                let cachedTask = _taskCache.get(buffer);
                if (cachedTask.key === taskKey)
                  return cachedTask.promise;
                if (buffer.byteLength === 0)
                  throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
              }
              let worker, taskID = this.workerNextTaskID++, taskCost = buffer.byteLength, geometryPending = this._getWorker(taskID, taskCost).then((_worker) => (worker = _worker, new Promise((resolve, reject) => {
                worker._callbacks[taskID] = {
                  resolve,
                  reject
                }, worker.postMessage({
                  type: "decode",
                  id: taskID,
                  taskConfig,
                  buffer
                }, [buffer]);
              }))).then((message) => this._createGeometry(message.geometry));
              return geometryPending.catch(() => !0).then(() => {
                worker && taskID && this._releaseTask(worker, taskID);
              }), _taskCache.set(buffer, {
                key: taskKey,
                promise: geometryPending
              }), geometryPending;
            }
            _createGeometry(geometryData) {
              let geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
              geometryData.index && geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));
              for (let i = 0; i < geometryData.attributes.length; i++) {
                let result = geometryData.attributes[i], name = result.name, array = result.array, itemSize = result.itemSize, attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize);
                name === "color" && (this._assignVertexColorSpace(attribute, result.vertexColorSpace), attribute.normalized = !(array instanceof Float32Array)), geometry.setAttribute(name, attribute);
              }
              return geometry;
            }
            _assignVertexColorSpace(attribute, inputColorSpace) {
              if (inputColorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace)
                return;
              let _color = new three__WEBPACK_IMPORTED_MODULE_0__.Color();
              for (let i = 0, il = attribute.count; i < il; i++)
                _color.fromBufferAttribute(attribute, i).convertSRGBToLinear(), attribute.setXYZ(i, _color.r, _color.g, _color.b);
            }
            _loadLibrary(url, responseType) {
              let loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
              return loader.setPath(this.decoderPath), loader.setResponseType(responseType), loader.setWithCredentials(this.withCredentials), new Promise((resolve, reject) => {
                loader.load(url, resolve, void 0, reject);
              });
            }
            preload() {
              return this._initDecoder(), this;
            }
            _initDecoder() {
              if (this.decoderPending)
                return this.decoderPending;
              let useJS = typeof WebAssembly != "object" || this.decoderConfig.type === "js", librariesPending = [];
              return useJS ? librariesPending.push(this._loadLibrary("draco_decoder.js", "text")) : (librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(librariesPending).then((libraries) => {
                let jsContent = libraries[0];
                useJS || (this.decoderConfig.wasmBinary = libraries[1]);
                let fn = DRACOWorker.toString(), body = ["/* draco decoder */", jsContent, "", "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join(`
`);
                this.workerSourceURL = URL.createObjectURL(new Blob([body]));
              }), this.decoderPending;
            }
            _getWorker(taskID, taskCost) {
              return this._initDecoder().then(() => {
                if (this.workerPool.length < this.workerLimit) {
                  let worker2 = new Worker(this.workerSourceURL);
                  worker2._callbacks = {}, worker2._taskCosts = {}, worker2._taskLoad = 0, worker2.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                  }), worker2.onmessage = function(e) {
                    let message = e.data;
                    switch (message.type) {
                      case "decode":
                        worker2._callbacks[message.id].resolve(message);
                        break;
                      case "error":
                        worker2._callbacks[message.id].reject(message);
                        break;
                      default:
                        console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
                    }
                  }, this.workerPool.push(worker2);
                } else
                  this.workerPool.sort(function(a, b) {
                    return a._taskLoad > b._taskLoad ? -1 : 1;
                  });
                let worker = this.workerPool[this.workerPool.length - 1];
                return worker._taskCosts[taskID] = taskCost, worker._taskLoad += taskCost, worker;
              });
            }
            _releaseTask(worker, taskID) {
              worker._taskLoad -= worker._taskCosts[taskID], delete worker._callbacks[taskID], delete worker._taskCosts[taskID];
            }
            debug() {
              console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
            }
            dispose() {
              for (let i = 0; i < this.workerPool.length; ++i)
                this.workerPool[i].terminate();
              return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
            }
          }
          function DRACOWorker() {
            let decoderConfig, decoderPending;
            onmessage = function(e) {
              let message = e.data;
              switch (message.type) {
                case "init":
                  decoderConfig = message.decoderConfig, decoderPending = new Promise(function(resolve) {
                    decoderConfig.onModuleLoaded = function(draco) {
                      resolve({
                        draco
                      });
                    }, DracoDecoderModule(decoderConfig);
                  });
                  break;
                case "decode":
                  let buffer = message.buffer, taskConfig = message.taskConfig;
                  decoderPending.then((module3) => {
                    let draco = module3.draco, decoder = new draco.Decoder();
                    try {
                      let geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig), buffers = geometry.attributes.map((attr) => attr.array.buffer);
                      geometry.index && buffers.push(geometry.index.array.buffer), self.postMessage({
                        type: "decode",
                        id: message.id,
                        geometry
                      }, buffers);
                    } catch (error) {
                      console.error(error), self.postMessage({
                        type: "error",
                        id: message.id,
                        error: error.message
                      });
                    } finally {
                      draco.destroy(decoder);
                    }
                  });
                  break;
              }
            };
            function decodeGeometry(draco, decoder, array, taskConfig) {
              let attributeIDs = taskConfig.attributeIDs, attributeTypes = taskConfig.attributeTypes, dracoGeometry, decodingStatus, geometryType = decoder.GetEncodedGeometryType(array);
              if (geometryType === draco.TRIANGULAR_MESH)
                dracoGeometry = new draco.Mesh(), decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
              else if (geometryType === draco.POINT_CLOUD)
                dracoGeometry = new draco.PointCloud(), decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
              else
                throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
              if (!decodingStatus.ok() || dracoGeometry.ptr === 0)
                throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
              let geometry = {
                index: null,
                attributes: []
              };
              for (let attributeName in attributeIDs) {
                let attributeType = self[attributeTypes[attributeName]], attribute, attributeID;
                if (taskConfig.useUniqueIDs)
                  attributeID = attributeIDs[attributeName], attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
                else {
                  if (attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]), attributeID === -1)
                    continue;
                  attribute = decoder.GetAttribute(dracoGeometry, attributeID);
                }
                let attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
                attributeName === "color" && (attributeResult.vertexColorSpace = taskConfig.vertexColorSpace), geometry.attributes.push(attributeResult);
              }
              return geometryType === draco.TRIANGULAR_MESH && (geometry.index = decodeIndex(draco, decoder, dracoGeometry)), draco.destroy(dracoGeometry), geometry;
            }
            function decodeIndex(draco, decoder, dracoGeometry) {
              let numIndices = dracoGeometry.num_faces() * 3, byteLength = numIndices * 4, ptr = draco._malloc(byteLength);
              decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
              let index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
              return draco._free(ptr), {
                array: index,
                itemSize: 1
              };
            }
            function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
              let numComponents = attribute.num_components(), numValues = dracoGeometry.num_points() * numComponents, byteLength = numValues * attributeType.BYTES_PER_ELEMENT, dataType = getDracoDataType(draco, attributeType), ptr = draco._malloc(byteLength);
              decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
              let array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
              return draco._free(ptr), {
                name: attributeName,
                array,
                itemSize: numComponents
              };
            }
            function getDracoDataType(draco, attributeType) {
              switch (attributeType) {
                case Float32Array:
                  return draco.DT_FLOAT32;
                case Int8Array:
                  return draco.DT_INT8;
                case Int16Array:
                  return draco.DT_INT16;
                case Int32Array:
                  return draco.DT_INT32;
                case Uint8Array:
                  return draco.DT_UINT8;
                case Uint16Array:
                  return draco.DT_UINT16;
                case Uint32Array:
                  return draco.DT_UINT32;
              }
            }
          }
        },
        "./node_modules/three/examples/jsm/loaders/GLTFLoader.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            GLTFLoader: () => GLTFLoader
          });
          var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/three/build/three.module.js"), _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2("./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js");
          class GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {
            constructor(manager) {
              super(manager);
              this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(parser) {
                return new GLTFMaterialsClearcoatExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMaterialsDispersionExtension(parser);
              }), this.register(function(parser) {
                return new GLTFTextureBasisUExtension(parser);
              }), this.register(function(parser) {
                return new GLTFTextureWebPExtension(parser);
              }), this.register(function(parser) {
                return new GLTFTextureAVIFExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMaterialsSheenExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMaterialsTransmissionExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMaterialsVolumeExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMaterialsIorExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMaterialsEmissiveStrengthExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMaterialsSpecularExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMaterialsIridescenceExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMaterialsAnisotropyExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMaterialsBumpExtension(parser);
              }), this.register(function(parser) {
                return new GLTFLightsExtension(parser);
              }), this.register(function(parser) {
                return new GLTFMeshoptCompression(parser);
              }), this.register(function(parser) {
                return new GLTFMeshGpuInstancing(parser);
              });
            }
            load(url, onLoad, onProgress, onError) {
              let scope = this, resourcePath;
              if (this.resourcePath !== "")
                resourcePath = this.resourcePath;
              else if (this.path !== "") {
                let relativeUrl = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);
                resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(relativeUrl, this.path);
              } else
                resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);
              this.manager.itemStart(url);
              let _onError = function(e) {
                onError ? onError(e) : console.error(e), scope.manager.itemError(url), scope.manager.itemEnd(url);
              }, loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
              loader.setPath(this.path), loader.setResponseType("arraybuffer"), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(this.withCredentials), loader.load(url, function(data) {
                try {
                  scope.parse(data, resourcePath, function(gltf) {
                    onLoad(gltf), scope.manager.itemEnd(url);
                  }, _onError);
                } catch (e) {
                  _onError(e);
                }
              }, onProgress, _onError);
            }
            setDRACOLoader(dracoLoader) {
              return this.dracoLoader = dracoLoader, this;
            }
            setDDSLoader() {
              throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
            }
            setKTX2Loader(ktx2Loader) {
              return this.ktx2Loader = ktx2Loader, this;
            }
            setMeshoptDecoder(meshoptDecoder) {
              return this.meshoptDecoder = meshoptDecoder, this;
            }
            register(callback) {
              return this.pluginCallbacks.indexOf(callback) === -1 && this.pluginCallbacks.push(callback), this;
            }
            unregister(callback) {
              return this.pluginCallbacks.indexOf(callback) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1), this;
            }
            parse(data, path, onLoad, onError) {
              let json, extensions = {}, plugins = {}, textDecoder = new TextDecoder();
              if (typeof data == "string")
                json = JSON.parse(data);
              else if (data instanceof ArrayBuffer)
                if (textDecoder.decode(new Uint8Array(data, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) {
                  try {
                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
                  } catch (error) {
                    onError && onError(error);
                    return;
                  }
                  json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
                } else
                  json = JSON.parse(textDecoder.decode(data));
              else
                json = data;
              if (json.asset === void 0 || json.asset.version[0] < 2) {
                onError && onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                return;
              }
              let parser = new GLTFParser(json, {
                path: path || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
              });
              parser.fileLoader.setRequestHeader(this.requestHeader);
              for (let i = 0; i < this.pluginCallbacks.length; i++) {
                let plugin = this.pluginCallbacks[i](parser);
                plugin.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), plugins[plugin.name] = plugin, extensions[plugin.name] = !0;
              }
              if (json.extensionsUsed)
                for (let i = 0; i < json.extensionsUsed.length; ++i) {
                  let extensionName = json.extensionsUsed[i], extensionsRequired = json.extensionsRequired || [];
                  switch (extensionName) {
                    case EXTENSIONS.KHR_MATERIALS_UNLIT:
                      extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                      break;
                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                      extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                      break;
                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                      extensions[extensionName] = new GLTFTextureTransformExtension();
                      break;
                    case EXTENSIONS.KHR_MESH_QUANTIZATION:
                      extensions[extensionName] = new GLTFMeshQuantizationExtension();
                      break;
                    default:
                      extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                  }
                }
              parser.setExtensions(extensions), parser.setPlugins(plugins), parser.parse(onLoad, onError);
            }
            parseAsync(data, path) {
              let scope = this;
              return new Promise(function(resolve, reject) {
                scope.parse(data, path, resolve, reject);
              });
            }
          }
          function GLTFRegistry() {
            let objects = {};
            return {
              get: function(key) {
                return objects[key];
              },
              add: function(key, object) {
                objects[key] = object;
              },
              remove: function(key) {
                delete objects[key];
              },
              removeAll: function() {
                objects = {};
              }
            };
          }
          let EXTENSIONS = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_MATERIALS_BUMP: "EXT_materials_bump",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
          };
          class GLTFLightsExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
              };
            }
            _markDefs() {
              let parser = this.parser, nodeDefs = this.parser.json.nodes || [];
              for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
                let nodeDef = nodeDefs[nodeIndex];
                nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0 && parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
              }
            }
            _loadLight(lightIndex) {
              let parser = this.parser, cacheKey = "light:" + lightIndex, dependency = parser.cache.get(cacheKey);
              if (dependency)
                return dependency;
              let json = parser.json, lightDef = ((json.extensions && json.extensions[this.name] || {}).lights || [])[lightIndex], lightNode, color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);
              lightDef.color !== void 0 && color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);
              let range = lightDef.range !== void 0 ? lightDef.range : 0;
              switch (lightDef.type) {
                case "directional":
                  lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color), lightNode.target.position.set(0, 0, -1), lightNode.add(lightNode.target);
                  break;
                case "point":
                  lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color), lightNode.distance = range;
                  break;
                case "spot":
                  lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color), lightNode.distance = range, lightDef.spot = lightDef.spot || {}, lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0, lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4, lightNode.angle = lightDef.spot.outerConeAngle, lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle, lightNode.target.position.set(0, 0, -1), lightNode.add(lightNode.target);
                  break;
                default:
                  throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
              }
              return lightNode.position.set(0, 0, 0), lightNode.decay = 2, assignExtrasToUserData(lightNode, lightDef), lightDef.intensity !== void 0 && (lightNode.intensity = lightDef.intensity), lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex), dependency = Promise.resolve(lightNode), parser.cache.add(cacheKey, dependency), dependency;
            }
            getDependency(type, index) {
              if (type === "light")
                return this._loadLight(index);
            }
            createNodeAttachment(nodeIndex) {
              let self2 = this, parser = this.parser, nodeDef = parser.json.nodes[nodeIndex], lightIndex = (nodeDef.extensions && nodeDef.extensions[this.name] || {}).light;
              return lightIndex === void 0 ? null : this._loadLight(lightIndex).then(function(light) {
                return parser._getNodeRef(self2.cache, lightIndex, light);
              });
            }
          }
          class GLTFMaterialsUnlitExtension {
            constructor() {
              this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
            }
            getMaterialType() {
              return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;
            }
            extendParams(materialParams, materialDef, parser) {
              let pending = [];
              materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1), materialParams.opacity = 1;
              let metallicRoughness = materialDef.pbrMetallicRoughness;
              if (metallicRoughness) {
                if (Array.isArray(metallicRoughness.baseColorFactor)) {
                  let array = metallicRoughness.baseColorFactor;
                  materialParams.color.setRGB(array[0], array[1], array[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace), materialParams.opacity = array[3];
                }
                metallicRoughness.baseColorTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace));
              }
              return Promise.all(pending);
            }
          }
          class GLTFMaterialsEmissiveStrengthExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let materialDef = this.parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
              return emissiveStrength !== void 0 && (materialParams.emissiveIntensity = emissiveStrength), Promise.resolve();
            }
          }
          class GLTFMaterialsClearcoatExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
            }
            getMaterialType(materialIndex) {
              let materialDef = this.parser.json.materials[materialIndex];
              return !materialDef.extensions || !materialDef.extensions[this.name] ? null : three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let parser = this.parser, materialDef = parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let pending = [], extension = materialDef.extensions[this.name];
              if (extension.clearcoatFactor !== void 0 && (materialParams.clearcoat = extension.clearcoatFactor), extension.clearcoatTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture)), extension.clearcoatRoughnessFactor !== void 0 && (materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor), extension.clearcoatRoughnessTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture)), extension.clearcoatNormalTexture !== void 0 && (pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture)), extension.clearcoatNormalTexture.scale !== void 0)) {
                let scale = extension.clearcoatNormalTexture.scale;
                materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);
              }
              return Promise.all(pending);
            }
          }
          class GLTFMaterialsDispersionExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
            }
            getMaterialType(materialIndex) {
              let materialDef = this.parser.json.materials[materialIndex];
              return !materialDef.extensions || !materialDef.extensions[this.name] ? null : three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let materialDef = this.parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let extension = materialDef.extensions[this.name];
              return materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0, Promise.resolve();
            }
          }
          class GLTFMaterialsIridescenceExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
            }
            getMaterialType(materialIndex) {
              let materialDef = this.parser.json.materials[materialIndex];
              return !materialDef.extensions || !materialDef.extensions[this.name] ? null : three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let parser = this.parser, materialDef = parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let pending = [], extension = materialDef.extensions[this.name];
              return extension.iridescenceFactor !== void 0 && (materialParams.iridescence = extension.iridescenceFactor), extension.iridescenceTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture)), extension.iridescenceIor !== void 0 && (materialParams.iridescenceIOR = extension.iridescenceIor), materialParams.iridescenceThicknessRange === void 0 && (materialParams.iridescenceThicknessRange = [100, 400]), extension.iridescenceThicknessMinimum !== void 0 && (materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum), extension.iridescenceThicknessMaximum !== void 0 && (materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum), extension.iridescenceThicknessTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture)), Promise.all(pending);
            }
          }
          class GLTFMaterialsSheenExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
            }
            getMaterialType(materialIndex) {
              let materialDef = this.parser.json.materials[materialIndex];
              return !materialDef.extensions || !materialDef.extensions[this.name] ? null : three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let parser = this.parser, materialDef = parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let pending = [];
              materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0), materialParams.sheenRoughness = 0, materialParams.sheen = 1;
              let extension = materialDef.extensions[this.name];
              if (extension.sheenColorFactor !== void 0) {
                let colorFactor = extension.sheenColorFactor;
                materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);
              }
              return extension.sheenRoughnessFactor !== void 0 && (materialParams.sheenRoughness = extension.sheenRoughnessFactor), extension.sheenColorTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace)), extension.sheenRoughnessTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture)), Promise.all(pending);
            }
          }
          class GLTFMaterialsTransmissionExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
            }
            getMaterialType(materialIndex) {
              let materialDef = this.parser.json.materials[materialIndex];
              return !materialDef.extensions || !materialDef.extensions[this.name] ? null : three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let parser = this.parser, materialDef = parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let pending = [], extension = materialDef.extensions[this.name];
              return extension.transmissionFactor !== void 0 && (materialParams.transmission = extension.transmissionFactor), extension.transmissionTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture)), Promise.all(pending);
            }
          }
          class GLTFMaterialsVolumeExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
            }
            getMaterialType(materialIndex) {
              let materialDef = this.parser.json.materials[materialIndex];
              return !materialDef.extensions || !materialDef.extensions[this.name] ? null : three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let parser = this.parser, materialDef = parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let pending = [], extension = materialDef.extensions[this.name];
              materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0, extension.thicknessTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture)), materialParams.attenuationDistance = extension.attenuationDistance || 1 / 0;
              let colorArray = extension.attenuationColor || [1, 1, 1];
              return materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace), Promise.all(pending);
            }
          }
          class GLTFMaterialsIorExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_IOR;
            }
            getMaterialType(materialIndex) {
              let materialDef = this.parser.json.materials[materialIndex];
              return !materialDef.extensions || !materialDef.extensions[this.name] ? null : three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let materialDef = this.parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let extension = materialDef.extensions[this.name];
              return materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5, Promise.resolve();
            }
          }
          class GLTFMaterialsSpecularExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
            }
            getMaterialType(materialIndex) {
              let materialDef = this.parser.json.materials[materialIndex];
              return !materialDef.extensions || !materialDef.extensions[this.name] ? null : three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let parser = this.parser, materialDef = parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let pending = [], extension = materialDef.extensions[this.name];
              materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1, extension.specularTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
              let colorArray = extension.specularColorFactor || [1, 1, 1];
              return materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace), extension.specularColorTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace)), Promise.all(pending);
            }
          }
          class GLTFMaterialsBumpExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
            }
            getMaterialType(materialIndex) {
              let materialDef = this.parser.json.materials[materialIndex];
              return !materialDef.extensions || !materialDef.extensions[this.name] ? null : three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let parser = this.parser, materialDef = parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let pending = [], extension = materialDef.extensions[this.name];
              return materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1, extension.bumpTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture)), Promise.all(pending);
            }
          }
          class GLTFMaterialsAnisotropyExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
            }
            getMaterialType(materialIndex) {
              let materialDef = this.parser.json.materials[materialIndex];
              return !materialDef.extensions || !materialDef.extensions[this.name] ? null : three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;
            }
            extendMaterialParams(materialIndex, materialParams) {
              let parser = this.parser, materialDef = parser.json.materials[materialIndex];
              if (!materialDef.extensions || !materialDef.extensions[this.name])
                return Promise.resolve();
              let pending = [], extension = materialDef.extensions[this.name];
              return extension.anisotropyStrength !== void 0 && (materialParams.anisotropy = extension.anisotropyStrength), extension.anisotropyRotation !== void 0 && (materialParams.anisotropyRotation = extension.anisotropyRotation), extension.anisotropyTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture)), Promise.all(pending);
            }
          }
          class GLTFTextureBasisUExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
            }
            loadTexture(textureIndex) {
              let parser = this.parser, json = parser.json, textureDef = json.textures[textureIndex];
              if (!textureDef.extensions || !textureDef.extensions[this.name])
                return null;
              let extension = textureDef.extensions[this.name], loader = parser.options.ktx2Loader;
              if (!loader) {
                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0)
                  throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null;
              }
              return parser.loadTextureImage(textureIndex, extension.source, loader);
            }
          }
          class GLTFTextureWebPExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.EXT_TEXTURE_WEBP, this.isSupported = null;
            }
            loadTexture(textureIndex) {
              let name = this.name, parser = this.parser, json = parser.json, textureDef = json.textures[textureIndex];
              if (!textureDef.extensions || !textureDef.extensions[name])
                return null;
              let extension = textureDef.extensions[name], source = json.images[extension.source], loader = parser.textureLoader;
              if (source.uri) {
                let handler = parser.options.manager.getHandler(source.uri);
                handler !== null && (loader = handler);
              }
              return this.detectSupport().then(function(isSupported) {
                if (isSupported)
                  return parser.loadTextureImage(textureIndex, extension.source, loader);
                if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0)
                  throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return parser.loadTexture(textureIndex);
              });
            }
            detectSupport() {
              return this.isSupported || (this.isSupported = new Promise(function(resolve) {
                let image = new Image();
                image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", image.onload = image.onerror = function() {
                  resolve(image.height === 1);
                };
              })), this.isSupported;
            }
          }
          class GLTFTextureAVIFExtension {
            constructor(parser) {
              this.parser = parser, this.name = EXTENSIONS.EXT_TEXTURE_AVIF, this.isSupported = null;
            }
            loadTexture(textureIndex) {
              let name = this.name, parser = this.parser, json = parser.json, textureDef = json.textures[textureIndex];
              if (!textureDef.extensions || !textureDef.extensions[name])
                return null;
              let extension = textureDef.extensions[name], source = json.images[extension.source], loader = parser.textureLoader;
              if (source.uri) {
                let handler = parser.options.manager.getHandler(source.uri);
                handler !== null && (loader = handler);
              }
              return this.detectSupport().then(function(isSupported) {
                if (isSupported)
                  return parser.loadTextureImage(textureIndex, extension.source, loader);
                if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0)
                  throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                return parser.loadTexture(textureIndex);
              });
            }
            detectSupport() {
              return this.isSupported || (this.isSupported = new Promise(function(resolve) {
                let image = new Image();
                image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", image.onload = image.onerror = function() {
                  resolve(image.height === 1);
                };
              })), this.isSupported;
            }
          }
          class GLTFMeshoptCompression {
            constructor(parser) {
              this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION, this.parser = parser;
            }
            loadBufferView(index) {
              let json = this.parser.json, bufferView = json.bufferViews[index];
              if (bufferView.extensions && bufferView.extensions[this.name]) {
                let extensionDef = bufferView.extensions[this.name], buffer = this.parser.getDependency("buffer", extensionDef.buffer), decoder = this.parser.options.meshoptDecoder;
                if (!decoder || !decoder.supported) {
                  if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                  return null;
                }
                return buffer.then(function(res) {
                  let byteOffset = extensionDef.byteOffset || 0, byteLength = extensionDef.byteLength || 0, count = extensionDef.count, stride = extensionDef.byteStride, source = new Uint8Array(res, byteOffset, byteLength);
                  return decoder.decodeGltfBufferAsync ? decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
                    return res2.buffer;
                  }) : decoder.ready.then(function() {
                    let result = new ArrayBuffer(count * stride);
                    return decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter), result;
                  });
                });
              } else
                return null;
            }
          }
          class GLTFMeshGpuInstancing {
            constructor(parser) {
              this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING, this.parser = parser;
            }
            createNodeMesh(nodeIndex) {
              let json = this.parser.json, nodeDef = json.nodes[nodeIndex];
              if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0)
                return null;
              let meshDef = json.meshes[nodeDef.mesh];
              for (let primitive of meshDef.primitives)
                if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0)
                  return null;
              let attributesDef = nodeDef.extensions[this.name].attributes, pending = [], attributes = {};
              for (let key in attributesDef)
                pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => (attributes[key] = accessor, attributes[key])));
              return pending.length < 1 ? null : (pending.push(this.parser.createNodeMesh(nodeIndex)), Promise.all(pending).then((results) => {
                let nodeObject = results.pop(), meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject], count = results[0].count, instancedMeshes = [];
                for (let mesh of meshes) {
                  let m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1), instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);
                  for (let i = 0; i < count; i++)
                    attributes.TRANSLATION && p.fromBufferAttribute(attributes.TRANSLATION, i), attributes.ROTATION && q.fromBufferAttribute(attributes.ROTATION, i), attributes.SCALE && s.fromBufferAttribute(attributes.SCALE, i), instancedMesh.setMatrixAt(i, m.compose(p, q, s));
                  for (let attributeName in attributes)
                    if (attributeName === "_COLOR_0") {
                      let attr = attributes[attributeName];
                      instancedMesh.instanceColor = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);
                    } else
                      attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE" && mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
                  three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh), this.parser.assignFinalMaterial(instancedMesh), instancedMeshes.push(instancedMesh);
                }
                return nodeObject.isGroup ? (nodeObject.clear(), nodeObject.add(...instancedMeshes), nodeObject) : instancedMeshes[0];
              }));
            }
          }
          let BINARY_EXTENSION_HEADER_MAGIC = "glTF", BINARY_EXTENSION_HEADER_LENGTH = 12, BINARY_EXTENSION_CHUNK_TYPES = {
            JSON: 1313821514,
            BIN: 5130562
          };
          class GLTFBinaryExtension {
            constructor(data) {
              this.name = EXTENSIONS.KHR_BINARY_GLTF, this.content = null, this.body = null;
              let headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH), textDecoder = new TextDecoder();
              if (this.header = {
                magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
                version: headerView.getUint32(4, !0),
                length: headerView.getUint32(8, !0)
              }, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC)
                throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
              if (this.header.version < 2)
                throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
              let chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH, chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH), chunkIndex = 0;
              for (; chunkIndex < chunkContentsLength; ) {
                let chunkLength = chunkView.getUint32(chunkIndex, !0);
                chunkIndex += 4;
                let chunkType = chunkView.getUint32(chunkIndex, !0);
                if (chunkIndex += 4, chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
                  let contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
                  this.content = textDecoder.decode(contentArray);
                } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
                  let byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
                  this.body = data.slice(byteOffset, byteOffset + chunkLength);
                }
                chunkIndex += chunkLength;
              }
              if (this.content === null)
                throw new Error("THREE.GLTFLoader: JSON content not found.");
            }
          }
          class GLTFDracoMeshCompressionExtension {
            constructor(json, dracoLoader) {
              if (!dracoLoader)
                throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
              this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION, this.json = json, this.dracoLoader = dracoLoader, this.dracoLoader.preload();
            }
            decodePrimitive(primitive, parser) {
              let json = this.json, dracoLoader = this.dracoLoader, bufferViewIndex = primitive.extensions[this.name].bufferView, gltfAttributeMap = primitive.extensions[this.name].attributes, threeAttributeMap = {}, attributeNormalizedMap = {}, attributeTypeMap = {};
              for (let attributeName in gltfAttributeMap) {
                let threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
                threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
              }
              for (let attributeName in primitive.attributes) {
                let threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
                if (gltfAttributeMap[attributeName] !== void 0) {
                  let accessorDef = json.accessors[primitive.attributes[attributeName]], componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
                  attributeTypeMap[threeAttributeName] = componentType.name, attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === !0;
                }
              }
              return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
                return new Promise(function(resolve, reject) {
                  dracoLoader.decodeDracoFile(bufferView, function(geometry) {
                    for (let attributeName in geometry.attributes) {
                      let attribute = geometry.attributes[attributeName], normalized = attributeNormalizedMap[attributeName];
                      normalized !== void 0 && (attribute.normalized = normalized);
                    }
                    resolve(geometry);
                  }, threeAttributeMap, attributeTypeMap, three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace, reject);
                });
              });
            }
          }
          class GLTFTextureTransformExtension {
            constructor() {
              this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
            }
            extendTexture(texture, transform) {
              return (transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0 || (texture = texture.clone(), transform.texCoord !== void 0 && (texture.channel = transform.texCoord), transform.offset !== void 0 && texture.offset.fromArray(transform.offset), transform.rotation !== void 0 && (texture.rotation = transform.rotation), transform.scale !== void 0 && texture.repeat.fromArray(transform.scale), texture.needsUpdate = !0), texture;
            }
          }
          class GLTFMeshQuantizationExtension {
            constructor() {
              this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
            }
          }
          class GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {
            constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
              super(parameterPositions, sampleValues, sampleSize, resultBuffer);
            }
            copySampleValue_(index) {
              let result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
              for (let i = 0; i !== valueSize; i++)
                result[i] = values[offset + i];
              return result;
            }
            interpolate_(i1, t0, t, t1) {
              let result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, stride2 = stride * 2, stride3 = stride * 3, td = t1 - t0, p = (t - t0) / td, pp = p * p, ppp = pp * p, offset1 = i1 * stride3, offset0 = offset1 - stride3, s2 = -2 * ppp + 3 * pp, s3 = ppp - pp, s0 = 1 - s2, s1 = s3 - pp + p;
              for (let i = 0; i !== stride; i++) {
                let p0 = values[offset0 + i + stride], m0 = values[offset0 + i + stride2] * td, p1 = values[offset1 + i + stride], m1 = values[offset1 + i] * td;
                result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
              }
              return result;
            }
          }
          let _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
          class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
            interpolate_(i1, t0, t, t1) {
              let result = super.interpolate_(i1, t0, t, t1);
              return _q.fromArray(result).normalize().toArray(result), result;
            }
          }
          let WEBGL_CONSTANTS = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
          }, WEBGL_COMPONENT_TYPES = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
          }, WEBGL_FILTERS = {
            9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,
            9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,
            9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,
            9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,
            9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,
            9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter
          }, WEBGL_WRAPPINGS = {
            33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,
            33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,
            10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping
          }, WEBGL_TYPE_SIZES = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
          }, ATTRIBUTES = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
          }, PATH_PROPERTIES = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
          }, INTERPOLATION = {
            CUBICSPLINE: void 0,
            LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,
            STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete
          }, ALPHA_MODES = {
            OPAQUE: "OPAQUE",
            MASK: "MASK",
            BLEND: "BLEND"
          };
          function createDefaultMaterial(cache) {
            return cache.DefaultMaterial === void 0 && (cache.DefaultMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({
              color: 16777215,
              emissive: 0,
              metalness: 1,
              roughness: 1,
              transparent: !1,
              depthTest: !0,
              side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide
            })), cache.DefaultMaterial;
          }
          function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
            for (let name in objectDef.extensions)
              knownExtensions[name] === void 0 && (object.userData.gltfExtensions = object.userData.gltfExtensions || {}, object.userData.gltfExtensions[name] = objectDef.extensions[name]);
          }
          function assignExtrasToUserData(object, gltfDef) {
            gltfDef.extras !== void 0 && (typeof gltfDef.extras == "object" ? Object.assign(object.userData, gltfDef.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras));
          }
          function addMorphTargets(geometry, targets, parser) {
            let hasMorphPosition = !1, hasMorphNormal = !1, hasMorphColor = !1;
            for (let i = 0, il = targets.length; i < il; i++) {
              let target = targets[i];
              if (target.POSITION !== void 0 && (hasMorphPosition = !0), target.NORMAL !== void 0 && (hasMorphNormal = !0), target.COLOR_0 !== void 0 && (hasMorphColor = !0), hasMorphPosition && hasMorphNormal && hasMorphColor)
                break;
            }
            if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
              return Promise.resolve(geometry);
            let pendingPositionAccessors = [], pendingNormalAccessors = [], pendingColorAccessors = [];
            for (let i = 0, il = targets.length; i < il; i++) {
              let target = targets[i];
              if (hasMorphPosition) {
                let pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
                pendingPositionAccessors.push(pendingAccessor);
              }
              if (hasMorphNormal) {
                let pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
                pendingNormalAccessors.push(pendingAccessor);
              }
              if (hasMorphColor) {
                let pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
                pendingColorAccessors.push(pendingAccessor);
              }
            }
            return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors), Promise.all(pendingColorAccessors)]).then(function(accessors) {
              let morphPositions = accessors[0], morphNormals = accessors[1], morphColors = accessors[2];
              return hasMorphPosition && (geometry.morphAttributes.position = morphPositions), hasMorphNormal && (geometry.morphAttributes.normal = morphNormals), hasMorphColor && (geometry.morphAttributes.color = morphColors), geometry.morphTargetsRelative = !0, geometry;
            });
          }
          function updateMorphTargets(mesh, meshDef) {
            if (mesh.updateMorphTargets(), meshDef.weights !== void 0)
              for (let i = 0, il = meshDef.weights.length; i < il; i++)
                mesh.morphTargetInfluences[i] = meshDef.weights[i];
            if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
              let targetNames = meshDef.extras.targetNames;
              if (mesh.morphTargetInfluences.length === targetNames.length) {
                mesh.morphTargetDictionary = {};
                for (let i = 0, il = targetNames.length; i < il; i++)
                  mesh.morphTargetDictionary[targetNames[i]] = i;
              } else
                console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
            }
          }
          function createPrimitiveKey(primitiveDef) {
            let geometryKey, dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
            if (dracoExtension ? geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes) : geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode, primitiveDef.targets !== void 0)
              for (let i = 0, il = primitiveDef.targets.length; i < il; i++)
                geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
            return geometryKey;
          }
          function createAttributesKey(attributes) {
            let attributesKey = "", keys = Object.keys(attributes).sort();
            for (let i = 0, il = keys.length; i < il; i++)
              attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
            return attributesKey;
          }
          function getNormalizedComponentScale(constructor) {
            switch (constructor) {
              case Int8Array:
                return 1 / 127;
              case Uint8Array:
                return 1 / 255;
              case Int16Array:
                return 1 / 32767;
              case Uint16Array:
                return 1 / 65535;
              default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
            }
          }
          function getImageURIMimeType(uri) {
            return uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
          }
          let _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
          class GLTFParser {
            constructor(json = {}, options = {}) {
              this.json = json, this.extensions = {}, this.plugins = {}, this.options = options, this.cache = new GLTFRegistry(), this.associations = new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                refs: {},
                uses: {}
              }, this.cameraCache = {
                refs: {},
                uses: {}
              }, this.lightCache = {
                refs: {},
                uses: {}
              }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
              let isSafari = !1, isFirefox = !1, firefoxVersion = -1;
              typeof navigator != "undefined" && (isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, isFirefox = navigator.userAgent.indexOf("Firefox") > -1, firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap == "undefined" || isSafari || isFirefox && firefoxVersion < 98 ? this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager) : this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
            }
            setExtensions(extensions) {
              this.extensions = extensions;
            }
            setPlugins(plugins) {
              this.plugins = plugins;
            }
            parse(onLoad, onError) {
              let parser = this, json = this.json, extensions = this.extensions;
              this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(ext) {
                return ext._markDefs && ext._markDefs();
              }), Promise.all(this._invokeAll(function(ext) {
                return ext.beforeRoot && ext.beforeRoot();
              })).then(function() {
                return Promise.all([parser.getDependencies("scene"), parser.getDependencies("animation"), parser.getDependencies("camera")]);
              }).then(function(dependencies) {
                let result = {
                  scene: dependencies[0][json.scene || 0],
                  scenes: dependencies[0],
                  animations: dependencies[1],
                  cameras: dependencies[2],
                  asset: json.asset,
                  parser,
                  userData: {}
                };
                return addUnknownExtensionsToUserData(extensions, result, json), assignExtrasToUserData(result, json), Promise.all(parser._invokeAll(function(ext) {
                  return ext.afterRoot && ext.afterRoot(result);
                })).then(function() {
                  for (let scene of result.scenes)
                    scene.updateMatrixWorld();
                  onLoad(result);
                });
              }).catch(onError);
            }
            _markDefs() {
              let nodeDefs = this.json.nodes || [], skinDefs = this.json.skins || [], meshDefs = this.json.meshes || [];
              for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
                let joints = skinDefs[skinIndex].joints;
                for (let i = 0, il = joints.length; i < il; i++)
                  nodeDefs[joints[i]].isBone = !0;
              }
              for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
                let nodeDef = nodeDefs[nodeIndex];
                nodeDef.mesh !== void 0 && (this._addNodeRef(this.meshCache, nodeDef.mesh), nodeDef.skin !== void 0 && (meshDefs[nodeDef.mesh].isSkinnedMesh = !0)), nodeDef.camera !== void 0 && this._addNodeRef(this.cameraCache, nodeDef.camera);
              }
            }
            _addNodeRef(cache, index) {
              index !== void 0 && (cache.refs[index] === void 0 && (cache.refs[index] = cache.uses[index] = 0), cache.refs[index]++);
            }
            _getNodeRef(cache, index, object) {
              if (cache.refs[index] <= 1)
                return object;
              let ref = object.clone(), updateMappings = (original, clone) => {
                let mappings = this.associations.get(original);
                mappings != null && this.associations.set(clone, mappings);
                for (let [i, child] of original.children.entries())
                  updateMappings(child, clone.children[i]);
              };
              return updateMappings(object, ref), ref.name += "_instance_" + cache.uses[index]++, ref;
            }
            _invokeOne(func) {
              let extensions = Object.values(this.plugins);
              extensions.push(this);
              for (let i = 0; i < extensions.length; i++) {
                let result = func(extensions[i]);
                if (result)
                  return result;
              }
              return null;
            }
            _invokeAll(func) {
              let extensions = Object.values(this.plugins);
              extensions.unshift(this);
              let pending = [];
              for (let i = 0; i < extensions.length; i++) {
                let result = func(extensions[i]);
                result && pending.push(result);
              }
              return pending;
            }
            getDependency(type, index) {
              let cacheKey = type + ":" + index, dependency = this.cache.get(cacheKey);
              if (!dependency) {
                switch (type) {
                  case "scene":
                    dependency = this.loadScene(index);
                    break;
                  case "node":
                    dependency = this._invokeOne(function(ext) {
                      return ext.loadNode && ext.loadNode(index);
                    });
                    break;
                  case "mesh":
                    dependency = this._invokeOne(function(ext) {
                      return ext.loadMesh && ext.loadMesh(index);
                    });
                    break;
                  case "accessor":
                    dependency = this.loadAccessor(index);
                    break;
                  case "bufferView":
                    dependency = this._invokeOne(function(ext) {
                      return ext.loadBufferView && ext.loadBufferView(index);
                    });
                    break;
                  case "buffer":
                    dependency = this.loadBuffer(index);
                    break;
                  case "material":
                    dependency = this._invokeOne(function(ext) {
                      return ext.loadMaterial && ext.loadMaterial(index);
                    });
                    break;
                  case "texture":
                    dependency = this._invokeOne(function(ext) {
                      return ext.loadTexture && ext.loadTexture(index);
                    });
                    break;
                  case "skin":
                    dependency = this.loadSkin(index);
                    break;
                  case "animation":
                    dependency = this._invokeOne(function(ext) {
                      return ext.loadAnimation && ext.loadAnimation(index);
                    });
                    break;
                  case "camera":
                    dependency = this.loadCamera(index);
                    break;
                  default:
                    if (dependency = this._invokeOne(function(ext) {
                      return ext != this && ext.getDependency && ext.getDependency(type, index);
                    }), !dependency)
                      throw new Error("Unknown type: " + type);
                    break;
                }
                this.cache.add(cacheKey, dependency);
              }
              return dependency;
            }
            getDependencies(type) {
              let dependencies = this.cache.get(type);
              if (!dependencies) {
                let parser = this, defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
                dependencies = Promise.all(defs.map(function(def, index) {
                  return parser.getDependency(type, index);
                })), this.cache.add(type, dependencies);
              }
              return dependencies;
            }
            loadBuffer(bufferIndex) {
              let bufferDef = this.json.buffers[bufferIndex], loader = this.fileLoader;
              if (bufferDef.type && bufferDef.type !== "arraybuffer")
                throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
              if (bufferDef.uri === void 0 && bufferIndex === 0)
                return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
              let options = this.options;
              return new Promise(function(resolve, reject) {
                loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
                  reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
                });
              });
            }
            loadBufferView(bufferViewIndex) {
              let bufferViewDef = this.json.bufferViews[bufferViewIndex];
              return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
                let byteLength = bufferViewDef.byteLength || 0, byteOffset = bufferViewDef.byteOffset || 0;
                return buffer.slice(byteOffset, byteOffset + byteLength);
              });
            }
            loadAccessor(accessorIndex) {
              let parser = this, json = this.json, accessorDef = this.json.accessors[accessorIndex];
              if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
                let itemSize = WEBGL_TYPE_SIZES[accessorDef.type], TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType], normalized = accessorDef.normalized === !0, array = new TypedArray(accessorDef.count * itemSize);
                return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));
              }
              let pendingBufferViews = [];
              return accessorDef.bufferView !== void 0 ? pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView)) : pendingBufferViews.push(null), accessorDef.sparse !== void 0 && (pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView)), pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView))), Promise.all(pendingBufferViews).then(function(bufferViews) {
                let bufferView = bufferViews[0], itemSize = WEBGL_TYPE_SIZES[accessorDef.type], TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType], elementBytes = TypedArray.BYTES_PER_ELEMENT, itemBytes = elementBytes * itemSize, byteOffset = accessorDef.byteOffset || 0, byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0, normalized = accessorDef.normalized === !0, array, bufferAttribute;
                if (byteStride && byteStride !== itemBytes) {
                  let ibSlice = Math.floor(byteOffset / byteStride), ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count, ib = parser.cache.get(ibCacheKey);
                  ib || (array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes), ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes), parser.cache.add(ibCacheKey, ib)), bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
                } else
                  bufferView === null ? array = new TypedArray(accessorDef.count * itemSize) : array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize), bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);
                if (accessorDef.sparse !== void 0) {
                  let itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR, TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType], byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0, byteOffsetValues = accessorDef.sparse.values.byteOffset || 0, sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices), sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
                  bufferView !== null && (bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized));
                  for (let i = 0, il = sparseIndices.length; i < il; i++) {
                    let index = sparseIndices[i];
                    if (bufferAttribute.setX(index, sparseValues[i * itemSize]), itemSize >= 2 && bufferAttribute.setY(index, sparseValues[i * itemSize + 1]), itemSize >= 3 && bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]), itemSize >= 4 && bufferAttribute.setW(index, sparseValues[i * itemSize + 3]), itemSize >= 5)
                      throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                  }
                }
                return bufferAttribute;
              });
            }
            loadTexture(textureIndex) {
              let json = this.json, options = this.options, sourceIndex = json.textures[textureIndex].source, sourceDef = json.images[sourceIndex], loader = this.textureLoader;
              if (sourceDef.uri) {
                let handler = options.manager.getHandler(sourceDef.uri);
                handler !== null && (loader = handler);
              }
              return this.loadTextureImage(textureIndex, sourceIndex, loader);
            }
            loadTextureImage(textureIndex, sourceIndex, loader) {
              let parser = this, json = this.json, textureDef = json.textures[textureIndex], sourceDef = json.images[sourceIndex], cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
              if (this.textureCache[cacheKey])
                return this.textureCache[cacheKey];
              let promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
                texture.flipY = !1, texture.name = textureDef.name || sourceDef.name || "", texture.name === "" && typeof sourceDef.uri == "string" && sourceDef.uri.startsWith("data:image/") === !1 && (texture.name = sourceDef.uri);
                let sampler = (json.samplers || {})[textureDef.sampler] || {};
                return texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter, texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, parser.associations.set(texture, {
                  textures: textureIndex
                }), texture;
              }).catch(function() {
                return null;
              });
              return this.textureCache[cacheKey] = promise, promise;
            }
            loadImageSource(sourceIndex, loader) {
              let parser = this, json = this.json, options = this.options;
              if (this.sourceCache[sourceIndex] !== void 0)
                return this.sourceCache[sourceIndex].then((texture) => texture.clone());
              let sourceDef = json.images[sourceIndex], URL2 = self.URL || self.webkitURL, sourceURI = sourceDef.uri || "", isObjectURL = !1;
              if (sourceDef.bufferView !== void 0)
                sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
                  isObjectURL = !0;
                  let blob = new Blob([bufferView], {
                    type: sourceDef.mimeType
                  });
                  return sourceURI = URL2.createObjectURL(blob), sourceURI;
                });
              else if (sourceDef.uri === void 0)
                throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
              let promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
                return new Promise(function(resolve, reject) {
                  let onLoad = resolve;
                  loader.isImageBitmapLoader === !0 && (onLoad = function(imageBitmap) {
                    let texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);
                    texture.needsUpdate = !0, resolve(texture);
                  }), loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
                });
              }).then(function(texture) {
                return isObjectURL === !0 && URL2.revokeObjectURL(sourceURI), texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri), texture;
              }).catch(function(error) {
                throw console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI), error;
              });
              return this.sourceCache[sourceIndex] = promise, promise;
            }
            assignTexture(materialParams, mapName, mapDef, colorSpace) {
              let parser = this;
              return this.getDependency("texture", mapDef.index).then(function(texture) {
                if (!texture)
                  return null;
                if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0 && (texture = texture.clone(), texture.channel = mapDef.texCoord), parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
                  let transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
                  if (transform) {
                    let gltfReference = parser.associations.get(texture);
                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform), parser.associations.set(texture, gltfReference);
                  }
                }
                return colorSpace !== void 0 && (texture.colorSpace = colorSpace), materialParams[mapName] = texture, texture;
              });
            }
            assignFinalMaterial(mesh) {
              let geometry = mesh.geometry, material = mesh.material, useDerivativeTangents = geometry.attributes.tangent === void 0, useVertexColors = geometry.attributes.color !== void 0, useFlatShading = geometry.attributes.normal === void 0;
              if (mesh.isPoints) {
                let cacheKey = "PointsMaterial:" + material.uuid, pointsMaterial = this.cache.get(cacheKey);
                pointsMaterial || (pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial(), three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material), pointsMaterial.color.copy(material.color), pointsMaterial.map = material.map, pointsMaterial.sizeAttenuation = !1, this.cache.add(cacheKey, pointsMaterial)), material = pointsMaterial;
              } else if (mesh.isLine) {
                let cacheKey = "LineBasicMaterial:" + material.uuid, lineMaterial = this.cache.get(cacheKey);
                lineMaterial || (lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial(), three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material), lineMaterial.color.copy(material.color), lineMaterial.map = material.map, this.cache.add(cacheKey, lineMaterial)), material = lineMaterial;
              }
              if (useDerivativeTangents || useVertexColors || useFlatShading) {
                let cacheKey = "ClonedMaterial:" + material.uuid + ":";
                useDerivativeTangents && (cacheKey += "derivative-tangents:"), useVertexColors && (cacheKey += "vertex-colors:"), useFlatShading && (cacheKey += "flat-shading:");
                let cachedMaterial = this.cache.get(cacheKey);
                cachedMaterial || (cachedMaterial = material.clone(), useVertexColors && (cachedMaterial.vertexColors = !0), useFlatShading && (cachedMaterial.flatShading = !0), useDerivativeTangents && (cachedMaterial.normalScale && (cachedMaterial.normalScale.y *= -1), cachedMaterial.clearcoatNormalScale && (cachedMaterial.clearcoatNormalScale.y *= -1)), this.cache.add(cacheKey, cachedMaterial), this.associations.set(cachedMaterial, this.associations.get(material))), material = cachedMaterial;
              }
              mesh.material = material;
            }
            getMaterialType() {
              return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;
            }
            loadMaterial(materialIndex) {
              let parser = this, json = this.json, extensions = this.extensions, materialDef = json.materials[materialIndex], materialType, materialParams = {}, materialExtensions = materialDef.extensions || {}, pending = [];
              if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
                let kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
                materialType = kmuExtension.getMaterialType(), pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
              } else {
                let metallicRoughness = materialDef.pbrMetallicRoughness || {};
                if (materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1), materialParams.opacity = 1, Array.isArray(metallicRoughness.baseColorFactor)) {
                  let array = metallicRoughness.baseColorFactor;
                  materialParams.color.setRGB(array[0], array[1], array[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace), materialParams.opacity = array[3];
                }
                metallicRoughness.baseColorTexture !== void 0 && pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace)), materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1, materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1, metallicRoughness.metallicRoughnessTexture !== void 0 && (pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture)), pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture))), materialType = this._invokeOne(function(ext) {
                  return ext.getMaterialType && ext.getMaterialType(materialIndex);
                }), pending.push(Promise.all(this._invokeAll(function(ext) {
                  return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
                })));
              }
              materialDef.doubleSided === !0 && (materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide);
              let alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
              if (alphaMode === ALPHA_MODES.BLEND ? (materialParams.transparent = !0, materialParams.depthWrite = !1) : (materialParams.transparent = !1, alphaMode === ALPHA_MODES.MASK && (materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5)), materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial && (pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture)), materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1), materialDef.normalTexture.scale !== void 0)) {
                let scale = materialDef.normalTexture.scale;
                materialParams.normalScale.set(scale, scale);
              }
              if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial && (pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture)), materialDef.occlusionTexture.strength !== void 0 && (materialParams.aoMapIntensity = materialDef.occlusionTexture.strength)), materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {
                let emissiveFactor = materialDef.emissiveFactor;
                materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);
              }
              return materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial && pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace)), Promise.all(pending).then(function() {
                let material = new materialType(materialParams);
                return materialDef.name && (material.name = materialDef.name), assignExtrasToUserData(material, materialDef), parser.associations.set(material, {
                  materials: materialIndex
                }), materialDef.extensions && addUnknownExtensionsToUserData(extensions, material, materialDef), material;
              });
            }
            createUniqueName(originalName) {
              let sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || "");
              return sanitizedName in this.nodeNamesUsed ? sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName] : (this.nodeNamesUsed[sanitizedName] = 0, sanitizedName);
            }
            loadGeometries(primitives) {
              let parser = this, extensions = this.extensions, cache = this.primitiveCache;
              function createDracoPrimitive(primitive) {
                return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
                  return addPrimitiveAttributes(geometry, primitive, parser);
                });
              }
              let pending = [];
              for (let i = 0, il = primitives.length; i < il; i++) {
                let primitive = primitives[i], cacheKey = createPrimitiveKey(primitive), cached = cache[cacheKey];
                if (cached)
                  pending.push(cached.promise);
                else {
                  let geometryPromise;
                  primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] ? geometryPromise = createDracoPrimitive(primitive) : geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser), cache[cacheKey] = {
                    primitive,
                    promise: geometryPromise
                  }, pending.push(geometryPromise);
                }
              }
              return Promise.all(pending);
            }
            loadMesh(meshIndex) {
              let parser = this, json = this.json, extensions = this.extensions, meshDef = json.meshes[meshIndex], primitives = meshDef.primitives, pending = [];
              for (let i = 0, il = primitives.length; i < il; i++) {
                let material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
                pending.push(material);
              }
              return pending.push(parser.loadGeometries(primitives)), Promise.all(pending).then(function(results) {
                let materials = results.slice(0, results.length - 1), geometries = results[results.length - 1], meshes = [];
                for (let i = 0, il = geometries.length; i < il; i++) {
                  let geometry = geometries[i], primitive = primitives[i], mesh, material = materials[i];
                  if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0)
                    mesh = meshDef.isSkinnedMesh === !0 ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material), mesh.isSkinnedMesh === !0 && mesh.normalizeSkinWeights(), primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ? mesh.geometry = (0, _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) : primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN && (mesh.geometry = (0, _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode));
                  else if (primitive.mode === WEBGL_CONSTANTS.LINES)
                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);
                  else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP)
                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);
                  else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP)
                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);
                  else if (primitive.mode === WEBGL_CONSTANTS.POINTS)
                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);
                  else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
                  Object.keys(mesh.geometry.morphAttributes).length > 0 && updateMorphTargets(mesh, meshDef), mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex), assignExtrasToUserData(mesh, meshDef), primitive.extensions && addUnknownExtensionsToUserData(extensions, mesh, primitive), parser.assignFinalMaterial(mesh), meshes.push(mesh);
                }
                for (let i = 0, il = meshes.length; i < il; i++)
                  parser.associations.set(meshes[i], {
                    meshes: meshIndex,
                    primitives: i
                  });
                if (meshes.length === 1)
                  return meshDef.extensions && addUnknownExtensionsToUserData(extensions, meshes[0], meshDef), meshes[0];
                let group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();
                meshDef.extensions && addUnknownExtensionsToUserData(extensions, group, meshDef), parser.associations.set(group, {
                  meshes: meshIndex
                });
                for (let i = 0, il = meshes.length; i < il; i++)
                  group.add(meshes[i]);
                return group;
              });
            }
            loadCamera(cameraIndex) {
              let camera, cameraDef = this.json.cameras[cameraIndex], params = cameraDef[cameraDef.type];
              if (!params) {
                console.warn("THREE.GLTFLoader: Missing camera parameters.");
                return;
              }
              return cameraDef.type === "perspective" ? camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6) : cameraDef.type === "orthographic" && (camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)), cameraDef.name && (camera.name = this.createUniqueName(cameraDef.name)), assignExtrasToUserData(camera, cameraDef), Promise.resolve(camera);
            }
            loadSkin(skinIndex) {
              let skinDef = this.json.skins[skinIndex], pending = [];
              for (let i = 0, il = skinDef.joints.length; i < il; i++)
                pending.push(this._loadNodeShallow(skinDef.joints[i]));
              return skinDef.inverseBindMatrices !== void 0 ? pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices)) : pending.push(null), Promise.all(pending).then(function(results) {
                let inverseBindMatrices = results.pop(), jointNodes = results, bones = [], boneInverses = [];
                for (let i = 0, il = jointNodes.length; i < il; i++) {
                  let jointNode = jointNodes[i];
                  if (jointNode) {
                    bones.push(jointNode);
                    let mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
                    inverseBindMatrices !== null && mat.fromArray(inverseBindMatrices.array, i * 16), boneInverses.push(mat);
                  } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
                }
                return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);
              });
            }
            loadAnimation(animationIndex) {
              let json = this.json, parser = this, animationDef = json.animations[animationIndex], animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex, pendingNodes = [], pendingInputAccessors = [], pendingOutputAccessors = [], pendingSamplers = [], pendingTargets = [];
              for (let i = 0, il = animationDef.channels.length; i < il; i++) {
                let channel = animationDef.channels[i], sampler = animationDef.samplers[channel.sampler], target = channel.target, name = target.node, input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input, output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
                target.node !== void 0 && (pendingNodes.push(this.getDependency("node", name)), pendingInputAccessors.push(this.getDependency("accessor", input)), pendingOutputAccessors.push(this.getDependency("accessor", output)), pendingSamplers.push(sampler), pendingTargets.push(target));
              }
              return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function(dependencies) {
                let nodes = dependencies[0], inputAccessors = dependencies[1], outputAccessors = dependencies[2], samplers = dependencies[3], targets = dependencies[4], tracks = [];
                for (let i = 0, il = nodes.length; i < il; i++) {
                  let node = nodes[i], inputAccessor = inputAccessors[i], outputAccessor = outputAccessors[i], sampler = samplers[i], target = targets[i];
                  if (node === void 0)
                    continue;
                  node.updateMatrix && node.updateMatrix();
                  let createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
                  if (createdTracks)
                    for (let k = 0; k < createdTracks.length; k++)
                      tracks.push(createdTracks[k]);
                }
                return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);
              });
            }
            createNodeMesh(nodeIndex) {
              let json = this.json, parser = this, nodeDef = json.nodes[nodeIndex];
              return nodeDef.mesh === void 0 ? null : parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
                let node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
                return nodeDef.weights !== void 0 && node.traverse(function(o) {
                  if (!!o.isMesh)
                    for (let i = 0, il = nodeDef.weights.length; i < il; i++)
                      o.morphTargetInfluences[i] = nodeDef.weights[i];
                }), node;
              });
            }
            loadNode(nodeIndex) {
              let json = this.json, parser = this, nodeDef = json.nodes[nodeIndex], nodePending = parser._loadNodeShallow(nodeIndex), childPending = [], childrenDef = nodeDef.children || [];
              for (let i = 0, il = childrenDef.length; i < il; i++)
                childPending.push(parser.getDependency("node", childrenDef[i]));
              let skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
              return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {
                let node = results[0], children = results[1], skeleton = results[2];
                skeleton !== null && node.traverse(function(mesh) {
                  !mesh.isSkinnedMesh || mesh.bind(skeleton, _identityMatrix);
                });
                for (let i = 0, il = children.length; i < il; i++)
                  node.add(children[i]);
                return node;
              });
            }
            _loadNodeShallow(nodeIndex) {
              let json = this.json, extensions = this.extensions, parser = this;
              if (this.nodeCache[nodeIndex] !== void 0)
                return this.nodeCache[nodeIndex];
              let nodeDef = json.nodes[nodeIndex], nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "", pending = [], meshPromise = parser._invokeOne(function(ext) {
                return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
              });
              return meshPromise && pending.push(meshPromise), nodeDef.camera !== void 0 && pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
              })), parser._invokeAll(function(ext) {
                return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
              }).forEach(function(promise) {
                pending.push(promise);
              }), this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
                let node;
                if (nodeDef.isBone === !0 ? node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone() : objects.length > 1 ? node = new three__WEBPACK_IMPORTED_MODULE_0__.Group() : objects.length === 1 ? node = objects[0] : node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D(), node !== objects[0])
                  for (let i = 0, il = objects.length; i < il; i++)
                    node.add(objects[i]);
                if (nodeDef.name && (node.userData.name = nodeDef.name, node.name = nodeName), assignExtrasToUserData(node, nodeDef), nodeDef.extensions && addUnknownExtensionsToUserData(extensions, node, nodeDef), nodeDef.matrix !== void 0) {
                  let matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
                  matrix.fromArray(nodeDef.matrix), node.applyMatrix4(matrix);
                } else
                  nodeDef.translation !== void 0 && node.position.fromArray(nodeDef.translation), nodeDef.rotation !== void 0 && node.quaternion.fromArray(nodeDef.rotation), nodeDef.scale !== void 0 && node.scale.fromArray(nodeDef.scale);
                return parser.associations.has(node) || parser.associations.set(node, {}), parser.associations.get(node).nodes = nodeIndex, node;
              }), this.nodeCache[nodeIndex];
            }
            loadScene(sceneIndex) {
              let extensions = this.extensions, sceneDef = this.json.scenes[sceneIndex], parser = this, scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();
              sceneDef.name && (scene.name = parser.createUniqueName(sceneDef.name)), assignExtrasToUserData(scene, sceneDef), sceneDef.extensions && addUnknownExtensionsToUserData(extensions, scene, sceneDef);
              let nodeIds = sceneDef.nodes || [], pending = [];
              for (let i = 0, il = nodeIds.length; i < il; i++)
                pending.push(parser.getDependency("node", nodeIds[i]));
              return Promise.all(pending).then(function(nodes) {
                for (let i = 0, il = nodes.length; i < il; i++)
                  scene.add(nodes[i]);
                let reduceAssociations = (node) => {
                  let reducedAssociations = new Map();
                  for (let [key, value] of parser.associations)
                    (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) && reducedAssociations.set(key, value);
                  return node.traverse((node2) => {
                    let mappings = parser.associations.get(node2);
                    mappings != null && reducedAssociations.set(node2, mappings);
                  }), reducedAssociations;
                };
                return parser.associations = reduceAssociations(scene), scene;
              });
            }
            _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
              let tracks = [], targetName = node.name ? node.name : node.uuid, targetNames = [];
              PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights ? node.traverse(function(object) {
                object.morphTargetInfluences && targetNames.push(object.name ? object.name : object.uuid);
              }) : targetNames.push(targetName);
              let TypedKeyframeTrack;
              switch (PATH_PROPERTIES[target.path]) {
                case PATH_PROPERTIES.weights:
                  TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;
                  break;
                case PATH_PROPERTIES.rotation:
                  TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;
                  break;
                case PATH_PROPERTIES.position:
                case PATH_PROPERTIES.scale:
                  TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;
                  break;
                default:
                  switch (outputAccessor.itemSize) {
                    case 1:
                      TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;
                      break;
                    case 2:
                    case 3:
                    default:
                      TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;
                      break;
                  }
                  break;
              }
              let interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear, outputArray = this._getArrayFromAccessor(outputAccessor);
              for (let j = 0, jl = targetNames.length; j < jl; j++) {
                let track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);
                sampler.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(track), tracks.push(track);
              }
              return tracks;
            }
            _getArrayFromAccessor(accessor) {
              let outputArray = accessor.array;
              if (accessor.normalized) {
                let scale = getNormalizedComponentScale(outputArray.constructor), scaled = new Float32Array(outputArray.length);
                for (let j = 0, jl = outputArray.length; j < jl; j++)
                  scaled[j] = outputArray[j] * scale;
                outputArray = scaled;
              }
              return outputArray;
            }
            _createCubicSplineTrackInterpolant(track) {
              track.createInterpolant = function(result) {
                let interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
                return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
              }, track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
            }
          }
          function computeBounds(geometry, primitiveDef, parser) {
            let attributes = primitiveDef.attributes, box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
            if (attributes.POSITION !== void 0) {
              let accessor = parser.json.accessors[attributes.POSITION], min = accessor.min, max = accessor.max;
              if (min !== void 0 && max !== void 0) {
                if (box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2])), accessor.normalized) {
                  let boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
                  box.min.multiplyScalar(boxScale), box.max.multiplyScalar(boxScale);
                }
              } else {
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                return;
              }
            } else
              return;
            let targets = primitiveDef.targets;
            if (targets !== void 0) {
              let maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
              for (let i = 0, il = targets.length; i < il; i++) {
                let target = targets[i];
                if (target.POSITION !== void 0) {
                  let accessor = parser.json.accessors[target.POSITION], min = accessor.min, max = accessor.max;
                  if (min !== void 0 && max !== void 0) {
                    if (vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0]))), vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1]))), vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2]))), accessor.normalized) {
                      let boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
                      vector.multiplyScalar(boxScale);
                    }
                    maxDisplacement.max(vector);
                  } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                }
              }
              box.expandByVector(maxDisplacement);
            }
            geometry.boundingBox = box;
            let sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();
            box.getCenter(sphere.center), sphere.radius = box.min.distanceTo(box.max) / 2, geometry.boundingSphere = sphere;
          }
          function addPrimitiveAttributes(geometry, primitiveDef, parser) {
            let attributes = primitiveDef.attributes, pending = [];
            function assignAttributeAccessor(accessorIndex, attributeName) {
              return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
                geometry.setAttribute(attributeName, accessor);
              });
            }
            for (let gltfAttributeName in attributes) {
              let threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
              threeAttributeName in geometry.attributes || pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
            }
            if (primitiveDef.indices !== void 0 && !geometry.index) {
              let accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
                geometry.setIndex(accessor2);
              });
              pending.push(accessor);
            }
            return three__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.workingColorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace && "COLOR_0" in attributes && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${three__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.workingColorSpace}" not supported.`), assignExtrasToUserData(geometry, primitiveDef), computeBounds(geometry, primitiveDef, parser), Promise.all(pending).then(function() {
              return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
            });
          }
        },
        "./node_modules/three/examples/jsm/loaders/KTX2Loader.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            KTX2Loader: () => KTX2Loader
          });
          var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/three/build/three.module.js"), _utils_WorkerPool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2("./node_modules/three/examples/jsm/utils/WorkerPool.js"), _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2("./node_modules/three/examples/jsm/libs/ktx-parse.module.js"), _libs_zstddec_module_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2("./node_modules/three/examples/jsm/libs/zstddec.module.js");
          let _taskCache = new WeakMap(), _activeLoaders = 0, _zstd;
          class KTX2Loader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {
            constructor(manager) {
              super(manager);
              this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new _utils_WorkerPool_js__WEBPACK_IMPORTED_MODULE_1__.WorkerPool(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER != "undefined" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
            }
            setTranscoderPath(path) {
              return this.transcoderPath = path, this;
            }
            setWorkerLimit(num) {
              return this.workerPool.setWorkerLimit(num), this;
            }
            async detectSupportAsync(renderer) {
              return this.workerConfig = {
                astcSupported: await renderer.hasFeatureAsync("texture-compression-astc"),
                etc1Supported: await renderer.hasFeatureAsync("texture-compression-etc1"),
                etc2Supported: await renderer.hasFeatureAsync("texture-compression-etc2"),
                dxtSupported: await renderer.hasFeatureAsync("texture-compression-bc"),
                bptcSupported: await renderer.hasFeatureAsync("texture-compression-bptc"),
                pvrtcSupported: await renderer.hasFeatureAsync("texture-compression-pvrtc")
              }, this;
            }
            detectSupport(renderer) {
              return renderer.isWebGPURenderer === !0 ? this.workerConfig = {
                astcSupported: renderer.hasFeature("texture-compression-astc"),
                etc1Supported: renderer.hasFeature("texture-compression-etc1"),
                etc2Supported: renderer.hasFeature("texture-compression-etc2"),
                dxtSupported: renderer.hasFeature("texture-compression-bc"),
                bptcSupported: renderer.hasFeature("texture-compression-bptc"),
                pvrtcSupported: renderer.hasFeature("texture-compression-pvrtc")
              } : this.workerConfig = {
                astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
                etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
                etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
                dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
                bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
                pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
              }, this;
            }
            init() {
              if (!this.transcoderPending) {
                let jsLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
                jsLoader.setPath(this.transcoderPath), jsLoader.setWithCredentials(this.withCredentials);
                let jsContent = jsLoader.loadAsync("basis_transcoder.js"), binaryLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
                binaryLoader.setPath(this.transcoderPath), binaryLoader.setResponseType("arraybuffer"), binaryLoader.setWithCredentials(this.withCredentials);
                let binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
                this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
                  let fn = KTX2Loader.BasisWorker.toString(), body = ["/* constants */", "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat), "/* basis_transcoder.js */", jsContent2, "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join(`
`);
                  this.workerSourceURL = URL.createObjectURL(new Blob([body])), this.transcoderBinary = binaryContent2, this.workerPool.setWorkerCreator(() => {
                    let worker = new Worker(this.workerSourceURL), transcoderBinary = this.transcoderBinary.slice(0);
                    return worker.postMessage({
                      type: "init",
                      config: this.workerConfig,
                      transcoderBinary
                    }, [transcoderBinary]), worker;
                  });
                }), _activeLoaders > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), _activeLoaders++;
              }
              return this.transcoderPending;
            }
            load(url, onLoad, onProgress, onError) {
              if (this.workerConfig === null)
                throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
              let loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
              loader.setResponseType("arraybuffer"), loader.setWithCredentials(this.withCredentials), loader.load(url, (buffer) => {
                if (_taskCache.has(buffer))
                  return _taskCache.get(buffer).promise.then(onLoad).catch(onError);
                this._createTexture(buffer).then((texture) => onLoad ? onLoad(texture) : null).catch(onError);
              }, onProgress, onError);
            }
            _createTextureFrom(transcodeResult, container) {
              let {
                faces,
                width,
                height,
                format,
                type,
                error,
                dfdFlags
              } = transcodeResult;
              if (type === "error")
                return Promise.reject(error);
              let texture;
              if (container.faceCount === 6)
                texture = new three__WEBPACK_IMPORTED_MODULE_0__.CompressedCubeTexture(faces, format, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType);
              else {
                let mipmaps = faces[0].mipmaps;
                texture = container.layerCount > 1 ? new three__WEBPACK_IMPORTED_MODULE_0__.CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType) : new three__WEBPACK_IMPORTED_MODULE_0__.CompressedTexture(mipmaps, width, height, format, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType);
              }
              return texture.minFilter = faces[0].mipmaps.length === 1 ? three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter, texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, texture.generateMipmaps = !1, texture.needsUpdate = !0, texture.colorSpace = parseColorSpace(container), texture.premultiplyAlpha = !!(dfdFlags & _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.KHR_DF_FLAG_ALPHA_PREMULTIPLIED), texture;
            }
            async _createTexture(buffer, config = {}) {
              let container = (0, _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.read)(new Uint8Array(buffer));
              if (container.vkFormat !== _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_UNDEFINED)
                return createRawTexture(container);
              let taskConfig = config, texturePending = this.init().then(() => this.workerPool.postMessage({
                type: "transcode",
                buffer,
                taskConfig
              }, [buffer])).then((e) => this._createTextureFrom(e.data, container));
              return _taskCache.set(buffer, {
                promise: texturePending
              }), texturePending;
            }
            dispose() {
              return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), _activeLoaders--, this;
            }
          }
          KTX2Loader.BasisFormat = {
            ETC1S: 0,
            UASTC_4x4: 1
          }, KTX2Loader.TranscoderFormat = {
            ETC1: 0,
            ETC2: 1,
            BC1: 2,
            BC3: 3,
            BC4: 4,
            BC5: 5,
            BC7_M6_OPAQUE_ONLY: 6,
            BC7_M5: 7,
            PVRTC1_4_RGB: 8,
            PVRTC1_4_RGBA: 9,
            ASTC_4x4: 10,
            ATC_RGB: 11,
            ATC_RGBA_INTERPOLATED_ALPHA: 12,
            RGBA32: 13,
            RGB565: 14,
            BGR565: 15,
            RGBA4444: 16
          }, KTX2Loader.EngineFormat = {
            RGBAFormat: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,
            RGBA_ASTC_4x4_Format: three__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_4x4_Format,
            RGBA_BPTC_Format: three__WEBPACK_IMPORTED_MODULE_0__.RGBA_BPTC_Format,
            RGBA_ETC2_EAC_Format: three__WEBPACK_IMPORTED_MODULE_0__.RGBA_ETC2_EAC_Format,
            RGBA_PVRTC_4BPPV1_Format: three__WEBPACK_IMPORTED_MODULE_0__.RGBA_PVRTC_4BPPV1_Format,
            RGBA_S3TC_DXT5_Format: three__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT5_Format,
            RGB_ETC1_Format: three__WEBPACK_IMPORTED_MODULE_0__.RGB_ETC1_Format,
            RGB_ETC2_Format: three__WEBPACK_IMPORTED_MODULE_0__.RGB_ETC2_Format,
            RGB_PVRTC_4BPPV1_Format: three__WEBPACK_IMPORTED_MODULE_0__.RGB_PVRTC_4BPPV1_Format,
            RGBA_S3TC_DXT1_Format: three__WEBPACK_IMPORTED_MODULE_0__.RGBA_S3TC_DXT1_Format
          }, KTX2Loader.BasisWorker = function() {
            let config, transcoderPending, BasisModule, EngineFormat = _EngineFormat, TranscoderFormat = _TranscoderFormat, BasisFormat = _BasisFormat;
            self.addEventListener("message", function(e) {
              let message = e.data;
              switch (message.type) {
                case "init":
                  config = message.config, init(message.transcoderBinary);
                  break;
                case "transcode":
                  transcoderPending.then(() => {
                    try {
                      let {
                        faces,
                        buffers,
                        width,
                        height,
                        hasAlpha,
                        format,
                        dfdFlags
                      } = transcode(message.buffer);
                      self.postMessage({
                        type: "transcode",
                        id: message.id,
                        faces,
                        width,
                        height,
                        hasAlpha,
                        format,
                        dfdFlags
                      }, buffers);
                    } catch (error) {
                      console.error(error), self.postMessage({
                        type: "error",
                        id: message.id,
                        error: error.message
                      });
                    }
                  });
                  break;
              }
            });
            function init(wasmBinary) {
              transcoderPending = new Promise((resolve) => {
                BasisModule = {
                  wasmBinary,
                  onRuntimeInitialized: resolve
                }, BASIS(BasisModule);
              }).then(() => {
                BasisModule.initializeBasis(), BasisModule.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
              });
            }
            function transcode(buffer) {
              let ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
              function cleanup() {
                ktx2File.close(), ktx2File.delete();
              }
              if (!ktx2File.isValid())
                throw cleanup(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
              let basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S, width = ktx2File.getWidth(), height = ktx2File.getHeight(), layerCount = ktx2File.getLayers() || 1, levelCount = ktx2File.getLevels(), faceCount = ktx2File.getFaces(), hasAlpha = ktx2File.getHasAlpha(), dfdFlags = ktx2File.getDFDFlags(), {
                transcoderFormat,
                engineFormat
              } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
              if (!width || !height || !levelCount)
                throw cleanup(), new Error("THREE.KTX2Loader:	Invalid texture");
              if (!ktx2File.startTranscoding())
                throw cleanup(), new Error("THREE.KTX2Loader: .startTranscoding failed");
              let faces = [], buffers = [];
              for (let face = 0; face < faceCount; face++) {
                let mipmaps = [];
                for (let mip = 0; mip < levelCount; mip++) {
                  let layerMips = [], mipWidth, mipHeight;
                  for (let layer = 0; layer < layerCount; layer++) {
                    let levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
                    face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 != 0 || levelInfo.origHeight % 4 != 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), levelCount > 1 ? (mipWidth = levelInfo.origWidth, mipHeight = levelInfo.origHeight) : (mipWidth = levelInfo.width, mipHeight = levelInfo.height);
                    let dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));
                    if (!ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1))
                      throw cleanup(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                    layerMips.push(dst);
                  }
                  let mipData = concat(layerMips);
                  mipmaps.push({
                    data: mipData,
                    width: mipWidth,
                    height: mipHeight
                  }), buffers.push(mipData.buffer);
                }
                faces.push({
                  mipmaps,
                  width,
                  height,
                  format: engineFormat
                });
              }
              return cleanup(), {
                faces,
                buffers,
                width,
                height,
                hasAlpha,
                format: engineFormat,
                dfdFlags
              };
            }
            let FORMAT_OPTIONS = [{
              if: "astcSupported",
              basisFormat: [BasisFormat.UASTC_4x4],
              transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
              engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
              priorityETC1S: 1 / 0,
              priorityUASTC: 1,
              needsPowerOfTwo: !1
            }, {
              if: "bptcSupported",
              basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
              transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
              engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
              priorityETC1S: 3,
              priorityUASTC: 2,
              needsPowerOfTwo: !1
            }, {
              if: "dxtSupported",
              basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
              transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
              engineFormat: [EngineFormat.RGBA_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
              priorityETC1S: 4,
              priorityUASTC: 5,
              needsPowerOfTwo: !1
            }, {
              if: "etc2Supported",
              basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
              transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
              engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
              priorityETC1S: 1,
              priorityUASTC: 3,
              needsPowerOfTwo: !1
            }, {
              if: "etc1Supported",
              basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
              transcoderFormat: [TranscoderFormat.ETC1],
              engineFormat: [EngineFormat.RGB_ETC1_Format],
              priorityETC1S: 2,
              priorityUASTC: 4,
              needsPowerOfTwo: !1
            }, {
              if: "pvrtcSupported",
              basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
              transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
              engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
              priorityETC1S: 5,
              priorityUASTC: 6,
              needsPowerOfTwo: !0
            }], ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
              return a.priorityETC1S - b.priorityETC1S;
            }), UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
              return a.priorityUASTC - b.priorityUASTC;
            });
            function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
              let transcoderFormat, engineFormat, options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
              for (let i = 0; i < options.length; i++) {
                let opt = options[i];
                if (!!config[opt.if] && !!opt.basisFormat.includes(basisFormat) && !(hasAlpha && opt.transcoderFormat.length < 2) && !(opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))))
                  return transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0], engineFormat = opt.engineFormat[hasAlpha ? 1 : 0], {
                    transcoderFormat,
                    engineFormat
                  };
              }
              return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), transcoderFormat = TranscoderFormat.RGBA32, engineFormat = EngineFormat.RGBAFormat, {
                transcoderFormat,
                engineFormat
              };
            }
            function isPowerOfTwo(value) {
              return value <= 2 ? !0 : (value & value - 1) == 0 && value !== 0;
            }
            function concat(arrays) {
              if (arrays.length === 1)
                return arrays[0];
              let totalByteLength = 0;
              for (let i = 0; i < arrays.length; i++)
                totalByteLength += arrays[i].byteLength;
              let result = new Uint8Array(totalByteLength), byteOffset = 0;
              for (let i = 0; i < arrays.length; i++) {
                let array = arrays[i];
                result.set(array, byteOffset), byteOffset += array.byteLength;
              }
              return result;
            }
          };
          let UNCOMPRESSED_FORMATS = new Set([three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.RGFormat, three__WEBPACK_IMPORTED_MODULE_0__.RedFormat]), FORMAT_MAP = {
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R32G32B32A32_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R16G16B16A16_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8G8B8A8_UNORM]: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8G8B8A8_SRGB]: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R32G32_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.RGFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R16G16_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.RGFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8G8_UNORM]: three__WEBPACK_IMPORTED_MODULE_0__.RGFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8G8_SRGB]: three__WEBPACK_IMPORTED_MODULE_0__.RGFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R32_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.RedFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R16_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.RedFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8_SRGB]: three__WEBPACK_IMPORTED_MODULE_0__.RedFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8_UNORM]: three__WEBPACK_IMPORTED_MODULE_0__.RedFormat,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: three__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_6x6_Format,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: three__WEBPACK_IMPORTED_MODULE_0__.RGBA_ASTC_6x6_Format
          }, TYPE_MAP = {
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R32G32B32A32_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.FloatType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R16G16B16A16_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8G8B8A8_UNORM]: three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8G8B8A8_SRGB]: three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R32G32_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.FloatType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R16G16_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8G8_UNORM]: three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8G8_SRGB]: three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R32_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.FloatType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R16_SFLOAT]: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8_SRGB]: three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_R8_UNORM]: three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_ASTC_6x6_SRGB_BLOCK]: three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType,
            [_libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.VK_FORMAT_ASTC_6x6_UNORM_BLOCK]: three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType
          };
          async function createRawTexture(container) {
            let {
              vkFormat
            } = container;
            if (FORMAT_MAP[vkFormat] === void 0)
              throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
            let zstd;
            container.supercompressionScheme === _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.KHR_SUPERCOMPRESSION_ZSTD && (_zstd || (_zstd = new Promise(async (resolve) => {
              let zstd2 = new _libs_zstddec_module_js__WEBPACK_IMPORTED_MODULE_3__.ZSTDDecoder();
              await zstd2.init(), resolve(zstd2);
            })), zstd = await _zstd);
            let mipmaps = [];
            for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {
              let levelWidth = Math.max(1, container.pixelWidth >> levelIndex), levelHeight = Math.max(1, container.pixelHeight >> levelIndex), levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0, level = container.levels[levelIndex], levelData;
              if (container.supercompressionScheme === _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.KHR_SUPERCOMPRESSION_NONE)
                levelData = level.levelData;
              else if (container.supercompressionScheme === _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.KHR_SUPERCOMPRESSION_ZSTD)
                levelData = zstd.decode(level.levelData, level.uncompressedByteLength);
              else
                throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
              let data;
              TYPE_MAP[vkFormat] === three__WEBPACK_IMPORTED_MODULE_0__.FloatType ? data = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT) : TYPE_MAP[vkFormat] === three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType ? data = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT) : data = levelData, mipmaps.push({
                data,
                width: levelWidth,
                height: levelHeight,
                depth: levelDepth
              });
            }
            let texture;
            if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat]))
              texture = container.pixelDepth === 0 ? new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new three__WEBPACK_IMPORTED_MODULE_0__.Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);
            else {
              if (container.pixelDepth > 0)
                throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
              texture = new three__WEBPACK_IMPORTED_MODULE_0__.CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight);
            }
            return texture.mipmaps = mipmaps, texture.type = TYPE_MAP[vkFormat], texture.format = FORMAT_MAP[vkFormat], texture.colorSpace = parseColorSpace(container), texture.needsUpdate = !0, Promise.resolve(texture);
          }
          function parseColorSpace(container) {
            let dfd = container.dataFormatDescriptor[0];
            return dfd.colorPrimaries === _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.KHR_DF_PRIMARIES_BT709 ? dfd.transferFunction === _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.KHR_DF_TRANSFER_SRGB ? three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace : three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace : dfd.colorPrimaries === _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.KHR_DF_PRIMARIES_DISPLAYP3 ? dfd.transferFunction === _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.KHR_DF_TRANSFER_SRGB ? three__WEBPACK_IMPORTED_MODULE_0__.DisplayP3ColorSpace : three__WEBPACK_IMPORTED_MODULE_0__.LinearDisplayP3ColorSpace : (dfd.colorPrimaries === _libs_ktx_parse_module_js__WEBPACK_IMPORTED_MODULE_2__.KHR_DF_PRIMARIES_UNSPECIFIED || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${dfd.colorPrimaries}"`), three__WEBPACK_IMPORTED_MODULE_0__.NoColorSpace);
          }
        },
        "./node_modules/three/examples/jsm/loaders/MTLLoader.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            MTLLoader: () => MTLLoader
          });
          var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/three/build/three.module.js");
          class MTLLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {
            constructor(manager) {
              super(manager);
            }
            load(url, onLoad, onProgress, onError) {
              let scope = this, path = this.path === "" ? three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url) : this.path, loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
              loader.setPath(this.path), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(this.withCredentials), loader.load(url, function(text) {
                try {
                  onLoad(scope.parse(text, path));
                } catch (e) {
                  onError ? onError(e) : console.error(e), scope.manager.itemError(url);
                }
              }, onProgress, onError);
            }
            setMaterialOptions(value) {
              return this.materialOptions = value, this;
            }
            parse(text, path) {
              let lines = text.split(`
`), info = {}, delimiter_pattern = /\s+/, materialsInfo = {};
              for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                if (line = line.trim(), line.length === 0 || line.charAt(0) === "#")
                  continue;
                let pos = line.indexOf(" "), key = pos >= 0 ? line.substring(0, pos) : line;
                key = key.toLowerCase();
                let value = pos >= 0 ? line.substring(pos + 1) : "";
                if (value = value.trim(), key === "newmtl")
                  info = {
                    name: value
                  }, materialsInfo[value] = info;
                else if (key === "ka" || key === "kd" || key === "ks" || key === "ke") {
                  let ss = value.split(delimiter_pattern, 3);
                  info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
                } else
                  info[key] = value;
              }
              let materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);
              return materialCreator.setCrossOrigin(this.crossOrigin), materialCreator.setManager(this.manager), materialCreator.setMaterials(materialsInfo), materialCreator;
            }
          }
          class MaterialCreator {
            constructor(baseUrl = "", options = {}) {
              this.baseUrl = baseUrl, this.options = options, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = this.options.side !== void 0 ? this.options.side : three__WEBPACK_IMPORTED_MODULE_0__.FrontSide, this.wrap = this.options.wrap !== void 0 ? this.options.wrap : three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;
            }
            setCrossOrigin(value) {
              return this.crossOrigin = value, this;
            }
            setManager(value) {
              this.manager = value;
            }
            setMaterials(materialsInfo) {
              this.materialsInfo = this.convert(materialsInfo), this.materials = {}, this.materialsArray = [], this.nameLookup = {};
            }
            convert(materialsInfo) {
              if (!this.options)
                return materialsInfo;
              let converted = {};
              for (let mn in materialsInfo) {
                let mat = materialsInfo[mn], covmat = {};
                converted[mn] = covmat;
                for (let prop in mat) {
                  let save = !0, value = mat[prop], lprop = prop.toLowerCase();
                  switch (lprop) {
                    case "kd":
                    case "ka":
                    case "ks":
                      this.options && this.options.normalizeRGB && (value = [value[0] / 255, value[1] / 255, value[2] / 255]), this.options && this.options.ignoreZeroRGBs && value[0] === 0 && value[1] === 0 && value[2] === 0 && (save = !1);
                      break;
                    default:
                      break;
                  }
                  save && (covmat[lprop] = value);
                }
              }
              return converted;
            }
            preload() {
              for (let mn in this.materialsInfo)
                this.create(mn);
            }
            getIndex(materialName) {
              return this.nameLookup[materialName];
            }
            getAsArray() {
              let index = 0;
              for (let mn in this.materialsInfo)
                this.materialsArray[index] = this.create(mn), this.nameLookup[mn] = index, index++;
              return this.materialsArray;
            }
            create(materialName) {
              return this.materials[materialName] === void 0 && this.createMaterial_(materialName), this.materials[materialName];
            }
            createMaterial_(materialName) {
              let scope = this, mat = this.materialsInfo[materialName], params = {
                name: materialName,
                side: this.side
              };
              function resolveURL(baseUrl, url) {
                return typeof url != "string" || url === "" ? "" : /^https?:\/\//i.test(url) ? url : baseUrl + url;
              }
              function setMapForType(mapType, value) {
                if (params[mapType])
                  return;
                let texParams = scope.getTextureParams(value, params), map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));
                map.repeat.copy(texParams.scale), map.offset.copy(texParams.offset), map.wrapS = scope.wrap, map.wrapT = scope.wrap, (mapType === "map" || mapType === "emissiveMap") && (map.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace), params[mapType] = map;
              }
              for (let prop in mat) {
                let value = mat[prop], n;
                if (value !== "")
                  switch (prop.toLowerCase()) {
                    case "kd":
                      params.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(value).convertSRGBToLinear();
                      break;
                    case "ks":
                      params.specular = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(value).convertSRGBToLinear();
                      break;
                    case "ke":
                      params.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(value).convertSRGBToLinear();
                      break;
                    case "map_kd":
                      setMapForType("map", value);
                      break;
                    case "map_ks":
                      setMapForType("specularMap", value);
                      break;
                    case "map_ke":
                      setMapForType("emissiveMap", value);
                      break;
                    case "norm":
                      setMapForType("normalMap", value);
                      break;
                    case "map_bump":
                    case "bump":
                      setMapForType("bumpMap", value);
                      break;
                    case "map_d":
                      setMapForType("alphaMap", value), params.transparent = !0;
                      break;
                    case "ns":
                      params.shininess = parseFloat(value);
                      break;
                    case "d":
                      n = parseFloat(value), n < 1 && (params.opacity = n, params.transparent = !0);
                      break;
                    case "tr":
                      n = parseFloat(value), this.options && this.options.invertTrProperty && (n = 1 - n), n > 0 && (params.opacity = 1 - n, params.transparent = !0);
                      break;
                    default:
                      break;
                  }
              }
              return this.materials[materialName] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial(params), this.materials[materialName];
            }
            getTextureParams(value, matParams) {
              let texParams = {
                scale: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1),
                offset: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0)
              }, items = value.split(/\s+/), pos;
              return pos = items.indexOf("-bm"), pos >= 0 && (matParams.bumpScale = parseFloat(items[pos + 1]), items.splice(pos, 2)), pos = items.indexOf("-s"), pos >= 0 && (texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2])), items.splice(pos, 4)), pos = items.indexOf("-o"), pos >= 0 && (texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2])), items.splice(pos, 4)), texParams.url = items.join(" ").trim(), texParams;
            }
            loadTexture(url, mapping, onLoad, onProgress, onError) {
              let manager = this.manager !== void 0 ? this.manager : three__WEBPACK_IMPORTED_MODULE_0__.DefaultLoadingManager, loader = manager.getHandler(url);
              loader === null && (loader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(manager)), loader.setCrossOrigin && loader.setCrossOrigin(this.crossOrigin);
              let texture = loader.load(url, onLoad, onProgress, onError);
              return mapping !== void 0 && (texture.mapping = mapping), texture;
            }
          }
        },
        "./node_modules/three/examples/jsm/loaders/OBJLoader.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            OBJLoader: () => OBJLoader
          });
          var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/three/build/three.module.js");
          let _object_pattern = /^[og]\s*(.+)?/, _material_library_pattern = /^mtllib /, _material_use_pattern = /^usemtl /, _map_use_pattern = /^usemap /, _face_vertex_data_separator_pattern = /\s+/, _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _ab = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _cb = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _color = new three__WEBPACK_IMPORTED_MODULE_0__.Color();
          function ParserState() {
            let state = {
              objects: [],
              object: {},
              vertices: [],
              normals: [],
              colors: [],
              uvs: [],
              materials: {},
              materialLibraries: [],
              startObject: function(name, fromDeclaration) {
                if (this.object && this.object.fromDeclaration === !1) {
                  this.object.name = name, this.object.fromDeclaration = fromDeclaration !== !1;
                  return;
                }
                let previousMaterial = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
                if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0), this.object = {
                  name: name || "",
                  fromDeclaration: fromDeclaration !== !1,
                  geometry: {
                    vertices: [],
                    normals: [],
                    colors: [],
                    uvs: [],
                    hasUVIndices: !1
                  },
                  materials: [],
                  smooth: !0,
                  startMaterial: function(name2, libraries) {
                    let previous = this._finalize(!1);
                    previous && (previous.inherited || previous.groupCount <= 0) && this.materials.splice(previous.index, 1);
                    let material = {
                      index: this.materials.length,
                      name: name2 || "",
                      mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
                      smooth: previous !== void 0 ? previous.smooth : this.smooth,
                      groupStart: previous !== void 0 ? previous.groupEnd : 0,
                      groupEnd: -1,
                      groupCount: -1,
                      inherited: !1,
                      clone: function(index) {
                        let cloned = {
                          index: typeof index == "number" ? index : this.index,
                          name: this.name,
                          mtllib: this.mtllib,
                          smooth: this.smooth,
                          groupStart: 0,
                          groupEnd: -1,
                          groupCount: -1,
                          inherited: !1
                        };
                        return cloned.clone = this.clone.bind(cloned), cloned;
                      }
                    };
                    return this.materials.push(material), material;
                  },
                  currentMaterial: function() {
                    if (this.materials.length > 0)
                      return this.materials[this.materials.length - 1];
                  },
                  _finalize: function(end) {
                    let lastMultiMaterial = this.currentMaterial();
                    if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1 && (lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3, lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart, lastMultiMaterial.inherited = !1), end && this.materials.length > 1)
                      for (let mi = this.materials.length - 1; mi >= 0; mi--)
                        this.materials[mi].groupCount <= 0 && this.materials.splice(mi, 1);
                    return end && this.materials.length === 0 && this.materials.push({
                      name: "",
                      smooth: this.smooth
                    }), lastMultiMaterial;
                  }
                }, previousMaterial && previousMaterial.name && typeof previousMaterial.clone == "function") {
                  let declared = previousMaterial.clone(0);
                  declared.inherited = !0, this.object.materials.push(declared);
                }
                this.objects.push(this.object);
              },
              finalize: function() {
                this.object && typeof this.object._finalize == "function" && this.object._finalize(!0);
              },
              parseVertexIndex: function(value, len) {
                let index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;
              },
              parseNormalIndex: function(value, len) {
                let index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;
              },
              parseUVIndex: function(value, len) {
                let index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 2) * 2;
              },
              addVertex: function(a, b, c) {
                let src = this.vertices, dst = this.object.geometry.vertices;
                dst.push(src[a + 0], src[a + 1], src[a + 2]), dst.push(src[b + 0], src[b + 1], src[b + 2]), dst.push(src[c + 0], src[c + 1], src[c + 2]);
              },
              addVertexPoint: function(a) {
                let src = this.vertices;
                this.object.geometry.vertices.push(src[a + 0], src[a + 1], src[a + 2]);
              },
              addVertexLine: function(a) {
                let src = this.vertices;
                this.object.geometry.vertices.push(src[a + 0], src[a + 1], src[a + 2]);
              },
              addNormal: function(a, b, c) {
                let src = this.normals, dst = this.object.geometry.normals;
                dst.push(src[a + 0], src[a + 1], src[a + 2]), dst.push(src[b + 0], src[b + 1], src[b + 2]), dst.push(src[c + 0], src[c + 1], src[c + 2]);
              },
              addFaceNormal: function(a, b, c) {
                let src = this.vertices, dst = this.object.geometry.normals;
                _vA.fromArray(src, a), _vB.fromArray(src, b), _vC.fromArray(src, c), _cb.subVectors(_vC, _vB), _ab.subVectors(_vA, _vB), _cb.cross(_ab), _cb.normalize(), dst.push(_cb.x, _cb.y, _cb.z), dst.push(_cb.x, _cb.y, _cb.z), dst.push(_cb.x, _cb.y, _cb.z);
              },
              addColor: function(a, b, c) {
                let src = this.colors, dst = this.object.geometry.colors;
                src[a] !== void 0 && dst.push(src[a + 0], src[a + 1], src[a + 2]), src[b] !== void 0 && dst.push(src[b + 0], src[b + 1], src[b + 2]), src[c] !== void 0 && dst.push(src[c + 0], src[c + 1], src[c + 2]);
              },
              addUV: function(a, b, c) {
                let src = this.uvs, dst = this.object.geometry.uvs;
                dst.push(src[a + 0], src[a + 1]), dst.push(src[b + 0], src[b + 1]), dst.push(src[c + 0], src[c + 1]);
              },
              addDefaultUV: function() {
                let dst = this.object.geometry.uvs;
                dst.push(0, 0), dst.push(0, 0), dst.push(0, 0);
              },
              addUVLine: function(a) {
                let src = this.uvs;
                this.object.geometry.uvs.push(src[a + 0], src[a + 1]);
              },
              addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
                let vLen = this.vertices.length, ia = this.parseVertexIndex(a, vLen), ib = this.parseVertexIndex(b, vLen), ic = this.parseVertexIndex(c, vLen);
                if (this.addVertex(ia, ib, ic), this.addColor(ia, ib, ic), na !== void 0 && na !== "") {
                  let nLen = this.normals.length;
                  ia = this.parseNormalIndex(na, nLen), ib = this.parseNormalIndex(nb, nLen), ic = this.parseNormalIndex(nc, nLen), this.addNormal(ia, ib, ic);
                } else
                  this.addFaceNormal(ia, ib, ic);
                if (ua !== void 0 && ua !== "") {
                  let uvLen = this.uvs.length;
                  ia = this.parseUVIndex(ua, uvLen), ib = this.parseUVIndex(ub, uvLen), ic = this.parseUVIndex(uc, uvLen), this.addUV(ia, ib, ic), this.object.geometry.hasUVIndices = !0;
                } else
                  this.addDefaultUV();
              },
              addPointGeometry: function(vertices) {
                this.object.geometry.type = "Points";
                let vLen = this.vertices.length;
                for (let vi = 0, l = vertices.length; vi < l; vi++) {
                  let index = this.parseVertexIndex(vertices[vi], vLen);
                  this.addVertexPoint(index), this.addColor(index);
                }
              },
              addLineGeometry: function(vertices, uvs) {
                this.object.geometry.type = "Line";
                let vLen = this.vertices.length, uvLen = this.uvs.length;
                for (let vi = 0, l = vertices.length; vi < l; vi++)
                  this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
                for (let uvi = 0, l = uvs.length; uvi < l; uvi++)
                  this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
              }
            };
            return state.startObject("", !1), state;
          }
          class OBJLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {
            constructor(manager) {
              super(manager);
              this.materials = null;
            }
            load(url, onLoad, onProgress, onError) {
              let scope = this, loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
              loader.setPath(this.path), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(this.withCredentials), loader.load(url, function(text) {
                try {
                  onLoad(scope.parse(text));
                } catch (e) {
                  onError ? onError(e) : console.error(e), scope.manager.itemError(url);
                }
              }, onProgress, onError);
            }
            setMaterials(materials) {
              return this.materials = materials, this;
            }
            parse(text) {
              let state = new ParserState();
              text.indexOf(`\r
`) !== -1 && (text = text.replace(/\r\n/g, `
`)), text.indexOf(`\\
`) !== -1 && (text = text.replace(/\\\n/g, ""));
              let lines = text.split(`
`), result = [];
              for (let i = 0, l = lines.length; i < l; i++) {
                let line = lines[i].trimStart();
                if (line.length === 0)
                  continue;
                let lineFirstChar = line.charAt(0);
                if (lineFirstChar !== "#")
                  if (lineFirstChar === "v") {
                    let data = line.split(_face_vertex_data_separator_pattern);
                    switch (data[0]) {
                      case "v":
                        state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3])), data.length >= 7 ? (_color.setRGB(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6])).convertSRGBToLinear(), state.colors.push(_color.r, _color.g, _color.b)) : state.colors.push(void 0, void 0, void 0);
                        break;
                      case "vn":
                        state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                        break;
                      case "vt":
                        state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                        break;
                    }
                  } else if (lineFirstChar === "f") {
                    let vertexData = line.slice(1).trim().split(_face_vertex_data_separator_pattern), faceVertices = [];
                    for (let j = 0, jl = vertexData.length; j < jl; j++) {
                      let vertex = vertexData[j];
                      if (vertex.length > 0) {
                        let vertexParts = vertex.split("/");
                        faceVertices.push(vertexParts);
                      }
                    }
                    let v1 = faceVertices[0];
                    for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {
                      let v2 = faceVertices[j], v3 = faceVertices[j + 1];
                      state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
                    }
                  } else if (lineFirstChar === "l") {
                    let lineParts = line.substring(1).trim().split(" "), lineVertices = [], lineUVs = [];
                    if (line.indexOf("/") === -1)
                      lineVertices = lineParts;
                    else
                      for (let li = 0, llen = lineParts.length; li < llen; li++) {
                        let parts = lineParts[li].split("/");
                        parts[0] !== "" && lineVertices.push(parts[0]), parts[1] !== "" && lineUVs.push(parts[1]);
                      }
                    state.addLineGeometry(lineVertices, lineUVs);
                  } else if (lineFirstChar === "p") {
                    let pointData = line.slice(1).trim().split(" ");
                    state.addPointGeometry(pointData);
                  } else if ((result = _object_pattern.exec(line)) !== null) {
                    let name = (" " + result[0].slice(1).trim()).slice(1);
                    state.startObject(name);
                  } else if (_material_use_pattern.test(line))
                    state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
                  else if (_material_library_pattern.test(line))
                    state.materialLibraries.push(line.substring(7).trim());
                  else if (_map_use_pattern.test(line))
                    console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                  else if (lineFirstChar === "s") {
                    if (result = line.split(" "), result.length > 1) {
                      let value = result[1].trim().toLowerCase();
                      state.object.smooth = value !== "0" && value !== "off";
                    } else
                      state.object.smooth = !0;
                    let material = state.object.currentMaterial();
                    material && (material.smooth = state.object.smooth);
                  } else {
                    if (line === "\0")
                      continue;
                    console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
                  }
              }
              state.finalize();
              let container = new three__WEBPACK_IMPORTED_MODULE_0__.Group();
              if (container.materialLibraries = [].concat(state.materialLibraries), !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0) === !0)
                for (let i = 0, l = state.objects.length; i < l; i++) {
                  let object = state.objects[i], geometry = object.geometry, materials = object.materials, isLine = geometry.type === "Line", isPoints = geometry.type === "Points", hasVertexColors = !1;
                  if (geometry.vertices.length === 0)
                    continue;
                  let buffergeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
                  buffergeometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(geometry.vertices, 3)), geometry.normals.length > 0 && buffergeometry.setAttribute("normal", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(geometry.normals, 3)), geometry.colors.length > 0 && (hasVertexColors = !0, buffergeometry.setAttribute("color", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(geometry.colors, 3))), geometry.hasUVIndices === !0 && buffergeometry.setAttribute("uv", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(geometry.uvs, 2));
                  let createdMaterials = [];
                  for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
                    let sourceMaterial = materials[mi], materialHash = sourceMaterial.name + "_" + sourceMaterial.smooth + "_" + hasVertexColors, material = state.materials[materialHash];
                    if (this.materials !== null) {
                      if (material = this.materials.create(sourceMaterial.name), isLine && material && !(material instanceof three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial)) {
                        let materialLine = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();
                        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(materialLine, material), materialLine.color.copy(material.color), material = materialLine;
                      } else if (isPoints && material && !(material instanceof three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial)) {
                        let materialPoints = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial({
                          size: 10,
                          sizeAttenuation: !1
                        });
                        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(materialPoints, material), materialPoints.color.copy(material.color), materialPoints.map = material.map, material = materialPoints;
                      }
                    }
                    material === void 0 && (isLine ? material = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial() : isPoints ? material = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial({
                      size: 1,
                      sizeAttenuation: !1
                    }) : material = new three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial(), material.name = sourceMaterial.name, material.flatShading = !sourceMaterial.smooth, material.vertexColors = hasVertexColors, state.materials[materialHash] = material), createdMaterials.push(material);
                  }
                  let mesh;
                  if (createdMaterials.length > 1) {
                    for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
                      let sourceMaterial = materials[mi];
                      buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
                    }
                    isLine ? mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(buffergeometry, createdMaterials) : isPoints ? mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(buffergeometry, createdMaterials) : mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(buffergeometry, createdMaterials);
                  } else
                    isLine ? mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(buffergeometry, createdMaterials[0]) : isPoints ? mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(buffergeometry, createdMaterials[0]) : mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(buffergeometry, createdMaterials[0]);
                  mesh.name = object.name, container.add(mesh);
                }
              else if (state.vertices.length > 0) {
                let material = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial({
                  size: 1,
                  sizeAttenuation: !1
                }), buffergeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
                buffergeometry.setAttribute("position", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(state.vertices, 3)), state.colors.length > 0 && state.colors[0] !== void 0 && (buffergeometry.setAttribute("color", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(state.colors, 3)), material.vertexColors = !0);
                let points = new three__WEBPACK_IMPORTED_MODULE_0__.Points(buffergeometry, material);
                container.add(points);
              }
              return container;
            }
          }
        },
        "./node_modules/three/examples/jsm/math/OBB.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            OBB: () => OBB
          });
          var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/three/build/three.module.js");
          let a = {
            c: null,
            u: [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()],
            e: []
          }, b = {
            c: null,
            u: [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()],
            e: []
          }, R = [[], [], []], AbsR = [[], [], []], t = [], xAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), yAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), zAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), v1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), size = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), closestPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), rotationMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3(), aabb = new three__WEBPACK_IMPORTED_MODULE_0__.Box3(), matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), inverse = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), localRay = new three__WEBPACK_IMPORTED_MODULE_0__.Ray();
          class OBB {
            constructor(center = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), halfSize = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), rotation = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix3()) {
              this.center = center, this.halfSize = halfSize, this.rotation = rotation;
            }
            set(center, halfSize, rotation) {
              return this.center = center, this.halfSize = halfSize, this.rotation = rotation, this;
            }
            copy(obb2) {
              return this.center.copy(obb2.center), this.halfSize.copy(obb2.halfSize), this.rotation.copy(obb2.rotation), this;
            }
            clone() {
              return new this.constructor().copy(this);
            }
            getSize(result) {
              return result.copy(this.halfSize).multiplyScalar(2);
            }
            clampPoint(point, result) {
              let halfSize = this.halfSize;
              v1.subVectors(point, this.center), this.rotation.extractBasis(xAxis, yAxis, zAxis), result.copy(this.center);
              let x = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);
              result.add(xAxis.multiplyScalar(x));
              let y = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);
              result.add(yAxis.multiplyScalar(y));
              let z = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);
              return result.add(zAxis.multiplyScalar(z)), result;
            }
            containsPoint(point) {
              return v1.subVectors(point, this.center), this.rotation.extractBasis(xAxis, yAxis, zAxis), Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;
            }
            intersectsBox3(box3) {
              return this.intersectsOBB(obb.fromBox3(box3));
            }
            intersectsSphere(sphere) {
              return this.clampPoint(sphere.center, closestPoint), closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
            }
            intersectsOBB(obb2, epsilon = Number.EPSILON) {
              a.c = this.center, a.e[0] = this.halfSize.x, a.e[1] = this.halfSize.y, a.e[2] = this.halfSize.z, this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]), b.c = obb2.center, b.e[0] = obb2.halfSize.x, b.e[1] = obb2.halfSize.y, b.e[2] = obb2.halfSize.z, obb2.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);
              for (let i = 0; i < 3; i++)
                for (let j = 0; j < 3; j++)
                  R[i][j] = a.u[i].dot(b.u[j]);
              v1.subVectors(b.c, a.c), t[0] = v1.dot(a.u[0]), t[1] = v1.dot(a.u[1]), t[2] = v1.dot(a.u[2]);
              for (let i = 0; i < 3; i++)
                for (let j = 0; j < 3; j++)
                  AbsR[i][j] = Math.abs(R[i][j]) + epsilon;
              let ra, rb;
              for (let i = 0; i < 3; i++)
                if (ra = a.e[i], rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2], Math.abs(t[i]) > ra + rb)
                  return !1;
              for (let i = 0; i < 3; i++)
                if (ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i], rb = b.e[i], Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb)
                  return !1;
              return ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0], rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1], !(Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb || (ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1], rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0], Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) || (ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2], rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0], Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) || (ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0], rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1], Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) || (ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1], rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0], Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) || (ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2], rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0], Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) || (ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0], rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1], Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) || (ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1], rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0], Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) || (ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2], rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0], Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb));
            }
            intersectsPlane(plane) {
              this.rotation.extractBasis(xAxis, yAxis, zAxis);
              let r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis)), d = plane.normal.dot(this.center) - plane.constant;
              return Math.abs(d) <= r;
            }
            intersectRay(ray, result) {
              return this.getSize(size), aabb.setFromCenterAndSize(v1.set(0, 0, 0), size), matrix.setFromMatrix3(this.rotation), matrix.setPosition(this.center), inverse.copy(matrix).invert(), localRay.copy(ray).applyMatrix4(inverse), localRay.intersectBox(aabb, result) ? result.applyMatrix4(matrix) : null;
            }
            intersectsRay(ray) {
              return this.intersectRay(ray, v1) !== null;
            }
            fromBox3(box3) {
              return box3.getCenter(this.center), box3.getSize(this.halfSize).multiplyScalar(0.5), this.rotation.identity(), this;
            }
            equals(obb2) {
              return obb2.center.equals(this.center) && obb2.halfSize.equals(this.halfSize) && obb2.rotation.equals(this.rotation);
            }
            applyMatrix4(matrix2) {
              let e = matrix2.elements, sx = v1.set(e[0], e[1], e[2]).length(), sy = v1.set(e[4], e[5], e[6]).length(), sz = v1.set(e[8], e[9], e[10]).length();
              matrix2.determinant() < 0 && (sx = -sx), rotationMatrix.setFromMatrix4(matrix2);
              let invSX = 1 / sx, invSY = 1 / sy, invSZ = 1 / sz;
              return rotationMatrix.elements[0] *= invSX, rotationMatrix.elements[1] *= invSX, rotationMatrix.elements[2] *= invSX, rotationMatrix.elements[3] *= invSY, rotationMatrix.elements[4] *= invSY, rotationMatrix.elements[5] *= invSY, rotationMatrix.elements[6] *= invSZ, rotationMatrix.elements[7] *= invSZ, rotationMatrix.elements[8] *= invSZ, this.rotation.multiply(rotationMatrix), this.halfSize.x *= sx, this.halfSize.y *= sy, this.halfSize.z *= sz, v1.setFromMatrixPosition(matrix2), this.center.add(v1), this;
            }
          }
          let obb = new OBB();
        },
        "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            computeMikkTSpaceTangents: () => computeMikkTSpaceTangents,
            computeMorphedAttributes: () => computeMorphedAttributes,
            deepCloneAttribute: () => deepCloneAttribute,
            deinterleaveAttribute: () => deinterleaveAttribute,
            deinterleaveGeometry: () => deinterleaveGeometry,
            estimateBytesUsed: () => estimateBytesUsed,
            interleaveAttributes: () => interleaveAttributes,
            mergeAttributes: () => mergeAttributes,
            mergeGeometries: () => mergeGeometries,
            mergeGroups: () => mergeGroups,
            mergeVertices: () => mergeVertices,
            toCreasedNormals: () => toCreasedNormals,
            toTrianglesDrawMode: () => toTrianglesDrawMode
          });
          var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/three/build/three.module.js");
          function computeMikkTSpaceTangents(geometry, MikkTSpace, negateSign = !0) {
            if (!MikkTSpace || !MikkTSpace.isReady)
              throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
            if (!geometry.hasAttribute("position") || !geometry.hasAttribute("normal") || !geometry.hasAttribute("uv"))
              throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');
            function getAttributeArray(attribute) {
              if (attribute.normalized || attribute.isInterleavedBufferAttribute) {
                let dstArray = new Float32Array(attribute.count * attribute.itemSize);
                for (let i = 0, j = 0; i < attribute.count; i++)
                  dstArray[j++] = attribute.getX(i), dstArray[j++] = attribute.getY(i), attribute.itemSize > 2 && (dstArray[j++] = attribute.getZ(i));
                return dstArray;
              }
              return attribute.array instanceof Float32Array ? attribute.array : new Float32Array(attribute.array);
            }
            let _geometry = geometry.index ? geometry.toNonIndexed() : geometry, tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv));
            if (negateSign)
              for (let i = 3; i < tangents.length; i += 4)
                tangents[i] *= -1;
            return _geometry.setAttribute("tangent", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(tangents, 4)), geometry !== _geometry && geometry.copy(_geometry), geometry;
          }
          function mergeGeometries(geometries, useGroups = !1) {
            let isIndexed = geometries[0].index !== null, attributesUsed = new Set(Object.keys(geometries[0].attributes)), morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes)), attributes = {}, morphAttributes = {}, morphTargetsRelative = geometries[0].morphTargetsRelative, mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), offset = 0;
            for (let i = 0; i < geometries.length; ++i) {
              let geometry = geometries[i], attributesCount = 0;
              if (isIndexed !== (geometry.index !== null))
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
              for (let name in geometry.attributes) {
                if (!attributesUsed.has(name))
                  return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.'), null;
                attributes[name] === void 0 && (attributes[name] = []), attributes[name].push(geometry.attributes[name]), attributesCount++;
              }
              if (attributesCount !== attributesUsed.size)
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes."), null;
              if (morphTargetsRelative !== geometry.morphTargetsRelative)
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
              for (let name in geometry.morphAttributes) {
                if (!morphAttributesUsed.has(name))
                  return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries."), null;
                morphAttributes[name] === void 0 && (morphAttributes[name] = []), morphAttributes[name].push(geometry.morphAttributes[name]);
              }
              if (useGroups) {
                let count;
                if (isIndexed)
                  count = geometry.index.count;
                else if (geometry.attributes.position !== void 0)
                  count = geometry.attributes.position.count;
                else
                  return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute"), null;
                mergedGeometry.addGroup(offset, count, i), offset += count;
              }
            }
            if (isIndexed) {
              let indexOffset = 0, mergedIndex = [];
              for (let i = 0; i < geometries.length; ++i) {
                let index = geometries[i].index;
                for (let j = 0; j < index.count; ++j)
                  mergedIndex.push(index.getX(j) + indexOffset);
                indexOffset += geometries[i].attributes.position.count;
              }
              mergedGeometry.setIndex(mergedIndex);
            }
            for (let name in attributes) {
              let mergedAttribute = mergeAttributes(attributes[name]);
              if (!mergedAttribute)
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " attribute."), null;
              mergedGeometry.setAttribute(name, mergedAttribute);
            }
            for (let name in morphAttributes) {
              let numMorphTargets = morphAttributes[name][0].length;
              if (numMorphTargets === 0)
                break;
              mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}, mergedGeometry.morphAttributes[name] = [];
              for (let i = 0; i < numMorphTargets; ++i) {
                let morphAttributesToMerge = [];
                for (let j = 0; j < morphAttributes[name].length; ++j)
                  morphAttributesToMerge.push(morphAttributes[name][j][i]);
                let mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
                if (!mergedMorphAttribute)
                  return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " morphAttribute."), null;
                mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
              }
            }
            return mergedGeometry;
          }
          function mergeAttributes(attributes) {
            let TypedArray, itemSize, normalized, gpuType = -1, arrayLength = 0;
            for (let i = 0; i < attributes.length; ++i) {
              let attribute = attributes[i];
              if (TypedArray === void 0 && (TypedArray = attribute.array.constructor), TypedArray !== attribute.array.constructor)
                return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
              if (itemSize === void 0 && (itemSize = attribute.itemSize), itemSize !== attribute.itemSize)
                return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
              if (normalized === void 0 && (normalized = attribute.normalized), normalized !== attribute.normalized)
                return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
              if (gpuType === -1 && (gpuType = attribute.gpuType), gpuType !== attribute.gpuType)
                return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
              arrayLength += attribute.count * itemSize;
            }
            let array = new TypedArray(arrayLength), result = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized), offset = 0;
            for (let i = 0; i < attributes.length; ++i) {
              let attribute = attributes[i];
              if (attribute.isInterleavedBufferAttribute) {
                let tupleOffset = offset / itemSize;
                for (let j = 0, l = attribute.count; j < l; j++)
                  for (let c = 0; c < itemSize; c++) {
                    let value = attribute.getComponent(j, c);
                    result.setComponent(j + tupleOffset, c, value);
                  }
              } else
                array.set(attribute.array, offset);
              offset += attribute.count * itemSize;
            }
            return gpuType !== void 0 && (result.gpuType = gpuType), result;
          }
          function deepCloneAttribute(attribute) {
            return attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ? deinterleaveAttribute(attribute) : attribute.isInstancedBufferAttribute ? new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute().copy(attribute) : new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute().copy(attribute);
          }
          function interleaveAttributes(attributes) {
            let TypedArray, arrayLength = 0, stride = 0;
            for (let i = 0, l = attributes.length; i < l; ++i) {
              let attribute = attributes[i];
              if (TypedArray === void 0 && (TypedArray = attribute.array.constructor), TypedArray !== attribute.array.constructor)
                return console.error("AttributeBuffers of different types cannot be interleaved"), null;
              arrayLength += attribute.array.length, stride += attribute.itemSize;
            }
            let interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride), offset = 0, res = [], getters = ["getX", "getY", "getZ", "getW"], setters = ["setX", "setY", "setZ", "setW"];
            for (let j = 0, l = attributes.length; j < l; j++) {
              let attribute = attributes[j], itemSize = attribute.itemSize, count = attribute.count, iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);
              res.push(iba), offset += itemSize;
              for (let c = 0; c < count; c++)
                for (let k = 0; k < itemSize; k++)
                  iba[setters[k]](c, attribute[getters[k]](c));
            }
            return res;
          }
          function deinterleaveAttribute(attribute) {
            let cons = attribute.data.array.constructor, count = attribute.count, itemSize = attribute.itemSize, normalized = attribute.normalized, array = new cons(count * itemSize), newAttribute;
            attribute.isInstancedInterleavedBufferAttribute ? newAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(array, itemSize, normalized, attribute.meshPerAttribute) : newAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);
            for (let i = 0; i < count; i++)
              newAttribute.setX(i, attribute.getX(i)), itemSize >= 2 && newAttribute.setY(i, attribute.getY(i)), itemSize >= 3 && newAttribute.setZ(i, attribute.getZ(i)), itemSize >= 4 && newAttribute.setW(i, attribute.getW(i));
            return newAttribute;
          }
          function deinterleaveGeometry(geometry) {
            let attributes = geometry.attributes, morphTargets = geometry.morphTargets, attrMap = new Map();
            for (let key in attributes) {
              let attr = attributes[key];
              attr.isInterleavedBufferAttribute && (attrMap.has(attr) || attrMap.set(attr, deinterleaveAttribute(attr)), attributes[key] = attrMap.get(attr));
            }
            for (let key in morphTargets) {
              let attr = morphTargets[key];
              attr.isInterleavedBufferAttribute && (attrMap.has(attr) || attrMap.set(attr, deinterleaveAttribute(attr)), morphTargets[key] = attrMap.get(attr));
            }
          }
          function estimateBytesUsed(geometry) {
            let mem = 0;
            for (let name in geometry.attributes) {
              let attr = geometry.getAttribute(name);
              mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
            }
            let indices = geometry.getIndex();
            return mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0, mem;
          }
          function mergeVertices(geometry, tolerance = 1e-4) {
            tolerance = Math.max(tolerance, Number.EPSILON);
            let hashToIndex = {}, indices = geometry.getIndex(), positions = geometry.getAttribute("position"), vertexCount = indices ? indices.count : positions.count, nextIndex = 0, attributeNames = Object.keys(geometry.attributes), tmpAttributes = {}, tmpMorphAttributes = {}, newIndices = [], getters = ["getX", "getY", "getZ", "getW"], setters = ["setX", "setY", "setZ", "setW"];
            for (let i = 0, l = attributeNames.length; i < l; i++) {
              let name = attributeNames[i], attr = geometry.attributes[name];
              tmpAttributes[name] = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new attr.array.constructor(attr.count * attr.itemSize), attr.itemSize, attr.normalized);
              let morphAttr = geometry.morphAttributes[name];
              morphAttr && (tmpMorphAttributes[name] = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize), morphAttr.itemSize, morphAttr.normalized));
            }
            let halfTolerance = tolerance * 0.5, exponent = Math.log10(1 / tolerance), hashMultiplier = Math.pow(10, exponent), hashAdditive = halfTolerance * hashMultiplier;
            for (let i = 0; i < vertexCount; i++) {
              let index = indices ? indices.getX(i) : i, hash = "";
              for (let j = 0, l = attributeNames.length; j < l; j++) {
                let name = attributeNames[j], attribute = geometry.getAttribute(name), itemSize = attribute.itemSize;
                for (let k = 0; k < itemSize; k++)
                  hash += `${~~(attribute[getters[k]](index) * hashMultiplier + hashAdditive)},`;
              }
              if (hash in hashToIndex)
                newIndices.push(hashToIndex[hash]);
              else {
                for (let j = 0, l = attributeNames.length; j < l; j++) {
                  let name = attributeNames[j], attribute = geometry.getAttribute(name), morphAttr = geometry.morphAttributes[name], itemSize = attribute.itemSize, newarray = tmpAttributes[name], newMorphArrays = tmpMorphAttributes[name];
                  for (let k = 0; k < itemSize; k++) {
                    let getterFunc = getters[k], setterFunc = setters[k];
                    if (newarray[setterFunc](nextIndex, attribute[getterFunc](index)), morphAttr)
                      for (let m = 0, ml = morphAttr.length; m < ml; m++)
                        newMorphArrays[m][setterFunc](nextIndex, morphAttr[m][getterFunc](index));
                  }
                }
                hashToIndex[hash] = nextIndex, newIndices.push(nextIndex), nextIndex++;
              }
            }
            let result = geometry.clone();
            for (let name in geometry.attributes) {
              let tmpAttribute = tmpAttributes[name];
              if (result.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize), tmpAttribute.itemSize, tmpAttribute.normalized)), name in tmpMorphAttributes)
                for (let j = 0; j < tmpMorphAttributes[name].length; j++) {
                  let tmpMorphAttribute = tmpMorphAttributes[name][j];
                  result.morphAttributes[name][j] = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize), tmpMorphAttribute.itemSize, tmpMorphAttribute.normalized);
                }
            }
            return result.setIndex(newIndices), result;
          }
          function toTrianglesDrawMode(geometry, drawMode) {
            if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode)
              return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), geometry;
            if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {
              let index = geometry.getIndex();
              if (index === null) {
                let indices = [], position = geometry.getAttribute("position");
                if (position !== void 0) {
                  for (let i = 0; i < position.count; i++)
                    indices.push(i);
                  geometry.setIndex(indices), index = geometry.getIndex();
                } else
                  return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), geometry;
              }
              let numberOfTriangles = index.count - 2, newIndices = [];
              if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode)
                for (let i = 1; i <= numberOfTriangles; i++)
                  newIndices.push(index.getX(0)), newIndices.push(index.getX(i)), newIndices.push(index.getX(i + 1));
              else
                for (let i = 0; i < numberOfTriangles; i++)
                  i % 2 == 0 ? (newIndices.push(index.getX(i)), newIndices.push(index.getX(i + 1)), newIndices.push(index.getX(i + 2))) : (newIndices.push(index.getX(i + 2)), newIndices.push(index.getX(i + 1)), newIndices.push(index.getX(i)));
              newIndices.length / 3 !== numberOfTriangles && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
              let newGeometry = geometry.clone();
              return newGeometry.setIndex(newIndices), newGeometry.clearGroups(), newGeometry;
            } else
              return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode), geometry;
          }
          function computeMorphedAttributes(object) {
            let _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
            function _calculateMorphedAttributeData(object2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {
              _vA.fromBufferAttribute(attribute, a2), _vB.fromBufferAttribute(attribute, b2), _vC.fromBufferAttribute(attribute, c2);
              let morphInfluences = object2.morphTargetInfluences;
              if (morphAttribute && morphInfluences) {
                _morphA.set(0, 0, 0), _morphB.set(0, 0, 0), _morphC.set(0, 0, 0);
                for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {
                  let influence = morphInfluences[i2], morph = morphAttribute[i2];
                  influence !== 0 && (_tempA.fromBufferAttribute(morph, a2), _tempB.fromBufferAttribute(morph, b2), _tempC.fromBufferAttribute(morph, c2), morphTargetsRelative2 ? (_morphA.addScaledVector(_tempA, influence), _morphB.addScaledVector(_tempB, influence), _morphC.addScaledVector(_tempC, influence)) : (_morphA.addScaledVector(_tempA.sub(_vA), influence), _morphB.addScaledVector(_tempB.sub(_vB), influence), _morphC.addScaledVector(_tempC.sub(_vC), influence)));
                }
                _vA.add(_morphA), _vB.add(_morphB), _vC.add(_morphC);
              }
              object2.isSkinnedMesh && (object2.applyBoneTransform(a2, _vA), object2.applyBoneTransform(b2, _vB), object2.applyBoneTransform(c2, _vC)), modifiedAttributeArray[a2 * 3 + 0] = _vA.x, modifiedAttributeArray[a2 * 3 + 1] = _vA.y, modifiedAttributeArray[a2 * 3 + 2] = _vA.z, modifiedAttributeArray[b2 * 3 + 0] = _vB.x, modifiedAttributeArray[b2 * 3 + 1] = _vB.y, modifiedAttributeArray[b2 * 3 + 2] = _vB.z, modifiedAttributeArray[c2 * 3 + 0] = _vC.x, modifiedAttributeArray[c2 * 3 + 1] = _vC.y, modifiedAttributeArray[c2 * 3 + 2] = _vC.z;
            }
            let geometry = object.geometry, material = object.material, a, b, c, index = geometry.index, positionAttribute = geometry.attributes.position, morphPosition = geometry.morphAttributes.position, morphTargetsRelative = geometry.morphTargetsRelative, normalAttribute = geometry.attributes.normal, morphNormal = geometry.morphAttributes.position, groups = geometry.groups, drawRange = geometry.drawRange, i, j, il, jl, group, start, end, modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize), modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
            if (index !== null)
              if (Array.isArray(material))
                for (i = 0, il = groups.length; i < il; i++)
                  for (group = groups[i], start = Math.max(group.start, drawRange.start), end = Math.min(group.start + group.count, drawRange.start + drawRange.count), j = start, jl = end; j < jl; j += 3)
                    a = index.getX(j), b = index.getX(j + 1), c = index.getX(j + 2), _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition), _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
              else
                for (start = Math.max(0, drawRange.start), end = Math.min(index.count, drawRange.start + drawRange.count), i = start, il = end; i < il; i += 3)
                  a = index.getX(i), b = index.getX(i + 1), c = index.getX(i + 2), _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition), _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
            else if (Array.isArray(material))
              for (i = 0, il = groups.length; i < il; i++)
                for (group = groups[i], start = Math.max(group.start, drawRange.start), end = Math.min(group.start + group.count, drawRange.start + drawRange.count), j = start, jl = end; j < jl; j += 3)
                  a = j, b = j + 1, c = j + 2, _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition), _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
            else
              for (start = Math.max(0, drawRange.start), end = Math.min(positionAttribute.count, drawRange.start + drawRange.count), i = start, il = end; i < il; i += 3)
                a = i, b = i + 1, c = i + 2, _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition), _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
            let morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3), morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);
            return {
              positionAttribute,
              normalAttribute,
              morphedPositionAttribute,
              morphedNormalAttribute
            };
          }
          function mergeGroups(geometry) {
            if (geometry.groups.length === 0)
              return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."), geometry;
            let groups = geometry.groups;
            if (groups = groups.sort((a, b) => a.materialIndex !== b.materialIndex ? a.materialIndex - b.materialIndex : a.start - b.start), geometry.getIndex() === null) {
              let positionAttribute = geometry.getAttribute("position"), indices = [];
              for (let i = 0; i < positionAttribute.count; i += 3)
                indices.push(i, i + 1, i + 2);
              geometry.setIndex(indices);
            }
            let index = geometry.getIndex(), newIndices = [];
            for (let i = 0; i < groups.length; i++) {
              let group = groups[i], groupStart = group.start, groupLength = groupStart + group.count;
              for (let j = groupStart; j < groupLength; j++)
                newIndices.push(index.getX(j));
            }
            geometry.dispose(), geometry.setIndex(newIndices);
            let start = 0;
            for (let i = 0; i < groups.length; i++) {
              let group = groups[i];
              group.start = start, start += group.count;
            }
            let currentGroup = groups[0];
            geometry.groups = [currentGroup];
            for (let i = 1; i < groups.length; i++) {
              let group = groups[i];
              currentGroup.materialIndex === group.materialIndex ? currentGroup.count += group.count : (currentGroup = group, geometry.groups.push(currentGroup));
            }
            return geometry;
          }
          function toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {
            let creaseDot = Math.cos(creaseAngle), hashMultiplier = (1 + 1e-10) * 100, verts = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()], tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
            function hashVertex(v) {
              let x = ~~(v.x * hashMultiplier), y = ~~(v.y * hashMultiplier), z = ~~(v.z * hashMultiplier);
              return `${x},${y},${z}`;
            }
            let resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry, posAttr = resultGeometry.attributes.position, vertexMap = {};
            for (let i = 0, l = posAttr.count / 3; i < l; i++) {
              let i3 = 3 * i, a = verts[0].fromBufferAttribute(posAttr, i3 + 0), b = verts[1].fromBufferAttribute(posAttr, i3 + 1), c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
              tempVec1.subVectors(c, b), tempVec2.subVectors(a, b);
              let normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();
              for (let n = 0; n < 3; n++) {
                let vert = verts[n], hash = hashVertex(vert);
                hash in vertexMap || (vertexMap[hash] = []), vertexMap[hash].push(normal);
              }
            }
            let normalArray = new Float32Array(posAttr.count * 3), normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, !1);
            for (let i = 0, l = posAttr.count / 3; i < l; i++) {
              let i3 = 3 * i, a = verts[0].fromBufferAttribute(posAttr, i3 + 0), b = verts[1].fromBufferAttribute(posAttr, i3 + 1), c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
              tempVec1.subVectors(c, b), tempVec2.subVectors(a, b), tempNorm.crossVectors(tempVec1, tempVec2).normalize();
              for (let n = 0; n < 3; n++) {
                let vert = verts[n], hash = hashVertex(vert), otherNormals = vertexMap[hash];
                tempNorm2.set(0, 0, 0);
                for (let k = 0, lk = otherNormals.length; k < lk; k++) {
                  let otherNorm = otherNormals[k];
                  tempNorm.dot(otherNorm) > creaseDot && tempNorm2.add(otherNorm);
                }
                tempNorm2.normalize(), normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);
              }
            }
            return resultGeometry.setAttribute("normal", normAttr), resultGeometry;
          }
        },
        "./node_modules/three/examples/jsm/utils/WorkerPool.js": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            WorkerPool: () => WorkerPool
          });
          class WorkerPool {
            constructor(pool = 4) {
              this.pool = pool, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
            }
            _initWorker(workerId) {
              if (!this.workers[workerId]) {
                let worker = this.workerCreator();
                worker.addEventListener("message", this._onMessage.bind(this, workerId)), this.workers[workerId] = worker;
              }
            }
            _getIdleWorker() {
              for (let i = 0; i < this.pool; i++)
                if (!(this.workerStatus & 1 << i))
                  return i;
              return -1;
            }
            _onMessage(workerId, msg) {
              let resolve = this.workersResolve[workerId];
              if (resolve && resolve(msg), this.queue.length) {
                let {
                  resolve: resolve2,
                  msg: msg2,
                  transfer
                } = this.queue.shift();
                this.workersResolve[workerId] = resolve2, this.workers[workerId].postMessage(msg2, transfer);
              } else
                this.workerStatus ^= 1 << workerId;
            }
            setWorkerCreator(workerCreator) {
              this.workerCreator = workerCreator;
            }
            setWorkerLimit(pool) {
              this.pool = pool;
            }
            postMessage(msg, transfer) {
              return new Promise((resolve) => {
                let workerId = this._getIdleWorker();
                workerId !== -1 ? (this._initWorker(workerId), this.workerStatus |= 1 << workerId, this.workersResolve[workerId] = resolve, this.workers[workerId].postMessage(msg, transfer)) : this.queue.push({
                  resolve,
                  msg,
                  transfer
                });
              });
            }
            dispose() {
              this.workers.forEach((worker) => worker.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
            }
          }
        },
        "./src/lib/three.mjs": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
          "use strict";
          __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, {
            default: () => __WEBPACK_DEFAULT_EXPORT__
          });
          var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2("./node_modules/three/build/three.module.js"), three_examples_jsm_loaders_DRACOLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2("./node_modules/three/examples/jsm/loaders/DRACOLoader.js"), three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2("./node_modules/three/examples/jsm/loaders/GLTFLoader.js"), three_examples_jsm_loaders_KTX2Loader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2("./node_modules/three/examples/jsm/loaders/KTX2Loader.js"), three_addons_math_OBB_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2("./node_modules/three/examples/jsm/math/OBB.js"), three_examples_jsm_loaders_OBJLoader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2("./node_modules/three/examples/jsm/loaders/OBJLoader.js"), three_examples_jsm_loaders_MTLLoader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2("./node_modules/three/examples/jsm/loaders/MTLLoader.js"), three_examples_jsm_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2("./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"), three_examples_jsm_lights_LightProbeGenerator_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2("./node_modules/three/examples/jsm/lights/LightProbeGenerator.js"), THREE3 = { ...three__WEBPACK_IMPORTED_MODULE_0__ };
          THREE3.DRACOLoader = three_examples_jsm_loaders_DRACOLoader_js__WEBPACK_IMPORTED_MODULE_1__.DRACOLoader, THREE3.GLTFLoader = three_examples_jsm_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_2__.GLTFLoader, THREE3.KTX2Loader = three_examples_jsm_loaders_KTX2Loader_js__WEBPACK_IMPORTED_MODULE_3__.KTX2Loader, THREE3.OBJLoader = three_examples_jsm_loaders_OBJLoader_js__WEBPACK_IMPORTED_MODULE_4__.OBJLoader, THREE3.MTLLoader = three_examples_jsm_loaders_MTLLoader_js__WEBPACK_IMPORTED_MODULE_5__.MTLLoader, THREE3.OBB = three_addons_math_OBB_js__WEBPACK_IMPORTED_MODULE_6__.OBB, THREE3.BufferGeometryUtils = three_examples_jsm_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_7__, THREE3.LightProbeGenerator = three_examples_jsm_lights_LightProbeGenerator_js__WEBPACK_IMPORTED_MODULE_8__.LightProbeGenerator;
          let __WEBPACK_DEFAULT_EXPORT__ = THREE3;
        },
        "./package.json": (module3) => {
          "use strict";
          module3.exports = JSON.parse('{"name":"aframe","version":"1.6.0","description":"A web framework for building virtual reality experiences.","homepage":"https://aframe.io/","main":"dist/aframe-master.js","scripts":{"dev":"cross-env INSPECTOR_VERSION=dev webpack serve --port 8080","dist":"node scripts/updateVersionLog.js && npm run dist:min && npm run dist:max","dist:max":"webpack --config webpack.config.js","dist:min":"webpack --config webpack.prod.config.js","docs":"markserv --dir docs --port 9001","preghpages":"node ./scripts/preghpages.js","ghpages":"ghpages -p gh-pages/","lint":"standardx -v | snazzy","lint:fix":"standardx --fix","precommit":"npm run lint","prepush":"node scripts/testOnlyCheck.js","prerelease":"node scripts/release.js 1.5.0 1.6.0","start":"npm run dev","start:https":"npm run dev -- --server-type https","test":"karma start ./tests/karma.conf.js","test:docs":"node scripts/docsLint.js","test:firefox":"npm test -- --browsers Firefox","test:chrome":"npm test -- --browsers Chrome","test:nobrowser":"NO_BROWSER=true npm test","test:node":"node --experimental-require-module ./node_modules/mocha/bin/mocha --ui tdd tests/node"},"repository":"aframevr/aframe","license":"MIT","files":["dist/*","docs/**/*","src/**/*","vendor/**/*"],"dependencies":{"buffer":"^6.0.3","debug":"^4.3.4","deep-assign":"^2.0.0","load-bmfont":"^1.2.3","super-animejs":"^3.1.0","three":"npm:super-three@0.164.0","three-bmfont-text":"dmarcos/three-bmfont-text#eed4878795be9b3e38cf6aec6b903f56acd1f695","webvr-polyfill":"^0.10.12"},"devDependencies":{"@babel/core":"^7.17.10","babel-loader":"^8.2.5","babel-plugin-istanbul":"^6.1.1","chai":"^4.3.6","chai-shallow-deep-equal":"^1.4.0","chalk":"^1.1.3","cross-env":"^7.0.3","css-loader":"^6.7.1","eslint":"^8.45.0","eslint-config-semistandard":"^17.0.0","eslint-config-standard-jsx":"^11.0.0","ghpages":"0.0.8","git-rev":"^0.2.1","glob":"^8.0.3","husky":"^0.11.7","jsdom":"^24.0.0","jsdom-global":"^3.0.2","karma":"^6.4.0","karma-chai-shallow-deep-equal":"0.0.4","karma-chrome-launcher":"^3.1.1","karma-coverage":"^2.2.0","karma-env-preprocessor":"^0.1.1","karma-firefox-launcher":"^2.1.2","karma-mocha":"^2.0.1","karma-mocha-reporter":"^2.2.5","karma-sinon-chai":"^2.0.2","karma-webpack":"^5.0.0","markserv":"github:sukima/markserv#feature/fix-broken-websoketio-link","mocha":"^10.0.0","replace-in-file":"^2.5.3","shelljs":"^0.7.7","shx":"^0.2.2","sinon":"<12.0.0","sinon-chai":"^3.7.0","snazzy":"^5.0.0","standardx":"^7.0.0","style-loader":"^3.3.1","too-wordy":"ngokevin/too-wordy","webpack":"^5.73.0","webpack-cli":"^4.10.0","webpack-dev-server":"^4.11.0","webpack-merge":"^5.8.0","write-good":"^1.0.8"},"link":true,"standardx":{"ignore":["build/**","dist/**","examples/**/shaders/*.js","**/vendor/**"]},"keywords":["3d","aframe","cardboard","components","oculus","three","three.js","rift","vive","vr","quest","meta","web-components","webvr","webxr"],"engines":{"node":">= 4.6.0","npm":">= 2.15.9"}}');
        }
      }, __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0)
          return cachedModule.exports;
        var module3 = __webpack_module_cache__[moduleId] = {
          id: moduleId,
          exports: {}
        };
        return __webpack_modules__[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__), module3.exports;
      }
      __webpack_require__.m = __webpack_modules__, (() => {
        __webpack_require__.n = (module3) => {
          var getter = module3 && module3.__esModule ? () => module3.default : () => module3;
          return __webpack_require__.d(getter, { a: getter }), getter;
        };
      })(), (() => {
        __webpack_require__.d = (exports2, definition) => {
          for (var key in definition)
            __webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key) && Object.defineProperty(exports2, key, { enumerable: !0, get: definition[key] });
        };
      })(), (() => {
        __webpack_require__.g = function() {
          if (typeof globalThis == "object")
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (e) {
            if (typeof window == "object")
              return window;
          }
        }();
      })(), (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      })(), (() => {
        __webpack_require__.r = (exports2) => {
          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(exports2, "__esModule", { value: !0 });
        };
      })(), (() => {
        __webpack_require__.b = document.baseURI || self.location.href;
        var installedChunks = {
          main: 0
        };
      })(), (() => {
        __webpack_require__.nc = void 0;
      })();
      var __webpack_exports__ = __webpack_require__("./src/index.js");
      return __webpack_exports__;
    })());
  }
});

// src/aframe-worker.js
__export(exports, {
  VRMLoader: () => VRMLoader
});

// src/aframe.js
var import_aframe = __toModule(require_aframe_master());
globalThis.THREE = import_aframe.default.THREE;
globalThis.AFRAME = import_aframe.default;
var THREE2 = import_aframe.default.THREE;

// src/vrm/lookat.ts
var VRMLookAt = class {
  constructor(initCtx) {
    this.target = null;
    this.angleLimit = 60 * Math.PI / 180;
    this._identQ = new THREE2.Quaternion();
    this._zV = new THREE2.Vector3(0, 0, -1);
    this._tmpQ0 = new THREE2.Quaternion();
    this._tmpV0 = new THREE2.Vector3();
    this._bone = initCtx.nodes[initCtx.vrm.firstPerson.firstPersonBone];
  }
  update(t) {
    let target = this.target, bone = this._bone;
    if (target == null || bone == null)
      return;
    let targetDirection = bone.worldToLocal(this._tmpV0.setFromMatrixPosition(target.matrixWorld)).normalize(), rot = this._tmpQ0.setFromUnitVectors(this._zV, targetDirection), boneLimit = this.angleLimit, speedFactor = 0.08, angle = 2 * Math.acos(rot.w);
    angle > boneLimit * 1.5 ? (rot = this._identQ, speedFactor = 0.04) : angle > boneLimit && rot.setFromAxisAngle(this._tmpV0.set(rot.x, rot.y, rot.z).normalize(), boneLimit), bone.quaternion.slerp(rot, speedFactor);
  }
};

// src/vrm/blendshape.ts
var VRMBlendShapeUtil = class {
  constructor(avatar) {
    this._currentShape = {};
    this._avatar = avatar;
  }
  setBlendShapeWeight(name, value) {
    this._currentShape[name] = value, value == 0 && delete this._currentShape[name], this._updateBlendShape();
  }
  getBlendShapeWeight(name) {
    return this._currentShape[name] || 0;
  }
  resetBlendShape() {
    this._currentShape = {}, this._updateBlendShape();
  }
  startBlink(blinkInterval) {
    this.animatedMorph || (this.animatedMorph = {
      name: "BLINK",
      times: [0, blinkInterval - 0.2, blinkInterval - 0.1, blinkInterval],
      values: [0, 0, 1, 0]
    }, this._updateBlendShape());
  }
  stopBlink() {
    this.animatedMorph = null, this._updateBlendShape();
  }
  _updateBlendShape() {
    let addWeights = (data, name, weights) => {
      let blend = this._avatar.blendShapes[name];
      blend && blend.binds.forEach((bind) => {
        let tname = bind.target.name, values = data[tname] || (data[tname] = new Array(bind.target.morphTargetInfluences.length * weights.length).fill(0));
        for (let t = 0; t < weights.length; t++) {
          let i = t * bind.target.morphTargetInfluences.length + bind.index;
          values[i] += Math.max(bind.weight * weights[t], values[i]);
        }
      });
    }, times = [0], trackdata = {};
    this.animatedMorph && (times = this.animatedMorph.times, addWeights(trackdata, this.animatedMorph.name, this.animatedMorph.values));
    for (let [name, value] of Object.entries(this._currentShape))
      this._avatar.blendShapes[name] && addWeights(trackdata, name, new Array(times.length).fill(value));
    let tracks = Object.entries(trackdata).map(([tname, values]) => new THREE2.NumberKeyframeTrack(tname + ".morphTargetInfluences", times, values)), nextAction = null;
    if (tracks.length > 0) {
      let clip = new THREE2.AnimationClip("morph", void 0, tracks);
      nextAction = this._avatar.mixer.clipAction(clip).setEffectiveWeight(1).play();
    }
    this.morphAction && this.morphAction.stop(), this.morphAction = nextAction;
  }
};

// src/vrm/firstperson.ts
var FirstPersonMeshUtil = class {
  constructor(initCtx) {
    this._firstPersonBone = initCtx.nodes[initCtx.vrm.firstPerson.firstPersonBone], this._annotatedMeshes = initCtx.vrm.firstPerson.meshAnnotations.map((ma) => ({ flag: ma.firstPersonFlag, mesh: initCtx.meshes[ma.mesh] }));
  }
  setFirstPerson(firstPerson) {
    this._annotatedMeshes.forEach((a) => {
      a.flag == "ThirdPersonOnly" ? a.mesh.visible = !firstPerson : a.flag == "FirstPersonOnly" ? a.mesh.visible = firstPerson : a.flag == "Auto" && this._firstPersonBone && (firstPerson ? this._genFirstPersonMesh(a.mesh) : this._resetFirstPersonMesh(a.mesh));
    });
  }
  _genFirstPersonMesh(mesh) {
    if (mesh.children.forEach((c) => this._genFirstPersonMesh(c)), !mesh.isSkinnedMesh)
      return;
    let firstPersonBones = {};
    this._firstPersonBone.traverse((b) => {
      firstPersonBones[b.uuid] = !0;
    });
    let skeletonBones = mesh.skeleton.bones, skinIndex = mesh.geometry.attributes.skinIndex, skinWeight = mesh.geometry.attributes.skinWeight, index = mesh.geometry.index, vertexErase = [], vcount = 0, fcount = 0;
    for (let i = 0; i < skinIndex.array.length; i++) {
      let b = skinIndex.array[i];
      skinWeight.array[i] > 0 && firstPersonBones[skeletonBones[b].uuid] && (vertexErase[i / skinIndex.itemSize | 0] || (vcount++, vertexErase[i / skinIndex.itemSize | 0] = !0));
    }
    let trinagleErase = [];
    for (let i = 0; i < index.count; i++)
      vertexErase[index.array[i]] && !trinagleErase[i / 3 | 0] && (trinagleErase[i / 3 | 0] = !0, fcount++);
    if (fcount != 0 && fcount * 3 == index.count) {
      mesh.visible = !1;
      return;
    }
  }
  _resetFirstPersonMesh(mesh) {
    mesh.children.forEach((c) => this._resetFirstPersonMesh(c)), mesh.visible = !0;
  }
};

// src/vrm/avatar.ts
var VRMLoader = class {
  constructor(gltfLoader) {
    this.gltfLoader = gltfLoader || new THREE2.GLTFLoader(THREE2.DefaultLoadingManager);
  }
  async load(url, moduleSpecs = []) {
    return new Promise((resolve, reject) => {
      this.gltfLoader.load(url, async (gltf) => {
        resolve(await new VRMAvatar(gltf).init(gltf, moduleSpecs));
      }, void 0, reject);
    });
  }
  async parse(data, path, moduleSpecs = []) {
    return new Promise((resolve, reject) => {
      let starttime = Date.now();
      this.gltfLoader.parse(data, path, async (gltf) => {
        console.log(`gltf parsed, duration: ${Date.now() - starttime} ms`), resolve(await new VRMAvatar(gltf).init(gltf, moduleSpecs));
      }, void 0, reject);
    });
  }
}, VRMAvatar = class {
  constructor(gltf) {
    this.bones = {};
    this.blendShapes = {};
    this.modules = {};
    this.meta = {};
    this.firstPersonBone = null;
    this._firstPersonMeshUtil = null;
    this.boneConstraints = {
      head: { type: "ball", limit: 60 * Math.PI / 180, twistAxis: new THREE2.Vector3(0, 1, 0), twistLimit: 60 * Math.PI / 180 },
      neck: { type: "ball", limit: 30 * Math.PI / 180, twistAxis: new THREE2.Vector3(0, 1, 0), twistLimit: 10 * Math.PI / 180 },
      leftUpperLeg: { type: "ball", limit: 170 * Math.PI / 180, twistAxis: new THREE2.Vector3(0, -1, 0), twistLimit: Math.PI / 2 },
      rightUpperLeg: { type: "ball", limit: 170 * Math.PI / 180, twistAxis: new THREE2.Vector3(0, -1, 0), twistLimit: Math.PI / 2 },
      leftLowerLeg: { type: "hinge", axis: new THREE2.Vector3(1, 0, 0), min: -170 * Math.PI / 180, max: 0 * Math.PI / 180 },
      rightLowerLeg: { type: "hinge", axis: new THREE2.Vector3(1, 0, 0), min: -170 * Math.PI / 180, max: 0 * Math.PI / 180 }
    };
    this.model = gltf.scene, this.mixer = new THREE2.AnimationMixer(this.model), this.isVRM = (gltf.userData.gltfExtensions || {}).VRM != null, this.animations = gltf.animations || [], this._blendShapeUtil = new VRMBlendShapeUtil(this);
  }
  async init(gltf, moduleSpecs) {
    if (!this.isVRM)
      return this;
    let vrmExt = gltf.userData.gltfExtensions.VRM, bones = this.bones, nodes = await gltf.parser.getDependencies("node"), meshes = await gltf.parser.getDependencies("mesh"), initCtx = { nodes, meshes, vrm: vrmExt, gltf };
    this.meta = vrmExt.meta, Object.values(vrmExt.humanoid.humanBones).forEach((humanBone) => {
      bones[humanBone.bone] = nodes[humanBone.node];
    }), vrmExt.firstPerson && (vrmExt.firstPerson.firstPersonBone && (this.firstPersonBone = nodes[vrmExt.firstPerson.firstPersonBone], this.modules.lookat = new VRMLookAt(initCtx)), vrmExt.firstPerson.meshAnnotations && (this._firstPersonMeshUtil = new FirstPersonMeshUtil(initCtx))), this.model.skeleton = new THREE2.Skeleton(Object.values(bones)), this._fixBoundingBox(), vrmExt.blendShapeMaster && this._initBlendShapes(initCtx);
    for (let spec of moduleSpecs) {
      let mod = spec.instantiate(this, initCtx);
      mod && (this.modules[spec.name] = mod);
    }
    return this;
  }
  _initBlendShapes(ctx) {
    this.blendShapes = (ctx.vrm.blendShapeMaster.blendShapeGroups || []).reduce((blendShapes, bg) => {
      let binds = bg.binds.flatMap((bind) => {
        let meshObj = ctx.meshes[bind.mesh];
        return (meshObj.isSkinnedMesh ? [meshObj] : meshObj.children.filter((obj) => obj.isSkinnedMesh)).map((obj) => ({ target: obj, index: bind.index, weight: bind.weight / 100 }));
      });
      return blendShapes[(bg.presetName || bg.name).toUpperCase()] = { name: bg.name, binds }, blendShapes;
    }, {});
  }
  _fixBoundingBox() {
    let bones = this.bones;
    if (!bones.hips)
      return;
    let tmpV = new THREE2.Vector3(), center = bones.hips.getWorldPosition(tmpV).clone();
    this.model.traverse((obj) => {
      let mesh = obj;
      if (mesh.isSkinnedMesh) {
        let pos = mesh.getWorldPosition(tmpV).sub(center).multiplyScalar(-1), r = pos.clone().sub(mesh.geometry.boundingSphere.center).length() + mesh.geometry.boundingSphere.radius;
        mesh.geometry.boundingSphere.center.copy(pos), mesh.geometry.boundingSphere.radius = r, mesh.geometry.boundingBox.min.set(pos.x - r, pos.y - r, pos.z - r), mesh.geometry.boundingBox.max.set(pos.x + r, pos.y + r, pos.z + r);
      }
    });
  }
  update(timeDelta) {
    this.mixer.update(timeDelta);
    for (let m of Object.values(this.modules))
      m.update(timeDelta);
  }
  setModule(name, module2) {
    this.removeModule(name), this.modules[name] = module2;
  }
  removeModule(name) {
    let module2 = this.modules[name];
    module2 && module2.dispose && module2.dispose(), delete this.modules[name];
  }
  dispose() {
    for (let m of Object.keys(this.modules))
      this.removeModule(m);
    this.model.traverse((obj) => {
      let mesh = obj;
      mesh.isMesh && (mesh.geometry.dispose(), mesh.material.map?.dispose()), obj.skeleton && obj.skeleton.dispose();
    });
  }
  get lookAtTarget() {
    let lookat = this.modules.lookat;
    return lookat ? lookat.target : null;
  }
  set lookAtTarget(v) {
    let lookat = this.modules.lookat;
    lookat && (lookat.target = v);
  }
  setBlendShapeWeight(name, value) {
    this._blendShapeUtil.setBlendShapeWeight(name, value);
  }
  getBlendShapeWeight(name) {
    return this._blendShapeUtil.getBlendShapeWeight(name);
  }
  resetBlendShape() {
    this._blendShapeUtil.resetBlendShape();
  }
  startBlink(blinkInterval) {
    this._blendShapeUtil.startBlink(blinkInterval);
  }
  stopBlink() {
    this._blendShapeUtil.stopBlink();
  }
  getPose(exportMorph) {
    let poseData = {
      bones: Object.keys(this.bones).map((name) => ({ name, q: this.bones[name].quaternion.toArray() }))
    };
    return exportMorph && (poseData.blendShape = Object.keys(this.blendShapes).map((name) => ({ name, value: this.getBlendShapeWeight(name) }))), poseData;
  }
  setPose(pose) {
    if (pose.bones)
      for (let boneParam of pose.bones)
        this.bones[boneParam.name] && this.bones[boneParam.name].quaternion.fromArray(boneParam.q);
    if (pose.blendShape)
      for (let morph of pose.blendShape)
        this.setBlendShapeWeight(morph.name, morph.value);
  }
  restPose() {
    for (let b of Object.values(this.bones))
      b.quaternion.set(0, 0, 0, 1);
  }
  setFirstPerson(firstPerson) {
    this._firstPersonMeshUtil && this._firstPersonMeshUtil.setFirstPerson(firstPerson);
  }
}, VRMCache = class {
  constructor() {
    this.cache = new Map();
  }
  init() {
    let assets = document.querySelectorAll("a-asset-item[vrm]").forEach((i) => {
      this.loadAvatar(i);
    });
  }
  async loadAvatar(el) {
    let data = el.data, path = el.getAttribute("src") ?? "", id = el.getAttribute("id"), avatar = await new VRMLoader().parse(data, path);
    this.cache.set("id", avatar);
  }
}, vrmCache = new VRMCache();
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
/**
 * @license
 * cardboard-vr-display
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * gl-preserve-state
 * Copyright (c) 2016, Brandon Jones.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * nosleep.js
 * Copyright (c) 2017, Rich Tibbett
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * webvr-polyfill
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * webvr-polyfill-dpdb
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * webvr-polyfill-dpdb 
 * Copyright (c) 2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * wglu-preserve-state
 * Copyright (c) 2016, Brandon Jones.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=aframe-worker.module.js.map
